### <a name="wpf-grid-allocation-of-space-to-star-columns"></a><span data-ttu-id="a115d-101">WPF 方格配置到星狀資料行的空間</span><span class="sxs-lookup"><span data-stu-id="a115d-101">WPF Grid allocation of space to star-columns</span></span>

|   |   |
|---|---|
|<span data-ttu-id="a115d-102">詳細資料</span><span class="sxs-lookup"><span data-stu-id="a115d-102">Details</span></span>|<span data-ttu-id="a115d-103">從.NET Framework 4.7 開始，WPF 會取代此演算法的<xref:System.Windows.Controls.Grid>配置空間，以使用 \*-資料行。</span><span class="sxs-lookup"><span data-stu-id="a115d-103">Starting with the .NET Framework 4.7, WPF replaces the algorithm that <xref:System.Windows.Controls.Grid> uses to allocate space to \*-columns.</span></span> <span data-ttu-id="a115d-104">這會變更指派給的實際寬度 \*-中的案例數目的資料行：</span><span class="sxs-lookup"><span data-stu-id="a115d-104">This will change the actual width assigned to \*-columns in a number of cases:</span></span><ul><li><span data-ttu-id="a115d-105">當一或多個 \*-資料行也會使用覆寫該資料行的調和間距配置的最小值或最大寬度。</span><span class="sxs-lookup"><span data-stu-id="a115d-105">When one or more \*-columns also have a minimum or maximum width that overrides the proportional allocation for that colum.</span></span> <span data-ttu-id="a115d-106">（最小寬度可以衍生從明確 MinWidth 宣告，或隱含的最小值取自資料行的內容。</span><span class="sxs-lookup"><span data-stu-id="a115d-106">(The minimum width can derive from an explicit MinWidth declaration, or from an implicit minimum obtained from the column's content.</span></span> <span data-ttu-id="a115d-107">最大寬度只能定義明確地從 MaxWidth 宣告。）</span><span class="sxs-lookup"><span data-stu-id="a115d-107">The maximum width can only be defined explicitly, from a MaxWidth declaration.)</span></span></li><li><span data-ttu-id="a115d-108">當一或多個 *-宣告極大的資料行 *-加權，大於 10 ^298。</span><span class="sxs-lookup"><span data-stu-id="a115d-108">When one or more *-columns declare an extremely large *-weight, greater than 10^298.</span></span></li><li><span data-ttu-id="a115d-109">當 \*-加權是完全不同發生浮點不穩定 （溢位、 反向溢位，遺失有效位數）。</span><span class="sxs-lookup"><span data-stu-id="a115d-109">When the \*-weights are sufficiently different to encounter floating-point instability (overflow, underflow, loss of precision).</span></span></li><li><span data-ttu-id="a115d-110">當版面配置進位已啟用，且有效顯示 DPI 夠高時。</span><span class="sxs-lookup"><span data-stu-id="a115d-110">When layout rounding is enabled, and the effective display DPI is sufficiently high.</span></span></li></ul><span data-ttu-id="a115d-111">在前兩個情況中，新的演算法所產生的寬度可以明顯不同於所產生舊的演算法。在最後一個的情況下，差異將最多一個或兩個像素為單位。新的演算法修正數個 bug 出現在舊的演算法：</span><span class="sxs-lookup"><span data-stu-id="a115d-111">In the first two cases, the widths produced by the new algorithm can be significantly different from those produced by the old algorithm; in the last case, the difference will be at most one or two pixels.The new algorithm fixes several bugs present in the old algorithm:</span></span><ol><li><span data-ttu-id="a115d-112">資料行的總配置可能會超過方格的寬度。</span><span class="sxs-lookup"><span data-stu-id="a115d-112">Total allocation to columns can exceed the Grid's width.</span></span> <span data-ttu-id="a115d-113">資料行的按比例共用若低於其大小下限，配置空間時就可能發生這個狀況。</span><span class="sxs-lookup"><span data-stu-id="a115d-113">This can occur when allocating space to a column whose proportional share is less than its minimum size.</span></span> <span data-ttu-id="a115d-114">此演算法會配置大小下限，因此，其他資料行的可用空間會減少。</span><span class="sxs-lookup"><span data-stu-id="a115d-114">The algorithm allocates the minimum size, which decreases the space available to other columns.</span></span> <span data-ttu-id="a115d-115">如果有任何 \*-將資料行配置保留，總計配置太大。</span><span class="sxs-lookup"><span data-stu-id="a115d-115">If there are no \*-columns left to allocate, the total allocation will be too large.</span></span></li><li><span data-ttu-id="a115d-116">總配置的方格寬度可能會不足。</span><span class="sxs-lookup"><span data-stu-id="a115d-116">Total allocation can fall short of the Grid's width.</span></span> <span data-ttu-id="a115d-117">這是雙重 # 1，超過最大的大小，以及未配置的資料行的調和間距的共用時所引發的問題 \*-由左到 slack 所佔用的資料行。</span><span class="sxs-lookup"><span data-stu-id="a115d-117">This is the dual problem to #1, arising when allocating to a column whose proportional share is greater than its maximum size, with no \*-columns left to take up the slack.</span></span></li><li><span data-ttu-id="a115d-118">兩個 *-資料行可以接收不成比例的配置其 *-加權。</span><span class="sxs-lookup"><span data-stu-id="a115d-118">Two *-columns can receive allocations not proportional to their *-weights.</span></span> <span data-ttu-id="a115d-119">相較於第 1 點/第 2 點，這是程度較輕的錯誤，在為 \*-columns A、B 和 C (依此順序) 配置空間時，若 B 的按比例共用違反其下限 (或上限) 條件約束，就會發生這個狀況。</span><span class="sxs-lookup"><span data-stu-id="a115d-119">This is a milder version of #1/#2, arising when allocating to \*-columns A, B, and C (in that order), where B's proportional share violates its min (or max) constraint.</span></span> <span data-ttu-id="a115d-120">如上所述，這會使資料行 C 的可用的空間產生變化，可能會獲得較 A 更少 (或更多) 的比例配置，</span><span class="sxs-lookup"><span data-stu-id="a115d-120">As above, this changes the space available to column C, who gets less (or more) proportional allocation than A did,</span></span></li><li><span data-ttu-id="a115d-121">具有極大的加權資料行 (&gt; 10 ^298) 的所有處理都有加權 10 ^298。</span><span class="sxs-lookup"><span data-stu-id="a115d-121">Columns with extremely large weights (&gt; 10^298) are all treated as if they had weight 10^298.</span></span> <span data-ttu-id="a115d-122">它們之間 (及權數較小的資料行之間) 的比例差異則可忽略。</span><span class="sxs-lookup"><span data-stu-id="a115d-122">Proportional differences between them (and between columns with slightly smaller weights) are not honored.</span></span></li><li><span data-ttu-id="a115d-123">使用 inifinte 加權資料行不會正確處理。</span><span class="sxs-lookup"><span data-stu-id="a115d-123">Columns with inifinte weights are not handled correctly.</span></span> <span data-ttu-id="a115d-124">[事實上，您無法將權數設為無限大，但這是人為限制。</span><span class="sxs-lookup"><span data-stu-id="a115d-124">[Actually you can't set a weight to Infinity, but this is an artificial restriction.</span></span> <span data-ttu-id="a115d-125">配置程式碼會嘗試處理它，但成效不彰。]</span><span class="sxs-lookup"><span data-stu-id="a115d-125">The allocation code was trying to handle it, but doing a bad job.]</span></span></li><li><span data-ttu-id="a115d-126">避免溢位、反向溢位時的幾個小問題、精確度失準及類似的浮點數問題。</span><span class="sxs-lookup"><span data-stu-id="a115d-126">Several minor problems while avoiding overflow, underflow, loss of precision and similar floating-point issues.</span></span></li><li><span data-ttu-id="a115d-127">版面配置進位的調整在 DPI 足夠高的情況下不正確。</span><span class="sxs-lookup"><span data-stu-id="a115d-127">Adjustments for layout rounding are incorrect at sufficiently high DPI.</span></span></li></ol><span data-ttu-id="a115d-128">新的演算法會產生符合下列準則： A 的結果。</span><span class="sxs-lookup"><span data-stu-id="a115d-128">The new algorithm produces results that meet the following criteria:A.</span></span> <span data-ttu-id="a115d-129">若要指派的實際寬度 \*-資料行永遠不會是小於或大於最大寬度小於其最小寬度。B.</span><span class="sxs-lookup"><span data-stu-id="a115d-129">The actual width assigned to a \*-column is never less than its minimum width nor greater than its maximum width.B.</span></span> <span data-ttu-id="a115d-130">每個<em>-資料行不是指派其最小值或最大寬度指派成正比寬度其<em>-加權。更明確地說，如果兩個資料行以寬度 x 宣告</em>和 y</em>分別和任何資料行接收其最小值或最大寬度，實際的寬度 v 和 w 指派給資料行是否以相同比例： v/w i n = = x / y.C.</span><span class="sxs-lookup"><span data-stu-id="a115d-130">Each <em>-column that is not assigned its minimum or maximum width is assigned a width proportional to its <em>-weight. To be precise, if two columns are declared with width x</em> and y</em> respectively, and if neither column receives its minimum or maximum width, the actual widths v and w assigned to the columns are in the same proportion: v / w == x / y.C.</span></span> <span data-ttu-id="a115d-131">總寬度配置給&quot;比例&quot;*-資料行之後將配置到條件約束的資料行是相等的可用空間 (固定，自動和 *-配置其最小值或最大寬度的資料行)。</span><span class="sxs-lookup"><span data-stu-id="a115d-131">The total width allocated to &quot;proportional&quot; *-columns is equal to the space available after allocating to the constrained columns (fixed, auto, and *-columns that are allocated their min or max width).</span></span> <span data-ttu-id="a115d-132">這可能會執行個體是零，如果最小寬度的總和超過方格 availbable 寬度。D.</span><span class="sxs-lookup"><span data-stu-id="a115d-132">This might be zero, for instance if the sum of the minimum widths exceeds the Grid's availbable width.D.</span></span> <span data-ttu-id="a115d-133">所有這些陳述式是相對於必須解譯&quot;理想&quot;版面配置。</span><span class="sxs-lookup"><span data-stu-id="a115d-133">All these statements are to be interpreted with respect to the &quot;ideal&quot; layout.</span></span> <span data-ttu-id="a115d-134">版面配置進位，則為作用中，當實際的寬度可能會不同於的理想寬度最多可達一個像素。舊的演算法會接受 (A)，但無法接受以上所述的案例中的其他準則。所有項目相關的資料行和本文中的寬度也適用於資料列和高度。</span><span class="sxs-lookup"><span data-stu-id="a115d-134">When layout rounding is in effect, the actual widths can differ from the ideal widths by as much as one pixel.The old algorithm honored (A) but failed to honor the other criteria in the cases outlined above.Everything said about columns and widths in this article applies as well to rows and heights.</span></span>|
|<span data-ttu-id="a115d-135">建議</span><span class="sxs-lookup"><span data-stu-id="a115d-135">Suggestion</span></span>|<span data-ttu-id="a115d-136">根據預設，應用程式從.NET Framework 4.7 的.NET framework 目標版本，將會看到新的演算法，同時應用程式的目標.NET Framework 4.6.2 或更早版本，將會看到舊的演算法。若要覆寫預設值，請使用下列組態設定：</span><span class="sxs-lookup"><span data-stu-id="a115d-136">By default, apps that target versions of the .NET Framework starting with the .NET Framework 4.7 will see the new algorithm, while apps that target the .NET Framework 4.6.2 or earlier versions will see the old algorithm.To override the default, use the following configuration setting:</span></span><pre><code class="language-xml">&lt;runtime&gt;&#13;&#10;&lt;AppContextSwitchOverrides value=&quot;Switch.System.Windows.Controls.Grid.StarDefinitionsCanExceedAvailableSpace=true&quot; /&gt;&#13;&#10;&lt;/runtime&gt;&#13;&#10;</code></pre><span data-ttu-id="a115d-137">值 'true' 選取舊的演算法，因此，'false' 選取新的演算法。</span><span class="sxs-lookup"><span data-stu-id="a115d-137">The value 'true' selects the old algorithm, 'false' selects the new algorithm.</span></span>|
|<span data-ttu-id="a115d-138">範圍</span><span class="sxs-lookup"><span data-stu-id="a115d-138">Scope</span></span>|<span data-ttu-id="a115d-139">次要</span><span class="sxs-lookup"><span data-stu-id="a115d-139">Minor</span></span>|
|<span data-ttu-id="a115d-140">版本</span><span class="sxs-lookup"><span data-stu-id="a115d-140">Version</span></span>|<span data-ttu-id="a115d-141">4.7</span><span class="sxs-lookup"><span data-stu-id="a115d-141">4.7</span></span>|
|<span data-ttu-id="a115d-142">類型</span><span class="sxs-lookup"><span data-stu-id="a115d-142">Type</span></span>|<span data-ttu-id="a115d-143">正在重定目標</span><span class="sxs-lookup"><span data-stu-id="a115d-143">Retargeting</span></span>|

