<Type Name="HostingEnvironment" FullName="System.Web.Hosting.HostingEnvironment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="323f647b75757e8c78f352ea5a949ed1fe17f800" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30540472" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HostingEnvironment : MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HostingEnvironment extends System.MarshalByRefObject" />
  <TypeSignature Language="DocId" Value="T:System.Web.Hosting.HostingEnvironment" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HostingEnvironment&#xA;Inherits MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class HostingEnvironment sealed : MarshalByRefObject" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>在 Managed 應用程式的應用程式定義域中向其提供應用程式管理功能和應用程式服務。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個受管理的應用程式定義域中包含的靜態執行個體<xref:System.Web.Hosting.HostingEnvironment>類別，可提供存取應用程式管理功能和應用程式服務。  
  
   
  
## Examples  
 下列程式碼範例是會顯示可從應用程式資訊的網頁<xref:System.Web.Hosting.HostingEnvironment>物件。  
  
 [!code-aspx-csharp[System.Web.Hosting.HostingEnvironment#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Hosting.HostingEnvironment/CS/hostingEnvironmentcs.aspx#1)]
 [!code-aspx-vb[System.Web.Hosting.HostingEnvironment#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Hosting.HostingEnvironment/VB/hostingEnvironmentvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HostingEnvironment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HostingEnvironment();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.Hosting.HostingEnvironment" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.HostingEnvironment.%23ctor%2A>建構函式初始化<xref:System.Web.Hosting.HostingEnvironment>物件。 <xref:System.Web.Hosting.HostingEnvironment.%23ctor%2A>的應用程式一次呼叫建構函式<xref:System.Web.Hosting.ApplicationManager>物件。 呼叫<xref:System.Web.Hosting.HostingEnvironment.%23ctor%2A>建構函式超過一次會造成<xref:System.InvalidOperationException>擲回的例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已多次呼叫 <see cref="M:System.Web.Hosting.HostingEnvironment.#ctor" /> 建構函式。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationHost">
      <MemberSignature Language="C#" Value="public static System.Web.Hosting.IApplicationHost ApplicationHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Hosting.IApplicationHost ApplicationHost" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.ApplicationHost" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationHost As IApplicationHost" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Hosting::IApplicationHost ^ ApplicationHost { System::Web::Hosting::IApplicationHost ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Hosting.IApplicationHost</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這個屬性支援 [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] 基礎結構，但是您不可以從程式碼直接使用它。</summary>
        <value>包含主應用程式相關資訊的物件。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationID">
      <MemberSignature Language="C#" Value="public static string ApplicationID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationID" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.ApplicationID" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationID { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式的唯一識別項。</summary>
        <value>應用程式的唯一識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式必須執行<xref:System.Web.AspNetHostingPermissionLevel>設定為高信任度，以存取<xref:System.Web.Hosting.HostingEnvironment.ApplicationID%2A>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationMonitors">
      <MemberSignature Language="C#" Value="public static System.Web.Hosting.ApplicationMonitors ApplicationMonitors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Hosting.ApplicationMonitors ApplicationMonitors" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.ApplicationMonitors" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationMonitors As ApplicationMonitors" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Hosting::ApplicationMonitors ^ ApplicationMonitors { System::Web::Hosting::ApplicationMonitors ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Hosting.ApplicationMonitors</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可取代的監視器物件群組，ASP.NET 子系統會用此群組來監視應用程式健全狀況。</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPhysicalPath">
      <MemberSignature Language="C#" Value="public static string ApplicationPhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationPhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.ApplicationPhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationPhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationPhysicalPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式之目錄在磁碟上的實體路徑。</summary>
        <value>應用程式之目錄在磁碟上的實體路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例使用<xref:System.Web.Hosting.HostingEnvironment.ApplicationPhysicalPath%2A>屬性來建構應用程式的 App_Data 目錄中的資料檔的路徑。 若要執行範例所需的完整程式碼，請參閱 < 範例 > 一節的<xref:System.Web.Hosting.VirtualPathProvider>類別概觀主題。  
  
 [!code-csharp[System.Web.Hosting.VirtualPathProvider#27](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.hosting.virtualpathprovider/CS/SamplePathProvider.cs#27)]
 [!code-vb[System.Web.Hosting.VirtualPathProvider#27](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.hosting.virtualpathprovider/VB/SamplePathProvider.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationVirtualPath">
      <MemberSignature Language="C#" Value="public static string ApplicationVirtualPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationVirtualPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationVirtualPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationVirtualPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式的根虛擬路徑。</summary>
        <value>應用程式的根虛擬路徑 (結尾沒有斜線 (/))。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A>屬性一律會傳回"`/"`做為傳回值的第一個字元。 如果應用程式位於網站根目錄中，只是傳回的值"`/"`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public static System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.Cache" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前應用程式的 <see cref="T:System.Web.Caching.Cache" /> 執行個體。</summary>
        <value>目前的 <see cref="T:System.Web.Caching.Cache" /> 執行個體。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DecrementBusyCount">
      <MemberSignature Language="C#" Value="public static void DecrementBusyCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DecrementBusyCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.DecrementBusyCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DecrementBusyCount ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DecrementBusyCount();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將裝載環境中的忙碌物件計數減少一個。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當忙碌的已註冊的物件完成其工作時，它會呼叫<xref:System.Web.Hosting.HostingEnvironment.DecrementBusyCount%2A>方法來通知<xref:System.Web.Hosting.HostingEnvironment>物件已完成處理並將的忙碌物件計數減少一個。  
  
 如果忙碌的計數小於或等於零，裝載應用程式不會逾即使沒有任何暫止要求。  
  
 必須呼叫<xref:System.Web.Hosting.HostingEnvironment.DecrementBusyCount%2A>方法每次呼叫<xref:System.Web.Hosting.HostingEnvironment.IncrementBusyCount%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Impersonate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>允許程式碼模擬不同使用者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Impersonate">
      <MemberSignature Language="C#" Value="public static IDisposable Impersonate ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable Impersonate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.Impersonate" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Impersonate () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IDisposable ^ Impersonate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>模擬由應用程式識別所表示的使用者。</summary>
        <returns>
          <see cref="T:System.IDisposable" /> 物件，表示模擬前的 Windows 使用者，這個物件可以用於還原為原始使用者的內容。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">處理序無法模擬。</exception>
      </Docs>
    </Member>
    <Member MemberName="Impersonate">
      <MemberSignature Language="C#" Value="public static IDisposable Impersonate (IntPtr token);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable Impersonate(native int token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.Impersonate(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Impersonate (token As IntPtr) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IDisposable ^ Impersonate(IntPtr token);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="token">Windows 帳戶語彙基元的控制代碼。</param>
        <summary>模擬由指定使用者語彙基元所表示的使用者。</summary>
        <returns>
          <see cref="T:System.IDisposable" /> 物件，表示模擬前的 Windows 使用者，這個物件可以用於還原為原始使用者的內容。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">處理序無法模擬。</exception>
      </Docs>
    </Member>
    <Member MemberName="Impersonate">
      <MemberSignature Language="C#" Value="public static IDisposable Impersonate (IntPtr userToken, string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable Impersonate(native int userToken, string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.Impersonate(System.IntPtr,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Impersonate (userToken As IntPtr, virtualPath As String) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IDisposable ^ Impersonate(IntPtr userToken, System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userToken" Type="System.IntPtr" />
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userToken">Windows 帳戶語彙基元的控制代碼。</param>
        <param name="virtualPath">要求之資源的路徑。</param>
        <summary>模擬由指定虛擬路徑之組態設定所指定的使用者，或指定的使用者語彙基元。</summary>
        <returns>
          <see cref="T:System.IDisposable" /> 物件，表示模擬前的 Windows 使用者，這個物件可以用於還原為原始使用者的內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.HostingEnvironment.Impersonate%2A>方法會模擬後套用組態設定會影響指定的虛擬路徑中的所有項目所產生的使用者。 如果`identity`項目未指定虛擬路徑，<xref:System.Web.Hosting.HostingEnvironment.Impersonate%2A>方法來模擬指定的 Windows 帳戶。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">處理序無法模擬。</exception>
      </Docs>
    </Member>
    <Member MemberName="InClientBuildManager">
      <MemberSignature Language="C#" Value="public static bool InClientBuildManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool InClientBuildManager" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.InClientBuildManager" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InClientBuildManager As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool InClientBuildManager { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示主機環境是否可以存取 ASP.NET 建置系統。</summary>
        <value>
          如果應用程式定義域是 <see langword="true" /> 情節中所使用的 ASP.NET 裝載應用程式定義域，則為 <see langword="ClientBuildManager" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncrementBusyCount">
      <MemberSignature Language="C#" Value="public static void IncrementBusyCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IncrementBusyCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.IncrementBusyCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IncrementBusyCount ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void IncrementBusyCount();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將裝載環境中的忙碌物件計數增加一個。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 註冊的物件訊號<xref:System.Web.Hosting.HostingEnvironment>物件已經在執行和的忙碌物件計數增加一。  
  
 如果忙碌的計數小於或等於零，裝載應用程式不會逾即使沒有任何暫止要求。  
  
 必須呼叫<xref:System.Web.Hosting.HostingEnvironment.DecrementBusyCount%2A>方法每次呼叫<xref:System.Web.Hosting.HostingEnvironment.IncrementBusyCount%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializationException">
      <MemberSignature Language="C#" Value="public static Exception InitializationException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Exception InitializationException" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.InitializationException" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InitializationException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Exception ^ InitializationException { Exception ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Web.Hosting.HostingEnvironment" /> 物件初始設定期間擲回的例外狀況。</summary>
        <value>
          <see cref="T:System.Web.Hosting.HostingEnvironment" /> 物件初始設定期間擲回的例外狀況。 如果未擲回例外狀況，則會傳回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>藉由防止建立使用期，為 <see cref="T:System.Web.Hosting.HostingEnvironment" /> 物件提供無限的存留期。</summary>
        <returns>一定是 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會覆寫<xref:System.MarshalByRefObject.InitializeLifetimeService%2A>其基底類別中的方法。 它會一律傳回`null`並防止建立會限制的使用期<xref:System.Web.Hosting.HostingEnvironment>物件存留期。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitiateShutdown">
      <MemberSignature Language="C#" Value="public static void InitiateShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitiateShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.InitiateShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InitiateShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitiateShutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始關閉與這個主機關聯的 Web 應用程式，並從系統中移除註冊的物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.Hosting.HostingEnvironment.InitiateShutdown%2A>方法來停止 web 應用程式定義域，並移除任何物件向<xref:System.Web.Hosting.HostingEnvironment.RegisterObject%2A>方法。 這個方法會立即傳回，在完成關機之前。  
  
 <xref:System.Web.Hosting.IRegisteredObject.Stop%2A>每個已註冊的物件上呼叫方法並傳遞的參數設定為`false`允許每個已註冊的物件，以非同步方式關閉。 在等候中指定的時間量之後`shutdownTimeout`屬性的組態項目<xref:System.Web.Hosting.IRegisteredObject.Stop%2A>傳遞的參數設定為使用一次呼叫方法`true`剩餘的每個已註冊物件。  
  
 當所有已註冊的物件完成後，正在關閉，<xref:System.Web.Hosting.HostingEnvironment>物件關閉應用程式定義域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDevelopmentEnvironment">
      <MemberSignature Language="C#" Value="public static bool IsDevelopmentEnvironment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsDevelopmentEnvironment" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.IsDevelopmentEnvironment" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsDevelopmentEnvironment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsDevelopmentEnvironment { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前應用程式是否在開發環境中。</summary>
        <value>
          如果應用程式是在開發環境中，則為 <see langword="true" />，否則為<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHosted">
      <MemberSignature Language="C#" Value="public static bool IsHosted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsHosted" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.IsHosted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsHosted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsHosted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前應用程式定義域是否由 <see cref="T:System.Web.Hosting.ApplicationManager" /> 物件裝載 (Host)。</summary>
        <value>
          如果應用程式定義域由 <see cref="T:System.Web.Hosting.ApplicationManager" /> 物件裝載則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public static string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">虛擬路徑 (絕對或相對)。</param>
        <summary>將虛擬路徑對應至伺服器上的實體路徑。</summary>
        <returns>伺服器上的實體路徑，由 <paramref name="virtualPath" /> 所指定。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MaxConcurrentRequestsPerCPU">
      <MemberSignature Language="C#" Value="public static int MaxConcurrentRequestsPerCPU { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxConcurrentRequestsPerCPU" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.MaxConcurrentRequestsPerCPU" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxConcurrentRequestsPerCPU As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxConcurrentRequestsPerCPU { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定每一個 CPU 的最大並行要求數目。</summary>
        <value>每一個 CPU 的最大並行要求數目。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxConcurrentThreadsPerCPU">
      <MemberSignature Language="C#" Value="public static int MaxConcurrentThreadsPerCPU { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxConcurrentThreadsPerCPU" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.MaxConcurrentThreadsPerCPU" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MaxConcurrentThreadsPerCPU As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxConcurrentThreadsPerCPU { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定每一個 CPU 的最大並行執行緒數目。</summary>
        <value>每一個 CPU 的最大並行執行緒數目。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageReceived">
      <MemberSignature Language="C#" Value="public static void MessageReceived ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MessageReceived() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.MessageReceived" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MessageReceived ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MessageReceived();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>這個方法支援 [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] 基礎結構，但是您不可以從程式碼直接使用它。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueBackgroundWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援]  
  
 排程可在背景中執行的工作，不受任何要求影響。  
  
 此多載方法不會讓 <see cref="T:System.Threading.ExecutionContext" /> 或 <see cref="T:System.Security.SecurityContext" /> 從呼叫者流入被呼叫者。 因此，這些物件的成員 (例如 <see cref="P:System.Threading.Thread.CurrentPrincipal" /> 屬性) 都不會從呼叫者流入被呼叫者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueBackgroundWorkItem">
      <MemberSignature Language="C#" Value="public static void QueueBackgroundWorkItem (Action&lt;System.Threading.CancellationToken&gt; workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void QueueBackgroundWorkItem(class System.Action`1&lt;valuetype System.Threading.CancellationToken&gt; workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.QueueBackgroundWorkItem(System.Action{System.Threading.CancellationToken})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub QueueBackgroundWorkItem (workItem As Action(Of CancellationToken))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void QueueBackgroundWorkItem(Action&lt;System::Threading::CancellationToken&gt; ^ workItem);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workItem" Type="System.Action&lt;System.Threading.CancellationToken&gt;" />
      </Parameters>
      <Docs>
        <param name="workItem">執行單位。</param>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援]  
  
 排程可在背景中執行的工作，不受任何要求影響。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於正常的執行緒集區工作項目，ASP.NET 可以追蹤的多少工作目前正在透過此 API 登錄項目和 ASP.NET 執行階段會嘗試延遲 AppDomain 關閉直到這些工作項目都已完成執行。 這個 API 不能呼叫 ASP.NET managed AppDomain 之外。 信號提供的 CancellationToken 會在應用程式正在關機而關閉。  
  
 <xref:System.Web.Hosting.HostingEnvironment.QueueBackgroundWorkItem%2A> 會傳回工作的回呼。工作項目將會被視為已完成回呼傳回時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueBackgroundWorkItem">
      <MemberSignature Language="C#" Value="public static void QueueBackgroundWorkItem (Func&lt;System.Threading.CancellationToken,System.Threading.Tasks.Task&gt; workItem);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void QueueBackgroundWorkItem(class System.Func`2&lt;valuetype System.Threading.CancellationToken, class System.Threading.Tasks.Task&gt; workItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.QueueBackgroundWorkItem(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub QueueBackgroundWorkItem (workItem As Func(Of CancellationToken, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void QueueBackgroundWorkItem(Func&lt;System::Threading::CancellationToken, System::Threading::Tasks::Task ^&gt; ^ workItem);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workItem" Type="System.Func&lt;System.Threading.CancellationToken,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="workItem">執行單位。</param>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援]  
  
 排程可在背景中執行的工作，不受任何要求影響。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於正常的執行緒集區工作項目，ASP.NET 可以追蹤的多少工作目前正在透過此 API 登錄項目和 ASP.NET 執行階段會嘗試延遲 AppDomain 關閉直到這些工作項目都已完成執行。 這個 API 不能呼叫 ASP.NET managed AppDomain 之外。 信號提供的 CancellationToken 會在應用程式正在關機而關閉。  
  
 <xref:System.Web.Hosting.HostingEnvironment.QueueBackgroundWorkItem%2A> 會傳回工作的回呼。工作項目將會被視為已完成時傳回的工作轉換至終端機的狀態。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterObject">
      <MemberSignature Language="C#" Value="public static void RegisterObject (System.Web.Hosting.IRegisteredObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterObject(class System.Web.Hosting.IRegisteredObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.RegisterObject(System.Web.Hosting.IRegisteredObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterObject (obj As IRegisteredObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterObject(System::Web::Hosting::IRegisteredObject ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Web.Hosting.IRegisteredObject" />
      </Parameters>
      <Docs>
        <param name="obj">要註冊的物件。</param>
        <summary>將物件置於應用程式的註冊物件清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.ApplicationManager>類別可讓目前的應用程式定義域來建立、 管理和摧毀目前的應用程式定義域內的物件之外的方法。 <xref:System.Web.Hosting.HostingEnvironment.RegisterObject%2A>方法用來向裝載的環境中的先前建立的物件。 物件向<xref:System.Web.Hosting.HostingEnvironment.RegisterObject%2A>方法必須實作<xref:System.Web.Hosting.IRegisteredObject>介面。  
  
 若要使用的已註冊的物件，請遵循下列步驟：  
  
1.  藉由呼叫建立的已註冊物件的新執行個體<xref:System.Web.Hosting.ApplicationManager.CreateObject%2A?displayProperty=nameWithType>方法。  
  
2.  呼叫的特定類型的方法來初始化新的物件。 在初始設定方法，呼叫<xref:System.Web.Hosting.HostingEnvironment.RegisterObject%2A>方法，將物件加入至已註冊的物件清單。  
  
3.  呼叫<xref:System.Web.Hosting.ApplicationManager.GetObject%2A?displayProperty=nameWithType>傳回已註冊的物件時所需的方法。  
  
4.  當您想要停止您的物件時，呼叫<xref:System.Web.Hosting.ApplicationManager.StopObject%2A?displayProperty=nameWithType>方法。 <xref:System.Web.Hosting.ApplicationManager.StopObject%2A?displayProperty=nameWithType>方法會呼叫<xref:System.Web.Hosting.IRegisteredObject.Stop%2A?displayProperty=nameWithType>方法。  
  
5.  在<xref:System.Web.Hosting.IRegisteredObject.Stop%2A?displayProperty=nameWithType>方法，讓物件呼叫<xref:System.Web.Hosting.HostingEnvironment.UnregisterObject%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例是實作`Start`註冊物件的方法。 若要執行範例所需的完整程式碼，請參閱 < 範例 > 一節的<xref:System.Web.Hosting.IRegisteredObject>介面的概觀主題。  
  
 [!code-csharp[System.Web.Hosting.ApplicationManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Hosting.ApplicationManager/CS/appManagercs.aspx.cs#2)]
 [!code-vb[System.Web.Hosting.ApplicationManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Hosting.ApplicationManager/VB/appManagervb.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.Hosting.HostingEnvironment.UnregisterObject(System.Web.Hosting.IRegisteredObject)" />
        <altmember cref="T:System.Web.Hosting.IRegisteredObject" />
        <altmember cref="M:System.Web.Hosting.ApplicationManager.CreateObject(System.String,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterVirtualPathProvider">
      <MemberSignature Language="C#" Value="public static void RegisterVirtualPathProvider (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterVirtualPathProvider(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.RegisterVirtualPathProvider(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterVirtualPathProvider(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">要加入至編譯系統的新 <see cref="T:System.Web.Hosting.VirtualPathProvider" /> 執行個體。</param>
        <summary>使用 ASP.NET 編譯系統註冊新的 <see cref="T:System.Web.Hosting.VirtualPathProvider" /> 執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.HostingEnvironment.RegisterVirtualPathProvider%2A>方法會將指定<xref:System.Web.Hosting.VirtualPathProvider>應用程式的清單執行個體的虛擬路徑提供者。  
  
 如需詳細資訊，請參閱<xref:System.Web.Hosting.VirtualPathProvider>類別概觀。  
  
   
  
## Examples  
 下列程式碼範例屬於登錄自訂應用程式啟動方法<xref:System.Web.Hosting.VirtualPathProvider>編譯系統具有執行個體。 若要執行範例所需的完整程式碼，請參閱 < 範例 > 一節的<xref:System.Web.Hosting.VirtualPathProvider>類別概觀主題。  
  
 [!code-csharp[System.Web.Hosting.VirtualPathProvider#11](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.hosting.virtualpathprovider/CS/AppStart.cs#11)]
 [!code-vb[System.Web.Hosting.VirtualPathProvider#11](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.hosting.virtualpathprovider/VB/AppStart.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCultures">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定目前執行緒的文化特性 (Culture) 資訊。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCultures">
      <MemberSignature Language="C#" Value="public static IDisposable SetCultures ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable SetCultures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.SetCultures" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetCultures () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IDisposable ^ SetCultures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前執行緒設為應用程式組態檔中指定的文化特性。</summary>
        <returns>
          <see cref="T:System.IDisposable" /> 物件，表示變更前的文化特性，這個物件可用於還原為先前的文化特性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.HostingEnvironment.SetCultures%2A>方法會將目前的執行緒設定中指定的文化特性[全球化項目 （ASP.NET 設定結構描述）](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7)應用程式的組態檔中的項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCultures">
      <MemberSignature Language="C#" Value="public static IDisposable SetCultures (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IDisposable SetCultures(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.SetCultures(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetCultures (virtualPath As String) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IDisposable ^ SetCultures(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">包含文化特性資訊的路徑。</param>
        <summary>將目前執行緒設為指定虛擬路徑的文化特性。</summary>
        <returns>
          <see cref="T:System.IDisposable" /> 物件，表示變更前的文化特性，這個物件可用於還原為先前的文化特性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.HostingEnvironment.SetCultures%2A>方法會設定目前執行緒文化特性套用影響指定的虛擬路徑的組態檔中的所有項目後所產生。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownReason">
      <MemberSignature Language="C#" Value="public static System.Web.ApplicationShutdownReason ShutdownReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.ApplicationShutdownReason ShutdownReason" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.ShutdownReason" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ShutdownReason As ApplicationShutdownReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::ApplicationShutdownReason ShutdownReason { System::Web::ApplicationShutdownReason get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ApplicationShutdownReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回列舉值，表示應用程式結束的原因。</summary>
        <value>其中一個 <see cref="T:System.Web.ApplicationShutdownReason" /> 值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SiteName">
      <MemberSignature Language="C#" Value="public static string SiteName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SiteName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.SiteName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SiteName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SiteName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此站台的名稱。</summary>
        <value>站台的名稱。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="public static event EventHandler StopListening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StopListening" />
      <MemberSignature Language="DocId" Value="E:System.Web.Hosting.HostingEnvironment.StopListening" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event StopListening As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ StopListening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[僅在 .NET Framework 4.5.1 中支援]  
  
 發生於與此主機相關聯的背景工作處理序或應用程式集區，已停止接聽新要求且最終將關閉時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當應用程式集區和其相關聯的背景工作處理序正在關閉 iis 時，例如當應用程式集區已達到排定的回收時間間隔，IIS 會通知應用程式正在關機而關閉 ASP.NET 執行階段和背景工作處理序應用程式集區會停止接聽新的要求。 應用程式，例如使用長時間執行的要求， [SignalR](http://go.microsoft.com/fwlink/?LinkID=285432)應用程式可以接聽<xref:System.Web.Hosting.HostingEnvironment.StopListening>事件和 IIS 已啟動的應用程式關閉時正常關閉其長時間執行的作業集區，及其相關聯的背景工作處理序。  
  
> [!WARNING]
>  有幾個開發人員在實作時必須考慮的設計考量<xref:System.Web.Hosting.HostingEnvironment.StopListening>事件：  
>   
>  1.  <xref:System.Web.Hosting.HostingEnvironment.StopListening>事件只適用於已設定為使用 IIS integrated 的管線的應用程式。  
> 2.  開發人員必須不會擲回錯誤，從其<xref:System.Web.Hosting.HostingEnvironment.StopListening>實作; 擲回錯誤，則會有無法預期的結果。  
> 3.  由於在 ASP.NET 中的作業並行的本質，也不會保證將會呼叫 ASP.NET<xref:System.Web.Hosting.HostingEnvironment.StopListening>事件之後已由開發人員實作。  
> 4.  <xref:System.Web.Hosting.HostingEnvironment.StopListening>事件可以與其他同時執行<xref:System.Web.Hosting.IRegisteredObject>通知。  
> 5.  開發人員必須注意可能關閉 ASP.NET 應用程式定義域時其<xref:System.Web.Hosting.HostingEnvironment.StopListening>事件時執行和設計其實作來處理該可能性。  
> 6.  <xref:System.Web.Hosting.HostingEnvironment.StopListening> 事件處理常式必須不會封鎖。封鎖實作將會導致死結，而且 IIS 會終止背景工作處理序時快速失敗保護間隔為止。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterObject">
      <MemberSignature Language="C#" Value="public static void UnregisterObject (System.Web.Hosting.IRegisteredObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterObject(class System.Web.Hosting.IRegisteredObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Hosting.HostingEnvironment.UnregisterObject(System.Web.Hosting.IRegisteredObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterObject (obj As IRegisteredObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterObject(System::Web::Hosting::IRegisteredObject ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Web.Hosting.IRegisteredObject" />
      </Parameters>
      <Docs>
        <param name="obj">要移除的物件。</param>
        <summary>移除於應用程式之註冊物件清單中的物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Hosting.ApplicationManager>類別可讓目前的應用程式定義域來建立、 管理和摧毀目前的應用程式定義域內的物件之外的方法。 <xref:System.Web.Hosting.HostingEnvironment.UnregisterObject%2A>方法用來裝載環境中移除先前註冊的物件。  
  
   
  
## Examples  
 下列程式碼範例是<xref:System.Web.Hosting.IRegisteredObject.Stop%2A>註冊物件的方法。 若要執行範例所需的完整程式碼，請參閱 < 範例 > 一節的<xref:System.Web.Hosting.IRegisteredObject>介面的概觀主題。  
  
 [!code-csharp[System.Web.Hosting.ApplicationManager#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Hosting.ApplicationManager/CS/appManagercs.aspx.cs#3)]
 [!code-vb[System.Web.Hosting.ApplicationManager#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Hosting.ApplicationManager/VB/appManagervb.aspx.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.Hosting.HostingEnvironment.RegisterObject(System.Web.Hosting.IRegisteredObject)" />
        <altmember cref="T:System.Web.Hosting.IRegisteredObject" />
        <altmember cref="M:System.Web.Hosting.ApplicationManager.CreateObject(System.String,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="VirtualPathProvider">
      <MemberSignature Language="C#" Value="public static System.Web.Hosting.VirtualPathProvider VirtualPathProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Hosting.VirtualPathProvider VirtualPathProvider" />
      <MemberSignature Language="DocId" Value="P:System.Web.Hosting.HostingEnvironment.VirtualPathProvider" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property VirtualPathProvider As VirtualPathProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Hosting::VirtualPathProvider ^ VirtualPathProvider { System::Web::Hosting::VirtualPathProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Hosting.VirtualPathProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個應用程式的虛擬路徑提供者。</summary>
        <value>這個應用程式的 <see cref="T:System.Web.Hosting.VirtualPathProvider" /> 執行個體。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當一個以上<xref:System.Web.Hosting.VirtualPathProvider>註冊執行個體，<xref:System.Web.Hosting.HostingEnvironment>物件管理的呼叫鏈結。 您無法控制稱為虛擬路徑提供者的順序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>