<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0b6477787c17199600536f8a4df06d52440d68c5" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008074" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 Helper 方法以處理 Web 要求。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法和屬性<xref:System.Web.HttpServerUtility>類別會公開透過內建<xref:System.Web.HttpContext.Server%2A>ASP.NET 所提供的物件。  
  
   
  
## Examples  
 含有原始程式碼的 Visual Studio Web site 專案位於本主題隨附了：[下載](https://go.microsoft.com/fwlink/?LinkId=192870)。  
  
 下列範例示範如何使用<xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法和<xref:System.Web.HttpServerUtility.UrlEncode%2A>方法<xref:System.Web.HttpServerUtility>類別。 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法可協助確保使用者提供的任何字串輸入會轉譯為靜態文字，而不是可執行的指令碼或 HTML 元素的瀏覽器中。 <xref:System.Web.HttpServerUtility.UrlEncode%2A>方法編碼 Url，以便正確地傳送 HTTP 資料流中。  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除先前的例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會清除上次擲回的例外狀況。  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 COM 物件的伺服器執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要建立執行個體的類別或物件類型。</param>
        <summary>建立物件程式設計識別項 (ProgID) 所識別之 COM 物件的伺服器執行個體。</summary>
        <returns>新物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會使用物件的 ProgID，以建立物件。  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">無法建立物件的執行個體。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" />，表示要建立的物件。</param>
        <summary>建立以物件類型識別的 COM 物件的伺服器執行個體。</summary>
        <returns>新物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">要建立執行個體之物件的類別識別項。</param>
        <summary>建立以物件的類別識別項 (CLSID) 識別的 COM 物件的伺服器執行個體。</summary>
        <returns>新物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何使用<xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A>方法用來建立 COM 物件的伺服器執行個體。  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">無法建立物件的執行個體。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在目前要求的內容中執行指定資源的處理常式，並將執行傳回叫用它的網頁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A>方法會執行的新頁面完成之後，繼續執行原始頁面。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。  
  
 ASP.NET 不會驗證目前的使用者已獲授權檢視所提供的資源<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯執行原始的資源處理常式會在呼叫之前，ASP.NET 就會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Execute%2A>方法且不重新驗證和授權的邏輯執行新的資源。 如果您的應用程式安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用，以強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A> 執行用戶端重新導向瀏覽器要求新的資源。 此重新導向是進入系統的新要求，因為它被必須的 Internet Information Services (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以確認使用者已透過合併自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法，應用程式會呼叫再<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
   
  
## Examples  
 下列範例會顯示.aspx 頁面 」 Updateinfo.aspx"在目前的目錄。 執行程式返回到起始頁 Updateinfo.aspx 頁面隨即顯示。  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。  
  
-或- 
執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="path" /> 不是虛擬路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合，而 <see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式，並指定是否清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何執行.aspx 網頁`Updateinfo.aspx`中的目前要求和保留<xref:System.Web.HttpRequest.QueryString%2A>和<xref:System.Web.HttpRequest.Form%2A>集合。 程式執行會返回到 [開始] 頁面之後`Updateinfo.aspx`隨即出現。  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。  
  
-或- 
執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="path" /> 不是虛擬路徑。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <param name="writer">要擷取輸出的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。 <see cref="T:System.IO.TextWriter" /> 會擷取已執行處理常式的輸出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A>方法會在指定之虛擬路徑的執行完成之後繼續執行原始的要求。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。  
  
 ASP.NET 不會驗證目前的使用者已獲授權檢視所提供的資源<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯執行原始的資源處理常式會在呼叫之前，ASP.NET 就會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Execute%2A>方法且不重新驗證和授權的邏輯執行新的資源。 如果您的應用程式安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用，以強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A> 執行用戶端重新導向瀏覽器要求新的資源。 此重新導向是進入系統的新要求，因為它被必須的 Internet Information Services (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以確認使用者已透過合併自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法，應用程式會呼叫再<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
   
  
## Examples  
 下列範例會執行`Login.aspx`頁面上目前的目錄中的伺服器，並從網頁透過接收輸出<xref:System.IO.StringWriter>物件`writer`。 它會將寫入從收到的 HTML 資料流`writer`至 HTTP 輸出資料流。  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。  
  
-或- 
執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="path" /> 不是虛擬路徑。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <param name="writer">要擷取輸出的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合，而 <see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。 <see cref="T:System.IO.TextWriter" /> 會擷取網頁的輸出，並且布林參數會指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A>方法會指定虛擬路徑的執行完成之後，繼續執行原始的要求。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。  
  
 ASP.NET 不會驗證目前的使用者已獲授權檢視所提供的資源<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯執行原始的資源處理常式會在呼叫之前，ASP.NET 就會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Execute%2A>方法且不重新驗證和授權的邏輯執行新的資源。 如果您的應用程式安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用，以強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A> 執行用戶端重新導向瀏覽器要求新的資源。 此重新導向是進入系統的新要求，因為它被必須的 Internet Information Services (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以確認使用者已透過合併自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法，應用程式會呼叫再<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
   
  
## Examples  
 下列範例會執行`Login.aspx`頁面上目前的目錄中的伺服器，並從網頁透過接收輸出<xref:System.IO.StringWriter>物件`writer`。 它會將寫入從收到的 HTML 資料流`writer`至 HTTP 輸出資料流。 內容<xref:System.Web.HttpRequest.Form%2A>和<xref:System.Web.HttpRequest.QueryString%2A>集合會保留。  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前 <see cref="T:System.Web.HttpContext" /> 是 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。  
  
-或- 
 <paramref name="path" /> 會以句點 (.) 結束。  
  
-或- 
執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 不是虛擬路徑。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">HTTP 處理常式，實作 <see cref="T:System.Web.IHttpHandler" />，以傳輸目前要求至此。</param>
        <param name="writer">要擷取輸出的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合，而 <see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。 <see cref="T:System.IO.TextWriter" /> 會擷取已執行處理常式的輸出，並且布林參數會指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以撰寫自訂的 HTTP 處理常式來處理特定的預先定義的類型與 Common Language Specification (CLS) 相容的任何語言的 HTTP 要求。 HTTP 處理常式類別，而不是傳統的 ASP (也稱為傳統 ASP) 網頁或 ASP.NET 網頁中定義的可執行程式碼會回應下列特定的要求。 HTTP 處理常式進行互動的低層級的要求和回應服務的 Web 伺服器正在執行 Internet Information Services (IIS) 及它們提供類似的功能 ISAPI 擴充程式，但具有簡單的程式設計模型。  
  
 ASP.NET 不會驗證目前的使用者無權檢視資源，由<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯執行原始的資源處理常式會在呼叫之前，ASP.NET 就會直接呼叫的處理常式，會由<xref:System.Web.HttpServerUtility.Execute%2A>方法且不重新執行驗證和授權邏輯新的資源。 如果您的應用程式的安全性原則需要用戶端具有適當的授權，以取得資源的存取權，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用，以強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>執行用戶端重新導向瀏覽器要求新的資源。 因為此重新導向新的要求進入系統，所以必須以 IIS 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以確認使用者已透過合併自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法，應用程式會呼叫再<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">執行 <paramref name="handler" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="handler" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回先前的例外狀況。</summary>
        <returns>被擲回的先前例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會列印至 HTTP 輸出資料流的應用程式的最後一個錯誤的描述。 如果已不發生任何錯誤，它就會列印 「 沒有錯誤 」。  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將已經編碼排除無效 HTML 字元的字串解碼。  
  
若要編碼或解碼 Web 應用程式之外的值，請使用 <see cref="T:System.Net.WebUtility" /> 類別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的 HTML 字串。</param>
        <summary>將 HTML 編碼字串解碼，並傳回解碼的字串。</summary>
        <returns>解碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼方式可確保文字會正確顯示在瀏覽器，而且無法加以解譯為 HTML 瀏覽器就行了。 比方說，如果文字字串包含小於符號 (\<) 或更新版本比符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 HTML 編碼的字元時，它們會轉換為字串`&lt;`和`&gt;`，因而導致瀏覽器顯示小於符號和大於號正確。 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> 將解碼已被傳送到伺服器的文字。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`若要存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例包含函式`LoadDecodedFile`，這將解碼檔案中的資料，並將它複製到一個字串。  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的 HTML 字串。</param>
        <param name="output">包含已解碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將 HTML 編碼字串解碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼方式可確保文字會正確顯示在瀏覽器，而且無法加以解譯為 HTML 瀏覽器就行了。 比方說，如果文字字串包含小於符號 (\<) 或更新版本比符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 HTML 編碼的字元時，它們會轉換為字串`&lt;`和`&gt;`，因而導致瀏覽器顯示小於符號和大於號正確。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> 將解碼已被傳送到伺服器的文字。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> 是便利的方式來存取<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，<xref:System.Web.HttpServerUtility.HtmlDecode%2A>使用<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例會解碼已 HTML 編碼的傳輸透過 HTTP 的字串。 它會提供名為的字串解碼`EncodedString`其中包含文字"這是&lt;測試字串&gt;。 」，並將它複製到名為字串`DecodedString`做為 「 這是\<測試字串 >。 」。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將字串編碼以顯示於瀏覽器。  
  
若要編碼或解碼 Web 應用程式之外的值，請使用 <see cref="T:System.Net.WebUtility" /> 類別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要編碼的文字字串。</param>
        <summary>將字串作 HTML 編碼，並傳回編碼的字串。</summary>
        <returns>HTML 編碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼方式可確保文字會正確顯示在瀏覽器，而且無法加以解譯為 HTML 瀏覽器就行了。 比方說，如果文字字串包含小於符號 (\<) 或更新版本比符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 HTML 編碼的字元時，它們會轉換為字串`&lt;`和`&gt;`，因而導致瀏覽器顯示小於符號和大於號正確。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`若要存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例會示範如何將 HTML 編碼的值，可能碼 unsafe 程式碼。 程式碼所在的網頁的程式碼後置檔案中。 要編碼的值是硬式編碼在此範例中只是要簡化範例，及顯示值的型別，您可能會進行 HTML 編碼。 一般而言，您會進行 HTML 編碼值，您有來自使用者或要求。 `Result` 是指`Literal`控制項。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何將 HTML 編碼在類別內的值不在程式碼後置檔案。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要編碼的字串。</param>
        <param name="output">包含已編碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將字串作 HTML 編碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼，可確保文字將會正確顯示在瀏覽器中，無法加以解譯為 HTML 瀏覽器中。 比方說，如果文字字串包含小於符號 (\<) 或更新版本比符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 這兩個字元的 HTML 編碼`&lt;`和`&gt;`分別，因而導致瀏覽器顯示小於符號和大於號正確。  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> 是便利的方式來存取<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，<xref:System.Web.HttpServerUtility.HtmlEncode%2A>使用<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例將字串編碼以進行 HTTP 傳輸。 它將字串編碼以名為`TestString`，其中包含文字"這是\<測試字串 >。 」，並將它複製到名為字串`EncodedString`做為 「 這是&lt;測試字串&gt;。 」。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得伺服器的電腦名稱。</summary>
        <value>本機電腦的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將伺服器的電腦名稱儲存為字串變數。  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">無法找到電腦名稱。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Web 應用程式中的虛擬路徑。</param>
        <summary>傳回對應至指定虛擬路徑的實體檔案路徑。</summary>
        <returns>網頁伺服器上對應至 <paramref name="path" /> 的實體檔案路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`path`已`null`，則<xref:System.Web.HttpServerUtility.MapPath%2A>方法會傳回包含目前要求路徑的目錄的完整實體路徑。 相對路徑不會不需要指定現有的檔案或資料夾，此方法才能傳回值。 不過，您無法指定 Web 應用程式以外的路徑。  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A>方法可能包含裝載環境的機密資訊。 傳回的值不應該向使用者顯示。  
  
 位於 Web 應用程式`C:\ExampleSites\TestMapPath`會傳回下列結果：  
  
|從要求|`path`|傳回值|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|"../ OutsideApplication"|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 下列範例示範如何擷取之實體檔案的相對虛擬路徑。 程式碼位於網頁的程式碼後置檔案，並利用預設`Server`物件。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何擷取程式碼後置檔案中沒有在類別內的實體路徑。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。
        
-或- 
<paramref name="path" /> 是實體路徑，但必須使用虛擬路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要求的逾時值 (以秒為單位)。</summary>
        <value>要求的逾時值設定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A>可以在 Web.config 檔案中設定屬性，藉由設定`executionTimeout`屬性[httpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369)項目。 設定的逾時以程式設計方式用<xref:System.Web.HttpServerUtility.ScriptTimeout%2A>屬性會優先於 Web.config 設定。  
  
> [!NOTE]
>  如果您設定`debug`的屬性[httpRuntime](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369)項目`true`在 Web.config 檔案中，值<xref:System.Web.HttpServerUtility.ScriptTimeout%2A>將會被忽略。  
  
   
  
## Examples  
 下列範例會設定為 60 秒的要求逾時期限。  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">逾時期間為 <see langword="null" />，否則不能被設定。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束目前網頁的執行，開始針對目前的要求執行新網頁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <summary>針對目前的要求結束目前網頁的執行，並使用指定的網頁 URL 路徑開始執行新網頁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [傳送到] 頁面上應該是另一個.aspx 頁面。 比方說，傳輸至.asp 或.asmx 頁面不是有效的。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法會保留<xref:System.Web.HttpRequest.QueryString%2A>和<xref:System.Web.HttpRequest.Form%2A>集合。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> 呼叫<xref:System.Web.HttpResponse.End%2A>，哪些則會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。  
  
 ASP.NET 不會驗證目前的使用者已獲授權檢視所提供的資源<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 雖然 ASP.NET 授權和驗證邏輯執行原始的資源處理常式會在呼叫之前，ASP.NET 就會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Transfer%2A>方法且不重新驗證和授權的邏輯執行新的資源。 如果您的應用程式安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用，以強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。 此重新導向是進入系統的新要求，因為它被必須的 Internet Information Services (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以確認使用者已透過合併自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法，應用程式會呼叫再<xref:System.Web.HttpServerUtility.Transfer%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合，而 <see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>結束目前網頁的執行，並使用指定的網頁 URL 路徑開始執行新網頁。 指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [傳送到] 頁面上應該是另一個.aspx 頁面。 比方說，傳輸至.asp 或.asmx 頁面不是有效的。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> 呼叫<xref:System.Web.HttpResponse.End%2A>，哪些則會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。  
  
 如果您設定`preserveForm`參數來`true`，[目標] 頁面將能夠存取前一頁的檢視狀態使用<xref:System.Web.UI.Page.PreviousPage%2A>屬性。  
  
 基於安全考量，您應該保留`enableViewStateMac`屬性設為`true`。 ASP.NET 不會驗證目前的使用者已獲授權檢視所提供的資源<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 雖然 ASP.NET 授權和驗證邏輯執行原始的資源處理常式會在呼叫之前，ASP.NET 就會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Transfer%2A>方法且不重新驗證和授權的邏輯執行新的資源。 如果您的應用程式安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用，以強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。 此重新導向是進入系統的新要求，因為它被必須的 Internet Information Services (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以確認使用者已透過合併自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法，應用程式會呼叫再<xref:System.Web.HttpServerUtility.Transfer%2A>方法。  
  
   
  
## Examples  
 下列範例會執行目前的頁面相同目錄中新的頁面。  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">目前的網頁要求為回呼。</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">HTTP 處理常式，實作 <see cref="T:System.Web.IHttpHandler" />，以傳輸目前要求至此。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合，而 <see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>結束目前網頁的執行，並使用實作 <see cref="T:System.Web.IHttpHandler" /> 介面的自訂 HTTP 處理常式開始執行新要求，以及指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以撰寫自訂的 HTTP 處理常式來處理特定的預先定義的類型與 Common Language Specification (CLS) 相容的任何語言的 HTTP 要求。 HTTP 處理常式類別，而不是傳統的 ASP (也稱為傳統 ASP) 網頁或 ASP.NET 網頁中定義的可執行程式碼會回應下列特定的要求。 HTTP 處理常式進行互動的低層級的要求和回應服務的 Web 伺服器正在執行 Internet Information Services (IIS) 及它們提供類似的功能 ISAPI 擴充程式，但具有簡單的程式設計模型。  
  
 如果您設定`preserveForm`參數來`true`，[目標] 頁面將能夠存取前一頁的檢視狀態使用<xref:System.Web.UI.Page.PreviousPage%2A>屬性。  
  
 基於安全考量，您應該保留`enableViewStateMac`屬性設為`true`。 ASP.NET 不會驗證目前的使用者已獲授權檢視所提供的資源<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 雖然 ASP.NET 授權和驗證邏輯執行原始的資源處理常式會在呼叫之前，ASP.NET 就會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Transfer%2A>方法，以及新的執行不會重新執行驗證和授權邏輯資源。 如果您的應用程式的安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用，以強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。 因為此重新導向新的要求進入系統，所以必須以 IIS 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以確認使用者已透過合併自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法，應用程式會呼叫再<xref:System.Web.HttpServerUtility.Transfer%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">目前的網頁要求為回呼。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行所指定 URL 的非同步執行工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> .NET Framework 3.5 版中引進。 摘要的.NET Framework 的詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <summary>執行所指定 URL 的非同步執行工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載會呼叫<xref:System.Web.HttpServerUtility.TransferRequest%2A>多載`preserveForm`參數設為`false`，則`method`參數設定為`null`，則`headers`參數設定為`null`，和`preserveUser`參數設定為`true`。 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的 Integrated 管線模式。</exception>
        <exception cref="T:System.Web.HttpException">無法使用伺服器來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 參數無效。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.Form" /> 集合，<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>執行所指定 URL 的非同步執行工作，並保留查詢字串參數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會呼叫<xref:System.Web.HttpServerUtility.TransferRequest%2A>多載`preserveForm`參數設定中，傳遞的值為`method`參數設定為`null`，則`headers`參數設為`null`，和`preserveUser`參數集若要`true`。 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的 Integrated 管線模式。</exception>
        <exception cref="T:System.Web.HttpException">無法使用伺服器來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 參數無效。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.Form" /> 集合，<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <param name="method">用於執行新要求的 HTTP 方法。</param>
        <param name="headers">新要求之要求標頭的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</param>
        <summary>使用指定的 HTTP 方法與標頭執行所指定 URL 的非同步執行工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用整合式的管線模式執行時，會使用這個方法[!INCLUDE[iisver](~/includes/iisver-md.md)]以允許要求處理程序從一個資源類型之間傳輸時執行正確的要求內容的目標要求。 例如，您可以使用<xref:System.Web.HttpServerUtility.TransferRequest%2A>ASPX 頁面要求傳送至 XML 頁面要求的方法。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A>方法執行非同步的子系執行指定的 URL 具有下列條件：  
  
-   如果`path`參數會指定查詢字串，它會當做新的查詢字串。 如果沒有查詢字串包含，則會重複使用要求的查詢字串。  
  
-   如果`method`參數指定，則會使用它。 如果是`null`，將會使用原始要求的 HTTP 方法。  
  
-   如果`preserveForm`參數是`true`，目前實體的要求可供目標要求。 這可讓表單張貼，並上傳至傳輸。  
  
-   如果原始要求上目前設定的使用者身分識別，身分識別會傳輸至新的要求。 這可讓已驗證的要求，重複使用的新要求的驗證結果。 如果您不想要傳送的使用者，將使用者設定為`null`在移轉之前在原始要求。  
  
-   如果`headers`指定參數，新的要求會執行指定的標頭。 這可用來修改要求標頭和新的要求，cookie，或新增特殊標頭，指定已在接收到原始的要求。  
  
     這個方法會呼叫<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29>方法多載`preserveUser`參數設為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 以 Integrated 模式執行。</exception>
        <exception cref="T:System.Web.HttpException">無法使用伺服器來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 參數無效。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveUser" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">路徑。</param>
        <param name="preserveForm"><see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.Form" /> 集合，<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <param name="method">用於新要求的 HTTP 方法。</param>
        <param name="headers">包含新要求之要求標頭的 <see cref="T:System.Collections.Specialized.NameValueCollection" /> 物件。</param>
        <param name="preserveUser"><see langword="true" /> 表示要保留使用者識別，否則為 <see langword="false" />。 這個方法的其他方法多載會呼叫這個多載（在此參數設定為<see langword="true" />的情況下）。</param>
        <summary>使用指定的 HTTP 方法、標頭和路徑，並選擇性地保留表單值和使用者識別，執行所指定 URL 的非同步執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的 Integrated 管線模式。</exception>
        <exception cref="T:System.Web.HttpException">無法使用伺服器來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 參數無效。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將編碼為 HTTP 傳輸的字串解碼，並以 URL 送至伺服器。  
  
若要編碼或解碼 Web 應用程式之外的值，請使用 <see cref="T:System.Net.WebUtility" /> 類別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的文字字串。</param>
        <summary>將字串作 URL 解碼，並傳回解碼的字串。</summary>
        <returns>解碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有的瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼`<a>`標記，或在查詢字串的字串可能由瀏覽器要求字串重新傳送。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`若要存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例示範如何進行 URL 解碼值從擷取的查詢字串。 程式碼所在的網頁的程式碼後置檔案中。 `ReturnPage` 是指`HyperLink`控制項。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何進行 URL 解碼值從類別內，不是在程式碼後置檔案中。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的 HTML 字串。</param>
        <param name="output">包含已解碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將 URL 中收到的 HTML 字串解碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有的瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼`<a>`標記，或在查詢字串的字串可能由瀏覽器要求字串重新傳送。  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> 是便利的方式來存取<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，<xref:System.Web.HttpServerUtility.UrlDecode%2A>使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例會將名為字串的解碼`EncodedString`（在 URL 中收到） 至名為字串`DecodedString`。  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>經由 URL 將字串編碼，以進行從 Web 伺服器至用戶端的可靠 HTTP 傳輸。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> 是便利的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，<xref:System.Web.HttpServerUtility.UrlEncode%2A>使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要作 URL 編碼的文字。</param>
        <summary>將字串作 URL 編碼，並傳回編碼的字串。</summary>
        <returns>URL 編碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有的瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼`<a>`標記，或在查詢字串的字串可能由瀏覽器要求字串重新傳送。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`若要存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例示範如何將 URL 編碼的值來當做超連結的查詢字串值。 程式碼所在的網頁的程式碼後置檔案中。 要編碼的值是硬式編碼在此範例中只是要簡化範例，及顯示值的型別，您可能會將 URL 編碼。 一般而言，您會將 URL 編碼值，您有來自使用者或要求。 `NextPage` 是指`HyperLink`控制項。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何將 URL 編碼類別內的值不在程式碼後置檔案。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要編碼的文字字串。</param>
        <param name="output">包含已編碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將字串作 URL 編碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有的瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼`<a>`標記，或在查詢字串的字串可能由瀏覽器要求字串重新傳送。  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> 是便利的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>從 ASP.NET 應用程式的執行階段的方法。 就內部而言，<xref:System.Web.HttpServerUtility.UrlEncode%2A>使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例將字串編碼以進行 HTTP 傳輸。 它將字串編碼以名為`TestString`，其中包含文字 「 這是\<測試字串 >。 」，並將它複製到名為字串`EncodedString`為"此 + 是 + a + %3ctest + 字串 %3e。 」。  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要作 URL 編碼的文字。</param>
        <summary>請勿使用，只在需要瀏覽器相容性時使用。 使用 <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />。</summary>
        <returns>URL 編碼的文字。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">要解碼的 URL 字串語彙基元。</param>
        <summary>使用 Base 64 數字，將 URL 字串語彙基元解碼成其對應的位元組陣列。</summary>
        <returns>包含已解碼 URL 字串語彙基元的位元組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A>方法會將 URL 字串語彙基元，二進位資料編碼為 base 64 數字，轉換為其對應的位元組陣列表示。 使用<xref:System.Web.HttpServerUtility.UrlTokenDecode%2A>方法來解碼權杖在 URL 上傳輸和編碼使用<xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>。  
  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A>方法會傳回空的位元組陣列，如果`input`參數的長度小於 1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 參數的值為 <see langword="null" />。</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">要編碼的位元組陣列。</param>
        <summary>將位元組陣列編碼成其對等的字串表示，該字串使用 Base 64 數字且可在 URL 上傳輸。</summary>
        <returns>如果位元組陣列 *length* 大於一，則為包含已編碼語彙基元的字串；否則為空字串 ("")。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>方法會將位元組陣列轉換成編碼為 base 64 數字相等的字串表示。 可以在 URL 上傳輸產生的字串語彙基元。  
  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>會傳回空字串，如果`input`參數的長度小於 1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 參數的值為 <see langword="null" />。</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>