<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af79683dbebba2bc232c66a7a70dd0748a5935a9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610762" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 Helper 方法以處理 Web 要求。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法和屬性<xref:System.Web.HttpServerUtility>類別會公開透過內建<xref:System.Web.HttpContext.Server%2A>ASP.NET 所提供的物件。  
  
   
  
## Examples  
 本主題隨附了含有原始程式碼的 Visual Studio Web 站台專案：[下載](http://go.microsoft.com/fwlink/?LinkId=192870)。  
  
 下列範例示範如何使用<xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法和<xref:System.Web.HttpServerUtility.UrlEncode%2A>方法<xref:System.Web.HttpServerUtility>類別。 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法可協助確保將會轉譯為靜態文字，而不是可執行的指令碼或 HTML 元素的瀏覽器中輸入任何使用者提供的字串。 <xref:System.Web.HttpServerUtility.UrlEncode%2A>方法編碼的 Url，以便正確地傳送 HTTP 資料流中。  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除先前的例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會清除上次擲回的例外狀況。  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立 COM 物件的伺服器執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">要建立執行個體的類別或物件類型。</param>
        <summary>建立物件程式設計識別項 (ProgID) 所識別之 COM 物件的伺服器執行個體。</summary>
        <returns>新物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會使用物件的 ProgID 來建立物件。  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">無法建立物件的執行個體。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" />，表示要建立的物件。</param>
        <summary>建立以物件類型識別的 COM 物件的伺服器執行個體。</summary>
        <returns>新物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">要建立執行個體之物件的類別識別項。</param>
        <summary>建立以物件的類別識別項 (CLSID) 識別的 COM 物件的伺服器執行個體。</summary>
        <returns>新物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何使用<xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A>方法來建立 COM 物件的伺服器執行個體。  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">無法建立物件的執行個體。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在目前要求的內容中執行指定資源的處理常式，並將執行傳回叫用它的網頁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A>方法會在新網頁的執行完成之後繼續執行原始頁面。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。  
  
 ASP.NET 不會驗證目前使用者是否獲得授權檢視所傳遞的資源<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Execute%2A>方法並不會重新執行驗證和授權邏輯新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A> 執行用戶端重新導向瀏覽器要求新的資源。 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前執行的應用程式呼叫<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
   
  
## Examples  
 下列範例會顯示.aspx 網頁 」 Updateinfo.aspx"在目前的目錄。 執行程式返回到起始頁 Updateinfo.aspx 頁面隨即顯示。  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。  
  
 \-或-  
  
 執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="path" /> 不是虛擬路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合；<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式，並指定是否清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何執行.aspx 頁面`Updateinfo.aspx`在目前要求和保留<xref:System.Web.HttpRequest.QueryString%2A>和<xref:System.Web.HttpRequest.Form%2A>集合。 程式執行到起始頁之後會傳回`Updateinfo.aspx`隨即出現。  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。  
  
 \-或-  
  
 執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="path" /> 不是虛擬路徑。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <param name="writer">要擷取輸出的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。 <see cref="T:System.IO.TextWriter" /> 會擷取已執行處理常式的輸出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A>方法會執行指定的虛擬路徑完成之後，繼續執行原始要求。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。  
  
 ASP.NET 不會驗證目前使用者是否獲得授權檢視所傳遞的資源<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Execute%2A>方法並不會重新執行驗證和授權邏輯新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A> 執行用戶端重新導向瀏覽器要求新的資源。 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前執行的應用程式呼叫<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
   
  
## Examples  
 下列範例會執行`Login.aspx`在目前的目錄中的伺服器上，從透過頁面接收輸出<xref:System.IO.StringWriter>物件`writer`。 它會將收到來自 HTML 資料流`writer`至 HTTP 輸出資料流。  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。  
  
 \-或-  
  
 執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="path" /> 不是虛擬路徑。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要執行的 URL 路徑。</param>
        <param name="writer">要擷取輸出的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合；<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。 <see cref="T:System.IO.TextWriter" /> 會擷取網頁的輸出，並且布林參數會指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A>方法指定的虛擬路徑的執行完成之後會繼續執行原始的要求。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。  
  
 ASP.NET 不會驗證目前使用者是否獲得授權檢視所傳遞的資源<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Execute%2A>方法並不會重新執行驗證和授權邏輯新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A> 執行用戶端重新導向瀏覽器要求新的資源。 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前執行的應用程式呼叫<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
   
  
## Examples  
 下列範例會執行`Login.aspx`在目前的目錄中的伺服器上，從透過頁面接收輸出<xref:System.IO.StringWriter>物件`writer`。 它會將收到來自 HTML 資料流`writer`至 HTTP 輸出資料流。 內容<xref:System.Web.HttpRequest.Form%2A>和<xref:System.Web.HttpRequest.QueryString%2A>集合都會保留下來。  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前 <see cref="T:System.Web.HttpContext" /> 是 Null 參考 (在 Visual Basic 中為 <see langword="Nothing" />)。  
  
 \-或-  
  
 <paramref name="path" /> 結束於句點 (.)。  
  
 \-或-  
  
 執行 <paramref name="path" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 不是虛擬路徑。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">HTTP 處理常式，實作 <see cref="T:System.Web.IHttpHandler" />，以傳輸目前要求至此。</param>
        <param name="writer">要擷取輸出的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合；<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>在目前要求的內容中，執行指定虛擬路徑的處理常式。 <see cref="T:System.IO.TextWriter" /> 會擷取已執行處理常式的輸出，並且布林參數會指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以撰寫自訂 HTTP 處理常式來處理 HTTP 要求中任何以 Common Language Specification (CLS) 相容的語言特定的預先定義的類型。 定義 HTTP 處理常式類別，而不是傳統 ASP (也稱為傳統 ASP) 網頁或 ASP.NET 網頁中的可執行程式碼回應這些特定的要求。 進行互動的低層級的要求和回應服務的 Web 伺服器正在執行網際網路資訊服務 (IIS) 允許 HTTP 處理常式，並且會提供類似功能的 ISAPI 擴充程式但更簡單的程式設計模型。  
  
 ASP.NET 不會驗證目前使用者是否獲得授權檢視資源前所交付<xref:System.Web.HttpServerUtility.Execute%2A>方法。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫處理常式所指定之<xref:System.Web.HttpServerUtility.Execute%2A>方法並不會重新執行驗證和授權邏輯新的資源。 如果您的應用程式的安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供的自訂存取控制機制。  
  
 您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Execute%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>用戶端重新導向瀏覽器要求新的資源。 這個重新導向時輸入系統的新要求，因為它必須同時 IIS 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前執行的應用程式呼叫<xref:System.Web.HttpServerUtility.Execute%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">執行 <paramref name="handler" /> 指定的處理常式時發生錯誤。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handler" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回先前的例外狀況。</summary>
        <returns>被擲回的先前例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會列印至 HTTP 輸出資料流的應用程式的最後一個錯誤的描述。 如果不發生任何錯誤，它會顯示 「 沒有錯誤 」。  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將已經編碼排除無效 HTML 字元的字串解碼。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <see cref="T:System.Net.WebUtility" /> 類別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的 HTML 字串。</param>
        <summary>將 HTML 編碼字串解碼，並傳回解碼的字串。</summary>
        <returns>解碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼確保文字會正確顯示在瀏覽器並不會解譯為 HTML 瀏覽器。 例如，如果文字字串包含小於符號 (\<) 或大於符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 當字元會以 HTML 編碼時，公告會轉換成字串`&lt;`和`&gt;`，因而導致瀏覽器顯示小於符號和大於號正確。 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> 將解碼已被傳送到伺服器的文字。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例包含函式`LoadDecodedFile`，這將檔案中的資料解碼，並將它複製到一個字串。  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的 HTML 字串。</param>
        <param name="output">包含已解碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將 HTML 編碼字串解碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼確保文字會正確顯示在瀏覽器並不會解譯為 HTML 瀏覽器。 例如，如果文字字串包含小於符號 (\<) 或大於符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 當字元會以 HTML 編碼時，公告會轉換成字串`&lt;`和`&gt;`，因而導致瀏覽器顯示小於符號和大於號正確。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> 將解碼已被傳送到伺服器的文字。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> 是方便的方式來存取<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，<xref:System.Web.HttpServerUtility.HtmlDecode%2A>使用<xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例會將已傳輸的 HTML 編碼透過 HTTP 的字串解碼。 它提供將字串解碼，名為`EncodedString`其中包含文字"這是&lt;測試字串&gt;。 」，並將它複製到名為字串`DecodedString`做為 「 這是\<測試字串 >。 」。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將字串編碼以顯示於瀏覽器。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <see cref="T:System.Net.WebUtility" /> 類別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要編碼的文字字串。</param>
        <summary>將字串作 HTML 編碼，並傳回編碼的字串。</summary>
        <returns>HTML 編碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼確保文字會正確顯示在瀏覽器並不會解譯為 HTML 瀏覽器。 例如，如果文字字串包含小於符號 (\<) 或大於符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 當字元會以 HTML 編碼時，公告會轉換成字串`&lt;`和`&gt;`，因而導致瀏覽器顯示小於符號和大於號正確。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例會示範如何以 HTML 編碼的值，可能代碼 unsafe 程式碼。 程式碼位於 web 網頁的程式碼後置檔案中。 要編碼的值是硬式編碼在此範例僅供簡化範例，顯示值的型別，您可能會進行 HTML 編碼。 一般而言，您就是進行 HTML 編碼所收到使用者或要求的值。 `Result` 是指`Literal`控制項。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何以 HTML 編碼類別內的值不在程式碼後置檔案。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要編碼的字串。</param>
        <param name="output">包含已編碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將字串作 HTML 編碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML 編碼，可確保文字將會正確顯示瀏覽器中，不會解譯為 HTML 瀏覽器中。 例如，如果文字字串包含小於符號 (\<) 或大於符號 (>)，瀏覽器會將這些字元解譯為左或右括號的 HTML 標記。 這兩個字元的 HTML 編碼方式是`&lt;`和`&gt;`分別，因而導致瀏覽器顯示小於符號和大於號正確。  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> 是方便的方式來存取<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，<xref:System.Web.HttpServerUtility.HtmlEncode%2A>使用<xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例將字串編碼以進行 HTTP 傳輸。 它將名為的字串編碼`TestString`，其中包含文字"這是\<測試字串 >。 」，並將它複製到名為字串`EncodedString`做為 「 這是&lt;測試字串&gt;。"。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得伺服器的電腦名稱。</summary>
        <value>本機電腦的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將伺服器的電腦名稱儲存為字串變數。  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">找不到電腦名稱。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Web 應用程式中的虛擬路徑。</param>
        <summary>傳回對應於指定虛擬路徑的實體檔案路徑。</summary>
        <returns>網頁伺服器上對應至 <paramref name="path" /> 的實體檔案路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`path`是`null`、<xref:System.Web.HttpServerUtility.MapPath%2A>方法會傳回包含目前要求路徑之目錄的完整實體路徑。 相對路徑不會不需要指定現有的檔案或資料夾，此方法傳回的值。 不過，您無法指定 Web 應用程式之外的路徑。  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A>方法可能包含機密資訊的裝載環境。 傳回值不應該顯示給使用者。  
  
 Web 應用程式位於`C:\ExampleSites\TestMapPath`就會傳回下列結果：  
  
|從要求|`path`|傳回值|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|"../OutsideApplication"|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 下列範例會示範如何擷取實體檔案的相對虛擬路徑。 此程式碼位於 web 網頁的程式碼後置檔案，並會利用預設`Server`物件。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何擷取的程式碼後置檔案中沒有類別中的實體路徑。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。
        
-或- 
        
<paramref name="path" /> 是實體路徑，但必須使用虛擬路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得和設定要求的逾時值 (以秒為單位)。</summary>
        <value>要求的逾時值設定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A>可以在 Web.config 檔案中設定屬性，藉由設定`executionTimeout`項目的屬性。 設定逾時以程式設計方式使用<xref:System.Web.HttpServerUtility.ScriptTimeout%2A>屬性會優先於 Web.config 設定。  
  
> [!NOTE]
>  如果您設定`debug`至項目的屬性`true`在 Web.config 檔案中，值<xref:System.Web.HttpServerUtility.ScriptTimeout%2A>會被忽略。  
  
   
  
## Examples  
 下列範例會設定要求逾時期限為 60 秒。  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">目前的 <see cref="T:System.Web.HttpContext" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">逾時期間為 <see langword="null" />，否則不能被設定。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束目前網頁的執行，開始針對目前的要求執行新網頁。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <summary>針對目前的要求結束目前網頁的執行，並使用指定的網頁 URL 路徑開始執行新網頁。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送到網頁應該是另一個.aspx 網頁。 比方說，傳輸至.asp 或.asmx 頁面不正確。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法可保留<xref:System.Web.HttpRequest.QueryString%2A>和<xref:System.Web.HttpRequest.Form%2A>集合。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> 呼叫<xref:System.Web.HttpResponse.End%2A>，哪些則會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。  
  
 ASP.NET 不會驗證目前使用者是否獲得授權檢視所傳遞的資源<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Transfer%2A>方法並不會重新執行驗證和授權邏輯新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前執行的應用程式呼叫<xref:System.Web.HttpServerUtility.Transfer%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合；<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>結束目前網頁的執行，並使用指定的網頁 URL 路徑開始執行新網頁。 指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳送到網頁應該是另一個.aspx 網頁。 比方說，傳輸至.asp 或.asmx 頁面不正確。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> 呼叫<xref:System.Web.HttpResponse.End%2A>，哪些則會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。  
  
 如果您設定`preserveForm`參數`true`，[目標] 頁面將能夠透過存取前一頁的檢視狀態<xref:System.Web.UI.Page.PreviousPage%2A>屬性。  
  
 基於安全性目的，您應該保留`enableViewStateMac`屬性設為`true`。 ASP.NET 不會驗證目前使用者是否獲得授權檢視所傳遞的資源<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Transfer%2A>方法並不會重新執行驗證和授權邏輯新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。  
  
 您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前執行的應用程式呼叫<xref:System.Web.HttpServerUtility.Transfer%2A>方法。  
  
   
  
## Examples  
 下列範例會執行目前的頁面相同目錄中新的頁面。  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">目前的網頁要求為回呼。</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">HTTP 處理常式，實作 <see cref="T:System.Web.IHttpHandler" />，以傳輸目前要求至此。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合；<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>結束目前網頁的執行，並使用實作 <see cref="T:System.Web.IHttpHandler" /> 介面的自訂 HTTP 處理常式開始執行新要求，以及指定是否要清除 <see cref="P:System.Web.HttpRequest.QueryString" /> 和 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以撰寫自訂 HTTP 處理常式來處理 HTTP 要求中任何以 Common Language Specification (CLS) 相容的語言特定的預先定義的類型。 定義 HTTP 處理常式類別，而不是傳統 ASP (也稱為傳統 ASP) 網頁或 ASP.NET 網頁中的可執行程式碼回應這些特定的要求。 進行互動的低層級的要求和回應服務的 Web 伺服器正在執行網際網路資訊服務 (IIS) 允許 HTTP 處理常式，並且會提供類似功能的 ISAPI 擴充程式但更簡單的程式設計模型。  
  
 如果您設定`preserveForm`參數`true`，[目標] 頁面將能夠透過存取前一頁的檢視狀態<xref:System.Web.UI.Page.PreviousPage%2A>屬性。  
  
 基於安全性目的，您應該保留`enableViewStateMac`屬性設為`true`。 ASP.NET 不會驗證目前使用者是否獲得授權檢視所傳遞的資源<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫所指定的處理常式<xref:System.Web.HttpServerUtility.Transfer%2A>方法，並針對新的作用不會重新執行驗證和授權邏輯資源。 如果您的應用程式的安全性原則需要有適當的權限可存取資源的用戶端，應該強制重新授權應用程式，或提供的自訂存取控制機制。  
  
 您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而非<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。 這個重新導向時輸入系統的新要求，因為它必須同時 IIS 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。  
  
 您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前執行的應用程式呼叫<xref:System.Web.HttpServerUtility.Transfer%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">目前的網頁要求為回呼。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行所指定 URL 的非同步執行工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> .NET Framework 3.5 版中引進了。 摘要.NET Framework 的詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <summary>執行所指定 URL 的非同步執行工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載會呼叫<xref:System.Web.HttpServerUtility.TransferRequest%2A>多載`preserveForm`參數設定為`false`、`method`參數設定為`null`、`headers`參數設定為`null`，而`preserveUser`參數設定為`true`。 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的 Integrated 管線模式。</exception>
        <exception cref="T:System.Web.HttpException">伺服器無法用來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數是無效的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.Form" /> 集合，<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <summary>執行所指定 URL 的非同步執行工作，並保留查詢字串參數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載呼叫<xref:System.Web.HttpServerUtility.TransferRequest%2A>多載`preserveForm`參數設定中，傳遞的值為`method`參數設定為`null`、`headers`參數設定為`null`，而`preserveUser`參數集若要`true`。 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的 Integrated 管線模式。</exception>
        <exception cref="T:System.Web.HttpException">伺服器無法用來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數是無效的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">要在伺服器上執行之新網頁的 URL 路徑。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.Form" /> 集合，<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <param name="method">用於執行新要求的 HTTP 方法。</param>
        <param name="headers">新要求之要求標頭的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</param>
        <summary>使用指定的 HTTP 方法與標頭執行所指定 URL 的非同步執行工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用的整合式的管線模式中執行時，這個方法用[!INCLUDE[iisver](~/includes/iisver-md.md)]允許從一個資源類型到另一個傳送執行正確的要求內容的目標要求時的要求處理。 例如，您可以使用<xref:System.Web.HttpServerUtility.TransferRequest%2A>方法來傳輸要求 XML 頁面的 ASPX 頁面的要求。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A>方法執行非同步的子系執行所指定的 url，使用以下條件：  
  
-   如果`path`參數指定的查詢字串，它會當做新的查詢字串。 如果包含任何查詢字串，不則要求的查詢字串將會重複使用。  
  
-   如果`method`參數指定，則會使用它。 如果是`null`，將會使用原始要求的 HTTP 方法。  
  
-   如果`preserveForm`參數是`true`，目前實體的要求將提供給目標要求。 這可讓表單張貼，並上傳至傳輸。  
  
-   如果目前的原始要求上設定的使用者身分識別，身分識別將轉移到新的要求。 這可讓已驗證的要求，重複使用的新要求的驗證結果。 如果您不想要傳送的使用者，將使用者設定為`null`之前在原始要求。  
  
-   如果`headers`參數指定，則新的要求將使用指定的標頭來執行。 這可以用來修改要求標頭和新的要求，cookie，或加入特殊的標頭，指定已在接收到原始要求。  
  
     這個方法會呼叫<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29>方法多載`preserveUser`參數設定為`true`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 以 Integrated 模式執行。</exception>
        <exception cref="T:System.Web.HttpException">伺服器無法用來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數是無效的。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">路徑。</param>
        <param name="preserveForm">
          <see langword="true" /> 表示保留 <see cref="P:System.Web.HttpRequest.Form" /> 集合，<see langword="false" /> 表示清除 <see cref="P:System.Web.HttpRequest.Form" /> 集合。</param>
        <param name="method">用於新要求的 HTTP 方法。</param>
        <param name="headers">包含新要求之要求標頭的 <see cref="T:System.Collections.Specialized.NameValueCollection" /> 物件。</param>
        <param name="preserveUser">
          <see langword="true" /> 表示要保留使用者識別，否則為 <see langword="false" />。 這個方法的其他方法多載會呼叫這個多載（在此參數設定為<see langword="true" />的情況下）。</param>
        <summary>使用指定的 HTTP 方法、標頭和路徑，並選擇性地保留表單值和使用者識別，執行所指定 URL 的非同步執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此要求需要 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的 Integrated 管線模式。</exception>
        <exception cref="T:System.Web.HttpException">伺服器無法用來處理要求。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數是無效的。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將編碼為 HTTP 傳輸的字串解碼，並以 URL 送至伺服器。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <see cref="T:System.Net.WebUtility" /> 類別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的文字字串。</param>
        <summary>將字串作 URL 解碼，並傳回解碼的字串。</summary>
        <returns>解碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例顯示如何進行 URL 解碼值是從所擷取的查詢字串。 程式碼位於 web 網頁的程式碼後置檔案中。 `ReturnPage` 是指`HyperLink`控制項。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何進行 URL 解碼值從類別內，不是程式碼後置檔案中。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要解碼的 HTML 字串。</param>
        <param name="output">包含已解碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將 URL 中收到的 HTML 字串解碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> 是方便的方式來存取<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，<xref:System.Web.HttpServerUtility.UrlDecode%2A>使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType>来解碼的字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例會將名為字串`EncodedString`（在 URL 中接收） 到名為字串`DecodedString`。  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>經由 URL 將字串編碼，以進行從 Web 伺服器至用戶端的可靠 HTTP 傳輸。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> 是方便的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，<xref:System.Web.HttpServerUtility.UrlEncode%2A>使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要作 URL 編碼的文字。</param>
        <summary>將字串作 URL 編碼，並傳回編碼的字串。</summary>
        <returns>URL 編碼的文字。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。  
  
 這個方法是便利的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`存取的執行個體<xref:System.Web.HttpServerUtility>類別。  
  
 Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。  
  
   
  
## Examples  
 下列範例顯示如何要作 URL 編碼的值，可做為超連結的查詢字串值。 程式碼位於 web 網頁的程式碼後置檔案中。 要編碼的值是硬式編碼在此範例僅供簡化範例，顯示值的型別，您可能要作 URL 編碼。 一般而言，您就是要作 URL 編碼值，您有來自使用者或要求。 `NextPage` 是指`HyperLink`控制項。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 下一個範例是類似於先前的範例，但它會顯示如何要作 URL 編碼類別內的值不在程式碼後置檔案。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">要編碼的文字字串。</param>
        <param name="output">包含已編碼字串的 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</param>
        <summary>將字串作 URL 編碼，並送出結果輸出至 <see cref="T:System.IO.TextWriter" /> 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 字元，例如問題標記 （？）、 連字號 (&)、 斜線符號 （/），和空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> 是方便的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>方法在執行階段從 ASP.NET 應用程式。 就內部而言，<xref:System.Web.HttpServerUtility.UrlEncode%2A>使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType>編碼字串。  
  
 若要編碼或解碼 Web 應用程式之外的值，請使用 <xref:System.Net.WebUtility> 類別。  
  
   
  
## Examples  
 下列範例將字串編碼以進行 HTTP 傳輸。 它將名為的字串編碼`TestString`，其中包含文字"這是\<測試字串 >。 」，並將它複製到名為字串`EncodedString`做為"這個 + 是 + a + %3ctest + 字串 %3e。 」。  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要作 URL 編碼的文字。</param>
        <summary>請勿使用，只在需要瀏覽器相容性時使用。 使用 <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />。</summary>
        <returns>URL 編碼的文字。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">要解碼的 URL 字串語彙基元。</param>
        <summary>使用 Base 64 數字，將 URL 字串語彙基元解碼成其對應的位元組陣列。</summary>
        <returns>包含已解碼 URL 字串語彙基元的位元組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A>方法會將 URL 字串語彙基元，二進位資料編碼為 base 64 數字，轉換為其對應的位元組陣列表示。 使用<xref:System.Web.HttpServerUtility.UrlTokenDecode%2A>方法來解碼語彙基元在 URL 上傳輸和編碼使用<xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>。  
  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A>方法會傳回空的位元組陣列，如果`input`參數的長度小於 1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 參數的值為 <see langword="null" />。</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">要編碼的位元組陣列。</param>
        <summary>將位元組陣列編碼成其對等的字串表示，該字串使用 Base 64 數字且可在 URL 上傳輸。</summary>
        <returns>如果位元組陣列 *length* 大於一，則為包含已編碼語彙基元的字串；否則為空字串 ("")。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>方法將位元組陣列轉換成以 base 64 數字編碼的相等字串表示。 可以在 URL 上傳輸產生的字串語彙基元。  
  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>會傳回空字串，如果`input`參數的長度小於 1。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> 參數的值為 <see langword="null" />。</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>