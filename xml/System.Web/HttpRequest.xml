<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d74d266f42608ff56b88df4f54acba091ee4ce60" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58874900" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>允許 ASP.NET 在 Web 要求期間讀取用戶端送出的 HTTP 值。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法和屬性<xref:System.Web.HttpRequest>類別會透過公開`Request`的屬性<xref:System.Web.HttpApplication>， <xref:System.Web.HttpContext>， <xref:System.Web.UI.Page>，和<xref:System.Web.UI.UserControl>類別。  
  
 從存取資料<xref:System.Web.HttpRequest.QueryString%2A>， <xref:System.Web.HttpRequest.Form%2A>， <xref:System.Web.HttpRequest.Cookies%2A>，或<xref:System.Web.HttpRequest.ServerVariables%2A>集合，您可以撰寫`Request["key"]`的範例所示，<xref:System.Web.HttpRequest.QueryString%2A>屬性。  
  
> [!NOTE]
>  Unicode 支援<xref:System.Web.HttpRequest>類別成員需要 IIS 6.0 或更新版本。  
  
   
  
## Examples  
 下列範例存取<xref:System.Web.HttpRequest>使用目前要求的執行個體<xref:System.Web.UI.Page.Request%2A>屬性<xref:System.Web.UI.Page>類別。  
  
 您可以使用簡化的語法來存取資料，從<xref:System.Web.HttpRequest.QueryString%2A>， <xref:System.Web.HttpRequest.Form%2A>， <xref:System.Web.HttpRequest.Cookies%2A>，或<xref:System.Web.HttpRequest.ServerVariables%2A>集合。 您可以撰寫`Request["key"]`。  
  
 第一個範例示範如何擷取查詢字串值，載入頁面。  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 下一個範例示範如何檢查會驗證要求並擷取原始的 URL。  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 含有原始程式碼的 Visual Studio Web site 專案位於本主題隨附了：[下載](https://go.microsoft.com/fwlink/?LinkID=191455)。  
  
 這個範例會使用<xref:System.IO.StreamWriter>類別來寫入數個值<xref:System.Web.HttpRequest>類別檔案的內容。 型別字串的屬性，這些值會以 HTML 編碼會寫入至檔案。 屬性代表集合的迴圈，並包含每個索引鍵/值組會寫入至檔案。  
  
> [!IMPORTANT]
>  這個範例有一個可接受使用者輸入的文字方塊，這可能會造成安全性威脅。 根據預設，ASP.NET Web 網頁會驗證使用者輸入未包含指令碼或 HTML 項目。 如需詳細資訊，請參閱 [Script Exploits Overview](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07) (指令碼攻擊概觀)。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">與要求相關聯的檔案名稱。</param>
        <param name="url">目前要求 URL 的相關資訊。</param>
        <param name="queryString">利用要求所傳送的整個查詢字串 (<c>'?'</c> 之後的所有內容)。</param>
        <summary>初始化 <see cref="T:System.Web.HttpRequest" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您不需要建立您自己的執行個體<xref:System.Web.HttpRequest>類別。 方法和屬性<xref:System.Web.HttpRequest>類別會透過公開`Request`屬性<xref:System.Web.HttpApplication>， <xref:System.Web.HttpContext>， <xref:System.Web.UI.Page>，和<xref:System.Web.UI.UserControl>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制終止造成任何待處理 I/O 失敗的基礎 TCP 連線。 您可以使用此方法，以回應惡意 HTTP 用戶端攻擊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是安全執行緒。 任何執行緒可以隨時呼叫它。  
  
 這個方法僅能在整合模式下使用。 如果您叫用它在傳統模式中，會擲回例外狀況。 若要判斷管線模式，請使用<xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端支援的 MIME 接受 (Accept) 類型的字串陣列。</summary>
        <value>用戶端支援的 MIME 接受類型的字串陣列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會擷取所傳回的多個值<xref:System.Web.HttpRequest.AcceptTypes%2A>屬性插入的物件變數並寫入 HTTP 輸出的個別行中的數目和每個值的名稱。  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得使用者的匿名識別項 (如果有)。</summary>
        <value>表示目前匿名使用者識別項的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.AnonymousID%2A>屬性會將長時間執行的唯一識別碼指派給未驗證的使用者，這可用來追蹤使用者或指派給該使用者的設定檔屬性，而不需要資料儲存於`Session`物件。 根據預設，<xref:System.Web.HttpRequest.AnonymousID%2A>屬性會追蹤使用 cookie，但它可以設定為使用 URI 時<xref:System.Web.Configuration.SessionStateSection.Cookieless%2A>匿名識別的 [設定] 區段中的屬性會設為<xref:System.Web.HttpCookieMode.UseUri>， <xref:System.Web.HttpCookieMode.UseDeviceProfile>，或<xref:System.Web.HttpCookieMode.AutoDetect>值。 如果您不再想要可供使用，例如當匿名使用者通過驗證，您必須明確地清除 cookie。  
  
 需要識別未經過驗證的實體時，需要授權時，會使用匿名識別。 如需詳細資訊，請參閱[anonymousIdentification 項目 （ASP.NET 設定結構描述）](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100))  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Web.HttpRequest.AnonymousID%2A>屬性來處理<xref:System.Web.Security.AnonymousIdentificationModule.Creating>Global.asax 檔案中的事件。 此範例中有兩個部分：  
  
-   處理 Global.asax 檔案中的方法<xref:System.Web.Security.AnonymousIdentificationModule.Creating>事件。  
  
-   Web Form 網頁。  
  
 在程式碼範例的第一個部分示範如何設定<xref:System.Web.HttpRequest.AnonymousID%2A>屬性來處理<xref:System.Web.Security.AnonymousIdentificationModule.Creating>Global.asax 檔案中的事件。 方法，稱為`AnonymousIdentification_Creating`設定<xref:System.Web.HttpRequest.AnonymousID%2A>匿名的識別碼建立時的屬性。  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 第二個部分的程式碼範例示範如何顯示的新<xref:System.Web.HttpRequest.AnonymousID%2A>，它由`AnonymousIdentification_Creating`在上述範例中的事件處理常式。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">anonymousIdentification 項目 (ASP.NET 設定結構描述)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 ASP.NET 應用程式在伺服器上的虛擬應用程式根路徑。</summary>
        <value>目前應用程式的虛擬路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個屬性來建構從頁面或 Web 使用者控制項不在根目錄中的應用程式根目錄的相對 URL。 這可讓網頁及共用存在於不同的目錄結構來使用相同的程式碼連結至應用程式中的固定位置的資源層級的控制項。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.StreamWriter.Write%2A>方法，以 HTML 編碼，然後撰寫的值<xref:System.Web.HttpRequest.ApplicationPath%2A>文字檔案的屬性。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。 它假設存在<xref:System.IO.StreamWriter>名為物件`sw`。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 下列範例會使用<xref:System.Web.HttpRequest.ApplicationPath%2A>來以程式設計方式建構應用程式中的固定位置中的資源路徑的屬性。 必須位於相同的目錄，做為資源沒有參考之資源的網頁。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 如果您執行此範例中名為 WebSite1，Web 應用程式`/WebSite1`將會顯示的值為<xref:System.Web.HttpRequest.ApplicationPath%2A>屬性和`/WebSite1/images/Image1.gif`將會顯示為映像的完整路徑。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得應用程式根目錄的虛擬路徑，並對應用程式根目錄使用波狀符號 (\~) 標記法，讓此路徑變成相對路徑 (就像是 "\~/page.aspx")。</summary>
        <value>目前要求的應用程式根目錄之虛擬路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性來提供將保持不變即使應用程式變更位置的 URL 資訊。 這可讓相同 URL 對應程式碼以用於測試環境中，並在最後一個部署環境中，或使用不同網域中的 Web 應用程式的複本。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A>屬性來設定的 URL<xref:System.Web.UI.WebControls.Image>頁面相同目錄中之影像的控制項。 若要查看產生的目錄結構的不同層級執行此頁面<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A>屬性值。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 下列範例會使用<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A>目前頁面的路徑為基礎的屬性設為資源，以程式設計方式設定的路徑。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">要讀取的位元組數。</param>
        <summary>在目前輸入資料流執行指定位元組數的二進位讀取。</summary>
        <returns>位元組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.BinaryRead%2A>方法提供與 ASP 的相容性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 為 0。  
  
-或- 
 <paramref name="count" /> 大於可用的位元組數目。</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定關於要求的用戶端瀏覽器功能的資訊。</summary>
        <value><see cref="T:System.Web.HttpBrowserCapabilities" /> 物件，列出用戶端瀏覽器的功能。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會傳回給用戶端 HTML 網頁中傳送一份瀏覽器的功能。  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">ASP.NET 伺服器控制項和瀏覽器功能</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前要求的用戶端安全憑證。</summary>
        <value><see cref="T:System.Web.HttpClientCertificate" /> 物件，包含用戶端安全性憑證設定的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會將用戶端的憑證設定傳送回用戶端 HTML 網頁中。  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得實體 (Entity) 主體的字元集 (Character Set)。</summary>
        <value><see cref="T:System.Text.Encoding" /> 物件，代表用戶端的字元集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中指定預設內容編碼[globalization 項目 （ASP.NET 設定結構描述）](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7)組態檔。 如果同時指定用戶端的內容編碼方式，會覆寫預設的組態設定。  
  
   
  
## Examples  
 下列程式碼範例會指派值，表示目前 HTTP 編碼的字串變數的描述。  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定用戶端送出的內容長度，以位元組為單位。</summary>
        <value>用戶端所送出的內容長度 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會指派給整數變數代表連入要求的內容長度的值。  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定連入要求的 MIME 內容類型。</summary>
        <value>字串，表示收到的要求之 MIME 內容類型，例如 "text/html"。 其他通用 MIME 類型包括 "audio.wav"、"image/gif" 和 "application/pdf"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會指派給 string 變數代表連入要求的內容類型的值。  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 下列範例顯示可能會產生此程式碼的輸出。  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端送出的 Cookie 的集合。</summary>
        <value><see cref="T:System.Web.HttpCookieCollection" /> 物件，代表用戶端的 Cookie 變數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 包含兩個內建 cookie 集合。 透過存取的集合<xref:System.Web.HttpRequest.Cookies%2A>的集合<xref:System.Web.HttpRequest>包含傳輸中的伺服器的用戶端的 cookie`Cookie`標頭。 透過存取的集合<xref:System.Web.HttpResponse.Cookies%2A>的集合<xref:System.Web.HttpResponse>包含在伺服器上建立並傳輸至用戶端中的新 cookie`Set-Cookie`標頭。  
  
> [!NOTE]
>  使用新增 cookie 之後<xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType>集合中，cookie 可立即用於<xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType>集合，即使尚未傳送回應給用戶端。  
  
   
  
## Examples  
 下列程式碼範例用戶端傳送的所有 cookie 執行都迴圈，並將名稱、 到期日，安全性參數和值的每個 cookie 傳送至 HTTP 輸出。  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前要求的虛擬路徑。</summary>
        <value>目前要求的虛擬路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> 目前正在執行的頁面處理常式傳回的檔案路徑。 使用重新導向案例<xref:System.Web.HttpServerUtility.Execute%2A>並<xref:System.Web.HttpServerUtility.Transfer%2A>方法，這表示<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>屬性傳回的路徑重新導向至 （子頁面） 頁面。 不過，當用戶端重新導向至另一個頁面上，<xref:System.Web.HttpRequest.FilePath%2A>屬性傳回的原始頁面的路徑。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> 屬性中指定之檔案名稱的副檔名。</summary>
        <value><see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> 屬性中指定之檔案名稱的副檔名。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前要求的虛擬路徑。</summary>
        <value>目前要求的虛擬路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.FilePath%2A>屬性不包含<xref:System.Web.HttpRequest.PathInfo%2A>結尾。 例如，對於 URL http://www.contoso.com/virdir/page.html/tail，則<xref:System.Web.HttpRequest.FilePath%2A>值是 /virdir/page.html。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.FilePath%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端所上傳的檔案集合，其格式為多重 MIME。</summary>
        <value><see cref="T:System.Web.HttpFileCollection" /> 物件，表示用戶端上傳的檔案集合。 <see cref="T:System.Web.HttpFileCollection" /> 物件的項目為 <see cref="T:System.Web.HttpPostedFile" /> 類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只會填入檔案集合在 HTTP 要求的`Content-Type`值是"multipart/表單資料的 」。  
  
   
  
## Examples  
 下列程式碼範例顯示中的所有檔案的名稱<xref:System.Web.HttpRequest.Files%2A>集合。  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在讀取目前輸入資料流時取得或設定要使用的篩選條件。</summary>
        <value>要當做篩選條件的 <see cref="T:System.IO.Stream" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會建立兩個新的類別，`QQQ1`並`QQQ2`該篩選<xref:System.Web.HttpRequest.InputStream%2A>。 這樣會篩選所有的 ASP.NET Web pages 應用程式中的所有輸入，請將類別放入 ASP.NET 應用程式的目錄中的 Global.asax 檔中。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定的 <see cref="T:System.IO.Stream" /> 無效。</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表單變數的集合。</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" />，代表表單變數的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Form%2A>屬性會填入在 HTTP 要求的`Content-Type`值為"application/x-www-表單-urlencoded"或"multipart/表單資料的 」。  
  
   
  
## Examples  
 下列範例示範如何讀取從瀏覽器張貼的表單集合中的值。 集合中的每個名稱/值組表示在表單和其值的控制項。  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得可用來讀取連入 HTTP 實體本文的 <see cref="T:System.IO.Stream" /> 物件。</summary>
        <returns>可用來讀取連入 HTTP 實體本文的 <see cref="T:System.IO.Stream" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>不同之處在於它也會將讀取的位元組複製到內部儲存體，供 ASP.NET 用來填入<xref:System.Web.HttpRequest.Form%2A>， <xref:System.Web.HttpRequest.Files%2A>，和<xref:System.Web.HttpRequest.InputStream%2A>屬性。 由於保留了這項資訊，如 ASP.NET Web Form 網頁 (.aspx 檔) 等下游程式碼將會成功執行。 這不是使用 <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> 方法的情況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已載入並剖析要求的實體主體。 造成載入及剖析實體主體的屬性包含下列範例： 
-   <see cref="P:System.Web.HttpRequest.Form" /> 屬性。  
  
-   <see cref="P:System.Web.HttpRequest.Files" /> 屬性。  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" /> 屬性。  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" /> 方法。  
  
若要避免此例外狀況，首先呼叫<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />方法。 如果在讀取實體主題時中斷連接用戶端，也會擲回這個例外狀況。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得可用來讀取連入 HTTP 實體本文的 <see cref="T:System.IO.Stream" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得可用來讀取連入 HTTP 實體本文的 <see cref="T:System.IO.Stream" /> 物件。</summary>
        <returns>可用來讀取連入 HTTP 實體本文的 <see cref="T:System.IO.Stream" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供替代使用<xref:System.Web.HttpRequest.InputStream%2A>屬性。 <xref:System.Web.HttpRequest.InputStream%2A>屬性會等到它傳回之前已收到整個要求<xref:System.IO.Stream>物件。 相反地，<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>方法會傳回<xref:System.IO.Stream>立即物件。 您可以使用此方法以開始處理之後才完成本文的內容已接收到的實體。  
  
 實體 （或盡可能為您的要求，且已收到） 只有在您使用的物件時，才會傳回透過呼叫方法，例如讀取資料流，這個方法所傳回<xref:System.IO.Stream.Read%2A>方法。 您使用的參數<xref:System.IO.Stream.Read%2A>方法，以指定要讀取實體主體中有多少。  
  
 <xref:System.IO.Stream>從這個方法由 ASP.NET 所傳回的物件支援同步和非同步讀取的方法。 <xref:System.IO.Stream>物件會實作<xref:System.IO.Stream.BeginRead%2A>和<xref:System.IO.Stream.EndRead%2A>方法。 非同步方法可讓您以非同步方式讀取要求實體中的區塊，而 ASP.NET 會釋放目前執行緒的非同步讀取迴圈的每個反覆項目之間。  
  
 如果要求上傳大型檔案，而且您想要開始存取檔案內容之前上傳完成，則這個方法就很有用。 不過，您應該只使用這個方法的情況下您要接管的實體主體的所有處理。 這表示您無法使用這個方法從.aspx 頁面，因為.aspx 頁面執行時，實體已讀取。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已載入並剖析要求的實體主體。 造成載入及剖析實體主體的屬性包含下列範例： 
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
若要避免此例外狀況，首先呼叫<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />方法。 如果在讀取實體主題時中斷連接用戶端，也會擲回這個例外狀況。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength"><see langword="true" /> 表示要停用要求長度限制，否則為 <see langword="false" />。</param>
        <summary>取得 <see cref="T:System.IO.Stream" /> 物件，其可用於讀取連入 HTTP 實體本文，並選擇性地停用 <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> 屬性中所設定的要求長度限制。</summary>
        <returns>可用來讀取連入 HTTP 實體本文的 <see cref="T:System.IO.Stream" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關這個方法的詳細資訊，請參閱<xref:System.Web.HttpRequest.GetBufferlessInputStream>多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已載入並剖析要求的實體主體。 造成載入及剖析實體主體的屬性包含下列範例： 
-   <see cref="P:System.Web.HttpRequest.Form" /> 屬性。  
  
-   <see cref="P:System.Web.HttpRequest.Files" /> 屬性。  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" /> 屬性。  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" /> 方法。  
  
若要避免此例外狀況，首先呼叫<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />方法。 如果在讀取實體主題時中斷連接用戶端，也會擲回這個例外狀況。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 HTTP 標頭的集合。</summary>
        <value>標頭的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需所有可能的標頭的清單，請參閱 <<c0> [ 要求標頭欄位](https://go.microsoft.com/fwlink/?LinkId=73147)W3C 網站上。  
  
   
  
## Examples  
 下列程式碼範例會顯示 HTTP 要求中的名稱和值的所有標頭。  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> 執行個體的 <see cref="T:System.Web.HttpWorkerRequest" /> 物件。</summary>
        <value>目前 <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> 執行個體的 <see cref="T:System.Web.HttpWorkerRequest" /> 物件。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">目前的 <see cref="T:System.Web.HttpWorkerRequest" /> 物件不是 <see langword="System.Web.Hosting.IIS7WorkerRequest" /> 物件或 <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端使用的 HTTP 資料傳輸方法 (例如 <see langword="GET" />、<see langword="POST" /> 或 <see langword="HEAD" />)。</summary>
        <value>用戶端使用的 HTTP 資料傳輸方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.HttpMethod%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 下列範例會顯示這段程式碼所產生的輸出。  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得連入 HTTP 實體主體的內容。</summary>
        <value><see cref="T:System.IO.Stream" /> 物件，代表連入 HTTP 內容主體的內容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例的內容複製<xref:System.Web.HttpRequest.InputStream%2A>轉換為字串。  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提供 IIS 方法的 Managed 包裝函式，這個方法會將 HTTP 要求實體本文插入記憶體中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A>方法多載會提供受管理的存取權給 IIS 7`IHttpRequest::InsertEntityBody`方法。 IIS 方法會插入記憶體中的 HTTP 要求實體主體 （用戶端所張貼的資料）。 這是實體的很有用，因為 IIS 不會維護一份要求之後已讀取。 <xref:System.Web.HttpRequest.InsertEntityBody%2A>方法建立的 HTTP 要求實體資料複本，並將它提供給 IIS 的其他自訂處理。  
  
> [!NOTE]
>  <xref:System.Web.HttpRequest.InsertEntityBody%2A>方法多載工作只在 IIS 7.0 或更新版本，因為`IHttpRequest::InsertEntityBody`方法在 IIS 7.0 中所加入。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 HTTP 要求實體本文的複本提供給 IIS。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已讀取之後，IIS 就不會維護要求的複本。 因此，建議只針對 HTTP 要求處理常式應該讀取要求的實體。  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType>方法多載以一份要求的實體提供 IIS 先前讀取 asp.net。 這個方法多載可用於 ASP.NET 具有讀取實體的要求，而且您想要重複使用現有的要求資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">已在比 IIS 7.0 版舊的 IIS 上叫用此方法。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">在主控環境中運作。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="buffer">包含要求實體資料的陣列。</param>
        <param name="offset">在 <paramref name="buffer" /> 中要開始儲存該要求實體資料的位置 (以零起始)。</param>
        <param name="count">要讀入 <paramref name="buffer" /> 陣列的位元組數目。</param>
        <summary>將 HTTP 要求實體本文的複本及該要求實體物件的相關資訊提供給 IIS。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已讀取之後，IIS 就不會維護要求的複本。 因此，建議只針對 HTTP 要求處理常式應該讀取要求的實體。  
  
 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType>方法多載是很有用，當您想要執行自訂處理，例如不同的實體本文插入記憶體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">已在比 IIS 7.0 版舊的 IIS 上叫用此方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 或 <paramref name="count" /> 為負值。</exception>
        <exception cref="T:System.ArgumentException">在指定 <paramref name="count" /> 值的情況下，<paramref name="buffer" /> 中的項目數大於 <paramref name="offset" /> 的可用空間。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">用於裝載環境中的作業。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示要求是否已經驗證過。</summary>
        <value>如果已經驗證要求，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例使用<xref:System.Web.HttpRequest.IsAuthenticated%2A>屬性來判斷目前的要求是否已經過驗證。 如果尚未驗證，可讓使用者輸入其認證至 Web 應用程式的另一個頁面重新導向要求。 這是常用的技巧的預設頁面應用程式。  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示要求是否來自本機電腦。</summary>
        <value>如果要求來自本機電腦，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.IsLocal%2A>屬性會傳回`true`如果要求的建立者的 IP 位址 127.0.0.1，或要求的 IP 位址是伺服器的 IP 位址相同。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個執會指示 HTTP 連接是否使用安全通訊 (也就是，HTTPS)。</summary>
        <value>如果連線為 SSL 連線，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會判斷是否<xref:System.Web.HttpRequest.IsSecureConnection%2A>屬性設定為 false。 如果是，<xref:System.Web.HttpResponse.SuppressContent%2A>屬性設定為 true，以停止傳送回應。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">要取得的集合成員名稱。</param>
        <summary>從 <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" /> 或 <see cref="P:System.Web.HttpRequest.ServerVariables" /> 集合取得指定的物件。</summary>
        <value><paramref name="key" /> 參數中指定的 <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" /> 或 <see cref="P:System.Web.HttpRequest.ServerVariables" /> 集合成員。 如果找不到指定的 <paramref name="key" />，則會傳回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前使用者的 <see cref="T:System.Security.Principal.WindowsIdentity" /> 型別。</summary>
        <value>目前 Microsoft 網際網路資訊服務 (IIS) 驗證設定的 <see cref="T:System.Security.Principal.WindowsIdentity" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.LogonUserIdentity%2A>屬性會公開的屬性和方法<xref:System.Security.Principal.WindowsIdentity>目前連接的使用者以 Microsoft 網際網路資訊服務 (IIS) 的物件。 執行個體<xref:System.Security.Principal.WindowsIdentity>類別所公開<xref:System.Web.HttpRequest.LogonUserIdentity%2A>追蹤 IIS 要求語彙基元，並可輕鬆存取此語彙基元在 ASP.NET 內正在處理目前的 HTTP 要求。 執行個體<xref:System.Security.Principal.WindowsIdentity>類別會自動建立，因此不需要為建構，以便存取其方法和屬性。  
  
   
  
## Examples  
 下列程式碼範例示範如何擷取<xref:System.Web.HttpRequest.LogonUserIdentity%2A>屬性寫出的文字檔案中的每個項目值與目前的使用者。 此程式碼置於表單的參考的 ASP.NET 頁面`ACTION`屬性。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Web 應用程式是在 IIS 7 整合模式中執行，而且尚未引發 <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> 事件。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">表單影像地圖的名稱。</param>
        <summary>將收到的影像欄的表單參數對應至適當的 X 座標和 Y 座標值。</summary>
        <returns>整數的二維陣列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將用戶端目前要求之 URL 的虛擬路徑對應至伺服器上的實體路徑。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">目前要求的虛擬路徑 (絕對或相對的)。</param>
        <summary>將指定的虛擬路徑對應至實體路徑。</summary>
        <returns>由 <paramref name="virtualPath" /> 所指定伺服器上的實際路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A>屬性可能包含裝載環境的機密資訊。 傳回的值不應該向使用者顯示。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Web.HttpRequest.MapPath%2A>方法，以將虛擬路徑轉換成在伺服器上的完整實體路徑。 此範例中有兩個部分：  
  
-   .Aspx 頁面的路徑對應、 讀取檔案，並會顯示讀取作業的結果。  
  
-   一種類別， `UpperCaseFilterStream`，變更為大寫通過的所有字元。  
  
 此範例的第一個部分示範如何將虛擬路徑轉換成完整的實體路徑，使用<xref:System.Web.HttpRequest.MapPath%2A>方法。 此實體的路徑會傳遞至<xref:System.IO.StreamReader>物件，它會取得檔案的內容。 <xref:System.Web.HttpResponse.Write%2A>方法接著會呼叫顯示在頁面上的檔案內容。 <xref:System.Web.HttpResponse.Filter%2A>屬性用來將篩選附加至回應資料流，讓 [全部大寫] 頁面上所顯示的文字。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 此範例的第二部分顯示的類別，繼承自<xref:System.IO.Stream>並將資料流中的所有字元都轉換成大寫。 將此程式碼放入`App_Code`應用程式資料夾。  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求未定義任何 <see cref="T:System.Web.HttpContext" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">目前要求的虛擬路徑 (絕對或相對的)。</param>
        <param name="baseVirtualDir">用於相對解析的虛擬基底目錄路徑。</param>
        <param name="allowCrossAppMapping">若為 <see langword="true" />，表示 <paramref name="virtualPath" /> 可能屬於另一個應用程式，否則為 <see langword="false" />。</param>
        <summary>將指定的虛擬路徑對應至實體路徑。</summary>
        <returns>伺服器的實體路徑。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A>屬性可能包含裝載環境的機密資訊。 傳回的值不應該向使用者顯示。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="allowCrossMapping" /> 為 <see langword="false" />，並且 <paramref name="virtualPath" /> 屬於另一個應用程式。

-或- 
要求未定義任何 <see cref="T:System.Web.HttpContext" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">影像欄位的名稱。</param>
        <summary>將收到的影像欄的表單參數對應至適當的 X 和 Y 座標值。</summary>
        <returns>x 和 Y 座標值。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" /> 和 <see cref="P:System.Web.HttpRequest.ServerVariables" /> 項目的組合集合。</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名稱 / 值組會加入至集合中以下列順序：  
  
1.  查詢字串參數。  
  
2.  表單欄位。  
  
3.  Cookie。  
  
4.  伺服器變數。  
  
   
  
## Examples  
 下列程式碼範例示範如何執行迴圈<xref:System.Web.HttpRequest.Params%2A>屬性頁面，以及如何顯示每個索引鍵/值組。  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前要求的虛擬路徑。</summary>
        <value>目前要求的虛擬路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.Path%2A>串連<xref:System.Web.HttpRequest.FilePath%2A>而<xref:System.Web.HttpRequest.PathInfo%2A>結尾。 例如，對於 URL http://www.contoso.com/virdir/page.html/tail，則<xref:System.Web.HttpRequest.Path%2A>是 /virdir/page.html/tail。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.Path%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得具有 URL 副檔名之資源的其他路徑資訊。</summary>
        <value>資源的其他路徑資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Url Http://www.contoso.com/virdir/page.html/tail，則<xref:System.Web.HttpRequest.PathInfo%2A>值是 /tail。  
  
   
  
## Examples  
 下列程式碼範例會判斷是否<xref:System.Web.HttpRequest.PathInfo%2A>屬性包含空字串。 若是如此，<xref:System.IO.StreamWriter.Write%2A>方法寫入字串，表示這個檔案。 如果沒有出現，請<xref:System.Web.HttpUtility.HtmlEncode%2A>方法將值以 HTML 編碼<xref:System.Web.HttpRequest.PathInfo%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前正在執行的伺服器應用程式的根目錄之實體檔案系統路徑。</summary>
        <value>目前應用程式的根目錄之檔案系統路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.PhysicalApplicationPath%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得對應到要求的 URL 之實體檔案系統路徑。</summary>
        <value>目前要求的檔案系統路徑。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中使用的重新導向情節<xref:System.Web.HttpServerUtility.Execute%2A>並<xref:System.Web.HttpServerUtility.Transfer%2A>，則<xref:System.Web.HttpRequest.PhysicalPath%2A>屬性傳回的原始頁面的路徑。 若要尋找目前正在執行的頁面使用的實體路徑<xref:System.Web.HttpRequest.MapPath%2A>方法的輸入引數設定為<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.PhysicalPath%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 HTTP 查詢字串變數的集合。</summary>
        <value>用戶端送出的查詢字串變數。 索引鍵和值已做 URL 解碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範兩種方式可取得名為 「 fullname 」 的查詢字串變數的值。 在每個案例中，如果 URL `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`，則傳回的值是"Fadi Fakhouri"，因為`%20`是 URL 解碼成的空格字元。 如果 URL 不一定`fullname`查詢字串 ID，傳回的值會是`null`。  
  
 第一行程式碼會尋找 「 fullname 」 只能在查詢字串中; 中的索引鍵第二行會尋找 「 fullname 」 中的所有 HTTP 要求集合的索引鍵。 如需有關第二行的詳細資訊，請參閱<xref:System.Web.HttpRequest.Item%2A>。  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前要求的原始 URL。</summary>
        <value>目前要求的原始 URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 原始的 URL 被定義為下列網域資訊的 URL 的一部分。 URL 字串中http://www.contoso.com/articles/recent.aspx，原始的 URL 是 /articles/recent.aspx。 如果有的話，原始的 URL 會包含查詢字串。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.RawUrl%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否已讀取要求實體主體，而且如果是的話，如何讀取。</summary>
        <value>指出要求實體內容的讀取方式（或尚未讀取）的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法用來避免如果已經讀取實體主體，而且嘗試使用不相容的方法來讀取它，就會擲回的例外狀況。 讀取實體主體的方法和屬性包括：  
  
-   <xref:System.Web.HttpRequest.Form%2A> 屬性。  
  
-   <xref:System.Web.HttpRequest.Files%2A> 屬性。  
  
-   <xref:System.Web.HttpRequest.InputStream%2A> 屬性。  
  
-   <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> 方法  
  
-   <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> 方法  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前要求的 <see cref="T:System.Web.Routing.RequestContext" /> 執行個體。</summary>
        <value>目前要求的 <see cref="T:System.Web.Routing.RequestContext" /> 執行個體。 如果是非路由的要求，則傳回的 <see cref="T:System.Web.Routing.RequestContext" /> 是空物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性可存取<xref:System.Web.Routing.RouteData>目前要求的物件。 如需有關 ASP.NET 路由的詳細資訊，請參閱。[ASP.NET 路由](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">逐步解說：使用 ASP.NET Web Forms 應用程式中的路由</related>
        <related type="Article" href="https://msdn.microsoft.com/library/dc88e6ba-470c-4b20-b644-35874cfd781d">HOW TO：路由頁面中的存取 URL 參數</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用戶端使用的 HTTP 資料傳輸方法 (<see langword="GET" /> 或 <see langword="POST" />)。</summary>
        <value>字串，代表用戶端送出的 HTTP 叫用類型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.RequestType%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">實體磁碟機路徑。</param>
        <param name="includeHeaders">布林值，指定 HTTP 標頭是否應該儲存至磁碟。</param>
        <summary>將 HTTP 要求儲存至磁碟。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 儲存至磁碟的要求內容可以是適用於偵錯。  
  
   
  
## Examples  
 下列程式碼範例會呼叫<xref:System.Web.HttpRequest.SaveAs%2A>方法載入頁面時。 呼叫指定的要求會儲存為文字檔案的目錄中，其中 ASP.NET 處理序身分識別已授與寫入權限，並在檔案中包含任何要求中所包含的標頭資訊。  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> 的 <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> 屬性設為 <see langword="true" />，但是 <paramref name="filename" /> 並非絕對路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 Web 伺服器變數的集合。</summary>
        <value>伺服器變數的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需支援的 IIS 伺服器變數的清單，請參閱 < [IIS 伺服器變數](https://go.microsoft.com/fwlink/?LinkId=52471)。  
  
   
  
## Examples  
 下列程式碼範例顯示的名稱和命名的伺服器的所有變數的值。  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得要求逾時已過時觸動的 <see cref="T:System.Threading.CancellationToken" /> 物件。</summary>
        <value>取消語彙基元。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以在 Web.config 檔案中指定的逾時期限 (請參閱<xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) 或以程式設計方式 (請參閱<xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>)。 在逾時期限是從要求傳入時開始計算。 110 秒的預設逾時作用中時，如果將不得早於 110 秒的要求處理開始之後觸動的取消語彙基元。 您可以變更<xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>屬性值，因為尚未尚未觸動長這個語彙基元，會遵守這項新的逾時值。  
  
 目前語彙基元，只提供 15 的第二個資料粒度，這表示如果逾時值為 110 秒，權杖會再要求處理開始之後的 110 和 125 秒之間的一段時間。 資料粒度可能會在未來變更。  
  
 雖然這個屬性是安全執行緒，有其用途限制。 如需詳細資訊，請參閱<xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>。  
  
 這個屬性就沒有意義，如果 Websocket 要求處理已開始。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 TLS 權杖繫結資訊。 此屬性可讓應用程從內送 HTTP 要求擷取權杖資訊，以執行增強式驗證。</summary>
        <value>目前連接的繫結語彙基元。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回`null`在非 windows 10 平台上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前輸入資料流的位元組數目。</summary>
        <value>在輸入資料流的位元組數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會判斷是否<xref:System.Web.HttpRequest.TotalBytes%2A>屬性值大於 1000 個位元組，並將該資訊寫入至檔案。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 HTTP 要求值，而不觸發要求驗證。</summary>
        <value>尚未使用要求驗證檢查的 HTTP 要求值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求驗證檢查 HTML 標記和指令碼，可能表示有潛在的跨網站指令碼的攻擊。 根據預設，所有的值會檢查使用要求驗證，而且如果任何值會包含標記或指令碼，ASP.NET 會擲回<xref:System.Web.HttpRequestValidationException>例外狀況。 使用這個方法，如果您預期的要求將會包含標記 （例如，您允許使用者張貼內容，其中包含標記） 和您想要取得要求的原始值。  
  
> [!IMPORTANT]
>  如果您使用這個屬性時，您必須手動檢查潛在的跨網站指令碼攻擊的資料。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關於目前要求的 URL 資訊。</summary>
        <value><see cref="T:System.Uri" /> 物件，其中包含目前要求的 URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會指派<xref:System.Uri>目前要求的物件變數，並顯示 URL 的兩個屬性的值物件至 HTTP 輸出的物件。  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得有關用戶端的先前要求之 URL (連結至目前 URL) 的資訊。</summary>
        <value><see cref="T:System.Uri" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例顯示的 URL，用來參考目前應用程式的用戶端的兩個屬性的值。  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">HTTP <see langword="Referer" /> 要求標頭的格式不正確，無法轉換成 <see cref="T:System.Uri" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已提供的用戶端瀏覽器原始使用者代理程式字串。 請注意，它可以是 null。</summary>
        <value>用戶端瀏覽器的原始使用者代理字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會將要求的瀏覽器的型別識別指派給字串變數。  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">ASP.NET 伺服器控制項和瀏覽器功能</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得遠端用戶端的 IP 主機位址。</summary>
        <value>遠端用戶端的 IP 位址。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.UserHostAddress%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得遠端用戶端的 DNS 名稱。</summary>
        <value>遠端用戶端的 DNS 名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會使用<xref:System.Web.HttpUtility.HtmlEncode%2A>方法，以 HTML 編碼的值<xref:System.Web.HttpRequest.UserHostName%2A>屬性和<xref:System.IO.TextWriter.WriteLine%2A>方法來寫入檔案的編碼的值。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Web.HttpRequest>類別。  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端語言喜好設定的已排序的字串陣列。</summary>
        <value>用戶端語言喜好設定的已排序字串陣列，如果為空白則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例會擷取所傳回的多個值<xref:System.Web.HttpRequest.UserLanguages%2A>屬性插入字串陣列，並寫入至 HTTP 輸出的個別行的每一種語言名稱。  
  
 瀏覽器中，所提供的語言名稱，並沒有明確的所有可能的程式碼清單。  通常包括二字元代碼的語言、 連字號和兩個字元的代碼，文化特性，例如 「 en-us-我們 「 適用於美國英文和"fr-ca"加拿大法文。  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>會對透過 <see cref="P:System.Web.HttpRequest.Cookies" />、<see cref="P:System.Web.HttpRequest.Form" /> 和 <see cref="P:System.Web.HttpRequest.QueryString" /> 屬性存取的集合進行驗證。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest>類別來追蹤是否執行驗證，透過存取要求集合上使用的輸入的驗證旗標<xref:System.Web.HttpRequest.Cookies%2A>， <xref:System.Web.HttpRequest.Form%2A>，和<xref:System.Web.HttpRequest.QueryString%2A>屬性。 <xref:System.Web.HttpRequest.ValidateInput%2A>方法會設定這些旗標，當的 get 存取子<xref:System.Web.HttpRequest.Cookies%2A>， <xref:System.Web.HttpRequest.Form%2A>，或<xref:System.Web.HttpRequest.QueryString%2A>叫用屬性，會執行輸入的驗證。 驗證的運作方式是檢查所有的輸入的資料，針對硬式編碼有潛在危險的資料清單。  
  
 如果頁面指示詞或組態來啟用驗證功能，在頁面的期間呼叫這個方法`ProcessRequest`處理階段。 <xref:System.Web.HttpRequest.ValidateInput%2A>可以由您的程式碼呼叫方法，如果未啟用驗證功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">連入用戶端的可能有危險的資料。</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>