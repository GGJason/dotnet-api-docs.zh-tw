<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68657bcf291225564a735695474ef67da01c6dca" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683990" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>封裝來自 ASP.NET 作業的 HTTP 回應資訊。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法和屬性<xref:System.Web.HttpResponse>類別公開會透過<xref:System.Web.HttpApplication.Response%2A>屬性<xref:System.Web.HttpApplication>， <xref:System.Web.HttpContext>， <xref:System.Web.UI.Page>，和<xref:System.Web.UI.UserControl>類別。  
  
 下列的方法<xref:System.Web.HttpResponse>類別支援回傳的案例中，而不是在非同步 post 備份案例：  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 當您使用時，會啟用局部網頁更新<xref:System.Web.UI.UpdatePanel>更新選取的區域，而不是整個頁面更新與回傳網頁的控制項。 如需詳細資訊，請參閱[UpdatePanel 控制項概觀](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a)和[局部網頁呈現概觀](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49)。  
  
   
  
## Examples  
 要求頁面時，下列範例會繪製三個重疊的矩形。 程式碼一開始會設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 使整個頁面將會轉譯為 JPEG 影像。 然後程式碼會呼叫<xref:System.Web.HttpResponse.Clear%2A>方法，以確保沒有收集到無關的內容會與這個回應傳送。 接下來，此程式碼設定<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，讓傳送要求的用戶端之前，將完全處理網頁。 然後建立兩個物件，用來繪製的矩形：<xref:System.Drawing.Bitmap>和<xref:System.Drawing.Graphics>物件。 網頁中建立的變數可用以座標來繪製矩形和出現在最大的矩形內的字串。  
  
 繪製三個矩形和其中出現的字串、<xref:System.Drawing.Bitmap>儲存至<xref:System.IO.Stream>與其相關聯物件<xref:System.Web.HttpResponse.OutputStream%2A>屬性，且其格式設定為 JPEG。 程式碼會呼叫<xref:System.Drawing.Image.Dispose%2A>和<xref:System.Drawing.Graphics.Dispose%2A>方法釋放兩個物件所使用的資源。 最後，程式碼會呼叫<xref:System.Web.HttpResponse.Flush%2A>方法來傳送要求的用戶端已緩衝的回應。  
  
> [!NOTE]
>  在程式碼，<xref:System.Web.HttpResponse>物件指由關鍵字`Response`。 例如，`Response.Clear()`指<xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType>方法。 <xref:System.Web.UI.Page>類別有一個屬性，名為<xref:System.Web.UI.Page.Response%2A>會公開目前的執行個體<xref:System.Web.HttpResponse>。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">啟用自訂 HTTP 輸出的 <see cref="T:System.IO.TextWriter" /> 物件。</param>
        <summary>初始化 <see cref="T:System.Web.HttpResponse" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成員支援 .NET Framework 基礎結構，並不能直接使用於您的程式碼中。  
  
 方法和屬性<xref:System.Web.HttpResponse>類別會公開透過內建<xref:System.Web.HttpContext.Response%2A>ASP.NET 中的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">要加入應用程式相依性清單的檔案、快取索引鍵或 <see cref="T:System.Web.Caching.CacheDependency" />。</param>
        <summary>如果回應儲存在輸出快取中而且指定的相依性變更，便使快取相依性集合與回應產生關聯，加速回應失效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddCacheDependency%2A>方法可讓快取回應之間建立相依性和<xref:System.Web.Caching.CacheDependency>物件。  
  
   
  
## Examples  
 下列範例示範如何透過建立快取相依性<xref:System.Web.HttpResponse.AddCacheDependency%2A>方法和<xref:System.Web.Caching.CacheDependency>物件。  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencies" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已經建立快取的回應之後，這個方法在快取處理管線中已太晚呼叫。</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓快取回應的有效性取決於快取中的其他項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">
          <see cref="T:System.Collections.ArrayList" />，包含目前快取回應所相依的項目索引鍵。</param>
        <summary>讓快取回應的有效性取決於快取中的其他項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目中所參考`cacheKeys`參數會移除從快取，目前項目的快取的回應無效。  
  
   
  
## Examples  
 下列範例示範如何使用 ASP.NET 頁面輸出快取。 網頁的程式碼會建立<xref:System.Collections.ArrayList>物件中儲存的項目相關聯的索引鍵的<xref:System.Web.Caching.Cache>物件。 接下來，在程式碼通過<xref:System.Collections.ArrayList>做為參數的呼叫中<xref:System.Web.HttpResponse.AddCacheItemDependencies%2A>方法。 這可讓快取輸出回應不正確，如果任何一個中指定的檔案<xref:System.Collections.ArrayList>變更。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">項目索引鍵的陣列，為快取回應所依存。</param>
        <summary>讓快取項目的有效性取決於快取中的另一個項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當任一`cacheKey`s 會移除從快取，目前項目的快取的回應無效。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">項目的索引鍵，為快取回應所依存。</param>
        <summary>讓快取回應的有效性取決於快取中的另一個項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當對應至的項目`cacheKey`從快取移除參數，目前項目的快取的回應無效。  
  
   
  
## Examples  
 下列範例是輸出快取的 ASP.NET 使用者控制項。 控制呼叫的程式碼<xref:System.Web.HttpResponse.AddCacheItemDependency%2A>方法中所儲存之項目的索引鍵<xref:System.Web.Caching.Cache>做為其參數傳遞的物件。 如果項目不存在於快取中，就會儲存在輸出快取中的控制項的回應失效。 這表示在後續要求中，新版本的控制項的回應會加入至輸出快取。  
  
 接下來，程式碼會檢查是否與項目相關聯`bookData`金鑰儲存在`Cache`物件，並會顯示兩行文字取決於結果的其中一個。 然後，此程式碼設定<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>屬性<xref:System.Web.UI.WebControls.DataGrid>控制項，名為`dgBooks`，呼叫自訂`DataHelper`類別共用`GetBookData`方法，並於其中填入<xref:System.Web.UI.WebControls.DataGrid>與<xref:System.Web.UI.Control.DataBind%2A>方法。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將檔案名稱群組加入目前回應所依存的檔案名稱的集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">要加入的檔案集合。</param>
        <summary>將檔案名稱群組加入目前回應所依存的檔案名稱的集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例為 ASP.NET 頁面輸出快取。 網頁的程式碼會建立<xref:System.Collections.ArrayList>的檔案路徑，然後傳遞<xref:System.Collections.ArrayList>做為參數的呼叫中<xref:System.Web.HttpResponse.AddFileDependencies%2A>方法。 這可讓輸出快取的回應無效任何的 if 檔案中指定<xref:System.Collections.ArrayList>變更。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">要加入的檔案陣列。</param>
        <summary>將檔案名稱陣列加入目前回應所依存的檔案名稱的集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將檔案名稱的陣列<xref:System.Web.HttpResponse.AddFileDependencies%2A>檔案相依性清單。 如果檔案變更，則會快取的回應失效。  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要加入的檔案名稱。</param>
        <summary>將單一檔案名稱加入目前回應所依存的檔案名稱的集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用<xref:System.Web.HttpResponse.AddFileDependency%2A>方法，將檔案相依性，您也必須指定輸出快取，以程式設計方式或以宣告方式。 例如，若要指定輸出快取以宣告方式，使用指示詞。 如需詳細資訊，請參閱[How to： 檔案相依性與快取頁面輸出](http://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db)。  
  
   
  
## Examples  
 下列範例示範如何將加入至單一檔案名稱<xref:System.Web.HttpResponse.AddFileDependency%2A>檔案相依性清單。 如果變更的檔案，則會快取的回應失效。  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要新增 <c>value</c> 之 HTTP 標頭的名稱。</param>
        <param name="value">要加入標頭的字串。</param>
        <summary>將 HTTP 標頭加入輸出資料流。 <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> 是提供來與 ASP 先前版本相容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> 等同於<xref:System.Web.HttpResponse.AppendHeader%2A>並提供是為了與 ASP 的舊版本相容性。 使用 ASP.NET， <xref:System.Web.HttpResponse.AppendHeader%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">回呼方法。</param>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援]  
  
 註冊 ASP.NET 執行階段會立即在回應標頭傳送給這個要求之前叫用的回呼。</summary>
        <returns>
          <see cref="T:System.Web.ISubscriptionToken" /> 物件，代表 OnSendingHeaders 虛擬事件的訂閱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  AddOnSendingHeaders 方法不會叫用，如果原生模組第一次排清回應。  
  
 虛擬事件 OnSendingHeaders 不同 IHttpModule 層級管線事件，因為它要求每個訂用帳戶，而不是每個應用程式的訂用帳戶。 其目的是回呼可能會修改回應狀態碼，或可能會設定回應的 cookie 或標頭。 其他的使用方式的事項及警告：  
  
-   IIS integrated 的管線模式管線中執行時，才，而且只有在回應標頭尚未針對目前的要求已傳送，這個方法會有效。  
  
-   ASP.NET 執行階段不保證任何關於的執行緒叫用回呼。 例如，可能會叫用回呼以同步方式在背景執行緒中如果正在執行背景清除。 <xref:System.Web.HttpContext.Current%2A> 不保證可在這類執行緒中使用。  
  
-   回呼必須呼叫操縱回應實體本文或排清，產生的任何方法。 例如，不可呼叫回呼<xref:System.Web.HttpResponse.Redirect%2A>，因為該方法可能會操作回應實體本文。  
  
-   回呼必須只包含執行短期同步程式碼。 嘗試叫用非同步作業，或等候這類作業可能會導致死結。  
  
-   回呼必須不會擲回例外狀況。否則行為是未定義。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">要加入輸出資料流的 <see cref="T:System.Web.HttpCookie" />。</param>
        <summary>將 HTTP Cookie 加入內建 Cookie 集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立名為新的 cookie`LastVisit`管理員、 設定 cookie 的值為目前的日期和時間，並將 cookie 附加至目前的 cookie 集合。 中的用戶端會傳送的 cookie 集合中的所有 cookie `Set-Cookie` http 標頭輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後，附加 Cookie。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要加入輸出資料流的 HTTP 標頭名稱。</param>
        <param name="value">附加到標頭的字串。</param>
        <summary>將 HTTP 標頭加入輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用<xref:System.Web.HttpResponse.AppendHeader%2A>方法來傳送快取特定標頭，並同時使用快取物件模型 (<xref:System.Web.HttpResponse.Cache%2A>) 以設定快取原則，與快取 HTTP 回應標頭 (`Cache-Control`， `Expires`， `Last-Modified`， `Pragma`，和`Vary`) 快取物件模型使用時可能會被刪除。 此行為可讓 ASP.NET 成為維護限制最嚴格的設定。 例如，考慮一個網頁，內含使用者控制項。 如果這些控制項有快取原則衝突，則將使用限制最嚴格的快取原則。 如果一個使用者控制項設定標頭 」`Cache-Control: Public`"和另一個使用者控制項設定更具限制性的標頭 」`Cache-Control: Private`」 透過呼叫<xref:System.Web.HttpCachePolicy.SetCacheability%2A>，則 「`Cache-Control: Private`"標頭會隨著回應一起傳送。  
  
 標準 HTTP/1.1 標頭的清單，請參閱 14 中，「 標頭欄位定義 」 一節，在[超文字傳輸通訊協定-HTTP/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) World Wide Web Consortium (W3C) 網站上的規格。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Web.HttpResponse.AppendHeader%2A>方法，將自訂標頭<xref:System.Web.HttpResponse>傳送要求的用戶端物件。  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">標頭在 HTTP 標頭送出之後被附加。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">要加入記錄檔的文字。</param>
        <summary>將自訂記錄資訊加入網際網路資訊服務 (IIS) 記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要允許記錄在記錄檔中指定的字串，必須先啟用**URI 查詢**選項**擴充記錄內容**的網站，您想要在 IIS 中記錄的活動 對話方塊.  
  
 若要自訂擴充在 IIS 6.0 中的記錄，請遵循下列步驟：  
  
1.  在 IIS 管理員 中，展開 本機電腦 節點，展開 Web 或 FTP 站台資料夾、 Web 或 FTP 站台，以滑鼠右鍵按一下，然後按一下**屬性**。  
  
2.  按一下**Web 或 FTP 站台**索引標籤，然後選取**啟用記錄**核取方塊 （如果尚未選取）。  
  
3.  在**作用中的記錄檔格式**方塊中，按一下**W3C 擴充記錄檔格式**。  
  
4.  按一下**屬性**。  
  
5.  按一下**進階**索引標籤上，選取您想要記錄，然後按一下屬性**確定**。  
  
   
  
## Examples  
 下列範例顯示如何將字串附加至記錄檔。  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">資源的虛擬路徑。</param>
        <summary>如果工作階段使用 <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 工作階段狀態並且傳回合併的路徑，則將工作階段 ID 加入虛擬路徑。 如果沒有使用 <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 工作階段狀態，則 <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> 會傳回原始虛擬路徑。</summary>
        <returns>已插入工作階段 ID 的 <paramref name="virtualPath" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 是無 cookie 工作階段只能搭配用來建構絕對的 Href。  
  
   
  
## Examples  
 下列範例宣告名為的字串變數`urlConverted`，並設定它的結果為<xref:System.Web.HttpResponse.ApplyAppPathModifier%2A>方法呼叫。 程式碼接著會將傳遞的變數的值，以<xref:System.Web.UI.WebControls.HyperLink>控制項的<xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A>屬性。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">回呼物件。</param>
        <param name="state">回應狀態。</param>
        <summary>將目前已緩衝的回應傳送到用戶端。</summary>
        <returns>非同步結果物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果基礎<xref:System.Web.HttpWorkerRequest>物件支援非同步清除作業，從非同步模組事件或非同步處理常式會呼叫這個方法會以非同步方式執行清除作業。 否則，會以同步方式執行排清作業。 IIS 6.0 和更新版本支援非同步清除。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已經完成回應。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">寫入輸出資料流的位元組。</param>
        <summary>將二進位字元的字串寫入 HTTP 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例讀入緩衝區中的文字檔案，並將緩衝區寫入 HTTP 輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要緩衝輸出並在整個回應處理完成之後將它送出。</summary>
        <value>
          如果對用戶端的輸出有緩衝，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Buffer%2A>屬性已被取代之喜好<xref:System.Web.HttpResponse.BufferOutput%2A>屬性並提供是為了與 ASP 的舊版本相容性。 使用 ASP.NET， <xref:System.Web.HttpResponse.BufferOutput%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要緩衝輸出並在整個網頁處理完成之後送出。</summary>
        <value>
          如果對用戶端的輸出有緩衝，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 回應呼叫<xref:System.Web.HttpResponse.Clear%2A>方法可能會附加至回應，並設定其他內容中移除<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，因此會使用整個頁面處理要求的用戶端傳送的任何內容之前。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁的快取原則 (例如，到期時間、隱私權設定與 Vary 子句)。</summary>
        <value>
          <see cref="T:System.Web.HttpCachePolicy" /> 物件，包含目前回應之快取原則的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將目前的快取原則的內容寫入 HTTP 輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定符合其中一個 <see cref="T:System.Web.HttpCacheability" /> 列舉值的 <see langword="Cache-Control" /> HTTP 標頭。</summary>
        <value>字串，代表 <see cref="T:System.Web.HttpCacheability" /> 列舉值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`Private`， `Public`，和`No-Cache`是，且必須括在引號 ("")。 如果<xref:System.Web.HttpResponse.CacheControl%2A>屬性設定為不符合其中一個值<xref:System.Web.HttpCacheability>列舉值，則<xref:System.ArgumentException>就會擲回。 如果<xref:System.Web.HttpResponse.CacheControl%2A>屬性未設定，快取的回應性會設定為<xref:System.Web.HttpCacheability.NoCache>。  
  
 `CacheControl`， <xref:System.Web.HttpResponse.Expires%2A>，和<xref:System.Web.HttpResponse.ExpiresAbsolute%2A>屬性已被取代。 相反地，方法<xref:System.Web.HttpCachePolicy>類別都是透過<xref:System.Web.HttpResponse.Cache%2A>來控制 網際網路資訊服務 (IIS) 的內建物件輸出快取和用戶端快取。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">設定的字串值不符合其中一個 <see cref="T:System.Web.HttpCacheability" /> 列舉值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定輸出資料流的 HTTP 字元集。</summary>
        <value>輸出資料流的 HTTP 字元集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Charset`屬性可以設定為`null`隱藏 HTTP`Content-Type`標頭。  
  
   
  
## Examples  
 下列範例會檢查輸出資料流的字元集是否中央歐語系 (ISO)。  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">在標頭送出之後，設定 <see langword="Charset" /> 屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從緩衝區資料流清除所有內容輸出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A>方法不會清除標頭資訊。  
  
   
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 回應呼叫<xref:System.Web.HttpResponse.Clear%2A>方法可能會附加至回應，並設定其他內容中移除<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，因此會在整個頁面處理要求的用戶端傳送的任何內容之前。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從緩衝區資料流清除所有內容輸出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A>方法不會清除標頭資訊。  
  
   
  
## Examples  
 下列範例會清除從緩衝區資料流的所有內容。  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從緩衝區資料流清除所有標頭。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會呼叫<xref:System.Web.HttpResponse.ClearHeaders%2A>方法，以確保與目前的回應會傳送任何標頭。 這項技術可以是 ASP.NET 回應產生的影像，例如 JPEG 檔案時尤其重要。 在此範例中<xref:System.Web.HttpResponse.ContentType%2A>屬性設定為 image/jpeg。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">標頭在 HTTP 標頭送出之後被清除。</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端中斷連接時發生錯誤的 <see cref="T:System.Threading.CancellationToken" /> 物件。</summary>
        <value>取消語彙基元。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個 API 已具備執行緒安全。 不過，有一些限制，應該如何使用取消語彙基元。 不當使用它可能會導致競爭條件、 死結或其他意外的行為。 請注意下列指導方針：  
  
-   因為 ASP.NET 將處置的取消語彙基元要求結尾，請確定在未呼叫此 api 在單一要求的範圍之外。 沒有保證權杖就會永遠轉換成已取消的狀態之前加以處置。 比方說，如果不需要中斷連線的用戶端完成要求時，會處置語彙基元而不需先取消。  
  
-   不需要等候<xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>，如這個非同步通知的目的，就失去了，而且可能會導致死結。  
  
-   請勿呼叫<xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>多載，就會叫用回呼原始<xref:System.Threading.SynchronizationContext>物件。  
  
-   請勿使用<xref:System.Web.HttpContext>物件或其他非安全執行緒 ASP.NET 內建物件提供給回呼內部<xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>方法。 回呼可能會執行與其他 ASP.NET 或應用程式程式碼。  
  
-   保留執行短期的回呼方法和非封鎖。  
  
-   請致力將避免擲回例外狀況從回呼方法中。  
  
 在整合模式下，才適用網際網路資訊服務 (IIS) 7.5 至這個屬性。 如果您沒有正確的 IIS 版本或管線模式，叫用<xref:System.PlatformNotSupportedException>就會擲回。 若要判斷 IIS 版本，請使用<xref:System.Web.HttpRuntime.IISVersion%2A>。 若要判斷管線模式，請使用<xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉與用戶端的通訊端連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法以突然方式終止用戶端的連接，並不適用於一般的 HTTP 要求處理。 方法會重設封包傳送到用戶端，可能會造成的緩衝處理回應資料伺服器、 用戶端，或某處之間要卸除。  
  
 不過，通常您應該呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>而如果您想要往前跳至<xref:System.Web.HttpApplication.EndRequest>事件，並將傳送至用戶端的回應。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定輸出資料流的 HTTP 字元集。</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> 物件，包含目前回應之字元集的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設`ContentEncoding`可以在 ASP.NET 組態檔中指定[全球化項目 （ASP.NET 設定結構描述）](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) > 一節。 如果<xref:System.Web.HttpResponse.ContentEncoding%2A>指定用戶端的預設組態設定會覆寫。  
  
   
  
## Examples  
 下列範例會寫字元集編碼方式寫入輸出資料流的人們可讀取描述。  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">嘗試將 <see cref="P:System.Web.HttpResponse.ContentEncoding" /> 設定為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定輸出資料流的 HTTP MIME 類型。</summary>
        <value>輸出資料流的 HTTP MIME 類型。 預設值為 "<see langword="text/html" />"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 回應呼叫<xref:System.Web.HttpResponse.Clear%2A>方法可能會附加至回應，並設定其他內容中移除<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，因此會在整個頁面處理要求的用戶端傳送的任何內容之前。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.ContentType" /> 屬性設定為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得回應 Cookie 集合。</summary>
        <value>回應 Cookie 集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 包含兩個內建 cookie 集合。 透過集合<xref:System.Web.HttpRequest.Cookies%2A>集合<xref:System.Web.HttpRequest>包含用戶端中的伺服器傳送的 cookie`Cookie`標頭。 透過集合<xref:System.Web.HttpResponse.Cookies%2A>集合<xref:System.Web.HttpResponse>包含在伺服器上建立並傳送給用戶端的新 cookie`Set-Cookie`標頭。  
  
 使用新增 cookie 之後<xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType>集合，cookie 可立即用於<xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType>集合，即使尚未傳送回應至用戶端。  
  
   
  
## Examples  
 下列範例會建立名為新的 cookie`LastVisit`管理員、 設定 cookie 的值為目前的日期和時間，並將 cookie 加入至目前的 cookie 集合。 中的用戶端會傳送的 cookie 集合中的所有 cookie `Set-Cookie` http 標頭輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停用目前回應的核心快取處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不支援的核心快取，則這個方法沒有任何作用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停用這個回應的 IIS 使用者模式快取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不支援的 IIS 使用者模式快取，這個方法會傳回而不執行任何動作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前所有受緩衝的輸出傳送到用戶端、停止網頁的執行，並引發 <see cref="E:System.Web.HttpApplication.EndRequest" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只為了與 ASP 的相容性 — 也就是以 COM 為基礎的 Web 程式設計技術，前面有 ASP.NET 相容性。 如果您想要往前跳至<xref:System.Web.HttpApplication.EndRequest>事件，並將傳送至用戶端的回應，它通常最好是呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>改為。  
  
 若要模擬的行為`End`ASP 中的方法，這個方法會嘗試以引發<xref:System.Threading.ThreadAbortException>例外狀況。 如果此嘗試成功，將會中止呼叫執行緒，即危害到您的網站效能。 在此情況下，在呼叫之後任何程式碼<xref:System.Web.HttpResponse.End%2A>執行方法。  
  
 如果<xref:System.Web.HttpResponse.End%2A>方法不是無法提高<xref:System.Threading.ThreadAbortException>，而是會清除回應位元組至用戶端。 這會同步執行，這也可能危害到您的網站效能。  
  
 在任一情況下 (不論是否<xref:System.Threading.ThreadAbortException>成功引發例外狀況)，回應管線向前跳至<xref:System.Web.HttpApplication.EndRequest>事件。  
  
 <xref:System.Web.HttpApplication.CompleteRequest%2A>方法不會引發例外狀況，程式碼的呼叫後方<xref:System.Web.HttpApplication.CompleteRequest%2A>方法可能會執行。 如果您是要避免執行後續的程式碼，而且會降低效能<xref:System.Web.HttpResponse.End%2A>可接受的您可以呼叫<xref:System.Web.HttpResponse.End%2A>而不是<xref:System.Web.HttpApplication.CompleteRequest%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">
          <see cref="M:System.Web.HttpResponse.End" /> 呼叫已終止目前要求。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">非同步結果物件。</param>
        <summary>完成非同步的清除作業。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">不支援非同步排清，而且 <paramref name="asyncResult" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">不支援非同步排清，而且 <paramref name="asyncResult" /> 參數無法轉換成 <c>FlushAsyncResult</c> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定瀏覽器上快取網頁到期以前的分鐘數。 如果使用者在頁面到期前返回相同的頁面，則會顯示快取版本。 <see cref="P:System.Web.HttpResponse.Expires" /> 是提供來與 ASP 先前版本相容。</summary>
        <value>在頁面到期前的分鐘數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Expires`，<xref:System.Web.HttpResponse.ExpiresAbsolute%2A>和<xref:System.Web.HttpResponse.CacheControl%2A>屬性已被取代的方法為<xref:System.Web.HttpCachePolicy>類別可透過<xref:System.Web.HttpResponse.Cache%2A>輸出快取來控制 網際網路資訊服務 (IIS) 的內建函式物件。和用戶端快取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定從快取中移除快取資訊的絕對日期和時間。 <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> 是提供來與 ASP 先前版本相容。</summary>
        <value>頁面到期的日期和時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ExpiresAbsolute`， <xref:System.Web.HttpResponse.Expires%2A>，和<xref:System.Web.HttpResponse.CacheControl%2A>屬性已被取代的方法為<xref:System.Web.HttpCachePolicy>類別可透過<xref:System.Web.HttpResponse.Cache%2A>輸出快取來控制 網際網路資訊服務 (IIS) 的內建函式物件。和用戶端快取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在傳輸之前修改 HTTP 實體主體的包裝篩選物件。</summary>
        <value>
          <see cref="T:System.IO.Stream" /> 物件，做為輸出篩選條件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您建立`Stream`物件，並設定<xref:System.Web.HttpResponse.Filter%2A>屬性`Stream`物件，所有的 HTTP 傳送輸出<xref:System.Web.HttpResponse.Write%2A>通過篩選。  
  
   
  
## Examples  
 下列範例會設定 ASP.NET 網頁<xref:System.Web.HttpResponse.Filter%2A>屬性的新執行個體`UpperCaseFilter`類別，自訂<xref:System.IO.Stream>將轉換成大寫通過的所有文字的類別。 要求的相關資訊會儲存到文字檔，然後<xref:System.Web.HttpResponse.Filter%2A>屬性設定。 回應篩選備妥之後，程式碼會呼叫<xref:System.Web.HttpRequest.MapPath%2A>方法來取得名為文字檔案的絕對路徑`TestFile.txt`做為回應的內容的來源。 程式碼接著會建立新<xref:System.IO.StreamReader>物件來讀取文字檔案從開始到結束，然後呼叫<xref:System.Web.HttpResponse.Write%2A>方法，以顯示在頁面上檔案的內容。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">不允許以實體篩選。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>送出所有目前正在緩衝的輸出到用戶端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 強制所有目前正在緩衝的輸出傳送至用戶端。 <xref:System.Web.HttpResponse.Flush%2A>方法可以要求處理期間呼叫多次。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Drawing.Graphics.Save%2A>方法來儲存<xref:System.Drawing.Bitmap>物件<xref:System.Web.HttpResponse.OutputStream%2A>屬性並將轉換為 JPEG 影像格式。 然後程式碼會呼叫`Dispose`方法<xref:System.Drawing.Bitmap>物件和<xref:System.Drawing.Graphics>物件，正在使用的資源釋出。 然後它會呼叫<xref:System.Web.HttpResponse.Flush%2A>方法來傳送要求的用戶端之回應的內容。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">快取在回應送出之後被清除。</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式將目前所緩衝的所輸出輸送到用戶端。</summary>
        <returns>表示非同步作業的 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Text.Encoding" /> 物件，代表目前標頭輸出資料流的編碼方式。</summary>
        <value>
          <see cref="T:System.Text.Encoding" />，包含目前標頭之字元集的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A>屬性可讓您停用或變更<xref:System.Text.Encoding>物件上使用的回應標頭<xref:System.Text.ASCIIEncoding>， <xref:System.Text.UnicodeEncoding>， <xref:System.Text.UTF7Encoding>，或<xref:System.Text.UTF8Encoding>物件。 預設編碼方式值是<xref:System.Text.UTF8Encoding>類別。  
  
 型別變更<xref:System.Web.HttpResponse.HeaderEncoding%2A>屬性，您可以提高特定惡意攻擊或透過回應標頭傳送的原因機密資料的風險。 標頭插入式攻擊，部份，即可避免離開<xref:System.Web.HttpResponse.HeaderEncoding%2A>屬性的預設設定的回應。 針對應用程式容易遭受攻擊，無法回應未受信任的資料做為回應標頭的一部分。 如果<xref:System.Web.HttpResponse.HeaderEncoding%2A>接續標頭中的線條，或如果任何標頭會建構為基礎的不受信任的資料的結果，應驗證標頭資料傳送至回應資料流之前，先停用由於需求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">編碼的值是 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException">編碼的值是 <see cref="P:System.Text.Encoding.Unicode" />。  
  
 \-或-  
  
 已傳送標頭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得回應標頭的集合。</summary>
        <value>回應標頭的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Headers%2A>屬性僅支援[!INCLUDE[iisver](~/includes/iisver-md.md)]整合式的管線模式且至少.NET Framework 3.0。 當您嘗試存取<xref:System.Web.HttpResponse.Headers%2A>屬性，其中這兩項條件不符合，<xref:System.PlatformNotSupportedException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此作業需要在 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的整合管線模式中，且至少為 .NET Framework 3.0 版。</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援]  
  
 取得指出是否已寫入回應標頭的值。</summary>
        <value>
          如果已寫入回應標頭則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出用戶端是否仍然與伺服器連接著。</summary>
        <value>
          如果目前已連接到用戶端，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.IsClientConnected%2A>屬性會傳回`false`下列條件成立：  
  
-   用戶端的連線已終止。 這種情形<xref:System.Web.HttpResponse.Close%2A>叫用方法，或用戶端停止執行的網頁，或瀏覽至另一個頁面。  
  
-   <xref:System.Web.HttpWorkerRequest>處理要求的物件是`null`或<xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType>方法會傳回`false`。 如果自訂<xref:System.Web.HttpWorkerRequest>物件會處理要求，然後在<xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType>方法可能會根據設定自訂準則。 例如，自訂背景工作要求可能會在一段時間之後強制逾時。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.HttpResponse.IsClientConnected%2A>屬性來檢查是否要求網頁用戶端仍然連接到伺服器。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 true，程式碼會呼叫<xref:System.Web.HttpResponse.Redirect%2A>方法和用戶端會檢視另一頁。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 false，則程式碼會呼叫<xref:System.Web.HttpResponse.End%2A>方法和所有的網頁處理已終止。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得布林值，指出用戶端是否傳輸至新位置。</summary>
        <value>
          如果位置回應標頭的值不同於目前的位置，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A>屬性<xref:System.Web.HttpResponse.RedirectLocation%2A>屬性測試，並決定是否絕對 URI 傳輸至用戶端在 HTTP`Location`標頭是不同於目前的 URI 以及什麼是新的預定的 URI將會傳送到。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>允許文字輸出至傳出 HTTP 回應資料流。</summary>
        <value>
          <see cref="T:System.IO.TextWriter" /> 物件，允許自訂輸出至用戶端。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例是 ASP.NET 網頁，其中包含<xref:System.Web.UI.WebControls.TextBox>控制項具有其<xref:System.Web.UI.WebControls.TextBox.TextMode%2A>屬性設定為<xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>。 網頁的程式碼會採用使用者在輸入的文字<xref:System.Web.UI.WebControls.TextBox.TextMode%2A>，會使用<xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法，以 HTML 編碼，而<xref:System.Web.HttpResponse.Output%2A>屬性，以顯示頁面的編碼的字串。  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>允許二進位輸出至傳出 HTTP 內容主體。</summary>
        <value>IO <see cref="T:System.IO.Stream" />，代表連出 HTTP 內容主體的原始內容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用.NET Framework 2.0 版中，從開始<xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法所傳回的 IO 資料流<xref:System.Web.HttpResponse.OutputStream%2A>屬性，下列的例外狀況可能會擲回：  
  
-   <xref:System.ArgumentOutOfRangeException>如果`offset`或`count`參數是負值或`buffer`參數的長度減去`offset`參數小於或等於零。  
  
-   <xref:System.ArgumentNullException>如果`buffer`參數是`null`。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Drawing.Image.Save%2A>方法來儲存<xref:System.Drawing.Bitmap>物件<xref:System.Web.HttpResponse.OutputStream%2A>屬性，並將影像轉換成 JPEG 格式。 程式碼接著會呼叫 Dispose 方法上<xref:System.Drawing.Bitmap>物件和<xref:System.Drawing.Graphics>物件，正在使用的資源釋出。 最後，程式碼會呼叫<xref:System.Web.HttpResponse.Flush%2A>方法來傳送要求的用戶端之回應的內容。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> 無法使用。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要加入 <see langword="PICS-Label" /> 標頭的字串。</param>
        <summary>附加 HTTP <see langword="PICS-Label" /> 標頭至輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 平台的網際網路內容選取項目 (PICS) 是全球資訊網協會 (W3C) 標準，設定標記的內容。 PICS 是基本上是一種語言建立分級系統。  
  
 任何值可以是 PICS 標籤。ASP.NET 不會驗證標籤。 字串的最大長度為 255 個字元。 如需 PICS 標準和語法的詳細資訊，請參閱[World Wide Web Consortium](http://go.microsoft.com/fwlink/?LinkID=37125)網站。  
  
   
  
## Examples  
 下列範例會顯示影像的 ASP.NET 網頁。 頁面的程式碼呼叫<xref:System.Web.HttpResponse.Pics%2A>方法，以設定 HTTP`PICS-Label`回應標頭。 會當做參數傳遞的字串<xref:System.Web.HttpResponse.Pics%2A>方法代表從網際網路內容分級關聯 (ICRA) 網站上產生的評等標籤。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提升承諾的物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">推播要求的 URL。 其應為伺服器想要推送到用戶端之相對資源的虛擬路徑。</param>
        <summary>此 API 可支援傳送推播確認給 HTTP 2.0 用戶端的應用程式。 您可以在下列網址上，找到更多有關 HTTP2 伺服器推播的詳細資料：[HTTP/2 Specification Section 8.2: Server Push](https://http2.github.io/http2-spec/#PushResources) (HTTP/2 規格 8.2 節：伺服器推播)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise 不具決定性，而且應用程式不應該擁有邏輯取決於它。 其唯一目的是在某些情況下的效能優勢。 有可能會導致完全忽略推播要求的許多情況 （通訊協定和實作）。 預期為基礎和不理 」。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">推播要求的 URL。 其應為伺服器想要推送到用戶端之相對資源的虛擬路徑。</param>
        <param name="method">推播要求要使用的 HTTP 要求方法。</param>
        <param name="headers">推播要求要使用的 HTTP 要求標頭。</param>
        <summary>此 API 可支援傳送推播確認給 HTTP 2.0 用戶端的應用程式。 您可以在下列網址上，找到更多有關 HTTP2 伺服器推播的詳細資料：[HTTP/2 Specification Section 8.2: Server Push](https://http2.github.io/http2-spec/#PushResources) (HTTP/2 規格 8.2 節：伺服器推播)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise 不具決定性，而且應用程式不應該擁有邏輯取決於它。 其唯一目的是在某些情況下的效能優勢。 有可能會導致完全忽略推播要求的許多情況 （通訊協定和實作）。 預期為基礎和不理 」。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>重新導向用戶端至新的 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">目標位置。 這可能是應用程式相對虛擬路徑。</param>
        <summary>重新導向要求至新的 URL 並指定新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Web.HttpResponse.Redirect%2A>就相當於呼叫<xref:System.Web.HttpResponse.Redirect%2A>與第二個參數設定為`true`。  
  
 <xref:System.Web.HttpResponse.Redirect%2A> 呼叫<xref:System.Web.HttpResponse.End%2A>哪些會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。 這個例外狀況會有不利的影響，對 Web 應用程式效能。 因此，我們建議您使用而不是這個多載<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>多載，並傳遞`false`如`endResponse`參數，然後再呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>方法。 如需詳細資訊，請參閱 <xref:System.Web.HttpResponse.End%2A> 方法。  
  
> [!NOTE]
>  僅適用行動網頁，如果您的應用程式依賴無 cookie 工作階段，或可能會收到要求，從行動裝置需要無 cookie 工作階段之路徑中使用波狀符號 （~） 導致建立新的工作階段，可能遺失工作階段資料。 行動控制項以路徑上設定屬性，例如"~ / 路徑 」，解析路徑使用<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"~ / 路徑 」 之前將其指派給屬性。  
  
 ASP.NET 會藉由傳回 302 的 HTTP 狀態碼來執行重新導向。 將控制權轉移到另一個頁面的替代方式是<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法是通常更有效率，因為它不會往返造成用戶端。 如需詳細資訊，請參閱[How to： 將使用者重新導向至其他頁面](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)。  
  
   
  
## Examples  
 下列範例會強制無條件的重新導向至另一個網站。  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">在送出 HTTP 標頭之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">目標的位置。</param>
        <param name="endResponse">表示是否應該終止目前網頁的執行。</param>
        <summary>重新導向用戶端至新的 URL。 指定新 URL 和是否應該結束目前網頁的執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 絕對 URL (例如，http://www.contoso.com/default.aspx)或相對 URL (例如 Default.aspx) 可以指定的目標位置，但某些瀏覽器可能會拒絕相對 URL。  
  
 當您使用這個方法中網頁處理常式終止要求一頁並啟動新要求的另一個頁面上，設定`endResponse`至`false`，然後呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>方法。 如果您指定`true`如`endResponse`參數，這個方法會呼叫<xref:System.Web.HttpResponse.End%2A>原始要求，會擲回方法<xref:System.Threading.ThreadAbortException>完成時的例外狀況。 這個例外狀況，並在 Web 應用程式效能，這就是為什麼傳遞的不利影響`false`如`endResponse`建議參數。 如需詳細資訊，請參閱 <xref:System.Web.HttpResponse.End%2A> 方法。  
  
> [!NOTE]
>  行動頁面，如果您的應用程式依賴無 cookie 工作階段，或可能會收到要求，從行動裝置需要無 cookie 工作階段之路徑中使用波狀符號 （~） 可以建立新的工作階段及可能遺失工作階段的資料。 行動控制項以路徑上設定屬性，例如"~ / 路徑 」，解析路徑使用<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"~ / 路徑 」 之前將其指派給屬性。  
  
 ASP.NET 會藉由傳回 302 的 HTTP 狀態碼來執行重新導向。 將控制權轉移到另一個頁面的替代方式是<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法是通常更有效率，因為它不會往返造成用戶端。 如需詳細資訊，請參閱[How to： 將使用者重新導向至其他頁面](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.HttpResponse.IsClientConnected%2A>屬性來檢查是否要求網頁用戶端仍然連接到伺服器。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 true，程式碼會呼叫<xref:System.Web.HttpResponse.Redirect%2A>方法和用戶端會檢視另一頁。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 false，則程式碼會呼叫<xref:System.Web.HttpResponse.End%2A>方法和所有的網頁處理已終止。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 包含新行字元。</exception>
        <exception cref="T:System.Web.HttpException">在送出 HTTP 標頭之後嘗試重新導向。</exception>
        <exception cref="T:System.ApplicationException">頁面要求是回呼的結果。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Http <see langword="Location" /> 標頭的值。</summary>
        <value>在 HTTP <see langword="Location" /> 標頭中要傳輸至用戶端的絕對 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會示範如何使用這個屬性來指定您程式碼透過 HTTP 301 回應程式碼中的永久重新導向時的重新導向 URL。  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已經寫入 HTTP 標頭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行從要求之 URL 至指定之 URL 的永久重新導向。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">要求將重新導向至其中的位置。</param>
        <summary>執行從要求之 URL 至指定之 URL 的永久重新導向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29>方法多載 301 的 HTTP 狀態碼回應中提供，並包含重新導向的要求的 URL。 301 的 HTTP 狀態碼是標準的程式碼，在 HTTP 回應中。 代表永久重新導向存在，且它會提供重新導向位置。  
  
 呼叫<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29>方法多載會終止回應。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 包含新行字元 (<c>\n</c>)。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">要求將重新導向至其中的位置。</param>
        <param name="endResponse">
          <see langword="true" /> 表示終止回應，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</param>
        <summary>執行從要求之 URL 至指定之 URL 的永久重新導向，並提供完成回應的選項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>方法多載 301 的 HTTP 狀態碼回應中提供，並包含重新導向的要求的 URL。 這個方法多載也會提供選項，可指定是否要終止或完成執行重新導向之後的回應。 301 的 HTTP 狀態碼是標準的程式碼，在 HTTP 回應中。 代表永久重新導向存在，且它會提供重新導向位置。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 包含新行字元 (<c>\n</c>)。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用路由參數值、路由名稱或兩者都使用，將要求重新導向至新的 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 此方法會將傳入的物件`routeValues`至<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 302 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <summary>使用路由名稱，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 此方法會將傳入的路由名稱`routeName`使用 url<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法。  
  
 ASP.NET 會藉由傳回 302 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Products`。  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 這個方法會呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法來決定的 URL。  
  
 ASP.NET 會藉由傳回 302 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值及路由名稱，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 此方法會將傳入的物件`routeValues`至<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 302 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`具有名為的參數和`productid`和`category`。  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值及路由名稱，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>呼叫方法來決定的 URL。  
  
 ASP.NET 會藉由傳回 302 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`具有名為的參數和`productid`和`category`。  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用路由參數值、路由名稱或兩者都使用，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 此方法會將傳入的物件`routeValues`至<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <summary>使用路由名稱，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 此方法會將傳入的路由名稱`routeName`使用 url<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Products`。  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 這個方法會呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法來決定的 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值以及對應到新 URL 的路由名稱，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.RedirectPermanent%2A>第二個參數設定為具有方法`false`。  
  
 此方法會將傳入的物件`routeValues`至<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`具有名為的參數和`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值及路由名稱，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法被提供給方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>第二個參數設定為具有方法`false`。  
  
 這個方法會呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法來決定的 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`具有名為的參數和`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用預設輸出快取區提供者，從輸出快取區移除快取的項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">從快取中移除之項目的虛擬絕對路徑。</param>
        <summary>從快取移除與預設輸出快取提供者關聯的所有快取項目。 此方法為靜態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法來移除與預設輸出快取提供者相關聯的輸出快取項目。 呼叫<xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A>方法，以移除網站組態檔中所指定的自訂輸出快取提供者相關聯的輸出快取項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 不是絕對虛擬路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">從快取中移除之項目的虛擬絕對路徑。</param>
        <param name="providerName">提供者，用來移除所有與指定路徑相關聯的輸出快取成品。</param>
        <summary>使用指定的輸出快取提供者，移除所有與指定之路徑關聯的輸出快取項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法來移除與網站組態檔中指定的自訂輸出快取提供者相關聯的輸出快取項目。 若要移除與預設輸出快取提供者相關聯的輸出快取項目，呼叫<xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是無效路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">集合中要更新的 Cookie。</param>
        <summary>因為 <b>HttpResponse.SetCookie</b> 方法僅供內部使用，所以您不應該在程式碼中呼叫它。 相反地，您可以呼叫 <b>HttpResponse.Cookies.Set</b> 方法，如下列範例所示。<br /> 更新 Cookie 集合中的現有 Cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會更新現有的 cookie 的值。  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">嘗試在 HTTP 標頭送出後設定 Cookie。</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>設定傳回至用戶端的 <see langword="Status" /> 行。</summary>
        <value>設定狀態碼會造成描述 HTTP 輸出狀態的字串被傳回至用戶端。 預設值為 200 (OK)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> 已被取代之喜好<xref:System.Web.HttpResponse.StatusDescription%2A>並提供是為了與 ASP 的舊版本相容性。 使用 ASP.NET，<xref:System.Web.HttpResponse.StatusDescription%2A>改為。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">狀態被設定為無效狀態碼。</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定傳回至用戶端的輸出之 HTTP 狀態碼。</summary>
        <value>整數，代表傳回至用戶端的 HTTP 輸出的狀態。 預設值為 200 (OK)。 如需有效狀態碼的清單，請參閱[Http 狀態碼](http://go.microsoft.com/fwlink/?LinkId=73157)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查輸出資料流的狀態碼。 如果狀態碼不等於 200，則會執行額外的程式碼。  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> 在 HTTP 標頭送出之後被設定。</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定傳回至用戶端的輸出之 HTTP 狀態字串。</summary>
        <value>字串，描述傳回至用戶端的 HTTP 輸出的狀態。 預設值為 [確定]。 如需有效狀態碼的清單，請參閱[Http 狀態碼](http://go.microsoft.com/fwlink/?LinkId=73157)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查輸出資料流的狀態字串。 如果狀態不是等於 [確定]，則會執行額外的程式碼。  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> 在 HTTP 標頭送出之後被設定。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">選取的值長度大於 512。</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定的值會評估回應的狀態碼是否合格。</summary>
        <value>整數值，代表 [!INCLUDE[iisver](~/includes/iisver-md.md)] 子狀態碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.SubStatusCode%2A>的整合式的管線模式中才支援屬性[!INCLUDE[iisver](~/includes/iisver-md.md)]且至少為.NET Framework 3.0 版。 當您將<xref:System.Web.HttpResponse.SubStatusCode%2A>屬性，狀態登入[!INCLUDE[iisver](~/includes/iisver-md.md)]如果失敗的要求追蹤的設定。 無關的值是否設定追蹤，將程式碼永遠不會傳送要求的最後一個回應的一部分。 如需詳細資訊，請參閱[疑難排解失敗的要求使用失敗要求的追蹤在 IIS 7.0 中](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1)。  
  
   
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.SubStatusCode%2A>屬性中的事件處理常式<xref:System.Web.HttpApplication>的執行個體<xref:System.Web.HttpApplication.PostAuthenticateRequest>事件。 將程式碼檔案放在 Web 應用程式 App_Code 資料夾，並設定 Web.config 檔案，以登錄的模組。 如需詳細資訊，請參閱[逐步解說： 建立及註冊自訂 HTTP 模組](http://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453)。  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此作業需要在 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的整合管線模式中，且至少為 .NET Framework 3.0 版。</exception>
        <exception cref="T:System.Web.HttpException">狀態碼是在送出所有 HTTP 標頭之後設定。</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出連接是否支援非同步清除作業。</summary>
        <value>
          如果連接支援非同步清除作業，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性傳回的值<xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否送出 HTTP 內容至用戶端。</summary>
        <value>
          <see langword="true" /> 表示要隱藏輸出，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查是否<xref:System.Web.HttpRequest.IsSecureConnection%2A>屬性設定為 false。 如果是，<xref:System.Web.HttpResponse.SuppressContent%2A>屬性設定為 true，以停止傳送回應。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援]  
  
 取得或設定值，這個值表示是否要隱藏目前 HTTP 回應的預設 <c>Cache Control: private</c> 標頭。</summary>
        <value>
          <see langword="true" /> 隱藏預設<c>Cache Control： 私用</c>標頭目前 HTTP 回應; 否則<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，ASP.NET 會`Cache-Control: private`回應標頭除非這個回應已指定明確的快取原則。 這個屬性可讓隱藏每個要求為基礎的這個預設回應標頭。 標頭可以仍然隱藏整個應用程式藉由設定<xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A>中[httpRuntime 元素 （ASP.NET 設定結構描述）](http://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369)或[outputCache 項目，快取 （ASP.NET 設定結構描述）](http://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 抑制預設時謹慎小心`Cache-Control: private`標頭，做為 proxy 與其他媒介之間進行可能沒有這個標頭的回應可快取，以視為預設。 此處理方式可能會導致機密資訊不小心快取。 請參閱[RFC 2616，秒 13.4](http://tools.ietf.org/html/rfc2616)如需詳細資訊。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定是否應該抑制表單驗證重新導向至登入頁面。</summary>
        <value>
          如果不應執行表單驗證重新導向，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，表單驗證會將 HTTP 401 狀態碼轉換為 302，以便重新導向至登入頁面。 這不是適當特定類別的錯誤，例如當驗證成功，但授權失敗，或當目前的要求是 AJAX 或 web 服務要求。 這個屬性會提供方法來抑制重新導向行為，並將原始的狀態碼傳送給用戶端。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定的檔案直接寫入 HTTP 回應輸出資料流，而不在記憶體中緩衝。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出的檔案名稱。</param>
        <summary>將指定的檔案直接寫入 HTTP 回應輸出資料流，而不在記憶體中緩衝。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出的檔案名稱。</param>
        <param name="offset">開始寫入 HTTP 輸出的檔案位置。</param>
        <param name="length">要傳送的位元組數目。</param>
        <summary>將指定的檔案部分直接寫入 HTTP 回應輸出資料流，而不在記憶體中緩衝。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您指定 0 做為`offset`參數，並為-1`length`參數，會傳送整個檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="offset" /> 參數小於零。  
  
 \-或-  
  
 <paramref name="length" /> 參數小於 -1。  
  
 \-或-  
  
 <paramref name="length" /> 參數指定大於檔案包含之位元組數目減去位移的位元組數目。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支援跨處理序背景工作要求。  
  
 \-或-  
  
 回應並未使用 <see cref="T:System.Web.HttpWriter" /> 物件。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 參數小於零或大於檔案大小。  
  
 \-或-  
  
 <paramref name="length" /> 參數小於 1，或大於 <paramref name="offset" /> 參數加上檔案大小的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，以指定是否要停用 [!INCLUDE[iisver](~/includes/iisver-md.md)] 自訂錯誤。</summary>
        <value>
          <see langword="true" /> 表示要停用 IIS 自訂錯誤，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>屬性只有在您的應用程式裝載在 IIS 7.0 中時，才使用。 在 IIS 7.0 中的傳統模式執行時<xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>屬性的預設值是`true`。 在整合模式中執行時<xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>屬性的預設值是`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將資訊寫入 HTTP 回應輸出資料流。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">要傳送至 HTTP 輸出資料流的字元。</param>
        <summary>將字元寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立一系列的 ASP.NET 網頁使用 Write 方法寫入的常數。 程式碼會呼叫 Write 方法寫入頁面的個別字元常數的這個版本。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要寫入 HTTP 輸出資料流的 <see cref="T:System.Object" />。</param>
        <summary>將 <see cref="T:System.Object" /> 寫入 HTTP 回應資料流。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要寫入 HTTP 輸出資料流的字串。</param>
        <summary>將字串寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果從用戶端接收或傳輸回到用戶端時，不會驗證從 Web 用戶端收到的輸入，動態產生的 HTML 頁面可能導致安全性風險。 輸入提交到網站並稍後寫回至用戶端中內嵌惡意指令碼可能會來自受信任的來源。 此安全性風險被指跨網站指令碼的攻擊。 您應該一律驗證將會從您的網站中傳輸到用戶端瀏覽器時，從用戶端收到的資料。  
  
 此外，每當您寫出為 HTML 做為輸入收到的任何資料，您應該加以編碼使用的技術，例如<xref:System.Web.HttpServerUtility.HtmlEncode%2A>或<xref:System.Web.HttpServerUtility.UrlEncode%2A>來防止執行惡意指令碼。 這項技術可用於在接收時未經過驗證的資料。  
  
 當您編碼或篩選資料時，您必須指定字元，設定您的網頁，讓您篩選條件可以識別並移除任何的位元組序列不屬於設定 （例如非英數字元順序） 和可能中內嵌惡意指令碼它們。  
  
 如需跨網站指令碼攻擊的詳細資訊，請參閱文件 Q252985，「 如何以防止跨網站指令碼處理安全性問題 」 [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?LinkID=37115)網站。  
  
   
  
## Examples  
 下列範例回應傳回至用戶端瀏覽器的用戶端的名稱。 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法會刪除任何惡意指令碼 」 和 「 無效的字元可能會在提交`UserName`輸入的欄位。  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要寫入的字元陣列。</param>
        <param name="index">開始寫入之字元陣列中的位置。</param>
        <param name="count">要寫入的字元數，從 <c>index</c> 開始。</param>
        <summary>將字元的陣列寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立一系列的 ASP.NET 網頁使用 Write 方法寫入的常數。 程式碼會呼叫 Write 方法寫入頁面的個別字元常數的這個版本。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定檔案直接寫入 HTTP 回應輸出資料流。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出的檔案名稱。</param>
        <summary>將指定的檔案內容直接寫入 HTTP 回應輸出資料流，做為檔案區塊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫此方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會將名為文字檔案的所有內容`Login.txt`（其中可能包含常值的 HTML 文字和輸入控制項） 直接寫入輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入記憶體區塊的檔案名稱。</param>
        <param name="readIntoMemory">指示檔案將是否被寫入記憶體區塊。</param>
        <summary>將指定的檔案內容直接寫入 HTTP 回應輸出資料流，做為記憶體區塊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫此方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會將檔案寫入記憶體。  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">要寫入 HTTP 輸出資料流之檔案的檔案控制代碼 (File Handle)。</param>
        <param name="offset">檔案中開始寫入處的位元組位置。</param>
        <param name="size">要寫入輸出資料流的位元組數目。</param>
        <summary>將指定檔案直接寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫此方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會將名為文字檔案的所有內容`Login.txt`（其中可能包含常值的 HTML 文字和輸入控制項） 直接寫入輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> 小於 0。  
  
 \-或-  
  
 <paramref name="size" /> 大於檔案大小減去 <paramref name="offset" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出資料流的檔案名稱。</param>
        <param name="offset">檔案中開始寫入處的位元組位置。</param>
        <param name="size">要寫入輸出資料流的位元組數目。</param>
        <summary>將指定檔案直接寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫此方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會將名為文字檔案的所有內容`Login.txt`（其中可能包含常值文字和 HTML 輸入控制項） 直接寫入輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> 小於 0。  
  
 \-或-  
  
 <paramref name="size" /> 大於檔案大小減去 <paramref name="offset" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">要替代的方法、使用者控制項或物件。</param>
        <summary>允許回應替代區塊插入回應，以便為輸出快取的回應，動態產生指定的回應區域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Web.HttpResponse.WriteSubstitution%2A>進行後置的快取輸出快取頁面中的替代方法。 藉由傳遞<xref:System.Web.HttpContext>物件至回呼方法與規定<xref:System.Web.HttpResponseSubstitutionCallback>簽章，您可以取代輸出快取在任何給定的位置，在網頁快取內容。 若要起始取代，呼叫<xref:System.Web.HttpResponse.WriteSubstitution%2A>方法，將回呼方法，這必須是安全執行緒，而且可以是下列任一項傳遞給它：  
  
-   容器網頁或使用者控制項上的靜態方法。  
  
-   靜態或執行個體上其他的任意物件的方法。  
  
 第一次要求頁面，<xref:System.Web.HttpResponse.WriteSubstitution%2A>呼叫<xref:System.Web.HttpResponseSubstitutionCallback>委派至產生的輸出。 然後，將會加入替代緩衝的回應，其中保留要在未來的要求呼叫的委派。 最後，它會降低用戶端快取功能從公用伺服器專用，以確保未來的要求頁面重新叫用委派不在用戶端上快取。  
  
> [!NOTE]
>  使用者控制層級的輸出快取套用所在的快取的使用者控制項不支援快取後替換。 這也稱為片段快取。 如需詳細資訊，請參閱[快取的 ASP.NET 網頁的部分](http://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="callback" /> 參數之目標的型別為 <see cref="T:System.Web.UI.Control" />。</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
  </Members>
</Type>