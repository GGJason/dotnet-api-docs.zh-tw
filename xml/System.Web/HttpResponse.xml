<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a17c7c8e915146f80783b48f66085b74aa697ffa" />
    <Meta Name="ms.sourcegitcommit" Value="c902e847cd05ac37d93eca981b0fb009aae0a790" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/28/2018" />
    <Meta Name="ms.locfileid" Value="52454922" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>封裝來自 ASP.NET 作業的 HTTP 回應資訊。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法和屬性<xref:System.Web.HttpResponse>類別會透過公開<xref:System.Web.HttpApplication.Response%2A>屬性<xref:System.Web.HttpApplication>， <xref:System.Web.HttpContext>， <xref:System.Web.UI.Page>，和<xref:System.Web.UI.UserControl>類別。  
  
 下列方法<xref:System.Web.HttpResponse>類別支援只有在回傳的情況下，而不是在非同步 post 來支援案例：  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 當您使用啟用網頁局部更新<xref:System.Web.UI.UpdatePanel>更新選取的區域，而不是更新整頁回傳與網頁的控制項。 如需詳細資訊，請參閱 < [UpdatePanel 控制項概觀](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a)並[網頁局部呈現概觀](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49)。  
  
   
  
## Examples  
 在要求網頁時，下列範例會繪製三個重疊的矩形。 程式碼開始時設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 使整個頁面將會轉譯為 JPEG 影像。 程式碼會接著呼叫<xref:System.Web.HttpResponse.Clear%2A>方法，以確保沒有多餘的內容隨這個回應傳送。 接下來，程式碼會設定<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，讓它傳送至要求的用戶端之前完全處理頁面。 然後建立用來繪製矩形的兩個物件：<xref:System.Drawing.Bitmap>和<xref:System.Drawing.Graphics>物件。 在頁面中建立的變數為座標，用於繪製的矩形和最大的矩形內顯示的字串。  
  
 繪製三個矩形和其中所顯示的字串，當<xref:System.Drawing.Bitmap>儲存到<xref:System.IO.Stream>相關聯的物件<xref:System.Web.HttpResponse.OutputStream%2A>屬性，且其格式設定為 JPEG。 程式碼會呼叫<xref:System.Drawing.Image.Dispose%2A>和<xref:System.Drawing.Graphics.Dispose%2A>方法來發行兩個物件所使用的資源。 最後，程式碼會呼叫<xref:System.Web.HttpResponse.Flush%2A>方法以傳送要求的用戶端已緩衝的回應。  
  
> [!NOTE]
>  程式碼中，<xref:System.Web.HttpResponse>物件指由關鍵字`Response`。 例如，`Response.Clear()`是指<xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType>方法。 <xref:System.Web.UI.Page>類別具有名為屬性<xref:System.Web.UI.Page.Response%2A>公開目前的執行個體<xref:System.Web.HttpResponse>。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">啟用自訂 HTTP 輸出的 <see cref="T:System.IO.TextWriter" /> 物件。</param>
        <summary>初始化 <see cref="T:System.Web.HttpResponse" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成員支援 .NET Framework 基礎結構，並不能直接使用於您的程式碼中。  
  
 方法和屬性<xref:System.Web.HttpResponse>類別會公開透過內建<xref:System.Web.HttpContext.Response%2A>在 ASP.NET 中的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">要加入應用程式相依性清單的檔案、快取索引鍵或 <see cref="T:System.Web.Caching.CacheDependency" />。</param>
        <summary>如果回應儲存在輸出快取中而且指定的相依性變更，便使快取相依性集合與回應產生關聯，加速回應失效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddCacheDependency%2A>方法可讓快取回應之間建立相依性和<xref:System.Web.Caching.CacheDependency>物件。  
  
   
  
## Examples  
 下列範例示範如何建立使用的快取相依性<xref:System.Web.HttpResponse.AddCacheDependency%2A>方法和<xref:System.Web.Caching.CacheDependency>物件。  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencies" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">已經建立快取的回應之後，這個方法在快取處理管線中已太晚呼叫。</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">快取的 ASP.NET 網頁</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓快取回應的有效性取決於快取中的其他項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">
          <see cref="T:System.Collections.ArrayList" />，包含目前快取回應所相依的項目索引鍵。</param>
        <summary>讓快取回應的有效性取決於快取中的其他項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目中所參考`cacheKeys`參數會從快取中移除，目前項目的快取的回應無效。  
  
   
  
## Examples  
 下列範例示範如何使用 ASP.NET 網頁輸出快取。 頁面的程式碼會建立<xref:System.Collections.ArrayList>物件中儲存的項目相關聯的索引鍵的<xref:System.Web.Caching.Cache>物件。 接下來，程式碼會傳遞<xref:System.Collections.ArrayList>做為參數呼叫<xref:System.Web.HttpResponse.AddCacheItemDependencies%2A>方法。 這讓快取輸出回應不是有效的如果任一項中指定的檔案<xref:System.Collections.ArrayList>變更。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">快取的 ASP.NET 網頁</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">項目索引鍵的陣列，為快取回應所依存。</param>
        <summary>讓快取項目的有效性取決於快取中的另一個項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當任一`cacheKey`s 會從快取中移除，目前項目的快取的回應無效。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">快取的 ASP.NET 網頁</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">項目的索引鍵，為快取回應所依存。</param>
        <summary>讓快取回應的有效性取決於快取中的另一個項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當項目對應至`cacheKey`從快取移除參數、 目前項目的快取的回應無效。  
  
   
  
## Examples  
 下列範例是 ASP.NET 使用者控制項輸出快取。 控制項呼叫的程式碼<xref:System.Web.HttpResponse.AddCacheItemDependency%2A>方法中所儲存之項目的索引鍵<xref:System.Web.Caching.Cache>做為其參數傳遞的物件。 如果項目不存在於快取中，儲存在輸出快取中的控制項的回應將會失效。 這表示在後續要求中，新版本的控制項的回應會新增至輸出快取。  
  
 接下來，程式碼會檢查項目要與相關聯`bookData`金鑰儲存在`Cache`物件，並顯示兩行文字取決於結果其中之一。 然後，程式碼會設定<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>的屬性<xref:System.Web.UI.WebControls.DataGrid>控制項，名為`dgBooks`，藉由呼叫自訂`DataHelper`類別的共用`GetBookData`方法，並於其中填入<xref:System.Web.UI.WebControls.DataGrid>具有<xref:System.Web.UI.Control.DataBind%2A>方法。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">快取的 ASP.NET 網頁</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將檔案名稱群組加入目前回應所依存的檔案名稱的集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">要加入的檔案集合。</param>
        <summary>將檔案名稱群組加入目前回應所依存的檔案名稱的集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例是 ASP.NET 網頁輸出快取。 頁面的程式碼會建立<xref:System.Collections.ArrayList>的檔案路徑，然後傳遞<xref:System.Collections.ArrayList>做為參數呼叫<xref:System.Web.HttpResponse.AddFileDependencies%2A>方法。 這可讓輸出快取的回應無效任何的 if 檔案中指定<xref:System.Collections.ArrayList>變更。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">快取的 ASP.NET 網頁</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">要加入的檔案陣列。</param>
        <summary>將檔案名稱陣列加入目前回應所依存的檔案名稱的集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將檔案名稱的陣列<xref:System.Web.HttpResponse.AddFileDependencies%2A>檔案相依性清單。 如果檔案變更，已失效快取回的應。  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">快取的 ASP.NET 網頁</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要加入的檔案名稱。</param>
        <summary>將單一檔案名稱加入目前回應所依存的檔案名稱的集合。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用<xref:System.Web.HttpResponse.AddFileDependency%2A>方法來加入檔案相依性，您也必須指定輸出快取，以程式設計方式或以宣告方式。 例如，若要指定輸出快取以宣告方式，使用指示詞。 如需詳細資訊，請參閱 <<c0> [ 如何： 使用檔案相依性的快取頁面輸出](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db)。  
  
   
  
## Examples  
 下列範例示範如何將單一檔案名稱來新增<xref:System.Web.HttpResponse.AddFileDependency%2A>檔案相依性清單。 如果變更的檔案，則會快取的回應失效。  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">快取的 ASP.NET 網頁</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要加入 <paramref name="value" /> 之 HTTP 標頭的名稱。</param>
        <param name="value">要加入標頭的字串。</param>
        <summary>將 HTTP 標頭加入輸出資料流。 提供 <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> 的目的，是為了與 ASP 的舊版本相容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> 等同於<xref:System.Web.HttpResponse.AppendHeader%2A>和提供是為了與 ASP 的舊版本的相容性。 使用 ASP.NET、 <xref:System.Web.HttpResponse.AppendHeader%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">回呼方法。</param>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援] 
註冊 ASP.NET 執行階段會立即在回應標頭傳送給這個要求之前叫用的回呼。</summary>
        <returns>
          <see cref="T:System.Web.ISubscriptionToken" /> 物件，代表 OnSendingHeaders 虛擬事件的訂閱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  AddOnSendingHeaders 方法不會叫用，如果原生模組第一次排清回應。  
  
 虛擬事件 OnSendingHeaders 與 IHttpModule 層級管線事件不同，在於它是每個要求的訂用帳戶，而不是每個應用程式的訂用帳戶。 其用意是回呼可能會修改回應狀態碼，或可能會設定回應的 cookie 或標頭。 其他使用方式附註和注意事項：  
  
-   IIS 整合式的管線模式管線中執行時，才，而且只有在回應標頭尚未針對目前的要求已傳送，這個方法會有效。  
  
-   ASP.NET 執行階段不保證任何關於叫用回呼的執行緒。 例如，可能會叫用回呼以同步方式在背景執行緒如果正在執行背景清除。 <xref:System.Web.HttpContext.Current%2A> 不保證可用於這類執行緒。  
  
-   回呼必須呼叫任何方法可操作的回應實體本文，或導致排清。 例如，回呼必須呼叫<xref:System.Web.HttpResponse.Redirect%2A>，因為該方法可能會操作回應實體本文。  
  
-   回呼必須只包含執行短期同步程式碼。 嘗試叫用非同步作業，或等候這類作業可能會導致死結。  
  
-   回呼不能擲回例外狀況;否則行為未定義。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">要加入輸出資料流的 <see cref="T:System.Web.HttpCookie" />。</param>
        <summary>將 HTTP Cookie 加入內建 Cookie 集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立新的 cookie，名為`LastVisit`管理員、 設定 cookie 的值為目前的日期和時間，並將 cookie 附加至目前的 cookie 集合。 中的用戶端傳送 cookie 集合中的所有 cookie `Set-Cookie` HTTP 標頭輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後，附加 Cookie。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要加入輸出資料流的 HTTP 標頭名稱。</param>
        <param name="value">附加到標頭的字串。</param>
        <summary>將 HTTP 標頭加入輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用<xref:System.Web.HttpResponse.AppendHeader%2A>方法來傳送快取特定標頭，並同時使用 快取物件模型 (<xref:System.Web.HttpResponse.Cache%2A>) 以設定快取原則，屬於快取的 HTTP 回應標頭 (`Cache-Control`， `Expires`， `Last-Modified`， `Pragma`，和`Vary`) 使用的快取物件模型時可能會被刪除。 此行為可讓 ASP.NET 以維護最嚴格的設定。 例如，請考慮包含使用者控制項的頁面。 如果控制項有衝突的快取原則，則將使用的限制最嚴格的快取原則。 如果一個使用者控制項設定的標頭 」`Cache-Control: Public`"和另一個使用者控制項設定更嚴格的標頭 >`Cache-Control: Private`"透過呼叫<xref:System.Web.HttpCachePolicy.SetCacheability%2A>，則 「`Cache-Control: Private`"標頭將會傳送回應。  
  
 如需標準 http/1.1 標頭，請參閱 14 」 標頭欄位定義 」 區段中[都會使用超文字傳輸通訊協定，HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) World Wide Web Consortium (W3C) 網站上的規格。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Web.HttpResponse.AppendHeader%2A>方法來加入自訂標頭<xref:System.Web.HttpResponse>傳送要求的用戶端物件。  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">標頭在 HTTP 標頭送出之後被附加。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">要加入記錄檔的文字。</param>
        <summary>將自訂記錄資訊加入網際網路資訊服務 (IIS) 記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要允許記錄在記錄檔中指定的字串，必須先啟用**URI 查詢**選項**擴充記錄內容**為您想要記錄的活動，在 IIS 中的網站 對話方塊.  
  
 若要自訂在 IIS 6.0 中的延伸記錄，請遵循下列步驟：  
  
1.  在 [IIS 管理員] 中，展開 [本機電腦] 節點，展開 [Web 或 FTP 站台] 資料夾、 Web 或 FTP 站台，以滑鼠右鍵按一下，然後按一下**屬性**。  
  
2.  按一下  **Web 或 FTP 站台**索引標籤，然後按**啟用記錄**核取方塊 （若尚未選取的話）。  
  
3.  在 **作用中的記錄檔格式**方塊中，按一下**W3C 擴充記錄檔格式**。  
  
4.  按一下 **屬性**。  
  
5.  按一下 **進階**索引標籤上，選取您想要記錄，然後按一下 屬性**確定**。  
  
   
  
## Examples  
 下列範例顯示如何將字串附加至記錄檔。  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Windows Server 2003 產品說明</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">資源的虛擬路徑。</param>
        <summary>如果工作階段使用 <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 工作階段狀態並且傳回合併的路徑，則將工作階段 ID 加入虛擬路徑。 如果沒有使用 <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> 工作階段狀態，則 <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> 會傳回原始虛擬路徑。</summary>
        <returns>已插入工作階段 ID 的 <paramref name="virtualPath" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> 是只使用無 cookie 工作階段用來建構絕對的 Href。  
  
   
  
## Examples  
 下列範例宣告名為的字串變數`urlConverted`，並設定它的結果為<xref:System.Web.HttpResponse.ApplyAppPathModifier%2A>方法呼叫。 程式碼接著會傳遞變數的值，以<xref:System.Web.UI.WebControls.HyperLink>控制項的<xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A>屬性。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">回呼物件。</param>
        <param name="state">回應狀態。</param>
        <summary>將目前已緩衝的回應傳送到用戶端。</summary>
        <returns>非同步結果物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果基礎<xref:System.Web.HttpWorkerRequest>物件支援非同步清除作業，從非同步模組事件或非同步處理常式，會呼叫這個方法會以非同步方式執行清除作業。 否則，清除作業是以同步方式執行。 IIS 6.0 和更新版本支援非同步排清。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已經完成回應。</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">寫入輸出資料流的位元組。</param>
        <summary>將二進位字元的字串寫入 HTTP 輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例讀入緩衝區中的文字檔案，並將緩衝區寫入 HTTP 輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要緩衝輸出並在整個回應處理完成之後將它送出。</summary>
        <value>如果對用戶端的輸出有緩衝，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Buffer%2A>屬性已被取代的益處<xref:System.Web.HttpResponse.BufferOutput%2A>屬性並提供是為了與 ASP 的舊版本的相容性。 使用 ASP.NET、 <xref:System.Web.HttpResponse.BufferOutput%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否要緩衝輸出並在整個網頁處理完成之後送出。</summary>
        <value>如果對用戶端的輸出有緩衝，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 的回應會呼叫<xref:System.Web.HttpResponse.Clear%2A>方法來移除其他內容，可能會附加至回應，並設定<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，讓整個頁面將會處理要求的用戶端傳送的任何內容之前。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得網頁的快取原則 (例如，到期時間、隱私權設定與 Vary 子句)。</summary>
        <value>
          <see cref="T:System.Web.HttpCachePolicy" /> 物件，包含目前回應之快取原則的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將目前的快取原則的內容寫入 HTTP 輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定符合其中一個 <see cref="T:System.Web.HttpCacheability" /> 列舉值的 <see langword="Cache-Control" /> HTTP 標頭。</summary>
        <value>字串，代表 <see cref="T:System.Web.HttpCacheability" /> 列舉值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`Private`， `Public`，和`No-Cache`為字串，必須括在引號 ("")。 如果<xref:System.Web.HttpResponse.CacheControl%2A>屬性設定為不符合其中一個值<xref:System.Web.HttpCacheability>列舉值，則<xref:System.ArgumentException>就會擲回。 如果<xref:System.Web.HttpResponse.CacheControl%2A>屬性未設定，快取的回應性會設定為<xref:System.Web.HttpCacheability.NoCache>。  
  
 `CacheControl`， <xref:System.Web.HttpResponse.Expires%2A>，和<xref:System.Web.HttpResponse.ExpiresAbsolute%2A>屬性已被取代。 相反地的方法<xref:System.Web.HttpCachePolicy>類別都是透過<xref:System.Web.HttpResponse.Cache%2A>來控制 Internet Information Services (IIS) 的內建物件輸出快取和用戶端快取。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">設定的字串值不符合其中一個 <see cref="T:System.Web.HttpCacheability" /> 列舉值。</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定輸出資料流的 HTTP 字元集。</summary>
        <value>輸出資料流的 HTTP 字元集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Charset`屬性可以設定為`null`隱藏 HTTP`Content-Type`標頭。  
  
   
  
## Examples  
 下列範例會檢查之字元集的輸出資料流是否中央歐語系 (ISO)。  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">在標頭送出之後，設定 <see langword="Charset" /> 屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從緩衝區資料流清除所有內容輸出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A>方法不會清除標頭資訊。  
  
   
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 的回應會呼叫<xref:System.Web.HttpResponse.Clear%2A>方法來移除其他內容，可能會附加至回應，並設定<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，因此會 [完成] 頁面處理要求的用戶端傳送的任何內容之前。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從緩衝區資料流清除所有內容輸出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A>方法不會清除標頭資訊。  
  
   
  
## Examples  
 下列範例會清除緩衝區資料流中的所有內容。  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從緩衝區資料流清除所有標頭。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會呼叫<xref:System.Web.HttpResponse.ClearHeaders%2A>方法，以確保沒有標頭會隨著目前的回應傳送。 這項技術可能特別重要，如果 ASP.NET 回應產生映像，例如 JPEG 檔案。 在此範例中<xref:System.Web.HttpResponse.ContentType%2A>屬性設定為 image/jpeg。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">標頭在 HTTP 標頭送出之後被清除。</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用戶端中斷連接時發生錯誤的 <see cref="T:System.Threading.CancellationToken" /> 物件。</summary>
        <value>取消語彙基元。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此 API 是安全執行緒。 不過，有一些限制應該如何使用取消語彙基元。 競爭情況、 死結或其他非預期的行為可能會導致不正確地使用它。 請記住下列指導方針：  
  
-   因為 ASP.NET 會處置的取消語彙基元要求結尾，請確定您不超出界限的單一要求中，此 api 呼叫。 沒有語彙基元將以往轉換至已取消的狀態之前處置時保證。 比方說，如果不需要中斷連線的用戶端，完成要求，而不需要先已取消將會處置語彙基元。  
  
-   不需要等候<xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>，因為這樣的效用的非同步通知，而且可能會導致死結。  
  
-   請勿呼叫<xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>叫用的回呼，在原始的多載<xref:System.Threading.SynchronizationContext>物件。  
  
-   請勿使用<xref:System.Web.HttpContext>物件或其他非執行緒安全 ASP.NET 內建函式物件在回呼中提供給<xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType>方法。 回呼可能會執行與其他 ASP.NET 同時或應用程式程式碼。  
  
-   將回呼方法執行短期和非封鎖。  
  
-   盡一切努力避免擲回例外狀況的回呼方法內。  
  
 在 網際網路資訊服務 (IIS) 7.5 或更高版本，在整合模式下才支援這個屬性。 如果您沒有正確 IIS 版本或管線模式中，叫用<xref:System.PlatformNotSupportedException>就會擲回。 若要判斷 IIS 版本，請使用<xref:System.Web.HttpRuntime.IISVersion%2A>。 若要判斷管線模式，請使用<xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉與用戶端的通訊端連接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法中突然方式終止用戶端的連線，並不適用於一般的 HTTP 要求處理。 方法會重設封包傳送到用戶端，這可能會回應資料緩衝處理，導致伺服器、 用戶端，或在某處之間卸除。  
  
 不過，通常您應該呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>而如果您想要往前跳至<xref:System.Web.HttpApplication.EndRequest>事件和傳送回應給用戶端。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定輸出資料流的 HTTP 字元集。</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> 物件，包含目前回應之字元集的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設值`ContentEncoding`可以在 ASP.NET 組態檔中指定[globalization 項目 （ASP.NET 設定結構描述）](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7)一節。 如果<xref:System.Web.HttpResponse.ContentEncoding%2A>由用戶端，會覆寫預設的組態設定。  
  
   
  
## Examples  
 下列範例會寫入的字元集編碼方式寫入輸出資料流可讀取描述。  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">嘗試將 <see cref="P:System.Web.HttpResponse.ContentEncoding" /> 設定為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定輸出資料流的 HTTP MIME 類型。</summary>
        <value>輸出資料流的 HTTP MIME 類型。 預設值為 "<see langword="text/html" />"。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.ContentType%2A>屬性為 image/jpeg、 的回應會呼叫<xref:System.Web.HttpResponse.Clear%2A>方法來移除其他內容，可能會附加至回應，並設定<xref:System.Web.HttpResponse.BufferOutput%2A>屬性設定為 true，因此會 [完成] 頁面處理要求的用戶端傳送的任何內容之前。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.ContentType" /> 屬性設定為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得回應 Cookie 集合。</summary>
        <value>回應 Cookie 集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET 包含兩個內建 cookie 集合。 透過存取的集合<xref:System.Web.HttpRequest.Cookies%2A>的集合<xref:System.Web.HttpRequest>包含傳輸中的伺服器的用戶端的 cookie`Cookie`標頭。 透過存取的集合<xref:System.Web.HttpResponse.Cookies%2A>的集合<xref:System.Web.HttpResponse>包含在伺服器上建立並傳輸至用戶端中的新 cookie`Set-Cookie`標頭。  
  
 使用新增 cookie 之後<xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType>集合中，cookie 可立即用於<xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType>集合，即使尚未傳送回應給用戶端。  
  
   
  
## Examples  
 下列範例會建立新的 cookie，名為`LastVisit`管理員、 設定 cookie 的值為目前的日期和時間，並將 cookie 加入至目前的 cookie 集合。 中的用戶端傳送 cookie 集合中的所有 cookie `Set-Cookie` HTTP 標頭輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停用目前回應的核心快取處理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不支援的核心快取，則這個方法沒有任何作用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停用這個回應的 IIS 使用者模式快取。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不支援 IIS 使用者模式快取，這個方法會傳回而不執行任何動作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前所有受緩衝的輸出傳送到用戶端、停止網頁的執行，並引發 <see cref="E:System.Web.HttpApplication.EndRequest" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法只為了與 ASP 的相容性 — 也就是使用以 COM 為基礎的 Web 程式設計技術的 ASP.NET 相容性。 如果您想要往前跳至<xref:System.Web.HttpApplication.EndRequest>事件和傳送回應給用戶端，它通常最好是呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>改。  
  
 若要模擬的行為`End`ASP 中的方法，這個方法會嘗試以引發<xref:System.Threading.ThreadAbortException>例外狀況。 如果此嘗試成功，呼叫的執行緒將會中止，也就是危害到您的網站效能。 在此情況下，在呼叫之後任何程式碼<xref:System.Web.HttpResponse.End%2A>執行方法。  
  
 如果<xref:System.Web.HttpResponse.End%2A>方法不是引發<xref:System.Threading.ThreadAbortException>，它改為排清回應位元組至用戶端。 它會以同步方式，可能也會危害到您的網站效能。  
  
 在任一情況下 (是否<xref:System.Threading.ThreadAbortException>成功引發例外狀況)，回應管線直接跳到<xref:System.Web.HttpApplication.EndRequest>事件。  
  
 <xref:System.Web.HttpApplication.CompleteRequest%2A>方法不會引發例外狀況，和呼叫後的程式碼<xref:System.Web.HttpApplication.CompleteRequest%2A>方法可能會執行。 如果您的用意是為了避免執行後續的程式碼，而且會降低效能<xref:System.Web.HttpResponse.End%2A>是可接受的您可以呼叫<xref:System.Web.HttpResponse.End%2A>而不是<xref:System.Web.HttpApplication.CompleteRequest%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">
          <see cref="M:System.Web.HttpResponse.End" /> 呼叫已終止目前要求。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">非同步結果物件。</param>
        <summary>完成非同步的清除作業。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">不支援非同步排清，而且 <paramref name="asyncResult" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">不支援非同步排清，而且 <paramref name="asyncResult" /> 參數無法轉換成 <c>FlushAsyncResult</c> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定瀏覽器上快取網頁到期以前的分鐘數。 如果使用者在頁面到期前返回相同的頁面，則會顯示快取版本。 提供 <see cref="P:System.Web.HttpResponse.Expires" /> 的目的，是為了與 ASP 的舊版本相容。</summary>
        <value>在頁面到期前的分鐘數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Expires`，<xref:System.Web.HttpResponse.ExpiresAbsolute%2A>並<xref:System.Web.HttpResponse.CacheControl%2A>屬性已被取代的方法由<xref:System.Web.HttpCachePolicy>類別可透過<xref:System.Web.HttpResponse.Cache%2A>輸出快取來控制 Internet Information Services (IIS) 的內建函式物件。和用戶端快取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定從快取中移除快取資訊的絕對日期和時間。 提供 <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> 的目的，是為了與 ASP 的舊版本相容。</summary>
        <value>頁面到期的日期和時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ExpiresAbsolute`， <xref:System.Web.HttpResponse.Expires%2A>，並<xref:System.Web.HttpResponse.CacheControl%2A>屬性已被取代的方法由<xref:System.Web.HttpCachePolicy>類別可透過<xref:System.Web.HttpResponse.Cache%2A>輸出快取來控制 Internet Information Services (IIS) 的內建函式物件。和用戶端快取。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在傳輸之前修改 HTTP 實體主體的包裝篩選物件。</summary>
        <value>
          <see cref="T:System.IO.Stream" /> 物件，做為輸出篩選條件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您建立`Stream`物件，並設定<xref:System.Web.HttpResponse.Filter%2A>屬性設`Stream`物件，所有的 HTTP 傳送的輸出<xref:System.Web.HttpResponse.Write%2A>通過篩選。  
  
   
  
## Examples  
 下列範例會設定 ASP.NET 網頁<xref:System.Web.HttpResponse.Filter%2A>的新執行個體的屬性`UpperCaseFilter`類別，自訂<xref:System.IO.Stream>將轉換成大寫通過的所有文字的類別。 要求的相關資訊會儲存到文字檔，然後<xref:System.Web.HttpResponse.Filter%2A>屬性設定。 回應篩選已備妥之後，程式碼會呼叫<xref:System.Web.HttpRequest.MapPath%2A>方法來取得名為文字檔案的絕對路徑`TestFile.txt`做為回應的內容的來源。 程式碼接著會建立新<xref:System.IO.StreamReader>物件來讀取文字檔，從開始到結束，然後再呼叫<xref:System.Web.HttpResponse.Write%2A>方法，以顯示在頁面上檔案的內容。  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">不允許以實體篩選。</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>送出所有目前正在緩衝的輸出到用戶端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 強制所有目前正在緩衝的輸出傳送至用戶端。 <xref:System.Web.HttpResponse.Flush%2A>方法可以在要求處理期間呼叫多次。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Drawing.Graphics.Save%2A>方法來儲存<xref:System.Drawing.Bitmap>物件到<xref:System.Web.HttpResponse.OutputStream%2A>屬性，並將轉換為 JPEG 影像格式。 程式碼會接著呼叫`Dispose`方法<xref:System.Drawing.Bitmap>物件和<xref:System.Drawing.Graphics>物件，釋放所佔用的資源。 然後它會呼叫<xref:System.Web.HttpResponse.Flush%2A>方法以傳送要求的用戶端回應的內容。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">快取在回應送出之後被清除。</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式將目前所緩衝的所輸出輸送到用戶端。</summary>
        <returns>表示非同步作業的 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Text.Encoding" /> 物件，代表目前標頭輸出資料流的編碼方式。</summary>
        <value>
          <see cref="T:System.Text.Encoding" />，包含目前標頭之字元集的相關資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A>屬性可讓您停用或變更<xref:System.Text.Encoding>物件上使用的回應標頭<xref:System.Text.ASCIIEncoding>， <xref:System.Text.UnicodeEncoding>， <xref:System.Text.UTF7Encoding>，或<xref:System.Text.UTF8Encoding>物件。 使用預設編碼方式值是<xref:System.Text.UTF8Encoding>類別。  
  
 藉由變更的型別<xref:System.Web.HttpResponse.HeaderEncoding%2A>屬性，您可以提高特定的惡意攻擊或原因要透過回應標頭傳送的機密資料的風險。 標頭插入式攻擊，部分，以避免留下<xref:System.Web.HttpResponse.HeaderEncoding%2A>屬性的預設設定的回應。 攻擊弱點的應用程式無法回應未受信任的資料做為回應標頭的一部分。 如果<xref:System.Web.HttpResponse.HeaderEncoding%2A>接續行的標頭中，或不受信任資料的結果為基礎來建構任何標頭時，如果應該驗證標頭資料傳送至回應資料流之前，先停用由於需求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">編碼的值是 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException">編碼的值是 <see cref="P:System.Text.Encoding.Unicode" />。  
  
\-或- 
已傳送標頭。</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得回應標頭的集合。</summary>
        <value>回應標頭的 <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Headers%2A>屬性僅支援[!INCLUDE[iisver](~/includes/iisver-md.md)]integrated 的管線模式且至少.NET Framework 3.0。 當您嘗試存取<xref:System.Web.HttpResponse.Headers%2A>屬性，其中這兩項條件不符合，<xref:System.PlatformNotSupportedException>就會擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此作業需要在 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的整合管線模式中，且至少為 .NET Framework 3.0 版。</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">升級至 IIS 7.0 的 ASP.NET 應用程式： IIS 7.0 整合模式和傳統模式之間的差異</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援] 
取得指出是否已寫入回應標頭的值。</summary>
        <value>如果已寫入回應標頭則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出用戶端是否仍然與伺服器連接著。</summary>
        <value>如果目前已連接到用戶端，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.IsClientConnected%2A>屬性會傳回`false`下列條件成立：  
  
-   用戶端的連線已終止。 這種情形<xref:System.Web.HttpResponse.Close%2A>已叫用方法，或如果用戶端停止 Web 網頁的執行，或瀏覽至另一個頁面。  
  
-   <xref:System.Web.HttpWorkerRequest>在於處理要求的物件`null`或<xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType>方法會傳回`false`。 如果自訂<xref:System.Web.HttpWorkerRequest>物件會處理要求，則<xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType>方法可能會根據設定自訂的準則。 比方說，自訂的背景工作要求可能會在一段時間之後強制逾時。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.HttpResponse.IsClientConnected%2A>屬性來檢查用戶端所要求的頁面是否仍然連接到伺服器。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 true，程式碼會呼叫<xref:System.Web.HttpResponse.Redirect%2A>方法和用戶端將檢視另一個頁面。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 false，則程式碼會呼叫<xref:System.Web.HttpResponse.End%2A>方法，而所有的頁面處理終止。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得布林值，指出用戶端是否傳輸至新位置。</summary>
        <value>如果位置回應標頭的值不同於目前的位置，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A>具有屬性<xref:System.Web.HttpResponse.RedirectLocation%2A>屬性測試，並決定是否絕對 URI，會傳輸至用戶端在 HTTP`Location`標頭是不同於目前的 URI 和項目正在新預定的 URI將會傳送到。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>允許文字輸出至傳出 HTTP 回應資料流。</summary>
        <value>
          <see cref="T:System.IO.TextWriter" /> 物件，允許自訂輸出至用戶端。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例是 ASP.NET 網頁，其中包含<xref:System.Web.UI.WebControls.TextBox>具有控制其<xref:System.Web.UI.WebControls.TextBox.TextMode%2A>屬性設定為<xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>。 頁面的程式碼會讓使用者在輸入的文字<xref:System.Web.UI.WebControls.TextBox.TextMode%2A>，使用<xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法，以 HTML 編碼，而<xref:System.Web.HttpResponse.Output%2A>屬性，以顯示頁面的編碼的字串。  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>允許二進位輸出至傳出 HTTP 內容主體。</summary>
        <value>IO <see cref="T:System.IO.Stream" />，代表連出 HTTP 內容主體的原始內容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您使用.NET Framework 2.0 版中，從開始<xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法所傳回的 IO 資料流<xref:System.Web.HttpResponse.OutputStream%2A>屬性，下列的例外狀況可能會擲回：  
  
-   <xref:System.ArgumentOutOfRangeException>如果`offset`或是`count`參數是負值或者`buffer`參數的長度減去`offset`參數小於或等於零。  
  
-   <xref:System.ArgumentNullException>如果`buffer`參數是`null`。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Drawing.Image.Save%2A>方法來儲存<xref:System.Drawing.Bitmap>物件到<xref:System.Web.HttpResponse.OutputStream%2A>屬性，並將影像轉換為 JPEG 格式。 程式碼接著會呼叫 Dispose 方法上<xref:System.Drawing.Bitmap>物件和<xref:System.Drawing.Graphics>物件，釋放所佔用的資源。 最後，程式碼會呼叫<xref:System.Web.HttpResponse.Flush%2A>方法以傳送要求的用戶端回應的內容。  
  
 如需完整範例，請參閱<xref:System.Web.HttpResponse>類別。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> 無法使用。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要加入 <see langword="PICS-Label" /> 標頭的字串。</param>
        <summary>附加 HTTP <see langword="PICS-Label" /> 標頭至輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 平台的網際網路內容選取範圍 (PICS) 是用於內容標記的 World Wide Web Consortium (W3C) 標準。 PICS 是基本上是一種語言，建立分級系統。  
  
 任何值可以是 PICS 標籤;ASP.NET 不會驗證標籤。 字串的最大長度為 255 個字元。 如需有關 PICS 標準和語法的詳細資訊，請參閱[World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125)網站。  
  
   
  
## Examples  
 下列範例是顯示影像的 ASP.NET 頁面。 網頁程式碼會呼叫<xref:System.Web.HttpResponse.Pics%2A>方法，以設定 HTTP`PICS-Label`回應標頭。 做為參數傳遞的字串<xref:System.Web.HttpResponse.Pics%2A>方法表示產生的網際網路內容分級關聯 (ICRA) 網站上的評等標籤。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>提升承諾的物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">推播要求的 URL。 其應為伺服器想要推送到用戶端之相對資源的虛擬路徑。</param>
        <summary>此 API 可支援傳送推播確認給 HTTP 2.0 用戶端的應用程式。 您可以在下列網址上，找到更多有關 HTTP2 伺服器推播的詳細資料：<see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see> (HTTP/2 規格 8.2 節：伺服器推播)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise 是不具決定性，應用程式不應該有相依於它的邏輯。 其唯一目的是在某些情況下的效能優勢。 有可能會導致完全忽略推播要求的許多情況 （通訊協定及實作）。 預期根據火災和忘記。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">推播要求的 URL。 其應為伺服器想要推送到用戶端之相對資源的虛擬路徑。</param>
        <param name="method">推播要求要使用的 HTTP 要求方法。</param>
        <param name="headers">推播要求要使用的 HTTP 要求標頭。</param>
        <summary>此 API 可支援傳送推播確認給 HTTP 2.0 用戶端的應用程式。 您可以在下列網址上，找到更多有關 HTTP2 伺服器推播的詳細資料：<see href="https://http2.github.io/http2-spec/#PushResources">HTTP/2 Specification Section 8.2: Server Push</see> (HTTP/2 規格 8.2 節：伺服器推播)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise 是不具決定性，應用程式不應該有相依於它的邏輯。 其唯一目的是在某些情況下的效能優勢。 有可能會導致完全忽略推播要求的許多情況 （通訊協定及實作）。 預期根據火災和忘記。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>重新導向用戶端至新的 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">目標位置。 這可能是應用程式相對虛擬路徑。</param>
        <summary>重新導向要求至新的 URL 並指定新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Web.HttpResponse.Redirect%2A>相當於呼叫<xref:System.Web.HttpResponse.Redirect%2A>第二個參數設定為`true`。  
  
 <xref:System.Web.HttpResponse.Redirect%2A> 呼叫<xref:System.Web.HttpResponse.End%2A>哪一個會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。 這個例外狀況有不利的影響，對 Web 應用程式效能。 因此，我們建議您使用而不是這個多載<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType>多載，並傳遞`false`for`endResponse`參數，然後再呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>方法。 如需詳細資訊，請參閱 <xref:System.Web.HttpResponse.End%2A> 方法。  
  
> [!NOTE]
>  行動頁面，如果您的應用程式依賴無 cookie 工作階段，或可能會接收來自行動裝置需要無 cookie 工作階段的要求，使用波狀符號 (\~) 的路徑可能會導致建立新的工作階段，可能會遺失工作階段資料。 行動控制項的路徑上設定屬性，例如"\~/path"，解析路徑使用<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"\~/path 」 再將它指派給屬性。  
  
 ASP.NET 會藉由傳回 302 HTTP 狀態碼來執行重新導向。 若要將控制權轉移到另一頁的替代方式是<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法是通常更有效率，因為它不會往返造成用戶端。 如需詳細資訊，請參閱 <<c0> [ 如何： 將使用者重新導向至其他頁面](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)。  
  
   
  
## Examples  
 下列範例會強制無條件重新導向到另一個網站。  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">在送出 HTTP 標頭之後嘗試重新導向。</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">目標的位置。</param>
        <param name="endResponse">表示是否應該終止目前網頁的執行。</param>
        <summary>重新導向用戶端至新的 URL。 指定新 URL 和是否應該結束目前網頁的執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 絕對 URL (例如http://www.contoso.com/default.aspx)或相對的 URL (例如 Default.aspx) 可以指定目標位置，但某些瀏覽器可能會拒絕的相對 URL。  
  
 當您使用這個方法的頁面處理常式中結束要求，一頁，並開始新的要求，另一個頁面，設定`endResponse`要`false`，然後呼叫<xref:System.Web.HttpApplication.CompleteRequest%2A>方法。 如果您指定`true`for`endResponse`參數，這個方法會呼叫<xref:System.Web.HttpResponse.End%2A>原始要求，則會擲回方法<xref:System.Threading.ThreadAbortException>完成時的例外狀況。 這個例外狀況有不利的影響，在 Web 應用程式效能，這就是為什麼傳遞`false`針對`endResponse`建議參數。 如需詳細資訊，請參閱 <xref:System.Web.HttpResponse.End%2A> 方法。  
  
> [!NOTE]
>  行動裝置頁面中，如果您的應用程式依賴無 cookie 工作階段，或可能會接收來自行動裝置需要無 cookie 工作階段的要求，使用波狀符號 (\~) 之路徑中可以建立新的工作階段並可能會遺失工作階段資料。 行動控制項的路徑上設定屬性，例如"\~/path"，解析路徑使用<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>"\~/path 」 再將它指派給屬性。  
  
 ASP.NET 會藉由傳回 302 HTTP 狀態碼來執行重新導向。 若要將控制權轉移到另一頁的替代方式是<xref:System.Web.HttpServerUtility.Transfer%2A>方法。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法是通常更有效率，因為它不會往返造成用戶端。 如需詳細資訊，請參閱 <<c0> [ 如何： 將使用者重新導向至其他頁面](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Web.HttpResponse.IsClientConnected%2A>屬性來檢查用戶端所要求的頁面是否仍然連接到伺服器。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 true，程式碼會呼叫<xref:System.Web.HttpResponse.Redirect%2A>方法和用戶端將檢視另一個頁面。 如果<xref:System.Web.HttpResponse.IsClientConnected%2A>為 false，則程式碼會呼叫<xref:System.Web.HttpResponse.End%2A>方法，而所有的頁面處理終止。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 包含新行字元。</exception>
        <exception cref="T:System.Web.HttpException">在送出 HTTP 標頭之後嘗試重新導向。</exception>
        <exception cref="T:System.ApplicationException">頁面要求是回呼的結果。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 Http <see langword="Location" /> 標頭的值。</summary>
        <value>在 HTTP <see langword="Location" /> 標頭中要傳輸至用戶端的絕對 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例示範如何使用這個屬性來指定重新導向 URL，當您在撰寫使用 HTTP 301 回應碼的永久重新導向程式碼。  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">已經寫入 HTTP 標頭。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行從要求之 URL 至指定之 URL 的永久重新導向。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">要求將重新導向至其中的位置。</param>
        <summary>執行從要求之 URL 至指定之 URL 的永久重新導向。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> 301 的 HTTP 狀態碼回應中提供方法多載，並包含重新導向到要求的 URL。 301 的 HTTP 狀態碼為 HTTP 回應中的標準程式碼。 它會指出，存在的永久重新導向，並提供重新導向的位置。  
  
 呼叫<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29>方法多載會結束回應。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 包含新行字元 (<c>\n</c>)。</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">要求將重新導向至其中的位置。</param>
        <param name="endResponse">
          <see langword="true" /> 表示終止回應，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</param>
        <summary>執行從要求之 URL 至指定之 URL 的永久重新導向，並提供完成回應的選項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> 301 的 HTTP 狀態碼回應中提供方法多載，並包含重新導向到要求的 URL。 這個方法多載也會提供選項來指定是否要終止或完成執行重新導向之後的回應。 301 的 HTTP 狀態碼為 HTTP 回應中的標準程式碼。 它會指出，存在的永久重新導向，並提供重新導向的位置。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 包含新行字元 (<c>\n</c>)。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用路由參數值、路由名稱或兩者都使用，將要求重新導向至新的 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會轉換傳入的物件`routeValues`要<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 302 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <summary>使用路由名稱，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會轉換傳入的路由名稱`routeName`url，以使用<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法。  
  
 ASP.NET 會藉由傳回 302 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為路由`Products`。  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法，以判斷 URL。  
  
 ASP.NET 會藉由傳回 302 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值及路由名稱，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會轉換傳入的物件`routeValues`要<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 302 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`且具有名為的參數`productid`和`category`。  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值及路由名稱，將要求重新導向至新的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 302 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`且具有名為的參數`productid`和`category`。  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用路由參數值、路由名稱或兩者都使用，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會轉換傳入的物件`routeValues`要<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <summary>使用路由名稱，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會轉換傳入的路由名稱`routeName`url，以使用<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為路由`Products`。  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法，以判斷 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至具有參數名稱的路由`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值以及對應到新 URL 的路由名稱，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.RedirectPermanent%2A>方法，第二個參數設定為`false`。  
  
 這個方法會轉換傳入的物件`routeValues`要<xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType>物件使用<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>建構函式。 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>然後呼叫方法來決定 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`且具有名為的參數`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">路徑的名稱。</param>
        <param name="routeValues">路由參數值。</param>
        <summary>使用路由參數值及路由名稱，執行永遠從要求的 URL 重新導向至指定的 URL。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供方便撰寫程式碼。 它相當於呼叫<xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29>方法，第二個參數設定為`false`。  
  
 這個方法會呼叫<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>方法，以判斷 URL。  
  
 ASP.NET 會藉由傳回 301 的 HTTP 狀態碼來執行重新導向。  
  
   
  
## Examples  
 下列範例示範如何呼叫這個方法，以重新導向至名為的路由`Product`且具有名為的參數`productid`和`category`。  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有路由對應到指定的路由參數。</exception>
        <exception cref="T:System.Web.HttpException">在 HTTP 標頭送出之後嘗試重新導向。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">ASP.NET 路由</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用預設輸出快取區提供者，從輸出快取區移除快取的項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">從快取中移除之項目的虛擬絕對路徑。</param>
        <summary>從快取移除與預設輸出快取提供者關聯的所有快取項目。 此方法為靜態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法，以移除預設輸出快取提供者相關聯的輸出快取項目。 呼叫<xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A>方法來移除網站組態檔中指定的自訂輸出快取提供者相關聯的輸出快取項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 不是絕對虛擬路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">從快取中移除之項目的虛擬絕對路徑。</param>
        <param name="providerName">提供者，用來移除所有與指定路徑相關聯的輸出快取成品。</param>
        <summary>使用指定的輸出快取提供者，移除所有與指定之路徑關聯的輸出快取項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法來移除網站組態檔中指定的自訂輸出快取提供者相關聯的輸出快取項目。 若要移除預設輸出快取提供者相關聯的輸出快取項目，請呼叫<xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29>方法多載。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是無效路徑。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">集合中要更新的 Cookie。</param>
        <summary>因為 <b>HttpResponse.SetCookie</b> 方法僅供內部使用，所以您不應該在程式碼中呼叫它。 相反地，您可以呼叫 <b>HttpResponse.Cookies.Set</b> 方法，如下列範例所示。<br /> 更新 Cookie 集合中的現有 Cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會更新現有的 cookie 值。  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">嘗試在 HTTP 標頭送出後設定 Cookie。</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>設定傳回至用戶端的 <see langword="Status" /> 行。</summary>
        <value>設定狀態碼會造成描述 HTTP 輸出狀態的字串被傳回至用戶端。 預設值為 200 (OK)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> 已被取代的益處<xref:System.Web.HttpResponse.StatusDescription%2A>和提供是為了與 ASP 的舊版本的相容性。 使用 ASP.NET、<xref:System.Web.HttpResponse.StatusDescription%2A>改。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">狀態被設定為無效狀態碼。</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定傳回至用戶端的輸出之 HTTP 狀態碼。</summary>
        <value>整數，代表傳回至用戶端的 HTTP 輸出的狀態。 預設值為 200 (OK)。 如需有效狀態碼的清單，請參閱 &lt; [Http 狀態碼](https://go.microsoft.com/fwlink/?LinkId=73157)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查輸出資料流的狀態碼。 如果狀態碼不等於 200，則會執行額外的程式碼。  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> 在 HTTP 標頭送出之後被設定。</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定傳回至用戶端的輸出之 HTTP 狀態字串。</summary>
        <value>字串，描述傳回至用戶端的 HTTP 輸出的狀態。 預設值為 [確定]。 如需有效狀態碼的清單，請參閱 &lt; [Http 狀態碼](https://go.microsoft.com/fwlink/?LinkId=73157)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查的狀態字串，輸出資料流。 如果狀態不等於 [確定]，則會執行額外的程式碼。  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> 在 HTTP 標頭送出之後被設定。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">選取的值長度大於 512。</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定的值會評估回應的狀態碼是否合格。</summary>
        <value>整數值，代表 [!INCLUDE[iisver](~/includes/iisver-md.md)] 子狀態碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.SubStatusCode%2A> Integrated 的管線模式僅支援屬性[!INCLUDE[iisver](~/includes/iisver-md.md)]且至少為.NET Framework 3.0 版。 當您設定<xref:System.Web.HttpResponse.SubStatusCode%2A>屬性，狀態會記錄[!INCLUDE[iisver](~/includes/iisver-md.md)]如果設定失敗要求追蹤。 除了追蹤是否設定之外，程式碼永遠不會傳送要求的最後一個回應的一部分。 如需詳細資訊，請參閱 <<c0> [ 疑難排解失敗的要求使用失敗要求追蹤在 IIS 7.0 中](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1)。  
  
   
  
## Examples  
 下列範例會設定<xref:System.Web.HttpResponse.SubStatusCode%2A>屬性中的事件處理常式<xref:System.Web.HttpApplication>的執行個體<xref:System.Web.HttpApplication.PostAuthenticateRequest>事件。 將程式碼檔案放在您的 Web 應用程式的 App_Code 資料夾中，設定 Web.config 檔案來註冊模組。 如需詳細資訊，請參閱 <<c0> [ 逐步解說： 建立及註冊自訂 HTTP 模組](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453)。  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">此作業需要在 [!INCLUDE[iisver](~/includes/iisver-md.md)] 的整合管線模式中，且至少為 .NET Framework 3.0 版。</exception>
        <exception cref="T:System.Web.HttpException">狀態碼是在送出所有 HTTP 標頭之後設定。</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出連接是否支援非同步清除作業。</summary>
        <value>如果連接支援非同步清除作業，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性傳回的值<xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType>屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否送出 HTTP 內容至用戶端。</summary>
        <value>
          <see langword="true" /> 表示要隱藏輸出，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查是否<xref:System.Web.HttpRequest.IsSecureConnection%2A>屬性設定為 false。 如果是，<xref:System.Web.HttpResponse.SuppressContent%2A>屬性設定為 true，以停止傳送回應。  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[在 .NET Framework 4.5.2 及更新版本中支援] 
取得或設定值，這個值表示是否要隱藏目前 HTTP 回應的預設 <c>Cache Control: private</c> 標頭。</summary>
        <value>
          <see langword="true" /> 若要抑制預設<c>Cache Control： 私用</c>目前 HTTP 回應標頭，否則為<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，ASP.NET 會將傳送`Cache-Control: private`回應標頭除非已指定明確的快取原則，這個回應。 這個屬性可讓您隱藏此預設回應標頭，在個別要求基礎上。 標頭仍可為整個應用程式隱藏 splittunneling<xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A>中[httpRuntime 項目 （ASP.NET 設定結構描述）](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369)或[outputCache 項目進行快取 （ASP.NET 設定結構描述）](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 隱藏預設值時請小心`Cache-Control: private`標頭，做為 proxy 和其他媒介可能會視為沒有這個標頭的回應快取預設。 此處理方式可能會導致機密資訊不小心快取。 請參閱[RFC 2616，sec 13.4](http://tools.ietf.org/html/rfc2616)如需詳細資訊。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定是否應該抑制表單驗證重新導向至登入頁面。</summary>
        <value>如果不應執行表單驗證重新導向，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，表單驗證會將 HTTP 401 狀態碼轉換為 302，若要重新導向至登入頁面。 這不是適當特定類別的錯誤，例如當驗證成功，但授權失敗，或當目前的要求是 AJAX 或 web 服務要求。 這個屬性可用來隱藏 重新導向行為，並將原始的狀態碼傳送至用戶端。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定的檔案直接寫入 HTTP 回應輸出資料流，而不在記憶體中緩衝。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出的檔案名稱。</param>
        <summary>將指定的檔案直接寫入 HTTP 回應輸出資料流，而不在記憶體中緩衝。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出的檔案名稱。</param>
        <param name="offset">開始寫入 HTTP 輸出的檔案位置。</param>
        <param name="length">要傳送的位元組數目。</param>
        <summary>將指定的檔案部分直接寫入 HTTP 回應輸出資料流，而不在記憶體中緩衝。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您指定 0 做為`offset`參數，為-1`length`參數，就會傳送整個檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="offset" /> 參數小於零。  
  
\-或- 
<paramref name="length" /> 參數小於 -1。  
  
\-或- 
<paramref name="length" /> 參數指定大於檔案包含之位元組數目減去位移的位元組數目。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支援跨處理序背景工作要求。  
  
\-或- 
回應並未使用 <see cref="T:System.Web.HttpWriter" /> 物件。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 參數小於零或大於檔案大小。  
  
\-或- 
<paramref name="length" /> 參數小於 1，或大於 <paramref name="offset" /> 參數加上檔案大小的值。</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，以指定是否要停用 [!INCLUDE[iisver](~/includes/iisver-md.md)] 自訂錯誤。</summary>
        <value>
          <see langword="true" /> 表示要停用 IIS 自訂錯誤，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>屬性只有在您的應用程式裝載在 IIS 7.0 和更新版本時，才使用。 在傳統模式中執行時<xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>屬性的預設值是`true`。 在整合模式中執行時<xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A>屬性的預設值是`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將資訊寫入 HTTP 回應輸出資料流。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">要傳送至 HTTP 輸出資料流的字元。</param>
        <summary>將字元寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立一系列的 ASP.NET 網頁使用 Write 方法寫入的常數。 程式碼會呼叫這個版本的 Write 方法寫入頁面中的個別字元常數。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要寫入 HTTP 輸出資料流的 <see cref="T:System.Object" />。</param>
        <summary>將 <see cref="T:System.Object" /> 寫入 HTTP 回應資料流。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">要寫入 HTTP 輸出資料流的字串。</param>
        <summary>將字串寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果從用戶端接收或傳送給用戶端時，不會驗證從 Web 用戶端接收的輸入，動態產生的 HTML 網頁會造成安全性風險。 惡意的指令碼會內嵌在輸入送出至網站，並稍後再寫回至用戶端似乎來自受信任的來源。 此安全性風險稱為跨網站指令碼的攻擊。 您應該一律驗證時將從您的網站中傳送至用戶端瀏覽器，從用戶端收到的資料。  
  
 此外，每當您寫出為 HTML 做為輸入收到的任何資料，您應該加以編碼使用的技術，例如<xref:System.Web.HttpServerUtility.HtmlEncode%2A>或<xref:System.Web.HttpServerUtility.UrlEncode%2A>以防止執行惡意指令碼。 這項技術可用於接收時未驗證的資料。  
  
 當您進行編碼，或篩選資料時，您必須指定為您的網頁，讓您的篩選條件可以識別並移除任何的位元組序列不屬於設定 （例如非英數字元的序列），且可能惡意的指令碼中內嵌的字元它們。  
  
 如需跨網站指令碼攻擊的詳細資訊，請參閱文件 Q252985，「 如何以防止跨網站指令碼安全性問題 」 [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?LinkID=37115)網站。  
  
   
  
## Examples  
 下列範例會回應傳回至用戶端的瀏覽器的用戶端的名稱。 <xref:System.Web.HttpServerUtility.HtmlEncode%2A>方法中移除任何惡意指令碼 」 和 「 無效的字元可能會在提交`UserName`輸入的欄位。  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要寫入的字元陣列。</param>
        <param name="index">開始寫入之字元陣列中的位置。</param>
        <param name="count">要寫入的字元數，從 <paramref name="index" /> 開始。</param>
        <summary>將字元的陣列寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立一系列的 ASP.NET 網頁使用 Write 方法寫入的常數。 程式碼會呼叫這個版本的 Write 方法寫入頁面中的個別字元常數。  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定檔案直接寫入 HTTP 回應輸出資料流。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出的檔案名稱。</param>
        <summary>將指定的檔案內容直接寫入 HTTP 回應輸出資料流，做為檔案區塊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會寫入名為文字檔的所有內容`Login.txt`（其中可能包含常值的 HTML 文字和輸入控制項） 直接寫入輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入記憶體區塊的檔案名稱。</param>
        <param name="readIntoMemory">指示檔案將是否被寫入記憶體區塊。</param>
        <summary>將指定的檔案內容直接寫入 HTTP 回應輸出資料流，做為記憶體區塊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會將檔案寫入記憶體。  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">要寫入 HTTP 輸出資料流之檔案的檔案控制代碼 (File Handle)。</param>
        <param name="offset">檔案中開始寫入處的位元組位置。</param>
        <param name="size">要寫入輸出資料流的位元組數目。</param>
        <summary>將指定檔案直接寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會寫入名為文字檔的所有內容`Login.txt`（其中可能包含常值的 HTML 文字和輸入控制項） 直接寫入輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> 小於 0。  
  
\-或- 
 <paramref name="size" /> 大於檔案大小減去 <paramref name="offset" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">要寫入 HTTP 輸出資料流的檔案名稱。</param>
        <param name="offset">檔案中開始寫入處的位元組位置。</param>
        <param name="size">要寫入輸出資料流的位元組數目。</param>
        <summary>將指定檔案直接寫入 HTTP 回應輸出資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當這個方法搭配大型檔案時，呼叫方法可能會擲回例外狀況。 可以搭配此方法之檔案的大小取決於 Web 伺服器的硬體組態。 如需詳細資訊，請參閱文件 812406，< PRB:: Response.WriteFile 無法下載大型檔案 > [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903)網站。  
  
   
  
## Examples  
 下列範例會寫入名為文字檔的所有內容`Login.txt`（其中可能包含常值文字和 HTML 輸入控制項） 直接寫入輸出資料流。  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> 小於 0。  
  
\-或- 
 <paramref name="size" /> 大於檔案大小減去 <paramref name="offset" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">要替代的方法、使用者控制項或物件。</param>
        <summary>允許回應替代區塊插入回應，以便為輸出快取的回應，動態產生指定的回應區域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Web.HttpResponse.WriteSubstitution%2A>進行輸出快取頁面中的快取後替代的方法。 藉由傳遞<xref:System.Web.HttpContext>至回呼方法，使用指定的物件<xref:System.Web.HttpResponseSubstitutionCallback>簽章，您可以將輸出快取在任何給定的位置，在頁面快取內容。 若要起始更換，請呼叫<xref:System.Web.HttpResponse.WriteSubstitution%2A>方法，將它傳遞回呼方法，必須是安全執行緒，而且可以是下列其中一項：  
  
-   在 [容器] 頁面或使用者控制項上的靜態方法。  
  
-   靜態或執行個體上其他的任意物件的方法。  
  
 在頁面上，第一個要求上<xref:System.Web.HttpResponse.WriteSubstitution%2A>呼叫<xref:System.Web.HttpResponseSubstitutionCallback>委派來產生輸出。 然後，將替代緩衝區新增至回應，仍會保留要在未來的要求呼叫的委派。 最後，它會降低用戶端快取功能從公用伺服器專用，以確保未來的要求頁面重新叫用委派不在用戶端上快取。  
  
> [!NOTE]
>  在使用者控制層級的輸出快取套用所在的快取的使用者控制項不支援快取後替代。 這也稱為片段快取。 如需詳細資訊，請參閱 <<c0> [ 快取部分 ASP.NET 網頁](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="callback" /> 參數的目標屬於 <see cref="T:System.Web.UI.Control" /> 類型。</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">設定頁面的快取性</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">快取的 ASP.NET 網頁的部分</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">以動態方式更新快取的頁面上的部分</related>
      </Docs>
    </Member>
  </Members>
</Type>