<Type Name="Animatable" FullName="System.Windows.Media.Animation.Animatable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3deae571239271cf8b76fddd2f4f851c3cee553f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36501184" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Animatable : System.Windows.Freezable, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Animatable extends System.Windows.Freezable implements class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Animatable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Animatable&#xA;Inherits Freezable&#xA;Implements IAnimatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Animatable abstract : System::Windows::Freezable, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type Animatable = class&#xA;    inherit Freezable&#xA;    interface IAnimatable&#xA;    interface DUCE.IResource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Abstract class that provides animation support.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Animatable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Animatable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Media.Animation.Animatable" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Animates the specified <see cref="T:System.Windows.DependencyProperty" /> using the specified <see cref="T:System.Windows.Media.Animation.AnimationClock" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="animatable.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">The property to animate.</param>
        <param name="clock">The clock with which to animate the specified property. If <c>clock</c> is <see langword="null" />, all animations will be removed from the specified property (but not stopped).</param>
        <summary>Applies an <see cref="T:System.Windows.Media.Animation.AnimationClock" /> to the specified <see cref="T:System.Windows.DependencyProperty" />. If the property is already animated, the <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> handoff behavior is used.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，使用此方法，從屬性移除時鐘時，不會停止這些時鐘。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="animatable.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">The property to animate.</param>
        <param name="clock">The clock with which to animate the specified property. If <c>handoffBehavior</c> is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> and <c>clock</c> is <see langword="null" />, all animations will be removed from the specified property (but not stopped). If <c>handoffBehavior</c> is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" /> and clock is <see langword="null" />, this method has no effect.</param>
        <param name="handoffBehavior">A value that specifies how the new animation should interact with any current animations already affecting the property value.</param>
        <summary>Applies an <see cref="T:System.Windows.Media.Animation.AnimationClock" /> to the specified <see cref="T:System.Windows.DependencyProperty" />. If the property is already animated, the specified <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> is used.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，使用此方法來從屬性移除時鐘時，不會停止這些時鐘。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰寫 HandoffBehavior  
 當您將套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統將不會自動移除這些時鐘。  
  
 若要避免發生效能問題，當您套用大量使用時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。 有幾個方式可移除時鐘。  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這將會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>時鐘的清單，從使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會呼叫事件。  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  記憶體回收物件時，也會中斷連接並記憶體回收其時鐘。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
   
  
## Examples  
 下列範例示範如何套用使用不同的動畫時鐘<xref:System.Windows.Media.Animation.HandoffBehavior>設定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Applies an animation to the specified <see cref="T:System.Windows.DependencyProperty" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="animatable.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">The property to animate.</param>
        <param name="animation">The animation used to animate the specified property.  If the animation's <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> is <see langword="null" />, any current animations will be removed and the current value of the property will be held.  If <c>animation</c> is <see langword="null" />, all animations will be removed from the property and the property value will revert back to its base value.</param>
        <summary>Applies an animation to the specified <see cref="T:System.Windows.DependencyProperty" />. The animation is started when the next frame is rendered. If the specified property is already animated, the <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> handoff behavior is used.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果動畫的<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>小於或等於零，動畫開始後從下一個畫面格呈現時間經過的時間量。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="animatable.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">The property to animate.</param>
        <param name="animation">The animation used to animate the specified property.  If <c>handoffBehavior</c> is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> and the animation's <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> is <see langword="null" />, any current animations will be removed and the current value of the property will be held.  If <c>handoffBehavior</c> is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> and <c>animation</c> is a <see langword="null" /> reference, all animations will be removed from the property and the property value will revert back to its base value.  If <c>handoffBehavior</c> is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" />, this method will have no effect if the animation or its <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> is <see langword="null" />.</param>
        <param name="handoffBehavior">A value that specifies how the new animation should interact with any current animations already affecting the property value.</param>
        <summary>Applies an animation to the specified <see cref="T:System.Windows.DependencyProperty" />. The animation is started when the next frame is rendered. If the specified property is already animated, the specified <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> is used.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果動畫的<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>小於或等於零，動畫開始後從下一個畫面格呈現時間經過的時間量。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用撰寫 HandoffBehavior  
 當您將套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統將不會自動移除這些時鐘。  
  
 若要避免發生效能問題，當您套用大量使用時鐘<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。 有幾個方式可移除時鐘。  
  
-   若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這將會從屬性移除所有動畫時鐘。  
  
-   若要移除特定<xref:System.Windows.Media.Animation.AnimationClock>時鐘的清單，從使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會呼叫事件。  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 這主要是在存留期較長的物件才會發生的動畫問題。  記憶體回收物件時，也會中斷連接並記憶體回收其時鐘。  
  
 如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
   
  
## Examples  
 下列範例示範如何將使用不同的動畫套用<xref:System.Windows.Media.Animation.HandoffBehavior>設定。  
  
 [!code-cpp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/cpp/VS_Snippets_Wpf/animateproperty/CPP/InteractiveExample.cpp#interactiveanimationexamplewholepage)]
 [!code-csharp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animateproperty/CSharp/InteractiveExample.cs#interactiveanimationexamplewholepage)]
 [!code-vb[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateproperty/VisualBasic/InteractiveExample.vb#interactiveanimationexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Animatable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Animatable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Animatable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Animatable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Media.Animation.Animatable" Usage="animatable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Animatable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone of this <see cref="T:System.Windows.Media.Animation.Animatable" />, making deep copies of this object's values. When copying this object's dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.</summary>
        <returns>A modifiable clone of this instance. The returned clone is effectively a deep copy of the current object. The clone's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is **false**.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Animatable.Clone%2A>方法可以用來產生的可修改複本凍結<xref:System.Windows.Freezable>物件。 為了方便起見，這個方法會遮蔽繼承<xref:System.Windows.Freezable.Clone%2A>方法以提供強類型的實作。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="animatable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> if this method should simply determine whether this instance can be frozen. <see langword="false" /> if this instance should actually freeze itself when this method is called.</param>
        <summary>Makes this <see cref="T:System.Windows.Media.Animation.Animatable" /> object unmodifiable or determines whether it can be made unmodifiable.</summary>
        <returns>If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if this <see cref="T:System.Windows.Media.Animation.Animatable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.  If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if this <see cref="T:System.Windows.Media.Animation.Animatable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable, with the side effect of having begun to change the frozen status of this object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回**false**時<xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A>是**true**。  
  
 請勿呼叫這個方法，直接 （只是呼叫基底實作中）。 這個方法在內部呼叫<xref:System.Windows.Freezable.CanFreeze%2A>(與`isChecking`等於`true`) 和<xref:System.Windows.Freezable.Freeze%2A>(與`isChecking`等於`false`)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>類別衍生自<see cref="T:System.Windows.Media.Animation.Animatable" />類別包含不會儲存使用相依性屬性的資料時，必須覆寫這個方法。一般的實作會呼叫基底實作，然後可以呼叫靜態<see cref="M:System.Windows.Freezable.Freeze" />上所有的方法<see cref="T:System.Windows.Freezable" />型別的屬性，其中包含類別，傳回<see langword="true" />才凍結所有屬性 (或可能已都凍結，請在案例通過<see langword="false" />值<paramref name="isChecking" />)。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="animatable.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identifies the property whose base (non-animated) value should be retrieved.</param>
        <summary>Returns the non-animated value of the specified <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>The value that would be returned if the specified property were not animated.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的屬性不會顯示動畫，這個方法會傳回相同結果<xref:System.Windows.DependencyObject.GetValue%2A>。  
  
   
  
## Examples  
 下列範例中，會擷取和顯示動畫屬性的非動畫值。  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalueexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalueexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Animatable.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.Media.Animation.Animatable.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether one or more <see cref="T:System.Windows.Media.Animation.AnimationClock" /> objects is associated with any of this object's dependency properties.</summary>
        <value>* * true * * 如果一或多個<see cref="T:System.Windows.Media.Animation.AnimationClock" />物件已有此物件的相依性屬性的任何相關聯，否則，* * false * *。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性不會指出這個物件是否包含動畫子物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStoredWeakReference">
      <MemberSignature Language="C#" Value="public static bool ShouldSerializeStoredWeakReference (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ShouldSerializeStoredWeakReference(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ShouldSerializeStoredWeakReference (target As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ShouldSerializeStoredWeakReference(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ShouldSerializeStoredWeakReference : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Represents an object that participates in the dependency property system.</param>
        <summary>Specifies whether a dependency object should be serialized.</summary>
        <returns>
          <see langword="true" /> to serialize <paramref name="target" />; otherwise, <see langword="false" />. The default is <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.TypeDescriptor>類別會使用<xref:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference%2A>方法，以判斷是否應該序列化屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>