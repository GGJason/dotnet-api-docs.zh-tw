<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LogRecordSequence.xml" source-language="en-US" target-language="zh-TW">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5330d85d921807042238a6dbb6d100c3f96cc1899.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">330d85d921807042238a6dbb6d100c3f96cc1899</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Represents a record sequence stored in a <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">表示 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 中儲存的記錄順序。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 類別會在一般記錄檔系統 (CLFS) 記錄頂端提供記錄順序介面實作。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</source>
          <target state="translated">除了標準的記錄導向功能之外，它還提供了一個原則模型，可用來避免記錄檔已滿狀況，以及在同一實體檔案上進行用戶端多工。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>It works with the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class, which provides an interface for directly manipulating and managing a CLFS log file.</source>
          <target state="translated">它會搭配使用 <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> 類別，這個類別會提供用來直接操作和管理 CLFS 記錄檔的介面。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The relationship between the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class and the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class is similar to the relationship between a disk file and a <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> 類別與 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 類別的關係就如同磁碟檔案與 <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> 物件的關係。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The disk file provides the concrete storage, and has attributes such as length and last access time; while the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object provides a view on the file that can be used to read from it and write to it.</source>
          <target state="translated">磁碟檔案提供實際的儲存區且具有「長度」和「上次存取時間」等屬性，而 <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> 物件則提供檔案的檢視，可用來讀取和寫入檔案。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> class has attributes like a policy and a collection of disk extents; and the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class provides a record-oriented mechanism for reading and writing data.</source>
          <target state="translated">同樣地，<ph id="ph1">&lt;xref:System.IO.Log.LogStore&gt;</ph> 類別也具有原則和延伸磁碟區集合等屬性；而 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 類別則會提供用來讀取和寫入資料的記錄導向機制。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class:</source>
          <target state="translated">這個範例會說明如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 類別：</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that this record sequence should use.</source>
          <target state="translated">這個記錄順序應該使用的 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with the specified log store.</source>
          <target state="translated">使用指定的記錄存放區，初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">緩衝區大小決定了可以附加或讀取的記錄大小上限。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>In this constructor, a default value of 64 is set.</source>
          <target state="translated">在這個建構函式中，會設為預設值 64。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source>The desired number of buffers is set to 10.</source>
          <target state="translated">需要的緩衝區數量設為 10。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)">
          <source><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要開啟之記錄存放區基底檔案的相對或絕對路徑。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值，可決定如何開啟或建立存放區。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access mode.</source>
          <target state="translated">使用指定的記錄存放區路徑和存取模式，初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path and mode.</source>
          <target state="translated">這個建構函式會在新的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 物件上初始化新的 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>，而這個物件是以指定的路徑和模式所開啟的。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>It is given read/write access to the store, and the store is opened sharing Read access.</source>
          <target state="translated">會給予存放區的讀取/寫入權限，並且會開啟存放區的共用讀取權限。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為空字串 ("")。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 僅包含泛空白字元。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一或多個無效的字元。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含無效的值。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>The file cannot be found.</source>
          <target state="translated">找不到檔案。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">開啟記錄存放區時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>This operation is not supported.</source>
          <target state="translated">不支援此作業。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 類別。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that this record sequence should use.</source>
          <target state="translated">這個記錄順序應該使用的 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">需要的緩衝區大小 (以位元組為單位)。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">緩衝區大小決定了可以附加或讀取的記錄大小上限。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>The desired number of buffers.</source>
          <target state="translated">需要的緩衝區數量。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with the specified log store, buffer size for each record, and buffer number.</source>
          <target state="translated">使用指定的記錄存放區、每個記錄的緩衝區大小和緩衝區數目，初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>Use this constructor if you want to specify values for <ph id="ph1">`bufferSize`</ph> and <ph id="ph2">`bufferCount`</ph> and do not want to use the default value of 64 for <ph id="ph3">`bufferSize`</ph> and 10 for <ph id="ph4">`bufferCount`</ph>.</source>
          <target state="translated">如果您想要指定 <ph id="ph1">`bufferSize`</ph> 和 <ph id="ph2">`bufferCount`</ph> 值，而且不想使用 <ph id="ph3">`bufferSize`</ph> 的預設值 64 和 <ph id="ph4">`bufferCount`</ph> 的預設值 10，可以使用這個建構函式。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logStore" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> 為負值或零。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferCount" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferCount" /&gt;</ph> 為負值或零。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要開啟之記錄存放區基底檔案的相對或絕對路徑。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值，可決定如何開啟或建立存放區。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 值，可決定 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 可以如何存取檔案。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access and share modes.</source>
          <target state="translated">使用指定的記錄存放區路徑以及存取和共用模式，初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">這個建構函式 (Constructor) 會在新的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 物件上初始化新的 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>，而這個物件是以指定的路徑、模式和存取權限所開啟的。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The store is opened sharing Read access.</source>
          <target state="translated">存放區便會開啟，並且共用讀取權限。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為空字串 ("")。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 僅包含泛空白字元。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一或多個無效的字元。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含無效的值。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file cannot be found.</source>
          <target state="translated">找不到檔案。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">開啟記錄存放區時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This operation is not supported.</source>
          <target state="translated">不支援此作業。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 類別。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要開啟之記錄存放區基底檔案的相對或絕對路徑。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值，可決定如何開啟或建立存放區。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 值，可決定 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 可以如何存取檔案。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> values that determines how the log store will be shared among processes.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> 值，可決定在處理序之間共用記錄存放區的方式。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store and the access mode.</source>
          <target state="translated">使用指定的記錄存放區路徑和存取模式，初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">這個建構函式 (Constructor) 會在新的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 物件上初始化新的 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>，而這個物件是以指定的路徑、模式和存取權限所開啟的。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">存放區會開啟，並且共用指定的存取權限。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This example shows how to use this <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> constructor:</source>
          <target state="translated">這個範例會說明如何使用這個 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 建構函式：</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為空字串 ("")。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 僅包含泛空白字元。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一或多個無效的字元。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含無效的值。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file cannot be found.</source>
          <target state="translated">找不到檔案。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">開啟記錄存放區時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This operation is not supported.</source>
          <target state="translated">不支援此作業。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 類別。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要開啟之記錄存放區基底檔案的相對或絕對路徑。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> values that determines how to open or create the store.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值，可決定如何開啟或建立存放區。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values that determines how the file can be accessed by the <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 值，可決定 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> 可以如何存取檔案。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> values that determines how the log store will be shared among processes.</source>
          <target state="translated">其中一個 <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> 值，可決定在處理序之間共用記錄存放區的方式。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">需要的緩衝區大小 (以位元組為單位)。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">緩衝區大小決定了可以附加或讀取的記錄大小上限。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The desired number of buffers.</source>
          <target state="translated">需要的緩衝區數量。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</source>
          <target state="translated">使用指定的記錄存放區路徑、檔案權限、存取與共用模式，以及緩衝區大小和記錄計數，初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>This constructor initializes a new <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> on a new <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph> object that it opens with the specified path, mode, and access.</source>
          <target state="translated">這個建構函式 (Constructor) 會在新的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 物件上初始化新的 <ph id="ph2">&lt;xref:System.IO.Log.LogStore&gt;</ph>，而這個物件是以指定的路徑、模式和存取權限所開啟的。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The store is opened sharing the specified access.</source>
          <target state="translated">存放區會開啟，並且共用指定的存取權限。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 為空字串 ("")。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains only white space.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 僅包含泛空白字元。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 包含一或多個無效的字元。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 包含無效的值。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>The file cannot be found.</source>
          <target state="translated">找不到檔案。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>An I/O error occurs when opening the log store.</source>
          <target state="translated">開啟記錄存放區時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>This operation is not supported.</source>
          <target state="translated">不支援此作業。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 類別。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A relative or absolute path for the base file of the log store to open.</source>
          <target state="translated">要開啟之記錄存放區基底檔案的相對或絕對路徑。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> value that determines how to open or create the store.</source>
          <target state="translated">有效的 <ph id="ph1">&lt;see cref="T:System.IO.FileMode" /&gt;</ph> 值，其決定如何開啟或建立存放區。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> value that determines how the log store can be accessed.</source>
          <target state="translated">有效的 <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> 值，決定如何存取記錄存放區。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> value that determines how the log store will be shared among processes.</source>
          <target state="translated">有效的 <ph id="ph1">&lt;see cref="T:System.IO.FileShare" /&gt;</ph> 值，可決定在處理序之間共用記錄存放區的方式。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The desired buffer size in bytes.</source>
          <target state="translated">需要的緩衝區大小 (以位元組為單位)。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The buffer size determines the maximum size of the record that can be appended or read.</source>
          <target state="translated">緩衝區大小決定了可以附加或讀取的記錄大小上限。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The desired number of buffers.</source>
          <target state="translated">需要的緩衝區數量。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> value that specifies the security to set on the newly created store if the store must be created.</source>
          <target state="translated">有效的 <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> 值，可指定要針對新建立的存放區設定的安全性 (如果必須建立存放區的話)。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 類別的新執行個體。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 指定的檔案無效。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The specified log store file name is not valid.</source>
          <target state="translated">指定的記錄存放區檔案名稱無效。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> has a value of <ph id="ph2">&lt;see cref="F:System.IO.FileMode.CreateNew" /&gt;</ph>, and cannot be used without write access.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 具有 <ph id="ph2">&lt;see cref="F:System.IO.FileMode.CreateNew" /&gt;</ph> 的值，而且無法在沒有寫入權限的情況下使用。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> has a value of <ph id="ph2">&lt;see cref="F:System.IO.FileMode.OpenOrCreate" /&gt;</ph>, and cannot be used without write access.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> 具有 <ph id="ph2">&lt;see cref="F:System.IO.FileMode.OpenOrCreate" /&gt;</ph> 的值，而且無法在沒有寫入權限的情況下使用。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>One or more of the arguments are out of range.</source>
          <target state="translated">一或多個引數超出範圍。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be found.</source>
          <target state="translated">找不到 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 指定的檔案。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be accessed because it is in use by another process.</source>
          <target state="translated">因為另一個處理序正在使用 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 所指定的檔案，所以無法存取該檔案。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The file specified by <ph id="ph1">&lt;paramref name="path" /&gt;</ph> cannot be created because the file or directory already exists.</source>
          <target state="translated">因為檔案或目錄已存在，所以無法建立 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 所指定的檔案。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The log handle could not be bound to the thread pool.</source>
          <target state="translated">記錄檔控制代碼無法繫結至執行緒集區。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的記錄檔格式或版本無效。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>This operation is not supported.</source>
          <target state="translated">不支援此作業。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> cannot be used because the required Common Log File System (CLFS) component is not installed.</source>
          <target state="translated">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Install the CLFS component if it is available for your platform, or use the <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> class.</source>
          <target state="translated">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <ph id="ph1">&lt;see cref="T:System.IO.Log.FileRecordSequence" /&gt;</ph> 類別。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Specifies the new base <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> for the log.</source>
          <target state="translated">指定記錄的新基底 <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</source>
          <target state="translated">必須介於記錄的目前基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Moves the base sequence number of the log forward.</source>
          <target state="translated">將記錄檔的基底序號往前移動。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This method is often used with the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free up space in a record.</source>
          <target state="translated">這個方法通常與 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件搭配使用，以釋放記錄中的空間。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件表示，必須將順序的結尾 (即基底序號) 往前移動才能釋放空間。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Freeing space can be done by either writing restart areas using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method, or truncating the log and using the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method to advance the base sequence number of a log to the one specified by the <ph id="ph3">`newBaseSequenceNumber`</ph> parameter.</source>
          <target state="translated">使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> 方法寫入重新啟動區域，或是截斷記錄並使用 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法將記錄基底序號依照 <ph id="ph3">`newBaseSequenceNumber`</ph> 參數所指定的往前移一個號碼，都可以達到釋放空間的目的。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">＜範例＞一節中，程式碼範例會示範其第二種處理方式。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Note that calling this method is the same as setting a new base sequence number using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method, except that no restart record is written to the log.</source>
          <target state="translated">請注意，呼叫這個方法與使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> 方法設定新基底序號的效果一樣，都不會在記錄中寫入重新啟動記錄。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free up space in a log sequence.</source>
          <target state="translated">這個範例將示範如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法搭配 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件來釋放記錄順序中的空間。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">新的或現有封存結尾或作用中記錄的基底無效。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSequenceNumber" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的記錄沒有任何延伸區。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>One or more extents must be created before a record sequence may be used.</source>
          <target state="translated">必須先建立一或多個延伸區，才能使用記錄順序。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">將記錄寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> member</source>
          <target state="translated">這個範例會說明如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> 成員。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Writes a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">將記錄寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The following example demonstrates how to use this method to append a log record to the sequence.</source>
          <target state="translated">下列範例將示範如何使用這個方法，將記錄附加到順序。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>.</source>
          <target state="translated">將記錄附加到 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含這筆記錄所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">使用之前在順序中保留的空間，將記錄附加到 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">附加的記錄將會使用 <ph id="ph1">`reservations`</ph> 參數指定的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 找不到有足夠空間可以容納 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留區。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含這筆記錄所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Appends a log record to the <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>, using space previously reserved in the sequence.</source>
          <target state="translated">使用之前在順序中保留的空間，將記錄附加到 <ph id="ph1">&lt;see cref="T:System.IO.Log.IRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">附加的記錄將會使用 <ph id="ph1">`reservations`</ph> 參數指定的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.IRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 找不到有足夠空間可以容納 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留區。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>Gets the sequence number of the first valid record in the current <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">取得目前 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>中第一個有效記錄的序號。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The lowest sequence number that corresponds to a valid record in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">對應至 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中之有效記錄的最小序號。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">有效的序號會大於或等於 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph>，而且小於 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The value of this property can be changed by calling the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method.</source>
          <target state="translated">這個屬性的值可藉由呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A&gt;</ph> 方法或 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法加以變更。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> member in a loop.</source>
          <target state="translated">這個範例會說明如何使用迴圈中的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> 成員。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後存取此屬性。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">開始執行非同步的附加作業。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">選擇性的非同步回呼，在附加完成時呼叫。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">開始執行非同步的附加作業。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的非同步附加作業。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">選擇性的非同步回呼，在附加完成時呼叫。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">開始執行非同步的附加作業。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的非同步附加作業。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含這筆記錄所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">選擇性的非同步回呼，在附加完成時呼叫。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">開始執行非同步的附加作業。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的非同步附加作業。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">附加的記錄將會使用 <ph id="ph1">`reservations`</ph> 參數指定的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 找不到有足夠空間可以容納 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留區。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this record.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含這筆記錄所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">選擇性的非同步回呼，在附加完成時呼叫。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous append operation.</source>
          <target state="translated">開始執行非同步的附加作業。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous append, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的非同步附加作業。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The appended record will consume space that has been previously reserved, using a reservation specified by the <ph id="ph1">`reservations`</ph> parameter.</source>
          <target state="translated">附加的記錄將會使用 <ph id="ph1">`reservations`</ph> 參數指定的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</source>
          <target state="translated">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Normally, this method completes before the record has been written.</source>
          <target state="translated">此方法通常會在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 找不到有足夠空間可以容納 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留區。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">必須寫入之最新記錄的序號。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">如果這個 <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> 無效，則必須寫入所有的記錄。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the flush is complete.</source>
          <target state="translated">選擇性的非同步回呼，在清除完成時呼叫。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous flush request from other requests.</source>
          <target state="translated">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步清除的要求。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous flush operation, using space previously reserved in the sequence.</source>
          <target state="translated">使用先前保留在順序中的空間，開始執行非同步的清除作業。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous flush operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的非同步清除作業。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the current method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method to ensure that the flush completes and resources are freed appropriately.</source>
          <target state="translated">您應該將目前方法傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 方法，以確保清除完成，並適當釋放資源。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If an error occurs during an asynchronous flush, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步清除期間發生錯誤，則必須在使用這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法後才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> are durably written.</source>
          <target state="translated">呼叫這個方法可以確保已永久寫入附加到 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 的所有記錄。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步清除要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤)，會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的記錄沒有任何延伸區。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">必須先建立一或多個延伸區，才能使用記錄順序。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">開始執行非同步的保留和附加作業。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">要在其中建立保留區的保留區集合。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要建立的保留區 (以位元組為單位)。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">選擇性的非同步回呼，在附加完成時呼叫。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">開始執行非同步的保留和附加作業。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的這項非同步作業。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果附加失敗，就不會保留任何空間。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">這個方法通常可以在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 找不到有足夠空間可以容納 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留區。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">要在其中建立保留區的保留區集合。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要建立的保留區 (以位元組為單位)。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the append is complete.</source>
          <target state="translated">選擇性的非同步回呼，在附加完成時呼叫。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous append request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous reserve and append operation.</source>
          <target state="translated">開始執行非同步的保留和附加作業。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents this asynchronous operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的這項非同步作業。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method to ensure that the append operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous append, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果附加失敗，就不會保留任何空間。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">這個方法通常可以在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一或多個引數無效。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">附加記錄時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的記錄或建立保留區。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Begins an asynchronous restart area write operation.</source>
          <target state="translated">開始執行非同步的重新啟動區域寫入作業。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄的位元組陣列區段。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基底序號。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序號必須大於或等於目前基底序號。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含此重新啟動區域所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">選擇性的非同步回呼 (Callback)，在重新啟動區域寫入完成時呼叫。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步重新啟動區域寫入要求與其他要求。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">使用先前保留在順序中的空間，開始執行非同步的重新啟用區域寫入作業。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的非同步重新啟動區域寫入作業。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步重新啟動區域寫入作業期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">當這個作業成功完成時，基底序號已經更新。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">只要是序號小於新基底序號的所有記錄都無法存取。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果已指定 <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果此方法成功，便會取用可以保存資料的最小保留區，而且該保留區將會從集合移除。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">指定的記錄列舉起始序號無效。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservation" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservation" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個參數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">新的或現有封存結尾或作用中記錄的基底無效。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基底序號。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序號必須大於或等於目前基底序號。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含此重新啟動區域所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the restart area write is complete.</source>
          <target state="translated">選擇性的非同步回呼 (Callback)，在重新啟動區域寫入完成時呼叫。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</source>
          <target state="translated">使用者所提供的物件，可區別此特定非同步重新啟動區域寫入要求與其他要求。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</source>
          <target state="translated">使用先前保留在順序中的空間，開始執行非同步的重新啟用區域寫入作業。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that represents the asynchronous restart area write operation, which could still be pending.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>，表示可能還在暫止中的非同步重新啟動區域寫入作業。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>You should pass the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method to the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</source>
          <target state="translated">您應該將這個方法所傳回的 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 傳遞給 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called with the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> returned by this method.</source>
          <target state="translated">如果在非同步重新啟動區域寫入作業期間發生錯誤，就要等到系統以這個方法傳回的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 呼叫 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> 方法時，才會擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>When the operation successfully completes, the base sequence number has been updated.</source>
          <target state="translated">當這個作業成功完成時，基底序號已經更新。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">只要是序號小於新基底序號的所有記錄都無法存取。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果已指定 <ph id="ph1">&lt;xref:System.IO.Log.ReservationCollection&gt;</ph>，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果此方法成功，便會取用可以保存資料的最小保留區，而且該保留區將會從集合移除。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">指定的記錄列舉起始序號無效。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個參數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">新的或現有封存結尾或作用中記錄的基底無效。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">建立新的 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>The newly created <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>.</source>
          <target state="translated">新建立的 <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Reservations can be performed in two ways as shown in the following examples.</source>
          <target state="translated">您可以透過兩種方式執行保留，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>You can adopt the practices in the samples for robust processing.</source>
          <target state="translated">您可以採用範例中的做法進行穩固的處理。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>Notice that this task can only be performed when using the CLFS-based <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class.</source>
          <target state="translated">請注意，您只能在使用 CLFS 的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 類別時執行這項工作。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.CreateReservationCollection">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>Releases the resources used by the component.</source>
          <target state="translated">釋放由元件使用的資源。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>This example shows how to use <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Dispose%2A&gt;</ph> to release resources:</source>
          <target state="translated">這個範例示範如何使用<ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.Dispose%2A&gt;</ph>釋放資源：</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Dispose">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">未處理的非同步 I/O 要求的參考。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Ends an asynchronous append operation.</source>
          <target state="translated">結束執行非同步的附加作業。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">這個方法會封鎖，直到 I/O 作業完成為止。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">在非同步寫入要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndAppend%2A&gt;</ph> 時顯示出來。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt;</ph> method.</source>
          <target state="translated">在 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法傳回的每一個 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginAppend%2A&gt;</ph> 上必須剛好呼叫這個方法一次。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已經針對此非同步作業呼叫 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">未處理的非同步 I/O 要求的參考。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Ends an asynchronous flush operation.</source>
          <target state="translated">結束執行非同步的清除作業。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">上一筆寫入之記錄的序號。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">這個方法會封鎖，直到 I/O 作業完成為止。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> is called.</source>
          <target state="translated">在非同步清除要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndFlush%2A&gt;</ph> 時顯示出來。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt;</ph> method.</source>
          <target state="translated">在 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法傳回的每一個 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginFlush%2A&gt;</ph> 上必須剛好呼叫這個方法一次。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已經針對此非同步作業呼叫 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">未處理的非同步 I/O 要求的參考。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Ends an asynchronous reserve and append operation.</source>
          <target state="translated">結束執行非同步的保留和附加作業。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">這個方法會封鎖，直到 I/O 作業完成為止。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> is called.</source>
          <target state="translated">在非同步寫入要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 時顯示出來。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt;</ph> method.</source>
          <target state="translated">在 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法傳回的每一個 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A&gt;</ph> 上必須剛好呼叫這個方法一次。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已經針對此非同步作業呼叫 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>A reference to the outstanding asynchronous I/O request.</source>
          <target state="translated">未處理的非同步 I/O 要求的參考。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Ends an asynchronous restart area write operation.</source>
          <target state="translated">結束執行非同步的重新啟動區域寫入作業。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The sequence number of the written log record.</source>
          <target state="translated">已寫入之記錄的序號。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method blocks until the I/O operation has completed.</source>
          <target state="translated">這個方法會封鎖，直到 I/O 作業完成為止。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> is called.</source>
          <target state="translated">在非同步寫入要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A&gt;</ph> 時顯示出來。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>This method must be called exactly once on every <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt;</ph> method.</source>
          <target state="translated">在 <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> 方法傳回的每一個 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A&gt;</ph> 上必須剛好呼叫這個方法一次。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="result" /&gt;</ph> is not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="result" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">新的或現有封存結尾或作用中記錄的基底無效。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see langword="End" /&gt;</ph> has already been called for this asynchronous operation.</source>
          <target state="translated">已經針對此非同步作業呼叫 <ph id="ph1">&lt;see langword="End" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes appended records durably</source>
          <target state="translated">永久地寫入附加的記錄</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Ensures that all appended records have been written.</source>
          <target state="translated">確定已寫入所有附加的記錄。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The sequence number of the last record written.</source>
          <target state="translated">上一筆寫入之記錄的序號。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Calling this method ensures that all records that have been appended to the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> have been durably written.</source>
          <target state="translated">呼叫這個方法可以確保已永久寫入附加到 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph>的所有記錄。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>An I/O error occurred while flushing the data.</source>
          <target state="translated">清除資料時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>This operation is not supported.</source>
          <target state="translated">不支援此作業。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的記錄沒有任何延伸區。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">必須先建立一或多個延伸區，才能使用記錄順序。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the latest record that must be written.</source>
          <target state="translated">必須寫入之最新記錄的序號。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>If this <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> is invalid, then all records must be written.</source>
          <target state="translated">如果這個 <ph id="ph1">&lt;see cref="T:System.IO.Log.SequenceNumber" /&gt;</ph> 無效，則必須寫入所有的記錄。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</source>
          <target state="translated">確保已將內含指定序號的所有附加記錄永久寫入。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The sequence number of the last record written.</source>
          <target state="translated">上一筆寫入之記錄的序號。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</source>
          <target state="translated">呼叫這個方法可以確保已將內含指定序號的所有記錄永久寫入。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The specified log does not have any extents.</source>
          <target state="translated">指定的記錄沒有任何延伸區。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>One or more extents must be created before a record sequence can be used.</source>
          <target state="translated">必須先建立一或多個延伸區，才能使用記錄順序。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>Gets the sequence number which is greater than the last record appended</source>
          <target state="translated">取得大於上一筆附加記錄的序號</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>A sequence number which is greater than the last record appended.</source>
          <target state="translated">大於上一筆附加記錄的序號。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</source>
          <target state="translated">這個屬性包含保證大於上一個附加記錄之序號的序號。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>Valid sequence numbers are greater than or equal to <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph> and less than <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>.</source>
          <target state="translated">有效的序號會大於或等於 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A&gt;</ph>，而且小於 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>All other sequence numbers are invalid.</source>
          <target state="translated">其他所有序號全都無效。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LastSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後存取此屬性。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that contains the data for this record sequence.</source>
          <target state="translated">取得 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>，包含這個記錄順序的資料。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph> that contains the data for this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.LogStore" /&gt;</ph>，包含這個記錄順序的資料。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.LogStore">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.LogStore%2A&gt;</ph> member to add extents.</source>
          <target state="translated">這個範例會示範如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.LogStore%2A&gt;</ph> 成員來新增延伸區。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.MaximumRecordLength">
          <source>Gets the maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">取得可以新增至這個記錄順序的記錄大小上限。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.MaximumRecordLength">
          <source>The maximum size of a record that can be added to this record sequence.</source>
          <target state="translated">可以新增至這個記錄順序的記錄大小上限。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The sequence number of the first record where the reading starts.</source>
          <target state="translated">開始讀取之第一筆記錄的序號。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>A valid <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> value that specifies the manner (that is, forward or backward) in which records should be read from a <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordEnumeratorType" /&gt;</ph> 的有效值，其中指定從 <ph id="ph2">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 讀取記錄的方式 (即往前或往後讀取)。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>Returns an enumerable collection of records in the sequence.</source>
          <target state="translated">傳回順序中之記錄的可列舉集合。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>An enumerable collection of records in the sequence.</source>
          <target state="translated">順序中的記錄的可列舉集合。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This method returns an enumerable collection of records in the sequence.</source>
          <target state="translated">這個方法會傳回順序中之記錄的可列舉集合。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The order of the enumerated records depends on the value of the <ph id="ph1">`logRecordEnum`</ph> parameter.</source>
          <target state="translated">列舉的記錄順序取決於 <ph id="ph1">`logRecordEnum`</ph> 參數的值。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>This example shows how to use <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A&gt;</ph> in a loop.</source>
          <target state="translated">這個範例會說明如何在迴圈中使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="logRecordEnum" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="logRecordEnum" /&gt;</ph> 無效。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The specified element was not found in the collection.</source>
          <target state="translated">在集合中找不到特定的項目。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">用來寫入記錄的緩衝區大小，大於用來讀取記錄的緩衝區大小。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The record sequence is corrupted.</source>
          <target state="translated">記錄順序已損毀。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的記錄檔格式或版本無效。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">記錄是以不相容的記錄順序版本所寫入。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">因為列舉尚未啟動，因此作業無效。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>A call to <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph> must be made.</source>
          <target state="translated">必須呼叫 <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Returns an enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">傳回序列中重新啟動區域的可列舉集合。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>An enumerable collection of the restart areas in the sequence.</source>
          <target state="translated">順序中的重新啟動區域的可列舉集合。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</source>
          <target state="translated">列舉重新啟動區域的方式是依照序號的相反順序列舉，也就是由最大序號到最小序號。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</source>
          <target state="translated">只會列舉含有介於最後一個序號和基底序號之間序號的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source><ph id="ph1">&lt;paramref name="start" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="start" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The buffer size used to write the log record is larger than the buffer size being used to read it.</source>
          <target state="translated">用來寫入記錄的緩衝區大小，大於用來讀取記錄的緩衝區大小。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The record sequence is corrupted.</source>
          <target state="translated">記錄順序已損毀。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的記錄檔格式或版本無效。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The record was written with an incompatible version of the record sequence.</source>
          <target state="translated">記錄是以不相容的記錄順序版本所寫入。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The operation is invalid because the enumeration has not been started.</source>
          <target state="translated">因為列舉尚未啟動，因此作業無效。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>A call to <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph> must be made.</source>
          <target state="translated">必須呼叫 <ph id="ph1">&lt;see cref="M:System.Collections.IEnumerator.MoveNext" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>-or</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The enumeration has ended.</source>
          <target state="translated">列舉已經結束。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReadRestartAreas">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">自動建立單一保留區，並將記錄附加至順序。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the collection to make reservations in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含要在其中建立保留區的集合。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要建立的保留區 (以位元組為單位)。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">自動建立單一保留區，並將記錄附加至順序。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果附加失敗，就不會保留任何空間。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">這個方法通常可以在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The following example shows how to use this method to make reservations.</source>
          <target state="translated">下列範例顯示如何使用這個方法來建立保留區。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Notice that this task can only be performed when using the CLFS-based <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> class.</source>
          <target state="translated">請注意，您只能在使用 CLFS 的 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence&gt;</ph> 類別時執行這項工作。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservations" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="nextUndoRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 找不到有足夠空間可以容納 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留區。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in the user-specified order.</source>
          <target state="translated">下一筆記錄的序號 (依照使用者指定的順序)。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the next record in Previous order.</source>
          <target state="translated">下一筆記錄的序號 (依照之前的順序)。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>A valid value of <ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> that specifies how the data should be written.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.RecordAppendOptions" /&gt;</ph> 的有效值，其中指定資料的寫入方式。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservation collection to make reservations in.</source>
          <target state="translated">要在其中建立保留區的保留區集合。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The reservations to make, in bytes.</source>
          <target state="translated">要建立的保留區 (以位元組為單位)。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Automatically makes a single reservation and appends a record to the sequence.</source>
          <target state="translated">自動建立單一保留區，並將記錄附加至順序。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The sequence number of the appended log record.</source>
          <target state="translated">已附加之記錄的序號。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Data contained in the <ph id="ph1">`data`</ph> parameter will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">包含在 <ph id="ph1">`data`</ph> 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>However, no provision is made for splitting data back into array segments when the record is read.</source>
          <target state="translated">不過，在讀取記錄時，並不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</source>
          <target state="translated">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>If the append fails, no space is reserved.</source>
          <target state="translated">如果附加失敗，就不會保留任何空間。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Normally, this method may complete before the record has been written.</source>
          <target state="translated">這個方法通常可以在寫入記錄前完成。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>To ensure that a record has been written, either specify the <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> flag using the <ph id="ph2">`recordAppendOptions`</ph> parameter, or call the <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> method.</source>
          <target state="translated">若要確定已寫入某筆記錄，請使用 <ph id="ph1">&lt;xref:System.IO.Log.RecordAppendOptions.ForceFlush&gt;</ph> 參數指定 <ph id="ph2">`recordAppendOptions`</ph> 旗標，或是呼叫 <ph id="ph3">&lt;xref:System.IO.Log.LogRecordSequence.Flush%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一或多個引數無效。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>An I/O error occurred while appending the record.</source>
          <target state="translated">附加記錄時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The record sequence could not make enough free space to contain the new record, or to make the reservation.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的記錄或建立保留區。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> or <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="userRecord" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="previousRecord" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>The operation cannot be performed because the record sequence was opened with read-only access.</source>
          <target state="translated">記錄順序是以唯讀存取所開啟，無法執行作業。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])">
          <source>No reservation large enough to fit <ph id="ph1">&lt;paramref name="data" /&gt;</ph> can be found in <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph>.</source>
          <target state="translated">在 <ph id="ph1">&lt;paramref name="data" /&gt;</ph> 找不到有足夠空間可以容納 <ph id="ph2">&lt;paramref name="reservations" /&gt;</ph> 的保留區。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>Gets the total number of bytes that have been reserved.</source>
          <target state="translated">取得保留的位元組總數。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>The total size of all reservations made in this record sequence.</source>
          <target state="translated">在此記錄順序中建立之所有保留區的總共大小。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.ReservedBytes">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後存取此屬性。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>Gets the sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">取得最接近記錄結尾之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The sequence number of the restart area closest to the end of the log.</source>
          <target state="translated">最接近記錄結尾之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>Using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;</ph> method, you can remove the most recently written restart area.</source>
          <target state="translated">使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A&gt;</ph> 方法，您就可以移除最近寫入的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後存取此屬性。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</source>
          <target state="translated">取得或設定值，這個值表示是否在記錄已滿時自動重試附加作業。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if appends are automatically retried if the log is full; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果要在記錄檔已滿時自動重試附加作業，則為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否則為 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">預設值為 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>If the value of this property is <ph id="ph1">`true`</ph>, and an <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</source>
          <target state="translated">如果這個屬性的值是 <ph id="ph1">`true`</ph>，且 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.Append%2A&gt;</ph> 呼叫因為順序中的空間不足而失敗，記錄順序將會嘗試釋放空間，並重試附加作業。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.RetryAppend%2A&gt;</ph> property.</source>
          <target state="translated">這個範例會說明如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.RetryAppend%2A&gt;</ph> 屬性。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="P:System.IO.Log.LogRecordSequence.RetryAppend">
          <source>The property was accessed after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後存取此屬性。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The new last sequence number in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中最新的序號。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>This should refer to a current valid record   currently in the log.</source>
          <target state="translated">這指的是目前在記錄中的最新有效記錄。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>Sets the last record in the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">設定 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> 中的最後一個記錄。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be larger than the base sequence number.</source>
          <target state="translated">指定的序號必須大於基底序號。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</source>
          <target state="translated">當這個方法完成時，先前附加序號大於指定序號的所有記錄會變成不可存取。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">新的或現有封存結尾或作用中記錄的基底無效。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sequenceNumber" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The end of the log has been reached.</source>
          <target state="translated">已經達到記錄的結尾。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The specified log file format or version is invalid.</source>
          <target state="translated">指定的記錄檔格式或版本無效。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Signals the need to move the tail of the sequence.</source>
          <target state="translated">標示需要移動順序結尾。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>You can fire this event when the record sequence has run out of space.</source>
          <target state="translated">您可以在記錄順序的空間用完時引發這個事件。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</source>
          <target state="translated">這個事件一經引發，就會將順序的結尾 (即基底序號) 往前移動以釋放空間。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</source>
          <target state="translated">當記錄順序基於任何理由決定必須釋放空間時，隨時都可以引發這個事件。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</source>
          <target state="translated">例如，當 CLFS 原則引擎判斷兩個共用同一記錄檔之記錄用戶端的結尾相距過遠時，就可能會決定引發事件。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Freeing space can be done by either writing restart areas, or truncating the log and using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> method to clear space.</source>
          <target state="translated">寫入重新啟動區域，或是截斷記錄檔並使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A&gt;</ph> 方法清除空間，都可以達到釋放空間的目的。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>The code sample in the Example section demonstrates the second approach.</source>
          <target state="translated">＜範例＞一節中，程式碼範例會示範其第二種處理方式。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>You can also call the <ph id="ph1">&lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;</ph> method outside of the <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event to free space.</source>
          <target state="translated">您也可以在 <ph id="ph1">&lt;xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A&gt;</ph> 事件外部呼叫 <ph id="ph2">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 方法來釋放空間。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>A restart area is similar to a checkpoint in other log processing systems.</source>
          <target state="translated">重新啟動區域類似於其他記錄處理系統中的檢查點。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</source>
          <target state="translated">呼叫這個方法，就表示應用程式會將所有在重新啟動區域之前的記錄都視為完全完成，而且可供日後附加記錄之用。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>Similar to any other records, the record written by this method requires actual free space in the log to function.</source>
          <target state="translated">與任何其他記錄相同，這個方法所寫入的記錄必須在記錄檔中有實際的可用空間，才會正常運作。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.IO.Log.LogRecordSequence.TailPinned">
          <source>This example shows how to use the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> event.</source>
          <target state="translated">這個範例會說明如何使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.TailPinned&gt;</ph> 事件。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="T:System.IO.Log.LogRecordSequence">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">將重新啟動區域寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Log.LogRecordSequence">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">您可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法來讀取重新啟動區域。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>An array segment that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄的陣列區段。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">將重新啟動區域寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">寫入之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">您可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法來讀取重新啟動區域。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">位元組陣列區段中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在讀取重新啟動區域時，不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一或多個引數無效。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">寫入重新啟動區域時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>.</source>
          <target state="translated">將重新啟動區域寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">寫入之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">您可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法來讀取重新啟動區域。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The data in the byte array segments will be concatenated into a single byte array for appending as the record.</source>
          <target state="translated">位元組陣列區段中的資料將串連至單一位元組陣列中，以便附加成記錄。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在讀取重新啟動區域時，不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一或多個引數無效。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">寫入重新啟動區域時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>One or more of the arguments are <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個引數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基底序號。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序號必須大於或等於目前基底序號。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> and updates the base sequence number.</source>
          <target state="translated">將重新啟動區域寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，並更新基底序號。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">寫入之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">您可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法來讀取重新啟動區域。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在讀取重新啟動區域時，不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">當這個方法成功完成時，基底序號已經更新。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">只要是序號小於新基底序號的所有記錄都無法存取。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一或多個引數無效。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">寫入重新啟動區域時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基底序號。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序號必須大於或等於目前基底序號。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> and updates the base sequence number.</source>
          <target state="translated">將重新啟動區域寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，並更新基底序號。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">寫入之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">您可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法來讀取重新啟動區域。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在讀取重新啟動區域時，不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">當這個方法成功完成時，基底序號已經更新。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">只要是序號小於新基底序號的所有記錄都無法存取。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一或多個引數無效。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">寫入重新啟動區域時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基底序號。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序號必須大於或等於目前基底序號。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含此重新啟動區域所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number.</source>
          <target state="translated">使用保留區將重新啟動區域寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，並更新基底序號。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">寫入之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">您可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法來讀取重新啟動區域。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在讀取重新啟動區域時，不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果已指定保留區，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果此方法成功，便會取用可以容納資料的最小保留區，而且該保留區將會從集合移除。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">當這個方法成功完成時，基底序號已經更新。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">只要是序號小於新基底序號的所有記錄都無法存取。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the arguments is invalid.</source>
          <target state="translated">一或多個引數無效。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>An I/O error occurred while writing the restart area.</source>
          <target state="translated">寫入重新啟動區域時發生 I/O 錯誤。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence could not make enough free space to contain the new restart area.</source>
          <target state="translated">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A list of byte array segments that will be concatenated and appended as the record.</source>
          <target state="translated">即將串連並附加成記錄之位元組陣列區段的清單。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The new base sequence number.</source>
          <target state="translated">新的基底序號。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified sequence number must be greater than or equal to the current base sequence number.</source>
          <target state="translated">指定的序號必須大於或等於目前基底序號。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph> that contains the reservation that should be used for this restart area.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.Log.ReservationCollection" /&gt;</ph>，其中包含此重新啟動區域所應使用的保留區。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Writes a restart area to the <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph> using a reservation, and updates the base sequence number.</source>
          <target state="translated">使用保留區將重新啟動區域寫入 <ph id="ph1">&lt;see cref="T:System.IO.Log.LogRecordSequence" /&gt;</ph>，並更新基底序號。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This method cannot be inherited.</source>
          <target state="translated">這個方法無法被繼承。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The sequence number of the written restart area.</source>
          <target state="translated">寫入之重新啟動區域的序號。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area is used to temporarily store information containing a client's last checkpoint operation.</source>
          <target state="translated">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</source>
          <target state="translated">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</source>
          <target state="translated">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</source>
          <target state="translated">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A restart area can be read using the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> method.</source>
          <target state="translated">您可以使用 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A&gt;</ph> 方法來讀取重新啟動區域。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</source>
          <target state="translated">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>No provision is made for splitting data back into array segments when the restart area is read.</source>
          <target state="translated">在讀取重新啟動區域時，不會將資料分割回陣列區段。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</source>
          <target state="translated">如果已指定保留區，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</source>
          <target state="translated">如果此方法成功，便會取用可以容納資料的最小保留區，而且該保留區將會從集合移除。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>When this method successfully completes, the base sequence number has been updated.</source>
          <target state="translated">當這個方法成功完成時，基底序號已經更新。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>All log records with sequence numbers less than the new base sequence number are inaccessible.</source>
          <target state="translated">只要是序號小於新基底序號的所有記錄都無法存取。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</source>
          <target state="translated">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> method is called.</source>
          <target state="translated">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <ph id="ph1">&lt;xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A&gt;</ph> 方法時擲回例外狀況。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not valid for this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 對此順序無效。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The specified log enumeration start sequence number is invalid.</source>
          <target state="translated">指定的記錄列舉起始序號無效。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> cannot be appended because it is larger than the maximum record size.</source>
          <target state="translated">無法附加 <ph id="ph1">&lt;paramref name="data" /&gt;</ph>，因為它已超過記錄大小上限。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> was not created by this record sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reservationCollection" /&gt;</ph> 不是由此記錄順序所建立。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>One or more of the parameters is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一或多個參數為 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>A new or existing archive tail or base of the active log is invalid.</source>
          <target state="translated">新的或現有封存結尾或作用中記錄的基底無效。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> is not between the base and last sequence numbers of this sequence.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="newBaseSeqNum" /&gt;</ph> 不是介於這個順序的基底序號和最後一個序號之間。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an unexpected I/O exception.</source>
          <target state="translated">由於意外的 I/O 例外狀況，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>-or-</source>
          <target state="translated">-或-</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The request could not be performed because of an I/O device error.</source>
          <target state="translated">因為 I/O 裝置錯誤，所以無法執行要求。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The method was called after the sequence has been disposed of.</source>
          <target state="translated">已在處置序列之後呼叫此方法。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>There is not enough memory to continue the execution of the program.</source>
          <target state="translated">沒有足夠的記憶體可以繼續執行程式。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>Access for the specified log sequence is denied by the operating system.</source>
          <target state="translated">存取指定的記錄順序遭作業系統拒絕。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)">
          <source>The record sequence is full.</source>
          <target state="translated">記錄順序已滿。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>