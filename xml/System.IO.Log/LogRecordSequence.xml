<Type Name="LogRecordSequence" FullName="System.IO.Log.LogRecordSequence">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7156e4e610a9d14909a701b75c25fcdefeaf4c8c" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37655520" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogRecordSequence extends System.Object implements class System.IDisposable, class System.IO.Log.IRecordSequence" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogRecordSequence" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogRecordSequence&#xA;Implements IDisposable, IRecordSequence" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogRecordSequence sealed : IDisposable, System::IO::Log::IRecordSequence" />
  <TypeSignature Language="F#" Value="type LogRecordSequence = class&#xA;    interface IRecordSequence&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IO.Log.IRecordSequence</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="391e8-101">表示 <see cref="T:System.IO.Log.LogStore" /> 中儲存的記錄順序。</span>
      <span class="sxs-lookup">
        <span data-stu-id="391e8-101">Represents a record sequence stored in a <see cref="T:System.IO.Log.LogStore" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-102"><xref:System.IO.Log.LogRecordSequence> 類別會在一般記錄檔系統 (CLFS) 記錄頂端提供記錄順序介面實作。</span><span class="sxs-lookup"><span data-stu-id="391e8-102">The <xref:System.IO.Log.LogRecordSequence> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</span></span> <span data-ttu-id="391e8-103">除了標準的記錄導向功能之外，它還提供了一個原則模型，可用來避免記錄檔已滿狀況，以及在同一實體檔案上進行用戶端多工。</span><span class="sxs-lookup"><span data-stu-id="391e8-103">In addition to the standard record-oriented features, it provides a policy model for avoiding log-full conditions, and multiplexing of clients on the same physical file.</span></span> <span data-ttu-id="391e8-104">它會搭配使用 <xref:System.IO.Log.LogStore> 類別，這個類別會提供用來直接操作和管理 CLFS 記錄檔的介面。</span><span class="sxs-lookup"><span data-stu-id="391e8-104">It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file.</span></span> <span data-ttu-id="391e8-105"><xref:System.IO.Log.LogStore> 類別與 <xref:System.IO.Log.LogRecordSequence> 類別的關係就如同磁碟檔案與 <xref:System.IO.FileStream> 物件的關係。</span><span class="sxs-lookup"><span data-stu-id="391e8-105">The relationship between the <xref:System.IO.Log.LogStore> class and the <xref:System.IO.Log.LogRecordSequence> class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="391e8-106">磁碟檔案提供實際的儲存區且具有「長度」和「上次存取時間」等屬性，而 <xref:System.IO.FileStream> 物件則提供檔案的檢視，可用來讀取和寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="391e8-106">The disk file provides the concrete storage, and has attributes such as length and last access time; while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it.</span></span> <span data-ttu-id="391e8-107">同樣地，<xref:System.IO.Log.LogStore> 類別也具有原則和延伸磁碟區集合等屬性；而 <xref:System.IO.Log.LogRecordSequence> 類別則會提供用來讀取和寫入資料的記錄導向機制。</span><span class="sxs-lookup"><span data-stu-id="391e8-107">Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents; and the <xref:System.IO.Log.LogRecordSequence> class provides a record-oriented mechanism for reading and writing data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-108">這個範例會說明如何使用 <xref:System.IO.Log.LogRecordSequence> 類別：</span><span class="sxs-lookup"><span data-stu-id="391e8-108">This example shows how to use the <xref:System.IO.Log.LogRecordSequence> class:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#0](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#0)]
 [!code-vb[S_UELogRecordSequence#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-109">初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-109">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence logStore" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <span data-ttu-id="391e8-110">這個記錄順序應該使用的 <see cref="T:System.IO.Log.LogStore" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-110">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-111">使用指定的記錄存放區，初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-111">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-112">緩衝區大小決定了可以附加或讀取的記錄大小上限。</span><span class="sxs-lookup"><span data-stu-id="391e8-112">The buffer size determines the maximum size of the record that can be appended or read.</span></span> <span data-ttu-id="391e8-113">在這個建構函式中，會設為預設值 64。</span><span class="sxs-lookup"><span data-stu-id="391e8-113">In this constructor, a default value of 64 is set.</span></span> <span data-ttu-id="391e8-114">需要的緩衝區數量設為 10。</span><span class="sxs-lookup"><span data-stu-id="391e8-114">The desired number of buffers is set to 10.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-115">
            <paramref name="logStore" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-115">
              <paramref name="logStore" /> is invalid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="391e8-116">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-116">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="391e8-117">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-117">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-118">使用指定的記錄存放區路徑和存取模式，初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-118">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-119">這個建構函式會在新的 <xref:System.IO.Log.LogRecordSequence> 物件上初始化新的 <xref:System.IO.Log.LogStore>，而這個物件是以指定的路徑和模式所開啟的。</span><span class="sxs-lookup"><span data-stu-id="391e8-119">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path and mode.</span></span> <span data-ttu-id="391e8-120">會給予存放區的讀取/寫入權限，並且會開啟存放區的共用讀取權限。</span><span class="sxs-lookup"><span data-stu-id="391e8-120">It is given read/write access to the store, and the store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-121">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-121">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-122">
            <paramref name="path" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-122">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="391e8-123">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-123">-or-</span>
          </span>
          <span data-ttu-id="391e8-124">
            <paramref name="path" /> 僅包含泛空白字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-124">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="391e8-125">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-125">-or-</span>
          </span>
          <span data-ttu-id="391e8-126">
            <paramref name="path" /> 包含一或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-126">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-127">
            <paramref name="mode" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-127">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="391e8-128">找不到檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-128">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-129">開啟記錄存放區時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-129">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-130">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-130">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-131">不支援此作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-131">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-132">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-132">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="391e8-133">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-133">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="391e8-134">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-134">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Log.LogStore logStore, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::IO::Log::LogStore ^ logStore, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : System.IO.Log.LogStore * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (logStore, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logStore" Type="System.IO.Log.LogStore" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="logStore">
          <span data-ttu-id="391e8-135">這個記錄順序應該使用的 <see cref="T:System.IO.Log.LogStore" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-135">The <see cref="T:System.IO.Log.LogStore" /> that this record sequence should use.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="391e8-136">需要的緩衝區大小 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-136">The desired buffer size in bytes.</span>
          </span>
          <span data-ttu-id="391e8-137">緩衝區大小決定了可以附加或讀取的記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-137">The buffer size determines the maximum size of the record that can be appended or read.</span>
          </span>
        </param>
        <param name="bufferCount">
          <span data-ttu-id="391e8-138">需要的緩衝區數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-138">The desired number of buffers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-139">使用指定的記錄存放區、每個記錄的緩衝區大小和緩衝區數目，初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-139">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with the specified log store, buffer size for each record, and buffer number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-140">如果您想要指定 `bufferSize` 和 `bufferCount` 值，而且不想使用 `bufferSize` 的預設值 64 和 `bufferCount` 的預設值 10，可以使用這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="391e8-140">Use this constructor if you want to specify values for `bufferSize` and `bufferCount` and do not want to use the default value of 64 for `bufferSize` and 10 for `bufferCount`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-141">
            <paramref name="logStore" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-141">
              <paramref name="logStore" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-142">
            <paramref name="bufferSize" /> 為負值或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-142">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="391e8-143">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-143">-or-</span>
          </span>
          <span data-ttu-id="391e8-144">
            <paramref name="bufferCount" /> 為負值或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-144">
              <paramref name="bufferCount" /> is negative or zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="391e8-145">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-145">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="391e8-146">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-146">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="391e8-147">其中一個 <see cref="T:System.IO.FileAccess" /> 值，可決定 <see cref="T:System.IO.Log.LogStore" /> 可以如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-147">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-148">使用指定的記錄存放區路徑以及存取和共用模式，初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-148">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access and share modes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-149">這個建構函式 (Constructor) 會在新的 <xref:System.IO.Log.LogRecordSequence> 物件上初始化新的 <xref:System.IO.Log.LogStore>，而這個物件是以指定的路徑、模式和存取權限所開啟的。</span><span class="sxs-lookup"><span data-stu-id="391e8-149">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="391e8-150">存放區便會開啟，並且共用讀取權限。</span><span class="sxs-lookup"><span data-stu-id="391e8-150">The store is opened sharing Read access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-151">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-151">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-152">
            <paramref name="path" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-152">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="391e8-153">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-153">-or-</span>
          </span>
          <span data-ttu-id="391e8-154">
            <paramref name="path" /> 僅包含泛空白字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-154">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="391e8-155">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-155">-or-</span>
          </span>
          <span data-ttu-id="391e8-156">
            <paramref name="path" /> 包含一或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-156">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-157">
            <paramref name="mode" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-157">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="391e8-158">找不到檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-158">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-159">開啟記錄存放區時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-159">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-160">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-160">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-161">不支援此作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-161">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-162">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-162">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="391e8-163">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-163">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="391e8-164">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-164">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="391e8-165">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-165">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="391e8-166">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-166">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="391e8-167">其中一個 <see cref="T:System.IO.FileAccess" /> 值，可決定 <see cref="T:System.IO.Log.LogStore" /> 可以如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-167">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="391e8-168">其中一個 <see cref="T:System.IO.FileShare" /> 值，可決定在處理序之間共用記錄存放區的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-168">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-169">使用指定的記錄存放區路徑和存取模式，初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-169">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store and the access mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-170">這個建構函式 (Constructor) 會在新的 <xref:System.IO.Log.LogRecordSequence> 物件上初始化新的 <xref:System.IO.Log.LogStore>，而這個物件是以指定的路徑、模式和存取權限所開啟的。</span><span class="sxs-lookup"><span data-stu-id="391e8-170">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="391e8-171">存放區會開啟，並且共用指定的存取權限。</span><span class="sxs-lookup"><span data-stu-id="391e8-171">The store is opened sharing the specified access.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-172">這個範例會說明如何使用這個 <xref:System.IO.Log.LogRecordSequence> 建構函式：</span><span class="sxs-lookup"><span data-stu-id="391e8-172">This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#1)]
 [!code-vb[S_UELogRecordSequence#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-173">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-173">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-174">
            <paramref name="path" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-174">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="391e8-175">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-175">-or-</span>
          </span>
          <span data-ttu-id="391e8-176">
            <paramref name="path" /> 僅包含泛空白字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-176">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="391e8-177">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-177">-or-</span>
          </span>
          <span data-ttu-id="391e8-178">
            <paramref name="path" /> 包含一或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-178">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-179">
            <paramref name="mode" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-179">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="391e8-180">找不到檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-180">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-181">開啟記錄存放區時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-181">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-182">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-182">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-183">不支援此作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-183">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-184">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-184">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="391e8-185">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-185">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="391e8-186">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-186">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, bufferCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="391e8-187">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-187">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="391e8-188">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-188">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="391e8-189">其中一個 <see cref="T:System.IO.FileAccess" /> 值，可決定 <see cref="T:System.IO.Log.LogStore" /> 可以如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-189">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="391e8-190">其中一個 <see cref="T:System.IO.FileShare" /> 值，可決定在處理序之間共用記錄存放區的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-190">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="391e8-191">需要的緩衝區大小 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-191">The desired buffer size in bytes.</span>
          </span>
          <span data-ttu-id="391e8-192">緩衝區大小決定了可以附加或讀取的記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-192">The buffer size determines the maximum size of the record that can be appended or read.</span>
          </span>
        </param>
        <param name="bufferCount">
          <span data-ttu-id="391e8-193">需要的緩衝區數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-193">The desired number of buffers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-194">使用指定的記錄存放區路徑、檔案權限、存取與共用模式，以及緩衝區大小和記錄計數，初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-194">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class with a specified path to the log store, file permission, access and share modes, and the buffer size and count for records.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-195">這個建構函式 (Constructor) 會在新的 <xref:System.IO.Log.LogRecordSequence> 物件上初始化新的 <xref:System.IO.Log.LogStore>，而這個物件是以指定的路徑、模式和存取權限所開啟的。</span><span class="sxs-lookup"><span data-stu-id="391e8-195">This constructor initializes a new <xref:System.IO.Log.LogRecordSequence> on a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="391e8-196">存放區會開啟，並且共用指定的存取權限。</span><span class="sxs-lookup"><span data-stu-id="391e8-196">The store is opened sharing the specified access.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-197">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-197">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-198">
            <paramref name="path" /> 為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-198">
              <paramref name="path" /> is an empty string ("").</span>
          </span>
          <span data-ttu-id="391e8-199">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-199">-or-</span>
          </span>
          <span data-ttu-id="391e8-200">
            <paramref name="path" /> 僅包含泛空白字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-200">
              <paramref name="path" /> contains only white space.</span>
          </span>
          <span data-ttu-id="391e8-201">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-201">-or-</span>
          </span>
          <span data-ttu-id="391e8-202">
            <paramref name="path" /> 包含一或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-202">
              <paramref name="path" /> contains one or more invalid characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-203">
            <paramref name="mode" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-203">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="391e8-204">找不到檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-204">The file cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-205">開啟記錄存放區時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-205">An I/O error occurs when opening the log store.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-206">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-206">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-207">不支援此作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-207">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-208">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-208">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="391e8-209">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-209">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="391e8-210">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-210">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, int32 bufferCount, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogRecordSequence(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, int bufferCount, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogRecordSequence : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * int * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogRecordSequence" Usage="new System.IO.Log.LogRecordSequence (path, mode, access, share, bufferSize, bufferCount, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="bufferCount" Type="System.Int32" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="391e8-211">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-211">A relative or absolute path for the base file of the log store to open.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="391e8-212">有效的 <see cref="T:System.IO.FileMode" /> 值，其決定如何開啟或建立存放區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-212">A valid <see cref="T:System.IO.FileMode" /> value that determines how to open or create the store.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="391e8-213">有效的 <see cref="T:System.IO.FileAccess" /> 值，決定如何存取記錄存放區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-213">A valid <see cref="T:System.IO.FileAccess" /> value that determines how the log store can be accessed.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="391e8-214">有效的 <see cref="T:System.IO.FileShare" /> 值，可決定在處理序之間共用記錄存放區的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-214">A valid <see cref="T:System.IO.FileShare" /> value that determines how the log store will be shared among processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="391e8-215">需要的緩衝區大小 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-215">The desired buffer size in bytes.</span>
          </span>
          <span data-ttu-id="391e8-216">緩衝區大小決定了可以附加或讀取的記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-216">The buffer size determines the maximum size of the record that can be appended or read.</span>
          </span>
        </param>
        <param name="bufferCount">
          <span data-ttu-id="391e8-217">需要的緩衝區數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-217">The desired number of buffers.</span>
          </span>
        </param>
        <param name="fileSecurity">
          <span data-ttu-id="391e8-218">有效的 <see cref="T:System.Security.AccessControl.FileSecurity" /> 值，可指定要針對新建立的存放區設定的安全性 (如果必須建立存放區的話)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-218">A valid <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-219">初始化 <see cref="T:System.IO.Log.LogRecordSequence" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-219">Initializes a new instance of the <see cref="T:System.IO.Log.LogRecordSequence" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-220">
            <paramref name="path" /> 指定的檔案無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-220">The file specified by <paramref name="path" /> is not valid.</span>
          </span>
          <span data-ttu-id="391e8-221">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-221">-or-</span>
          </span>
          <span data-ttu-id="391e8-222">指定的記錄存放區檔案名稱無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-222">The specified log store file name is not valid.</span>
          </span>
          <span data-ttu-id="391e8-223">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-223">-or-</span>
          </span>
          <span data-ttu-id="391e8-224">
            <paramref name="mode" /> 具有 <see cref="F:System.IO.FileMode.CreateNew" /> 的值，而且無法在沒有寫入權限的情況下使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-224">
              <paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.CreateNew" />, and cannot be used without write access.</span>
          </span>
          <span data-ttu-id="391e8-225">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-225">-or-</span>
          </span>
          <span data-ttu-id="391e8-226">
            <paramref name="mode" /> 具有 <see cref="F:System.IO.FileMode.OpenOrCreate" /> 的值，而且無法在沒有寫入權限的情況下使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-226">
              <paramref name="mode" /> has a value of <see cref="F:System.IO.FileMode.OpenOrCreate" />, and cannot be used without write access.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-227">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-227">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-228">一或多個引數超出範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-228">One or more of the arguments are out of range.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="391e8-229">找不到 <paramref name="path" /> 指定的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-229">The file specified by <paramref name="path" /> cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-230">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-230">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-231">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-231">-or-</span>
          </span>
          <span data-ttu-id="391e8-232">因為另一個處理序正在使用 <paramref name="path" /> 所指定的檔案，所以無法存取該檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-232">The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.</span>
          </span>
          <span data-ttu-id="391e8-233">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-233">-or-</span>
          </span>
          <span data-ttu-id="391e8-234">因為檔案或目錄已存在，所以無法建立 <paramref name="path" /> 所指定的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-234">The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.</span>
          </span>
          <span data-ttu-id="391e8-235">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-235">-or-</span>
          </span>
          <span data-ttu-id="391e8-236">記錄檔控制代碼無法繫結至執行緒集區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-236">The log handle could not be bound to the thread pool.</span>
          </span>
          <span data-ttu-id="391e8-237">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-237">-or-</span>
          </span>
          <span data-ttu-id="391e8-238">指定的記錄檔格式或版本無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-238">The specified log file format or version is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-239">不支援此作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-239">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-240">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-240">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-241">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-241">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="391e8-242">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-242">
              <see cref="T:System.IO.Log.LogRecordSequence" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span>
          </span>
          <span data-ttu-id="391e8-243">如果 CLFS 元件適用於您的平台，請進行安裝，或請使用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-243">Install the CLFS component if it is available for your platform, or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-244">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-244">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-245">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-245">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AdvanceBaseSequenceNumber">
      <MemberSignature Language="C#" Value="public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AdvanceBaseSequenceNumber(valuetype System.IO.Log.SequenceNumber newBaseSequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AdvanceBaseSequenceNumber (newBaseSequenceNumber As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AdvanceBaseSequenceNumber(System::IO::Log::SequenceNumber newBaseSequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit&#xA;override this.AdvanceBaseSequenceNumber : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.AdvanceBaseSequenceNumber newBaseSequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newBaseSequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="newBaseSequenceNumber">
          <span data-ttu-id="391e8-246">指定記錄的新基底 <see cref="T:System.IO.Log.SequenceNumber" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-246">Specifies the new base <see cref="T:System.IO.Log.SequenceNumber" /> for the log.</span>
          </span>
          <span data-ttu-id="391e8-247">必須介於記錄的目前基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-247">This must lie in the range between the current base sequence number and the last sequence number of the log inclusively.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-248">將記錄檔的基底序號往前移動。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-248">Moves the base sequence number of the log forward.</span>
          </span>
          <span data-ttu-id="391e8-249">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-249">This method cannot be inherited.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-250">這個方法通常與 <xref:System.IO.Log.LogRecordSequence.TailPinned> 事件搭配使用，以釋放記錄中的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-250">This method is often used with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a record.</span></span> <span data-ttu-id="391e8-251"><xref:System.IO.Log.LogRecordSequence.TailPinned> 事件表示，必須將順序的結尾 (即基底序號) 往前移動才能釋放空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-251">The <xref:System.IO.Log.LogRecordSequence.TailPinned> event indicates that the tail of the sequence (that is, the base sequence number) needs to be moved forward to free up space.</span></span> <span data-ttu-id="391e8-252">使用 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 方法寫入重新啟動區域，或是截斷記錄並使用 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 方法將記錄基底序號依照 `newBaseSequenceNumber` 參數所指定的往前移一個號碼，都可以達到釋放空間的目的。</span><span class="sxs-lookup"><span data-stu-id="391e8-252">Freeing space can be done by either writing restart areas using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to advance the base sequence number of a log to the one specified by the `newBaseSequenceNumber` parameter.</span></span> <span data-ttu-id="391e8-253">＜範例＞一節中，程式碼範例會示範其第二種處理方式。</span><span class="sxs-lookup"><span data-stu-id="391e8-253">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="391e8-254">請注意，呼叫這個方法與使用 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 方法設定新基底序號的效果一樣，都不會在記錄中寫入重新啟動記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-254">Note that calling this method is the same as setting a new base sequence number using the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method, except that no restart record is written to the log.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-255">這個範例將示範如何使用 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 方法搭配 <xref:System.IO.Log.LogRecordSequence.TailPinned> 事件來釋放記錄順序中的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-255">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-256">
            <paramref name="newBaseSequenceNumber" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-256">
              <paramref name="newBaseSequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-257">新的或現有封存結尾或作用中記錄的基底無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-257">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="391e8-258">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-258">-or-</span>
          </span>
          <span data-ttu-id="391e8-259">
            <paramref name="newBaseSequenceNumber" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-259">
              <paramref name="newBaseSequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-260">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-260">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-261">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-261">-or-</span>
          </span>
          <span data-ttu-id="391e8-262">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-262">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-263">指定的記錄沒有任何延伸區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-263">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="391e8-264">必須先建立一或多個延伸區，才能使用記錄順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-264">One or more extents must be created before a record sequence may be used.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-265">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-265">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-266">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-266">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-267">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-267">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-268">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-268">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-269">將記錄寫入 <see cref="T:System.IO.Log.IRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-269">Writes a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="391e8-270">這個範例會說明如何使用 <xref:System.IO.Log.LogRecordSequence.Append%2A> 成員。</span><span class="sxs-lookup"><span data-stu-id="391e8-270">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.Append%2A> member</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#5)]
 [!code-vb[S_UELogRecordSequence#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-271">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-271">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="391e8-272">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-272">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-273">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-273">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-274">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-274">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-275">將記錄寫入 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-275">Writes a log record to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="391e8-276">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-276">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-277">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-277">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-278">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-278">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-279">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-279">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-280">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-280">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-281">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-281">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-282">下列範例將示範如何使用這個方法，將記錄附加到順序。</span><span class="sxs-lookup"><span data-stu-id="391e8-282">The following example demonstrates how to use this method to append a log record to the sequence.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#13)]
 [!code-vb[S_UELogRecordSequence#13](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-283">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-283">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-284">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-284">-or-</span>
          </span>
          <span data-ttu-id="391e8-285">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-285">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-286">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-286">-or-</span>
          </span>
          <span data-ttu-id="391e8-287">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-287">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-288">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-288">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-289">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-289">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-290">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-290">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-291">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-291">-or-</span>
          </span>
          <span data-ttu-id="391e8-292">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-292">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-293">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-293">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-294">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-294">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-295">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-295">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-296">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-296">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-297">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-297">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-298">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-298">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="391e8-299">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-299">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-300">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-300">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-301">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-301">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-302">將記錄附加到 <see cref="T:System.IO.Log.IRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-302">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />.</span>
          </span>
          <span data-ttu-id="391e8-303">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-303">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-304">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-304">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-305">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-305">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-306">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-306">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-307">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-307">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-308">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-308">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-309">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-309">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-310">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-310">-or-</span>
          </span>
          <span data-ttu-id="391e8-311">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-311">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-312">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-312">-or-</span>
          </span>
          <span data-ttu-id="391e8-313">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-313">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-314">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-314">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-315">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-315">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-316">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-316">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-317">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-317">-or-</span>
          </span>
          <span data-ttu-id="391e8-318">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-318">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-319">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-319">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-320">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-320">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-321">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-321">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-322">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-322">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-323">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-323">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-324">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-324">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="391e8-325">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-325">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-326">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-326">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-327">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-327">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-328">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含這筆記錄所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-328">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-329">使用之前在順序中保留的空間，將記錄附加到 <see cref="T:System.IO.Log.IRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-329">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="391e8-330">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-330">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-331">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-331">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-332">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-332">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-333">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-333">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-334">附加的記錄將會使用 `reservations` 參數指定的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-334">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="391e8-335">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-335">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-336">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-336">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-337">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-337">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-338">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-338">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-339">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-339">-or-</span>
          </span>
          <span data-ttu-id="391e8-340">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-340">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-341">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-341">-or-</span>
          </span>
          <span data-ttu-id="391e8-342">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-342">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-343">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-343">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-344">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-344">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-345">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-345">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-346">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-346">-or-</span>
          </span>
          <span data-ttu-id="391e8-347">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-347">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-348">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-348">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-349">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-349">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-350">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-350">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-351">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-351">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-352">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-352">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="391e8-353">在 <paramref name="data" /> 找不到有足夠空間可以容納 <paramref name="reservations" /> 的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-353">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Append(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Append(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.Append : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Append (data, userRecord, previousRecord, recordAppendOptions, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-354">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-354">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="391e8-355">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-355">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-356">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-356">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-357">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-357">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-358">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含這筆記錄所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-358">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-359">使用之前在順序中保留的空間，將記錄附加到 <see cref="T:System.IO.Log.IRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-359">Appends a log record to the <see cref="T:System.IO.Log.IRecordSequence" />, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="391e8-360">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-360">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-361">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-361">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-362">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-362">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-363">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-363">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-364">附加的記錄將會使用 `reservations` 參數指定的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-364">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="391e8-365">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-365">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-366">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-366">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-367">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.IRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-367">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.IRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-368">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-368">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-369">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-369">-or-</span>
          </span>
          <span data-ttu-id="391e8-370">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-370">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-371">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-371">-or-</span>
          </span>
          <span data-ttu-id="391e8-372">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-372">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-373">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-373">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-374">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-374">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-375">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-375">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-376">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-376">-or-</span>
          </span>
          <span data-ttu-id="391e8-377">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-377">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-378">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-378">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-379">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-379">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-380">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-380">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-381">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-381">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-382">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-382">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="391e8-383">在 <paramref name="data" /> 找不到有足夠空間可以容納 <paramref name="reservations" /> 的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-383">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.BaseSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-384">取得目前 <see cref="T:System.IO.Log.LogRecordSequence" />中第一個有效記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-384">Gets the sequence number of the first valid record in the current <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="391e8-385">對應至 <see cref="T:System.IO.Log.LogRecordSequence" /> 中之有效記錄的最小序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-385">The lowest sequence number that corresponds to a valid record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-386">有效的序號會大於或等於 <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>，而且小於 <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>。</span><span class="sxs-lookup"><span data-stu-id="391e8-386">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span>  
  
 <span data-ttu-id="391e8-387">這個屬性的值可藉由呼叫 <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 方法或 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 方法加以變更。</span><span class="sxs-lookup"><span data-stu-id="391e8-387">The value of this property can be changed by calling the <xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> method or <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-388">這個範例會說明如何使用迴圈中的 <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> 成員。</span><span class="sxs-lookup"><span data-stu-id="391e8-388">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> member in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-389">已在處置序列之後存取此屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-389">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-390">開始執行非同步的附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-390">Begins an asynchronous append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-391">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-391">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="391e8-392">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-392">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-393">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-393">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-394">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-394">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-395">選擇性的非同步回呼，在附加完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-395">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-396">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-396">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-397">開始執行非同步的附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-397">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="391e8-398">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-398">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-399">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-399">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-400">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-400">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-401">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-401">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-402">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-402">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-403">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-403">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-404">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-404">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-405">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-405">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-406">
            <paramref name="nextUndoRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-406">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-407">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-407">-or-</span>
          </span>
          <span data-ttu-id="391e8-408">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-408">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-409">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-409">-or-</span>
          </span>
          <span data-ttu-id="391e8-410">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-410">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-411">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-411">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-412">
            <paramref name="nextUndoRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-412">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-413">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-413">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-414">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-414">-or-</span>
          </span>
          <span data-ttu-id="391e8-415">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-415">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-416">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-416">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-417">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-417">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-418">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-418">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-419">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-419">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-420">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-420">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-421">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-421">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="391e8-422">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-422">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-423">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-423">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-424">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-424">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-425">選擇性的非同步回呼，在附加完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-425">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-426">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-426">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-427">開始執行非同步的附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-427">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="391e8-428">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-428">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-429">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-429">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-430">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-430">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-431">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-431">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-432">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-432">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-433">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-433">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-434">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-434">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-435">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-435">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-436">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-436">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-437">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-437">-or-</span>
          </span>
          <span data-ttu-id="391e8-438">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-438">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-439">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-439">-or-</span>
          </span>
          <span data-ttu-id="391e8-440">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-440">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-441">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-441">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-442">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-442">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-443">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-443">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-444">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-444">-or-</span>
          </span>
          <span data-ttu-id="391e8-445">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-445">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-446">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-446">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-447">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-447">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-448">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-448">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-449">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-449">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-450">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-450">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-451">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-451">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="391e8-452">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-452">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-453">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-453">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-454">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-454">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-455">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含這筆記錄所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-455">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-456">選擇性的非同步回呼，在附加完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-456">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-457">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-457">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-458">開始執行非同步的附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-458">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="391e8-459">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-459">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-460">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-460">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-461">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-461">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-462">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-462">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-463">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-463">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-464">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-464">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-465">附加的記錄將會使用 `reservations` 參數指定的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-465">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="391e8-466">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-466">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-467">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-467">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-468">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-468">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-469">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-469">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-470">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-470">-or-</span>
          </span>
          <span data-ttu-id="391e8-471">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-471">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-472">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-472">-or-</span>
          </span>
          <span data-ttu-id="391e8-473">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-473">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-474">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-474">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-475">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-475">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-476">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-476">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-477">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-477">-or-</span>
          </span>
          <span data-ttu-id="391e8-478">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-478">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-479">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-479">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-480">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-480">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-481">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-481">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-482">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-482">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-483">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-483">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="391e8-484">在 <paramref name="data" /> 找不到有足夠空間可以容納 <paramref name="reservations" /> 的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-484">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginAppend (data, userRecord, previousRecord, recordAppendOptions, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-485">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-485">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="391e8-486">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-486">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-487">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-487">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-488">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-488">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-489">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含這筆記錄所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-489">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this record.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-490">選擇性的非同步回呼，在附加完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-490">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-491">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-491">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-492">開始執行非同步的附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-492">Begins an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="391e8-493">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-493">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-494">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-494">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous append, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-495">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-495">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-496">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-496">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-497">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-497">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-498">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-498">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-499">附加的記錄將會使用 `reservations` 參數指定的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-499">The appended record will consume space that has been previously reserved, using a reservation specified by the `reservations` parameter.</span></span> <span data-ttu-id="391e8-500">如果附加成功，則會使用可以保存資料的最小保留區域，而且該保留區域將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-500">If the append succeeds, it will consume the smallest reservation area that can hold the data, and that reservation area will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-501">此方法通常會在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-501">Normally, this method completes before the record has been written.</span></span> <span data-ttu-id="391e8-502">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-502">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-503">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-503">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-504">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-504">-or-</span>
          </span>
          <span data-ttu-id="391e8-505">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-505">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-506">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-506">-or-</span>
          </span>
          <span data-ttu-id="391e8-507">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-507">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-508">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-508">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-509">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-509">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-510">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-510">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-511">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-511">-or-</span>
          </span>
          <span data-ttu-id="391e8-512">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-512">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-513">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-513">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-514">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-514">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-515">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-515">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-516">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-516">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-517">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-517">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="391e8-518">在 <paramref name="data" /> 找不到有足夠空間可以容納 <paramref name="reservations" /> 的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-518">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginFlush(valuetype System.IO.Log.SequenceNumber sequenceNumber, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginFlush(System::IO::Log::SequenceNumber sequenceNumber, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginFlush : System.IO.Log.SequenceNumber * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginFlush (sequenceNumber, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="391e8-519">必須寫入之最新記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-519">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="391e8-520">如果這個 <see cref="T:System.IO.Log.SequenceNumber" /> 無效，則必須寫入所有的記錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-520">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-521">選擇性的非同步回呼，在清除完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-521">An optional asynchronous callback, to be called when the flush is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-522">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步清除的要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-522">A user-provided object that distinguishes this particular asynchronous flush request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-523">使用先前保留在順序中的空間，開始執行非同步的清除作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-523">Begins an asynchronous flush operation, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="391e8-524">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-524">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-525">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步清除作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-525">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous flush operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-526">您應該將目前方法傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> 方法，以確保清除完成，並適當釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-526">You should pass the <xref:System.IAsyncResult> returned by the current method to the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method to ensure that the flush completes and resources are freed appropriately.</span></span> <span data-ttu-id="391e8-527">如果在非同步清除期間發生錯誤，則必須在使用這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> 呼叫 <xref:System.IAsyncResult> 方法後才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-527">If an error occurs during an asynchronous flush, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-528">呼叫這個方法可以確保已永久寫入附加到 <xref:System.IO.Log.LogRecordSequence> 的所有記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-528">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> are durably written.</span></span>  
  
 <span data-ttu-id="391e8-529">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-529">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-530">在非同步清除要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤)，會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-530">Errors that occurred during an asynchronous flush request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-531">
            <paramref name="sequenceNumber" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-531">
              <paramref name="sequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-532">
            <paramref name="sequenceNumber" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-532">
              <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-533">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-533">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-534">指定的記錄沒有任何延伸區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-534">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="391e8-535">必須先建立一或多個延伸區，才能使用記錄順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-535">One or more extents must be created before a record sequence can be used.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-536">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-536">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-537">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-537">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-538">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-538">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-539">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-539">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-540">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-540">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-541">開始執行非同步的保留和附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-541">Begins an asynchronous reserve and append operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-542">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-542">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="391e8-543">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-543">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-544">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-544">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-545">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-545">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="391e8-546">要在其中建立保留區的保留區集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-546">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-547">要建立的保留區 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-547">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-548">選擇性的非同步回呼，在附加完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-548">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-549">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-549">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-550">開始執行非同步的保留和附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-550">Begins an asynchronous reserve and append operation.</span>
          </span>
          <span data-ttu-id="391e8-551">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-551">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-552">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的這項非同步作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-552">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-553">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-553">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-554">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-554">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-555">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-555">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-556">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-556">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-557">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</span><span class="sxs-lookup"><span data-stu-id="391e8-557">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="391e8-558">如果附加失敗，就不會保留任何空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-558">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="391e8-559">這個方法通常可以在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-559">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="391e8-560">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-560">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-561">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-561">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-562">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-562">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-563">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-563">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-564">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-564">-or-</span>
          </span>
          <span data-ttu-id="391e8-565">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-565">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-566">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-566">-or-</span>
          </span>
          <span data-ttu-id="391e8-567">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-567">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-568">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-568">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-569">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-569">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-570">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-570">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-571">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-571">-or-</span>
          </span>
          <span data-ttu-id="391e8-572">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-572">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-573">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-573">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-574">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-574">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-575">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-575">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-576">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-576">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-577">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-577">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="391e8-578">在 <paramref name="data" /> 找不到有足夠空間可以容納 <paramref name="reservations" /> 的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-578">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReserveAndAppend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, cli::array &lt;long&gt; ^ reservations, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-579">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-579">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="391e8-580">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-580">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-581">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-581">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-582">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-582">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="391e8-583">要在其中建立保留區的保留區集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-583">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-584">要建立的保留區 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-584">The reservations to make, in bytes.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-585">選擇性的非同步回呼，在附加完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-585">An optional asynchronous callback, to be called when the append is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-586">使用者所提供的物件，可區別此特定非同步附加要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-586">A user-provided object that distinguishes this particular asynchronous append request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-587">開始執行非同步的保留和附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-587">Begins an asynchronous reserve and append operation.</span>
          </span>
          <span data-ttu-id="391e8-588">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-588">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-589">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的這項非同步作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-589">An <see cref="T:System.IAsyncResult" /> that represents this asynchronous operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-590">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法，以確定附加作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-590">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method to ensure that the append operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-591">如果在非同步附加期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-591">If an error has occurred during an asynchronous append, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-592">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-592">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-593">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-593">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-594">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</span><span class="sxs-lookup"><span data-stu-id="391e8-594">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="391e8-595">如果附加失敗，就不會保留任何空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-595">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="391e8-596">這個方法通常可以在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-596">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="391e8-597">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-597">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-598">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-598">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-599">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-599">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-600">一或多個引數無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-600">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-601">附加記錄時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-601">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-602">記錄順序無法騰出足夠的可用空間來容納新的記錄或建立保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-602">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-603">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-603">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginWriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-604">開始執行非同步的重新啟動區域寫入作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-604">Begins an asynchronous restart area write operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservation, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginWriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservation As ReservationCollection, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservation, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservation, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservation" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-605">即將串連並附加成記錄的位元組陣列區段。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-605">Byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="391e8-606">新的基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-606">The new base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-607">指定的序號必須大於或等於目前基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-607">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservation">
          <span data-ttu-id="391e8-608">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含此重新啟動區域所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-608">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-609">選擇性的非同步回呼 (Callback)，在重新啟動區域寫入完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-609">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-610">使用者所提供的物件，可區別此特定非同步重新啟動區域寫入要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-610">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-611">使用先前保留在順序中的空間，開始執行非同步的重新啟用區域寫入作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-611">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="391e8-612">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-612">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-613">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步重新啟動區域寫入作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-613">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-614">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-614">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-615">如果在非同步重新啟動區域寫入作業期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-615">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-616">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-616">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-617">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-617">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-618">當這個作業成功完成時，基底序號已經更新。</span><span class="sxs-lookup"><span data-stu-id="391e8-618">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="391e8-619">只要是序號小於新基底序號的所有記錄都無法存取。</span><span class="sxs-lookup"><span data-stu-id="391e8-619">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="391e8-620">如果已指定 <xref:System.IO.Log.ReservationCollection>，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-620">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="391e8-621">如果此方法成功，便會取用可以保存資料的最小保留區，而且該保留區將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-621">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-622">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-622">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-623">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-623">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-624">
            <paramref name="newBaseSeqNum" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-624">
              <paramref name="newBaseSeqNum" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-625">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-625">-or-</span>
          </span>
          <span data-ttu-id="391e8-626">指定的記錄列舉起始序號無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-626">The specified log enumeration start sequence number is invalid.</span>
          </span>
          <span data-ttu-id="391e8-627">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-627">-or-</span>
          </span>
          <span data-ttu-id="391e8-628">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-628">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-629">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-629">-or-</span>
          </span>
          <span data-ttu-id="391e8-630">
            <paramref name="reservation" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-630">
              <paramref name="reservation" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-631">一或多個參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-631">One or more of the parameters is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-632">新的或現有封存結尾或作用中記錄的基底無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-632">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="391e8-633">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-633">-or-</span>
          </span>
          <span data-ttu-id="391e8-634">
            <paramref name="newBaseSeqNum" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-634">
              <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-635">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-635">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-636">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-636">-or-</span>
          </span>
          <span data-ttu-id="391e8-637">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-637">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-638">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-638">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-639">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-639">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-640">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-640">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-641">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-641">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWriteRestartArea">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection * AsyncCallback * obj -&gt; IAsyncResult" Usage="logRecordSequence.BeginWriteRestartArea (data, newBaseSeqNum, reservationCollection, callback, state)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-642">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-642">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="391e8-643">新的基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-643">The new base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-644">指定的序號必須大於或等於目前基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-644">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="391e8-645">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含此重新啟動區域所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-645">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="391e8-646">選擇性的非同步回呼 (Callback)，在重新啟動區域寫入完成時呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-646">An optional asynchronous callback, to be called when the restart area write is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="391e8-647">使用者所提供的物件，可區別此特定非同步重新啟動區域寫入要求與其他要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-647">A user-provided object that distinguishes this particular asynchronous restart area write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-648">使用先前保留在順序中的空間，開始執行非同步的重新啟用區域寫入作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-648">Begins an asynchronous restart area write operation, using space previously reserved in the sequence.</span>
          </span>
          <span data-ttu-id="391e8-649">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-649">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-650">
            <see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步重新啟動區域寫入作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-650">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous restart area write operation, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-651">您應該將這個方法所傳回的 <xref:System.IAsyncResult> 傳遞給 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</span><span class="sxs-lookup"><span data-stu-id="391e8-651">You should pass the <xref:System.IAsyncResult> returned by this method to the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method to ensure that the restart area write operation has completed and resources can be freed appropriately.</span></span> <span data-ttu-id="391e8-652">如果在非同步重新啟動區域寫入作業期間發生錯誤，就要等到系統以這個方法傳回的 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 呼叫 <xref:System.IAsyncResult> 方法時，才會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-652">If an error has occurred during an asynchronous restart area write operation, an exception is not thrown until the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called with the <xref:System.IAsyncResult> returned by this method.</span></span>  
  
 <span data-ttu-id="391e8-653">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-653">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-654">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-654">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-655">當這個作業成功完成時，基底序號已經更新。</span><span class="sxs-lookup"><span data-stu-id="391e8-655">When the operation successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="391e8-656">只要是序號小於新基底序號的所有記錄都無法存取。</span><span class="sxs-lookup"><span data-stu-id="391e8-656">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="391e8-657">如果已指定 <xref:System.IO.Log.ReservationCollection>，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-657">If a <xref:System.IO.Log.ReservationCollection> is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="391e8-658">如果此方法成功，便會取用可以保存資料的最小保留區，而且該保留區將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-658">If the method succeeds, it will consume the smallest reservation that can hold the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-659">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-659">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-660">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-660">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-661">
            <paramref name="newBaseSeqNum" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-661">
              <paramref name="newBaseSeqNum" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-662">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-662">-or-</span>
          </span>
          <span data-ttu-id="391e8-663">指定的記錄列舉起始序號無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-663">The specified log enumeration start sequence number is invalid.</span>
          </span>
          <span data-ttu-id="391e8-664">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-664">-or-</span>
          </span>
          <span data-ttu-id="391e8-665">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-665">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-666">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-666">-or-</span>
          </span>
          <span data-ttu-id="391e8-667">
            <paramref name="reservationCollection" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-667">
              <paramref name="reservationCollection" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-668">一或多個參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-668">One or more of the parameters is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-669">新的或現有封存結尾或作用中記錄的基底無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-669">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="391e8-670">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-670">-or-</span>
          </span>
          <span data-ttu-id="391e8-671">
            <paramref name="newBaseSeqNum" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-671">
              <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-672">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-672">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-673">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-673">-or-</span>
          </span>
          <span data-ttu-id="391e8-674">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-674">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-675">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-675">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-676">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-676">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-677">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-677">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-678">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-678">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateReservationCollection">
      <MemberSignature Language="C#" Value="public System.IO.Log.ReservationCollection CreateReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Log.ReservationCollection CreateReservationCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.CreateReservationCollection" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReservationCollection () As ReservationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::ReservationCollection ^ CreateReservationCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection&#xA;override this.CreateReservationCollection : unit -&gt; System.IO.Log.ReservationCollection" Usage="logRecordSequence.CreateReservationCollection " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.CreateReservationCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.ReservationCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="391e8-679">建立新的 <see cref="T:System.IO.Log.ReservationCollection" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-679">Creates a new <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
          <span data-ttu-id="391e8-680">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-680">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-681">新建立的 <see cref="T:System.IO.Log.ReservationCollection" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-681">The newly created <see cref="T:System.IO.Log.ReservationCollection" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="391e8-682">您可以透過兩種方式執行保留，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="391e8-682">Reservations can be performed in two ways as shown in the following examples.</span></span> <span data-ttu-id="391e8-683">您可以採用範例中的做法進行穩固的處理。</span><span class="sxs-lookup"><span data-stu-id="391e8-683">You can adopt the practices in the samples for robust processing.</span></span> <span data-ttu-id="391e8-684">請注意，您只能在使用 CLFS 的 <xref:System.IO.Log.LogRecordSequence> 類別時執行這項工作。</span><span class="sxs-lookup"><span data-stu-id="391e8-684">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-685">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-685">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logRecordSequence.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="391e8-686">釋放由元件使用的資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-686">Releases the resources used by the component.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="391e8-687">此範例示範如何使用<xref:System.IO.Log.LogRecordSequence.Dispose%2A>釋放資源：</span><span class="sxs-lookup"><span data-stu-id="391e8-687">This example shows how to use <xref:System.IO.Log.LogRecordSequence.Dispose%2A> to release resources:</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 [!code-csharp[S_UELogRecordSequence#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#12)] 
 [!code-vb[S_UELogRecordSequence#12](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#12)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-688">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-688">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-689">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-689">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="391e8-690">未處理的非同步 I/O 要求的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-690">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-691">結束執行非同步的附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-691">Ends an asynchronous append operation.</span>
          </span>
          <span data-ttu-id="391e8-692">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-692">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-693">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-693">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-694">這個方法會封鎖，直到 I/O 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="391e8-694">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="391e8-695">在非同步寫入要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> 時顯示出來。</span><span class="sxs-lookup"><span data-stu-id="391e8-695">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="391e8-696">在 <xref:System.IAsyncResult> 方法傳回的每一個 <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> 上必須剛好呼叫這個方法一次。</span><span class="sxs-lookup"><span data-stu-id="391e8-696">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-697">
            <paramref name="result" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-697">
              <paramref name="result" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-698">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-698">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-699">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-699">-or-</span>
          </span>
          <span data-ttu-id="391e8-700">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-700">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-701">已經針對此非同步作業呼叫 <see langword="End" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-701">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-702">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-702">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-703">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-703">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-704">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-704">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-705">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-705">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-706">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-706">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndFlush(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndFlush (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndFlush(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndFlush : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndFlush result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="391e8-707">未處理的非同步 I/O 要求的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-707">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-708">結束執行非同步的清除作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-708">Ends an asynchronous flush operation.</span>
          </span>
          <span data-ttu-id="391e8-709">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-709">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-710">上一筆寫入之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-710">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-711">這個方法會封鎖，直到 I/O 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="391e8-711">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="391e8-712">在非同步清除要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> 時顯示出來。</span><span class="sxs-lookup"><span data-stu-id="391e8-712">Errors that occur during an asynchronous flush request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndFlush%2A> is called.</span></span>  
  
 <span data-ttu-id="391e8-713">在 <xref:System.IAsyncResult> 方法傳回的每一個 <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> 上必須剛好呼叫這個方法一次。</span><span class="sxs-lookup"><span data-stu-id="391e8-713">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-714">
            <paramref name="result" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-714">
              <paramref name="result" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-715">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-715">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-716">已經針對此非同步作業呼叫 <see langword="End" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-716">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-717">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-717">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-718">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-718">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-719">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-719">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-720">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-720">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-721">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-721">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndReserveAndAppend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReserveAndAppend (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndReserveAndAppend(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndReserveAndAppend : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndReserveAndAppend result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="391e8-722">未處理的非同步 I/O 要求的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-722">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-723">結束執行非同步的保留和附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-723">Ends an asynchronous reserve and append operation.</span>
          </span>
          <span data-ttu-id="391e8-724">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-724">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-725">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-725">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-726">這個方法會封鎖，直到 I/O 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="391e8-726">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="391e8-727">在非同步寫入要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 時顯示出來。</span><span class="sxs-lookup"><span data-stu-id="391e8-727">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> is called.</span></span>  
  
 <span data-ttu-id="391e8-728">在 <xref:System.IAsyncResult> 方法傳回的每一個 <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> 上必須剛好呼叫這個方法一次。</span><span class="sxs-lookup"><span data-stu-id="391e8-728">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-729">
            <paramref name="result" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-729">
              <paramref name="result" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-730">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-730">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-731">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-731">-or-</span>
          </span>
          <span data-ttu-id="391e8-732">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-732">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-733">已經針對此非同步作業呼叫 <see langword="End" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-733">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-734">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-734">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-735">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-735">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-736">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-736">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-737">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-737">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-738">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-738">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber EndWriteRestartArea(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndWriteRestartArea (result As IAsyncResult) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber EndWriteRestartArea(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber&#xA;override this.EndWriteRestartArea : IAsyncResult -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.EndWriteRestartArea result" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <span data-ttu-id="391e8-739">未處理的非同步 I/O 要求的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-739">A reference to the outstanding asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-740">結束執行非同步的重新啟動區域寫入作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-740">Ends an asynchronous restart area write operation.</span>
          </span>
          <span data-ttu-id="391e8-741">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-741">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-742">已寫入之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-742">The sequence number of the written log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-743">這個方法會封鎖，直到 I/O 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="391e8-743">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="391e8-744">在非同步寫入要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會在呼叫 <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> 時顯示出來。</span><span class="sxs-lookup"><span data-stu-id="391e8-744">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, become visible when <xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> is called.</span></span>  
  
 <span data-ttu-id="391e8-745">在 <xref:System.IAsyncResult> 方法傳回的每一個 <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> 上必須剛好呼叫這個方法一次。</span><span class="sxs-lookup"><span data-stu-id="391e8-745">This method must be called exactly once on every <xref:System.IAsyncResult> returned by the <xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-746">
            <paramref name="result" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-746">
              <paramref name="result" /> is not valid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-747">新的或現有封存結尾或作用中記錄的基底無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-747">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-748">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-748">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-749">已經針對此非同步作業呼叫 <see langword="End" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-749">
              <see langword="End" /> has already been called for this asynchronous operation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-750">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-750">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-751">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-751">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-752">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-752">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-753">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-753">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-754">永久地寫入附加的記錄</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-754">Writes appended records durably</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Function Flush () As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : unit -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="391e8-755">確定已寫入所有附加的記錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-755">Ensures that all appended records have been written.</span>
          </span>
          <span data-ttu-id="391e8-756">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-756">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-757">上一筆寫入之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-757">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-758">呼叫這個方法可以確保已永久寫入附加到 <xref:System.IO.Log.LogRecordSequence>的所有記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-758">Calling this method ensures that all records that have been appended to the <xref:System.IO.Log.LogRecordSequence> have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-759">清除資料時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-759">An I/O error occurred while flushing the data.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-760">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-760">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-761">不支援此作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-761">This operation is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-762">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-762">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-763">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-763">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-764">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-764">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-765">指定的記錄沒有任何延伸區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-765">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="391e8-766">必須先建立一或多個延伸區，才能使用記錄順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-766">One or more extents must be created before a record sequence can be used.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber Flush(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber Flush(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="abstract member Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.Flush : System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.Flush sequenceNumber" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="391e8-767">必須寫入之最新記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-767">The sequence number of the latest record that must be written.</span>
          </span>
          <span data-ttu-id="391e8-768">如果這個 <see cref="T:System.IO.Log.SequenceNumber" /> 無效，則必須寫入所有的記錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-768">If this <see cref="T:System.IO.Log.SequenceNumber" /> is invalid, then all records must be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-769">確保已將內含指定序號的所有附加記錄永久寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-769">Ensures that all appended records up to and including the record with the specified sequence number have been durably written.</span>
          </span>
          <span data-ttu-id="391e8-770">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-770">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-771">上一筆寫入之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-771">The sequence number of the last record written.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-772">呼叫這個方法可以確保已將內含指定序號的所有記錄永久寫入。</span><span class="sxs-lookup"><span data-stu-id="391e8-772">Calling this method ensures that all records with sequence numbers up to and including the specified sequence number have been durably written.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-773">
            <paramref name="sequenceNumber" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-773">
              <paramref name="sequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-774">
            <paramref name="sequenceNumber" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-774">
              <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-775">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-775">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-776">指定的記錄沒有任何延伸區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-776">The specified log does not have any extents.</span>
          </span>
          <span data-ttu-id="391e8-777">必須先建立一或多個延伸區，才能使用記錄順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-777">One or more extents must be created before a record sequence can be used.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-778">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-778">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-779">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-779">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-780">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-780">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-781">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-781">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-782">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-782">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.LastSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-783">取得大於上一筆附加記錄的序號</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-783">Gets the sequence number which is greater than the last record appended</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="391e8-784">大於上一筆附加記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-784">A sequence number which is greater than the last record appended.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-785">這個屬性包含保證大於上一個附加記錄之序號的序號。</span><span class="sxs-lookup"><span data-stu-id="391e8-785">This property contains a sequence number that is guaranteed to be larger than the sequence number of the last appended record.</span></span> <span data-ttu-id="391e8-786">有效的序號會大於或等於 <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>，而且小於 <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>。</span><span class="sxs-lookup"><span data-stu-id="391e8-786">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</span></span> <span data-ttu-id="391e8-787">其他所有序號全都無效。</span><span class="sxs-lookup"><span data-stu-id="391e8-787">All other sequence numbers are invalid.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-788">已在處置序列之後存取此屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-788">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="LogStore">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogStore LogStore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogStore LogStore" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.LogStore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStore As LogStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogStore ^ LogStore { System::IO::Log::LogStore ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStore : System.IO.Log.LogStore" Usage="System.IO.Log.LogRecordSequence.LogStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-789">取得 <see cref="T:System.IO.Log.LogStore" />，包含這個記錄順序的資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-789">Gets the <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span>
          </span>
          <span data-ttu-id="391e8-790">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-790">This method cannot be inherited.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="391e8-791">
            <see cref="T:System.IO.Log.LogStore" />，包含這個記錄順序的資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-791">The <see cref="T:System.IO.Log.LogStore" /> that contains the data for this record sequence.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="391e8-792">這個範例會示範如何使用 <xref:System.IO.Log.LogRecordSequence.LogStore%2A> 成員來新增延伸區。</span><span class="sxs-lookup"><span data-stu-id="391e8-792">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.LogStore%2A> member to add extents.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#11)]
 [!code-vb[S_UELogRecordSequence#11](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumRecordLength">
      <MemberSignature Language="C#" Value="public long MaximumRecordLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumRecordLength" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaximumRecordLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumRecordLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumRecordLength : int64" Usage="System.IO.Log.LogRecordSequence.MaximumRecordLength" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.MaximumRecordLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-793">取得可以新增至這個記錄順序的記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-793">Gets the maximum size of a record that can be added to this record sequence.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="391e8-794">可以新增至這個記錄順序的記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-794">The maximum size of a record that can be added to this record sequence.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLogRecords">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadLogRecords(valuetype System.IO.Log.SequenceNumber start, valuetype System.IO.Log.LogRecordEnumeratorType logRecordEnum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLogRecords (start As SequenceNumber, logRecordEnum As LogRecordEnumeratorType) As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadLogRecords(System::IO::Log::SequenceNumber start, System::IO::Log::LogRecordEnumeratorType logRecordEnum);" />
      <MemberSignature Language="F#" Value="abstract member ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadLogRecords : System.IO.Log.SequenceNumber * System.IO.Log.LogRecordEnumeratorType -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadLogRecords (start, logRecordEnum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="logRecordEnum" Type="System.IO.Log.LogRecordEnumeratorType" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="391e8-795">開始讀取之第一筆記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-795">The sequence number of the first record where the reading starts.</span>
          </span>
        </param>
        <param name="logRecordEnum">
          <span data-ttu-id="391e8-796">
            <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> 的有效值，其中指定從 <see cref="T:System.IO.Log.LogRecordSequence" /> 讀取記錄的方式 (即往前或往後讀取)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-796">A valid <see cref="T:System.IO.Log.LogRecordEnumeratorType" /> value that specifies the manner (that is, forward or backward) in which records should be read from a <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-797">傳回順序中之記錄的可列舉集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-797">Returns an enumerable collection of records in the sequence.</span>
          </span>
          <span data-ttu-id="391e8-798">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-798">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-799">順序中的記錄的可列舉集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-799">An enumerable collection of records in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-800">這個方法會傳回順序中之記錄的可列舉集合。</span><span class="sxs-lookup"><span data-stu-id="391e8-800">This method returns an enumerable collection of records in the sequence.</span></span> <span data-ttu-id="391e8-801">列舉的記錄順序取決於 `logRecordEnum` 參數的值。</span><span class="sxs-lookup"><span data-stu-id="391e8-801">The order of the enumerated records depends on the value of the `logRecordEnum` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-802">這個範例會說明如何在迴圈中使用 <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A>。</span><span class="sxs-lookup"><span data-stu-id="391e8-802">This example shows how to use <xref:System.IO.Log.LogRecordSequence.ReadLogRecords%2A> in a loop.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mymultiplexlog.cs#10)]
 [!code-vb[S_UELogRecordSequence#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mymultiplexlog.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-803">
            <paramref name="start" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-803">
              <paramref name="start" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-804">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-804">-or-</span>
          </span>
          <span data-ttu-id="391e8-805">
            <paramref name="logRecordEnum" /> 無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-805">
              <paramref name="logRecordEnum" /> is invalid.</span>
          </span>
          <span data-ttu-id="391e8-806">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-806">-or-</span>
          </span>
          <span data-ttu-id="391e8-807">在集合中找不到特定的項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-807">The specified element was not found in the collection.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-808">
            <paramref name="start" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-808">
              <paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-809">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-809">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-810">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-810">-or-</span>
          </span>
          <span data-ttu-id="391e8-811">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-811">The request could not be performed because of an I/O device error.</span>
          </span>
          <span data-ttu-id="391e8-812">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-812">-or</span>
          </span>
          <span data-ttu-id="391e8-813">用來寫入記錄的緩衝區大小，大於用來讀取記錄的緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-813">The buffer size used to write the log record is larger than the buffer size being used to read it.</span>
          </span>
          <span data-ttu-id="391e8-814">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-814">-or-</span>
          </span>
          <span data-ttu-id="391e8-815">記錄順序已損毀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-815">The record sequence is corrupted.</span>
          </span>
          <span data-ttu-id="391e8-816">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-816">-or-</span>
          </span>
          <span data-ttu-id="391e8-817">指定的記錄檔格式或版本無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-817">The specified log file format or version is invalid.</span>
          </span>
          <span data-ttu-id="391e8-818">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-818">-or-</span>
          </span>
          <span data-ttu-id="391e8-819">記錄是以不相容的記錄順序版本所寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-819">The record was written with an incompatible version of the record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-820">因為列舉尚未啟動，因此作業無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-820">The operation is invalid because the enumeration has not been started.</span>
          </span>
          <span data-ttu-id="391e8-821">必須呼叫 <see cref="M:System.Collections.IEnumerator.MoveNext" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-821">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-822">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-822">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-823">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-823">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-824">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-824">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadRestartAreas">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt; ReadRestartAreas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.Log.LogRecord&gt; ReadRestartAreas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReadRestartAreas" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadRestartAreas () As IEnumerable(Of LogRecord)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::IO::Log::LogRecord ^&gt; ^ ReadRestartAreas();" />
      <MemberSignature Language="F#" Value="abstract member ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;&#xA;override this.ReadRestartAreas : unit -&gt; seq&lt;System.IO.Log.LogRecord&gt;" Usage="logRecordSequence.ReadRestartAreas " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReadRestartAreas</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.Log.LogRecord&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="391e8-825">傳回序列中重新啟動區域的可列舉集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-825">Returns an enumerable collection of the restart areas in the sequence.</span>
          </span>
          <span data-ttu-id="391e8-826">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-826">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-827">順序中的重新啟動區域的可列舉集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-827">An enumerable collection of the restart areas in the sequence.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-828">列舉重新啟動區域的方式是依照序號的相反順序列舉，也就是由最大序號到最小序號。</span><span class="sxs-lookup"><span data-stu-id="391e8-828">The restart areas are enumerated in reverse sequence number order, that is, from the highest sequence number to the lowest sequence number.</span></span> <span data-ttu-id="391e8-829">只會列舉含有介於最後一個序號和基底序號之間序號的重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-829">Only restart areas with sequence numbers between the last sequence number and the base sequence number are enumerated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-830">
            <paramref name="start" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-830">
              <paramref name="start" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-831">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-831">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-832">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-832">-or-</span>
          </span>
          <span data-ttu-id="391e8-833">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-833">The request could not be performed because of an I/O device error.</span>
          </span>
          <span data-ttu-id="391e8-834">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-834">-or</span>
          </span>
          <span data-ttu-id="391e8-835">用來寫入記錄的緩衝區大小，大於用來讀取記錄的緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-835">The buffer size used to write the log record is larger than the buffer size being used to read it.</span>
          </span>
          <span data-ttu-id="391e8-836">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-836">-or-</span>
          </span>
          <span data-ttu-id="391e8-837">記錄順序已損毀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-837">The record sequence is corrupted.</span>
          </span>
          <span data-ttu-id="391e8-838">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-838">-or-</span>
          </span>
          <span data-ttu-id="391e8-839">指定的記錄檔格式或版本無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-839">The specified log file format or version is invalid.</span>
          </span>
          <span data-ttu-id="391e8-840">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-840">-or-</span>
          </span>
          <span data-ttu-id="391e8-841">記錄是以不相容的記錄順序版本所寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-841">The record was written with an incompatible version of the record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="391e8-842">因為列舉尚未啟動，因此作業無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-842">The operation is invalid because the enumeration has not been started.</span>
          </span>
          <span data-ttu-id="391e8-843">必須呼叫 <see cref="M:System.Collections.IEnumerator.MoveNext" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-843">A call to <see cref="M:System.Collections.IEnumerator.MoveNext" /> must be made.</span>
          </span>
          <span data-ttu-id="391e8-844">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-844">-or</span>
          </span>
          <span data-ttu-id="391e8-845">列舉已經結束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-845">The enumeration has ended.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-846">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-846">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-847">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-847">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-848">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-848">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReserveAndAppend">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-849">自動建立單一保留區，並將記錄附加至順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-849">Automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber nextUndoRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber nextUndoRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, nextUndoRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="nextUndoRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-850">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-850">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="nextUndoRecord">
          <span data-ttu-id="391e8-851">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-851">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-852">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-852">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-853">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-853">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="391e8-854">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含要在其中建立保留區的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-854">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-855">要建立的保留區 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-855">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-856">自動建立單一保留區，並將記錄附加至順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-856">Automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
          <span data-ttu-id="391e8-857">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-857">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-858">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-858">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-859">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-859">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-860">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-860">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-861">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</span><span class="sxs-lookup"><span data-stu-id="391e8-861">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="391e8-862">如果附加失敗，就不會保留任何空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-862">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="391e8-863">這個方法通常可以在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-863">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="391e8-864">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-864">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-865">下列範例顯示如何使用這個方法來建立保留區。</span><span class="sxs-lookup"><span data-stu-id="391e8-865">The following example shows how to use this method to make reservations.</span></span> <span data-ttu-id="391e8-866">請注意，您只能在使用 CLFS 的 <xref:System.IO.Log.LogRecordSequence> 類別時執行這項工作。</span><span class="sxs-lookup"><span data-stu-id="391e8-866">Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-867">
            <paramref name="nextUndoRecord" /> 或 <paramref name="previousRecord" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-867">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-868">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-868">-or-</span>
          </span>
          <span data-ttu-id="391e8-869">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-869">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-870">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-870">-or-</span>
          </span>
          <span data-ttu-id="391e8-871">
            <paramref name="reservations" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-871">
              <paramref name="reservations" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-872">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-872">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-873">
            <paramref name="nextUndoRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-873">
              <paramref name="nextUndoRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-874">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-874">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-875">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-875">-or-</span>
          </span>
          <span data-ttu-id="391e8-876">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-876">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-877">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-877">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-878">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-878">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-879">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-879">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-880">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-880">The record sequence is full.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-881">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-881">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="391e8-882">在 <paramref name="data" /> 找不到有足夠空間可以容納 <paramref name="reservations" /> 的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-882">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveAndAppend">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, params long[] reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber ReserveAndAppend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber userRecord, valuetype System.IO.Log.SequenceNumber previousRecord, valuetype System.IO.Log.RecordAppendOptions recordAppendOptions, class System.IO.Log.ReservationCollection reservationCollection, int64[] reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber ReserveAndAppend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber userRecord, System::IO::Log::SequenceNumber previousRecord, System::IO::Log::RecordAppendOptions recordAppendOptions, System::IO::Log::ReservationCollection ^ reservationCollection, ... cli::array &lt;long&gt; ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber&#xA;override this.ReserveAndAppend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber * System.IO.Log.RecordAppendOptions * System.IO.Log.ReservationCollection * int64[] -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.ReserveAndAppend (data, userRecord, previousRecord, recordAppendOptions, reservationCollection, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="userRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="previousRecord" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="recordAppendOptions" Type="System.IO.Log.RecordAppendOptions" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
        <Parameter Name="reservations" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-883">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-883">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="userRecord">
          <span data-ttu-id="391e8-884">下一筆記錄的序號 (依照使用者指定的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-884">The sequence number of the next record in the user-specified order.</span>
          </span>
        </param>
        <param name="previousRecord">
          <span data-ttu-id="391e8-885">下一筆記錄的序號 (依照之前的順序)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-885">The sequence number of the next record in Previous order.</span>
          </span>
        </param>
        <param name="recordAppendOptions">
          <span data-ttu-id="391e8-886">
            <see cref="T:System.IO.Log.RecordAppendOptions" /> 的有效值，其中指定資料的寫入方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-886">A valid value of <see cref="T:System.IO.Log.RecordAppendOptions" /> that specifies how the data should be written.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="391e8-887">要在其中建立保留區的保留區集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-887">The reservation collection to make reservations in.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-888">要建立的保留區 (以位元組為單位)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-888">The reservations to make, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-889">自動建立單一保留區，並將記錄附加至順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-889">Automatically makes a single reservation and appends a record to the sequence.</span>
          </span>
          <span data-ttu-id="391e8-890">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-890">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-891">已附加之記錄的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-891">The sequence number of the appended log record.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-892">包含在 `data` 參數中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-892">Data contained in the `data` parameter will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-893">不過，在讀取記錄時，並不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-893">However, no provision is made for splitting data back into array segments when the record is read.</span></span>  
  
 <span data-ttu-id="391e8-894">指定的保留區會在不可部分完成的作業 (Atomic Operation) 與記錄附加作業中，加入至提供的保留區集合。</span><span class="sxs-lookup"><span data-stu-id="391e8-894">The specified reservations are added to the provided reservation collection in an atomic operation with a record append operation.</span></span> <span data-ttu-id="391e8-895">如果附加失敗，就不會保留任何空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-895">If the append fails, no space is reserved.</span></span>  
  
 <span data-ttu-id="391e8-896">這個方法通常可以在寫入記錄前完成。</span><span class="sxs-lookup"><span data-stu-id="391e8-896">Normally, this method may complete before the record has been written.</span></span> <span data-ttu-id="391e8-897">若要確定已寫入某筆記錄，請使用 <xref:System.IO.Log.RecordAppendOptions.ForceFlush> 參數指定 `recordAppendOptions` 旗標，或是呼叫 <xref:System.IO.Log.LogRecordSequence.Flush%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="391e8-897">To ensure that a record has been written, either specify the <xref:System.IO.Log.RecordAppendOptions.ForceFlush> flag using the `recordAppendOptions` parameter, or call the <xref:System.IO.Log.LogRecordSequence.Flush%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-898">一或多個引數無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-898">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-899">附加記錄時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-899">An I/O error occurred while appending the record.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-900">記錄順序無法騰出足夠的可用空間來容納新的記錄或建立保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-900">The record sequence could not make enough free space to contain the new record, or to make the reservation.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-901">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-901">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-902">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-902">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-903">
            <paramref name="userRecord" /> 或 <paramref name="previousRecord" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-903">
              <paramref name="userRecord" /> or <paramref name="previousRecord" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="391e8-904">記錄順序是以唯讀存取所開啟，無法執行作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-904">The operation cannot be performed because the record sequence was opened with read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-905">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-905">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-906">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-906">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.ReservationNotFoundException">
          <span data-ttu-id="391e8-907">在 <paramref name="data" /> 找不到有足夠空間可以容納 <paramref name="reservations" /> 的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-907">No reservation large enough to fit <paramref name="data" /> can be found in <paramref name="reservations" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReservedBytes">
      <MemberSignature Language="C#" Value="public long ReservedBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ReservedBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReservedBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ReservedBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.ReservedBytes : int64" Usage="System.IO.Log.LogRecordSequence.ReservedBytes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.ReservedBytes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-908">取得保留的位元組總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-908">Gets the total number of bytes that have been reserved.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="391e8-909">在此記錄順序中建立之所有保留區的總共大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-909">The total size of all reservations made in this record sequence.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-910">已在處置序列之後存取此屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-910">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestartSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber RestartSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestartSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber RestartSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.RestartSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogRecordSequence.RestartSequenceNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RestartSequenceNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-911">取得最接近記錄結尾之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-911">Gets the sequence number of the restart area closest to the end of the log.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="391e8-912">最接近記錄結尾之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-912">The sequence number of the restart area closest to the end of the log.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-913">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-913">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-914">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-914">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-915">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-915">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-916">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-916">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-917">使用 <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> 方法，您就可以移除最近寫入的重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-917">Using the <xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A> method, you can remove the most recently written restart area.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-918">已在處置序列之後存取此屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-918">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RetryAppend">
      <MemberSignature Language="C#" Value="public bool RetryAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RetryAppend" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property RetryAppend As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RetryAppend { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RetryAppend : bool with get, set" Usage="System.IO.Log.LogRecordSequence.RetryAppend" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IO.Log.IRecordSequence.RetryAppend</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-919">取得或設定值，這個值表示是否在記錄已滿時自動重試附加作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-919">Gets or sets a value indicating whether or not appends are automatically retried if the log is full.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="391e8-920">如果要在記錄檔已滿時自動重試附加作業，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-920">
              <see langword="true" /> if appends are automatically retried if the log is full; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="391e8-921">預設值為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-921">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-922">如果這個屬性的值是 `true`，且 <xref:System.IO.Log.LogRecordSequence.Append%2A> 呼叫因為順序中的空間不足而失敗，記錄順序將會嘗試釋放空間，並重試附加作業。</span><span class="sxs-lookup"><span data-stu-id="391e8-922">If the value of this property is `true`, and an <xref:System.IO.Log.LogRecordSequence.Append%2A> call fails because there is not enough space in the sequence, the record sequence will try to free space and retry the append.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-923">這個範例會說明如何使用 <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="391e8-923">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.RetryAppend%2A> property.</span></span>  
  
 [!code-csharp[S_UELogRecordSequence#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uelogrecordsequence/cs/mylogrecordsequence.cs#3)]
 [!code-vb[S_UELogRecordSequence#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_uelogrecordsequence/vb/mylogrecordsequence.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-924">已在處置序列之後存取此屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-924">The property was accessed after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLastRecord">
      <MemberSignature Language="C#" Value="public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetLastRecord(valuetype System.IO.Log.SequenceNumber sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetLastRecord(System::IO::Log::SequenceNumber sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.SetLastRecord : System.IO.Log.SequenceNumber -&gt; unit" Usage="logRecordSequence.SetLastRecord sequenceNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sequenceNumber" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="sequenceNumber">
          <span data-ttu-id="391e8-925">
            <see cref="T:System.IO.Log.LogRecordSequence" /> 中最新的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-925">The new last sequence number in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="391e8-926">這指的是目前在記錄中的最新有效記錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-926">This should refer to a current valid record   currently in the log.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-927">設定 <see cref="T:System.IO.Log.LogRecordSequence" /> 中的最後一個記錄。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-927">Sets the last record in the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-928">指定的序號必須大於基底序號。</span><span class="sxs-lookup"><span data-stu-id="391e8-928">The specified sequence number must be larger than the base sequence number.</span></span>  
  
 <span data-ttu-id="391e8-929">當這個方法完成時，先前附加序號大於指定序號的所有記錄會變成不可存取。</span><span class="sxs-lookup"><span data-stu-id="391e8-929">When this method completes, all records that had previously been appended with sequence numbers greater than the specified sequence number are inaccessible.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-930">
            <paramref name="sequenceNumber" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-930">
              <paramref name="sequenceNumber" /> is not valid for this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-931">新的或現有封存結尾或作用中記錄的基底無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-931">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="391e8-932">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-932">-or-</span>
          </span>
          <span data-ttu-id="391e8-933">
            <paramref name="sequenceNumber" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-933">
              <paramref name="sequenceNumber" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-934">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-934">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-935">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-935">-or-</span>
          </span>
          <span data-ttu-id="391e8-936">已經達到記錄的結尾。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-936">The end of the log has been reached.</span>
          </span>
          <span data-ttu-id="391e8-937">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-937">-or-</span>
          </span>
          <span data-ttu-id="391e8-938">指定的記錄檔格式或版本無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-938">The specified log file format or version is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-939">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-939">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-940">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-940">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-941">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-941">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TailPinned">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; TailPinned;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IO.Log.TailPinnedEventArgs&gt; TailPinned" />
      <MemberSignature Language="DocId" Value="E:System.IO.Log.LogRecordSequence.TailPinned" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TailPinned As EventHandler(Of TailPinnedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler&lt;System::IO::Log::TailPinnedEventArgs ^&gt; ^ TailPinned;" />
      <MemberSignature Language="F#" Value="member this.TailPinned : EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " Usage="member this.TailPinned : System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.IO.Log.IRecordSequence.TailPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IO.Log.TailPinnedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-942">標示需要移動順序結尾。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-942">Signals the need to move the tail of the sequence.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-943">您可以在記錄順序的空間用完時引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="391e8-943">You can fire this event when the record sequence has run out of space.</span></span> <span data-ttu-id="391e8-944">這個事件一經引發，就會將順序的結尾 (即基底序號) 往前移動以釋放空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-944">When this event is fired, the tail of the sequence (that is, the base sequence number) is moved forward to free up space.</span></span>  
  
 <span data-ttu-id="391e8-945">當記錄順序基於任何理由決定必須釋放空間時，隨時都可以引發這個事件。</span><span class="sxs-lookup"><span data-stu-id="391e8-945">The event can be fired at any time when the record sequence decides that it must free up space, for any reason.</span></span> <span data-ttu-id="391e8-946">例如，當 CLFS 原則引擎判斷兩個共用同一記錄檔之記錄用戶端的結尾相距過遠時，就可能會決定引發事件。</span><span class="sxs-lookup"><span data-stu-id="391e8-946">For example, the CLFS policy engine may decide to fire the event when it determines that the tails of two log clients sharing the same log file are too far apart.</span></span> <span data-ttu-id="391e8-947">寫入重新啟動區域，或是截斷記錄檔並使用 <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 方法清除空間，都可以達到釋放空間的目的。</span><span class="sxs-lookup"><span data-stu-id="391e8-947">Freeing space can be done by either writing restart areas, or truncating the log and using the <xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> method to clear space.</span></span> <span data-ttu-id="391e8-948">＜範例＞一節中，程式碼範例會示範其第二種處理方式。</span><span class="sxs-lookup"><span data-stu-id="391e8-948">The code sample in the Example section demonstrates the second approach.</span></span>  
  
 <span data-ttu-id="391e8-949">您也可以在 <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> 事件外部呼叫 <xref:System.IO.Log.LogRecordSequence.TailPinned> 方法來釋放空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-949">You can also call the <xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> method outside of the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free space.</span></span> <span data-ttu-id="391e8-950">重新啟動區域類似於其他記錄處理系統中的檢查點。</span><span class="sxs-lookup"><span data-stu-id="391e8-950">A restart area is similar to a checkpoint in other log processing systems.</span></span> <span data-ttu-id="391e8-951">呼叫這個方法，就表示應用程式會將所有在重新啟動區域之前的記錄都視為完全完成，而且可供日後附加記錄之用。</span><span class="sxs-lookup"><span data-stu-id="391e8-951">Calling this method indicates that the application considers all prior records before the restart area as fully completed, and usable for future record appends.</span></span> <span data-ttu-id="391e8-952">與任何其他記錄相同，這個方法所寫入的記錄必須在記錄檔中有實際的可用空間，才會正常運作。</span><span class="sxs-lookup"><span data-stu-id="391e8-952">Similar to any other records, the record written by this method requires actual free space in the log to function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="391e8-953">這個範例會說明如何使用 <xref:System.IO.Log.LogRecordSequence.TailPinned> 事件。</span><span class="sxs-lookup"><span data-stu-id="391e8-953">This example shows how to use the <xref:System.IO.Log.LogRecordSequence.TailPinned> event.</span></span>  
  
```  
recordSequence.RetryAppend = true;  
recordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  
  
void HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  
{  
   // tailPinnedEventArgs.TargetSequenceNumber is the target   
   // sequence number to free up space to.    
   // However, this sequence number is not necessarily valid.  We have  
   // to use this sequence number as a starting point for finding a  
   // valid point within the log to advance toward. You need to  
   // identify a record with a sequence number equal to, or greater  
   // than TargetSequenceNumber; let's call this   
   // realTargetSequenceNumber. Once found, move the base  
  
   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  
  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRestartArea">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="391e8-954">將重新啟動區域寫入 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-954">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-955">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-955">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-956">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-956">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-957">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-957">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-958">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-958">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-959">您可以使用 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 方法來讀取重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-959">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte)) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-960">即將串連並附加成記錄的陣列區段。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-960">An array segment that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-961">將重新啟動區域寫入 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-961">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="391e8-962">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-962">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-963">寫入之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-963">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-964">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-964">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-965">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-965">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-966">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-966">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-967">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-967">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-968">您可以使用 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 方法來讀取重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-968">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-969">位元組陣列區段中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-969">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-970">在讀取重新啟動區域時，不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-970">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-971">一或多個引數無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-971">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-972">寫入重新啟動區域時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-972">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-973">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-973">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-974">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-974">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-975">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-975">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-976">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-976">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-977">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-977">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte))) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea data" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-978">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-978">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-979">將重新啟動區域寫入 <see cref="T:System.IO.Log.LogRecordSequence" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-979">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" />.</span>
          </span>
          <span data-ttu-id="391e8-980">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-980">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-981">寫入之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-981">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-982">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-982">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-983">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-983">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-984">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-984">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-985">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-985">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-986">您可以使用 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 方法來讀取重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-986">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-987">位元組陣列區段中的資料將串連至單一位元組陣列中，以便附加成記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-987">The data in the byte array segments will be concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-988">在讀取重新啟動區域時，不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-988">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-989">一或多個引數無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-989">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-990">寫入重新啟動區域時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-990">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-991">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-991">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-992">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-992">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-993">一或多個引數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-993">One or more of the arguments are <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-994">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-994">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-995">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-995">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-996">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-996">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="391e8-997">新的基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-997">The new base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-998">指定的序號必須大於或等於目前基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-998">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-999">將重新啟動區域寫入 <see cref="T:System.IO.Log.LogRecordSequence" />，並更新基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-999">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-1000">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1000">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-1001">寫入之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1001">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-1002">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-1002">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-1003">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-1003">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-1004">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-1004">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-1005">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-1005">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-1006">您可以使用 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 方法來讀取重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-1006">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-1007">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-1007">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-1008">在讀取重新啟動區域時，不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-1008">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="391e8-1009">當這個方法成功完成時，基底序號已經更新。</span><span class="sxs-lookup"><span data-stu-id="391e8-1009">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="391e8-1010">只要是序號小於新基底序號的所有記錄都無法存取。</span><span class="sxs-lookup"><span data-stu-id="391e8-1010">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="391e8-1011">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1011">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-1012">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1012">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-1013">一或多個引數無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1013">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-1014">寫入重新啟動區域時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1014">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-1015">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1015">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-1016">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1016">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As IList(Of ArraySegment(Of Byte)), newBaseSeqNum As SequenceNumber) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-1017">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1017">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="391e8-1018">新的基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1018">The new base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-1019">指定的序號必須大於或等於目前基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1019">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-1020">將重新啟動區域寫入 <see cref="T:System.IO.Log.LogRecordSequence" />，並更新基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1020">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-1021">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1021">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-1022">寫入之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1022">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-1023">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-1023">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-1024">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-1024">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-1025">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-1025">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-1026">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-1026">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-1027">您可以使用 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 方法來讀取重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-1027">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-1028">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-1028">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-1029">在讀取重新啟動區域時，不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-1029">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="391e8-1030">當這個方法成功完成時，基底序號已經更新。</span><span class="sxs-lookup"><span data-stu-id="391e8-1030">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="391e8-1031">只要是序號小於新基底序號的所有記錄都無法存取。</span><span class="sxs-lookup"><span data-stu-id="391e8-1031">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="391e8-1032">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1032">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-1033">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1033">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-1034">一或多個引數無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1034">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-1035">寫入重新啟動區域時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1035">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-1036">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1036">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-1037">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1037">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment&lt;byte&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(valuetype System.ArraySegment`1&lt;unsigned int8&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteRestartArea (data As ArraySegment(Of Byte), newBaseSeqNum As SequenceNumber, reservations As ReservationCollection) As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(ArraySegment&lt;System::Byte&gt; data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservations);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : ArraySegment&lt;byte&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservations)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ArraySegment&lt;System.Byte&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservations" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-1038">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1038">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="391e8-1039">新的基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1039">The new base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-1040">指定的序號必須大於或等於目前基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1040">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservations">
          <span data-ttu-id="391e8-1041">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含此重新啟動區域所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1041">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-1042">使用保留區將重新啟動區域寫入 <see cref="T:System.IO.Log.LogRecordSequence" />，並更新基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1042">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-1043">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1043">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-1044">寫入之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1044">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-1045">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-1045">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-1046">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-1046">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-1047">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-1047">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-1048">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-1048">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-1049">您可以使用 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 方法來讀取重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-1049">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-1050">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-1050">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-1051">在讀取重新啟動區域時，不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-1051">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="391e8-1052">如果已指定保留區，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-1052">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="391e8-1053">如果此方法成功，便會取用可以容納資料的最小保留區，而且該保留區將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-1053">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-1054">當這個方法成功完成時，基底序號已經更新。</span><span class="sxs-lookup"><span data-stu-id="391e8-1054">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="391e8-1055">只要是序號小於新基底序號的所有記錄都無法存取。</span><span class="sxs-lookup"><span data-stu-id="391e8-1055">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="391e8-1056">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1056">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-1057">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1057">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-1058">一或多個引數無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1058">One or more of the arguments is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-1059">寫入重新啟動區域時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1059">An I/O error occurred while writing the restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-1060">記錄順序無法騰出足夠的可用空間來容納新的重新啟動區域。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1060">The record sequence could not make enough free space to contain the new restart area.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-1061">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1061">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteRestartArea">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.IO.Log.SequenceNumber WriteRestartArea(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; data, valuetype System.IO.Log.SequenceNumber newBaseSeqNum, class System.IO.Log.ReservationCollection reservationCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Log::SequenceNumber WriteRestartArea(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ data, System::IO::Log::SequenceNumber newBaseSeqNum, System::IO::Log::ReservationCollection ^ reservationCollection);" />
      <MemberSignature Language="F#" Value="abstract member WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber&#xA;override this.WriteRestartArea : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.IO.Log.SequenceNumber * System.IO.Log.ReservationCollection -&gt; System.IO.Log.SequenceNumber" Usage="logRecordSequence.WriteRestartArea (data, newBaseSeqNum, reservationCollection)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="newBaseSeqNum" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="reservationCollection" Type="System.IO.Log.ReservationCollection" />
      </Parameters>
      <Docs>
        <param name="data">
          <span data-ttu-id="391e8-1062">即將串連並附加成記錄之位元組陣列區段的清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1062">A list of byte array segments that will be concatenated and appended as the record.</span>
          </span>
        </param>
        <param name="newBaseSeqNum">
          <span data-ttu-id="391e8-1063">新的基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1063">The new base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-1064">指定的序號必須大於或等於目前基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1064">The specified sequence number must be greater than or equal to the current base sequence number.</span>
          </span>
        </param>
        <param name="reservationCollection">
          <span data-ttu-id="391e8-1065">
            <see cref="T:System.IO.Log.ReservationCollection" />，其中包含此重新啟動區域所應使用的保留區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1065">A <see cref="T:System.IO.Log.ReservationCollection" /> that contains the reservation that should be used for this restart area.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="391e8-1066">使用保留區將重新啟動區域寫入 <see cref="T:System.IO.Log.LogRecordSequence" />，並更新基底序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1066">Writes a restart area to the <see cref="T:System.IO.Log.LogRecordSequence" /> using a reservation, and updates the base sequence number.</span>
          </span>
          <span data-ttu-id="391e8-1067">這個方法無法被繼承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1067">This method cannot be inherited.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="391e8-1068">寫入之重新啟動區域的序號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1068">The sequence number of the written restart area.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="391e8-1069">重新啟動區域可用來暫時儲存包含用戶端上一個檢查點作業的資訊。</span><span class="sxs-lookup"><span data-stu-id="391e8-1069">A restart area is used to temporarily store information containing a client's last checkpoint operation.</span></span> <span data-ttu-id="391e8-1070">一般記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證至少有一個有效區域永遠可供使用。</span><span class="sxs-lookup"><span data-stu-id="391e8-1070">The Common Log File System (CLFS) maintains two restart areas to guarantee that at least one valid area is always available.</span></span> <span data-ttu-id="391e8-1071">當需要復原時，CLFS 會讀取其重新啟動區域，以及上一個檢查點作業傳回的所有資料。</span><span class="sxs-lookup"><span data-stu-id="391e8-1071">When a recovery is necessary, the CLFS reads its restart area and all the data from the last checkpoint operation.</span></span> <span data-ttu-id="391e8-1072">這些資料會初始化異動資料表、中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。</span><span class="sxs-lookup"><span data-stu-id="391e8-1072">This data initializes the transaction table, dirty pages table, and open file table so they can be used in the recovery process.</span></span>  
  
 <span data-ttu-id="391e8-1073">您可以使用 <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> 方法來讀取重新啟動區域。</span><span class="sxs-lookup"><span data-stu-id="391e8-1073">A restart area can be read using the <xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A> method.</span></span>  
  
 <span data-ttu-id="391e8-1074">當寫入重新啟動區域時，位元組陣列區段中的資料會串連至單一位元組陣列，以便附加為記錄。</span><span class="sxs-lookup"><span data-stu-id="391e8-1074">When a restart area is written, the data in the byte array segments are concatenated into a single byte array for appending as the record.</span></span> <span data-ttu-id="391e8-1075">在讀取重新啟動區域時，不會將資料分割回陣列區段。</span><span class="sxs-lookup"><span data-stu-id="391e8-1075">No provision is made for splitting data back into array segments when the restart area is read.</span></span>  
  
 <span data-ttu-id="391e8-1076">如果已指定保留區，寫入的重新啟動區域將會使用包含在集合中的保留區，以取用先前所保留的空間。</span><span class="sxs-lookup"><span data-stu-id="391e8-1076">If a reservation is specified, the written restart area will consume space that has been previously reserved, using a reservation contained in the collection.</span></span> <span data-ttu-id="391e8-1077">如果此方法成功，便會取用可以容納資料的最小保留區，而且該保留區將會從集合移除。</span><span class="sxs-lookup"><span data-stu-id="391e8-1077">If the method succeeds, it will consume the smallest reservation that can contain the data, and that reservation will be removed from the collection.</span></span>  
  
 <span data-ttu-id="391e8-1078">當這個方法成功完成時，基底序號已經更新。</span><span class="sxs-lookup"><span data-stu-id="391e8-1078">When this method successfully completes, the base sequence number has been updated.</span></span> <span data-ttu-id="391e8-1079">只要是序號小於新基底序號的所有記錄都無法存取。</span><span class="sxs-lookup"><span data-stu-id="391e8-1079">All log records with sequence numbers less than the new base sequence number are inaccessible.</span></span>  
  
 <span data-ttu-id="391e8-1080">如果處置了記錄順序，或是您傳遞了無效的引數，就會立即在此作業中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1080">If a record sequence has been disposed of, or if you pass an invalid argument, exceptions are thrown immediately within this operation.</span></span> <span data-ttu-id="391e8-1081">在非同步附加要求期間發生的錯誤 (例如，在 I/O 要求期間發生的磁碟錯誤) 會導致在呼叫 <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> 方法時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="391e8-1081">Errors that occurred during an asynchronous append request, for example, a disk failure during the I/O request, will result in exceptions being thrown when the <xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> method is called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="391e8-1082">
            <paramref name="newBaseSeqNum" /> 對此順序無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1082">
              <paramref name="newBaseSeqNum" /> is not valid for this sequence.</span>
          </span>
          <span data-ttu-id="391e8-1083">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1083">-or-</span>
          </span>
          <span data-ttu-id="391e8-1084">指定的記錄列舉起始序號無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1084">The specified log enumeration start sequence number is invalid.</span>
          </span>
          <span data-ttu-id="391e8-1085">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1085">-or-</span>
          </span>
          <span data-ttu-id="391e8-1086">無法附加 <paramref name="data" />，因為它已超過記錄大小上限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1086">
              <paramref name="data" /> cannot be appended because it is larger than the maximum record size.</span>
          </span>
          <span data-ttu-id="391e8-1087">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1087">-or-</span>
          </span>
          <span data-ttu-id="391e8-1088">
            <paramref name="reservationCollection" /> 不是由此記錄順序所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1088">
              <paramref name="reservationCollection" /> was not created by this record sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="391e8-1089">一或多個參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1089">One or more of the parameters is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="391e8-1090">新的或現有封存結尾或作用中記錄的基底無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1090">A new or existing archive tail or base of the active log is invalid.</span>
          </span>
          <span data-ttu-id="391e8-1091">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1091">-or-</span>
          </span>
          <span data-ttu-id="391e8-1092">
            <paramref name="newBaseSeqNum" /> 不是介於這個順序的基底序號和最後一個序號之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1092">
              <paramref name="newBaseSeqNum" /> is not between the base and last sequence numbers of this sequence.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="391e8-1093">由於意外的 I/O 例外狀況，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1093">The request could not be performed because of an unexpected I/O exception.</span>
          </span>
          <span data-ttu-id="391e8-1094">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1094">-or-</span>
          </span>
          <span data-ttu-id="391e8-1095">因為 I/O 裝置錯誤，所以無法執行要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1095">The request could not be performed because of an I/O device error.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="391e8-1096">已在處置序列之後呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1096">The method was called after the sequence has been disposed of.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="391e8-1097">沒有足夠的記憶體可以繼續執行程式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1097">There is not enough memory to continue the execution of the program.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="391e8-1098">存取指定的記錄順序遭作業系統拒絕。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1098">Access for the specified log sequence is denied by the operating system.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.Log.SequenceFullException">
          <span data-ttu-id="391e8-1099">記錄順序已滿。</span>
          <span class="sxs-lookup">
            <span data-stu-id="391e8-1099">The record sequence is full.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>