<Type Name="LogStore" FullName="System.IO.Log.LogStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e09c8f57cbb65b4338595c8c78cf1de13180ff3f" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="37759109" /></Metadata><TypeSignature Language="C#" Value="public sealed class LogStore : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit LogStore extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.LogStore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class LogStore&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class LogStore sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type LogStore = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="12a53-101">代表記錄結構化儲存區。</span><span class="sxs-lookup"><span data-stu-id="12a53-101">Represents a log-structured storage.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-102"><xref:System.IO.Log.LogRecordSequence> 類別會在一般記錄檔系統 (CLFS) 記錄頂端提供記錄順序介面實作。</span><span class="sxs-lookup"><span data-stu-id="12a53-102">The <xref:System.IO.Log.LogRecordSequence> class provides an implementation of the record sequence interface on top of a Common Log File System (CLFS) log.</span></span> <span data-ttu-id="12a53-103">它會搭配使用 <xref:System.IO.Log.LogStore> 類別，這個類別會提供用來直接操作和管理 CLFS 記錄檔的介面。</span><span class="sxs-lookup"><span data-stu-id="12a53-103">It works with the <xref:System.IO.Log.LogStore> class, which provides an interface for directly manipulating and managing a CLFS log file.</span></span> <span data-ttu-id="12a53-104">記錄存放區會在一組延伸磁碟區中提供僅能附加的儲存區。</span><span class="sxs-lookup"><span data-stu-id="12a53-104">A log store provides append-only storage across a set of disk extents.</span></span> <span data-ttu-id="12a53-105"><xref:System.IO.Log.LogStore> 類別代表這個儲存區，並且提供用來加入和移除容器、設定原則以及建立封存檔的方法，</span><span class="sxs-lookup"><span data-stu-id="12a53-105">The <xref:System.IO.Log.LogStore> class represents this storage, and provides methods for adding and removing containers, setting policy, and creating archives.</span></span> <span data-ttu-id="12a53-106">但是不提供讀取和寫入儲存區的方法；這些方法會由 <xref:System.IO.Log.LogRecordSequence> 類別提供。</span><span class="sxs-lookup"><span data-stu-id="12a53-106">It does not provide methods for reading from and writing to the storage; these methods are provided by the <xref:System.IO.Log.LogRecordSequence> class.</span></span>  
  
 <span data-ttu-id="12a53-107"><xref:System.IO.Log.LogStore> 類別與 <xref:System.IO.Log.LogRecordSequence> 類別的關係就如同磁碟檔案與 <xref:System.IO.FileStream> 物件的關係。</span><span class="sxs-lookup"><span data-stu-id="12a53-107">The relationship between the <xref:System.IO.Log.LogStore> class and the <xref:System.IO.Log.LogRecordSequence> class is similar to the relationship between a disk file and a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="12a53-108">磁碟檔案提供實際的儲存區且具有「長度」和「上次存取時間」等屬性，而 <xref:System.IO.FileStream> 物件則提供檔案的檢視，可用來讀取和寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-108">The disk file provides the actual storage and has attributes such as length and last access time, while the <xref:System.IO.FileStream> object provides a view on the file that can be used to read from it and write to it.</span></span> <span data-ttu-id="12a53-109">同樣地，<xref:System.IO.Log.LogStore> 類別也具有原則和延伸磁碟區集合等屬性，而 <xref:System.IO.Log.LogRecordSequence> 類別則會提供用來讀取和寫入資料的記錄導向機制。</span><span class="sxs-lookup"><span data-stu-id="12a53-109">Similarly, the <xref:System.IO.Log.LogStore> class has attributes like a policy and a collection of disk extents, and the <xref:System.IO.Log.LogRecordSequence> class provides a record-oriented mechanism for reading and writing data.</span></span>  
  
 <span data-ttu-id="12a53-110">與 <xref:System.IO.Log.FileRecordSequence> 類別所代表的檔案記錄順序不同，<xref:System.IO.Log.LogStore> 執行個體會將它的資料儲存在 <xref:System.IO.Log.LogExtent> 執行個體所代表的延伸磁碟區集合中。</span><span class="sxs-lookup"><span data-stu-id="12a53-110">Unlike the file record sequence represented by the <xref:System.IO.Log.FileRecordSequence> class, a <xref:System.IO.Log.LogStore> instance stores its data in a collection of disk extents, represented by <xref:System.IO.Log.LogExtent> instances.</span></span> <span data-ttu-id="12a53-111">指定 <xref:System.IO.Log.LogStore> 執行個體中的延伸區大小均等，而在 <xref:System.IO.Log.LogStore> 執行個體中新增和移除空間時，將會以延伸區累加的方式來進行。</span><span class="sxs-lookup"><span data-stu-id="12a53-111">The extents in a given <xref:System.IO.Log.LogStore> instance are all of uniform size, and space is added to and removed from a <xref:System.IO.Log.LogStore> instance in extent increments.</span></span> <span data-ttu-id="12a53-112">若要新增及移除延伸記錄區，請使用 <xref:System.IO.Log.LogExtentCollection.Add%2A> 物件的 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 和 <xref:System.IO.Log.LogExtentCollection> 方法，這個物件可以由 <xref:System.IO.Log.LogStore.Extents%2A> 屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="12a53-112">To add and remove log extents, use the <xref:System.IO.Log.LogExtentCollection.Add%2A> and <xref:System.IO.Log.LogExtentCollection.Remove%2A> methods of the <xref:System.IO.Log.LogExtentCollection> object, which can be returned by the <xref:System.IO.Log.LogStore.Extents%2A> property.</span></span>  
  
 <span data-ttu-id="12a53-113"><xref:System.IO.Log.LogStore> 執行個體可能會有與它相關聯的原則。</span><span class="sxs-lookup"><span data-stu-id="12a53-113">A <xref:System.IO.Log.LogStore> instance can have policies associated with it.</span></span> <span data-ttu-id="12a53-114">這些原則是以可由 <xref:System.IO.Log.LogPolicy> 屬性傳回的 <xref:System.IO.Log.LogStore.Policy%2A> 執行個體來代表。</span><span class="sxs-lookup"><span data-stu-id="12a53-114">These are represented by <xref:System.IO.Log.LogPolicy> instances that can be returned by the <xref:System.IO.Log.LogStore.Policy%2A> property.</span></span> <span data-ttu-id="12a53-115">原則會規定記錄檔所要遵循的規則，例如延伸區的數目上限和大小下限，以及在特定條件下擴大或縮小 <xref:System.IO.Log.LogStore> 的相關指示。</span><span class="sxs-lookup"><span data-stu-id="12a53-115">A policy dictates rules that the log will attempt to follow, such as maximum number of extents and minimum size, and instructions on growing or shrinking the <xref:System.IO.Log.LogStore> under certain conditions.</span></span> <span data-ttu-id="12a53-116">此外，您還可以指定是否可以封存 <xref:System.IO.Log.LogStore> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="12a53-116">In addition, you can specify whether a <xref:System.IO.Log.LogStore> instance can be archived.</span></span> <span data-ttu-id="12a53-117">原則是針對個別記錄檔設定的，而且是變動的 (Volatile)，代表一旦關閉記錄檔的所有控制代碼，就不再會有原則存在。</span><span class="sxs-lookup"><span data-stu-id="12a53-117">Policies are set per log and are volatile, which means that once every handle to the log is closed, the policy no longer exists.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12a53-118">下列範例示範如何將 <xref:System.IO.Log.LogStore> 封存至 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="12a53-118">The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.</span></span>  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="12a53-119">初始化 <see cref="T:System.IO.Log.LogStore" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="12a53-119">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="12a53-120">目前 <see cref="T:System.IO.Log.LogStore" /> 物件所封裝之記錄檔的檔案控制代碼。</span><span class="sxs-lookup"><span data-stu-id="12a53-120">A file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> object encapsulates.</span></span></param>
        <summary><span data-ttu-id="12a53-121">為指定的控制代碼初始化 <see cref="T:System.IO.Log.LogStore" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="12a53-121">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class for the specified handle.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="12a53-122"><paramref name="handle" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-122"><paramref name="handle" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-123">記錄檔控制代碼無法繫結至執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="12a53-123">The log handle could not be bound to the thread pool.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-124">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-124">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-125">已在處置序列之後呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="12a53-125">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-126">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-126">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="12a53-127">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="12a53-127">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="12a53-128">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-128">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <summary><span data-ttu-id="12a53-129">使用指定的路徑和模式初始化 <see cref="T:System.IO.Log.LogStore" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="12a53-129">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path and mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-130">使用這個建構函式，以指定的路徑和模式來開啟記錄存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-130">Use this constructor to open a log store with the specified path and mode.</span></span> <span data-ttu-id="12a53-131">存放區便會以讀取/寫入權限開啟，並且共用讀取權限。</span><span class="sxs-lookup"><span data-stu-id="12a53-131">The store is opened with read/write access, and shares read access.</span></span>  
  
 <span data-ttu-id="12a53-132">`path` 參數應使用下列語法：</span><span class="sxs-lookup"><span data-stu-id="12a53-132">The `path` parameter should use the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="12a53-133">其中 `<physical log name>` 是記錄檔的有效路徑，而 `<log client name>` 則是唯一的用戶端識別項。</span><span class="sxs-lookup"><span data-stu-id="12a53-133">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="12a53-134">記錄存放區必須是實體記錄存放區或虛擬記錄存放區，但不會同時為這兩者。</span><span class="sxs-lookup"><span data-stu-id="12a53-134">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="12a53-135">一旦建立實體或虛擬記錄存放區，其狀態就會永久保持不變。</span><span class="sxs-lookup"><span data-stu-id="12a53-135">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="12a53-136">實體記錄存放區的建立方式是單獨指定實體記錄名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-136">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="12a53-137">虛擬記錄存放區的建立方式是同時指定實體記錄名稱和記錄用戶端名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-137">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="12a53-138">實體記錄名稱相同的用戶端，其延伸區集合和原則也會相同。</span><span class="sxs-lookup"><span data-stu-id="12a53-138">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="12a53-139"><paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-139"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-140"><paramref name="path" /> 為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="12a53-140"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="12a53-141">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-141">-or-</span></span> 
 <span data-ttu-id="12a53-142"><paramref name="path" /> 僅包含泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-142"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="12a53-143">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-143">-or-</span></span> 
 <span data-ttu-id="12a53-144"><paramref name="path" /> 包含一或多個無效的字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-144"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="12a53-145"><paramref name="mode" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-145"><paramref name="mode" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="12a53-146">找不到檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-146">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-147">開啟記錄存放區時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-147">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-148">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-148">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="12a53-149">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogStore" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-149"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="12a53-150">如果 CLFS 元件適用於您的平台，請加以安裝或改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span><span class="sxs-lookup"><span data-stu-id="12a53-150">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-151">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-151">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="12a53-152">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="12a53-152">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="12a53-153">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-153">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="12a53-154">其中一個 <see cref="T:System.IO.FileAccess" /> 值，可決定 <see cref="T:System.IO.Log.LogStore" /> 可以如何存取檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-154">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <summary><span data-ttu-id="12a53-155">使用指定的路徑、模式和存取權限初始化 <see cref="T:System.IO.Log.LogStore" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="12a53-155">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class with the specified path, mode, and access.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-156">使用這個建構函式，以指定的路徑、模式和存取權限來開啟新的記錄存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-156">Use this constructor to open a new log store with the specified path, mode, and access.</span></span> <span data-ttu-id="12a53-157">存放區便會開啟，並且共用讀取權限。</span><span class="sxs-lookup"><span data-stu-id="12a53-157">The store is opened sharing read access.</span></span>  
  
 <span data-ttu-id="12a53-158">`path` 參數應使用下列語法：</span><span class="sxs-lookup"><span data-stu-id="12a53-158">The `path` parameter should use the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="12a53-159">其中 `<physical log name>` 是記錄檔的有效路徑，而 `<log client name>` 則是唯一的用戶端識別項。</span><span class="sxs-lookup"><span data-stu-id="12a53-159">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="12a53-160">記錄存放區必須是實體記錄存放區或虛擬記錄存放區，但不會同時為這兩者。</span><span class="sxs-lookup"><span data-stu-id="12a53-160">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="12a53-161">一旦建立實體或虛擬記錄存放區，其狀態就會永久保持不變。</span><span class="sxs-lookup"><span data-stu-id="12a53-161">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="12a53-162">實體記錄存放區的建立方式是單獨指定實體記錄名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-162">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="12a53-163">虛擬記錄存放區的建立方式是同時指定實體記錄名稱和記錄用戶端名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-163">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="12a53-164">實體記錄名稱相同的用戶端，其延伸區集合和原則也會相同。</span><span class="sxs-lookup"><span data-stu-id="12a53-164">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="12a53-165"><paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-165"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-166"><paramref name="path" /> 為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="12a53-166"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="12a53-167">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-167">-or-</span></span> 
 <span data-ttu-id="12a53-168"><paramref name="path" /> 僅包含泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-168"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="12a53-169">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-169">-or-</span></span> 
 <span data-ttu-id="12a53-170"><paramref name="path" /> 包含一或多個無效的字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-170"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="12a53-171"><paramref name="mode" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-171"><paramref name="mode" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="12a53-172">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-172">-or</span></span> 
 <span data-ttu-id="12a53-173"><paramref name="access" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-173"><paramref name="access" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="12a53-174">找不到檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-174">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-175">開啟記錄存放區時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-175">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-176">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-176">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="12a53-177">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogStore" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-177"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="12a53-178">如果 CLFS 元件適用於您的平台，請加以安裝或改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span><span class="sxs-lookup"><span data-stu-id="12a53-178">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-179">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-179">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="12a53-180">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="12a53-180">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="12a53-181">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-181">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="12a53-182">其中一個 <see cref="T:System.IO.FileAccess" /> 值，可決定 <see cref="T:System.IO.Log.LogStore" /> 可以如何存取檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-182">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="12a53-183">其中一個 <see cref="T:System.IO.FileShare" /> 值，可決定在處理序之間共用記錄存放區的方式。</span><span class="sxs-lookup"><span data-stu-id="12a53-183">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <summary><span data-ttu-id="12a53-184">初始化 <see cref="T:System.IO.Log.LogStore" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="12a53-184">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-185">這個建構函式會初始化新的 <xref:System.IO.Log.LogStore> 物件，而這個物件是以指定的路徑、模式和存取權限所開啟的。</span><span class="sxs-lookup"><span data-stu-id="12a53-185">This constructor initializes a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="12a53-186">存放區會開啟，並且共用指定的存取權限。</span><span class="sxs-lookup"><span data-stu-id="12a53-186">The store is opened sharing the specified access.</span></span>  
  
 <span data-ttu-id="12a53-187">`path` 參數應使用下列語法：</span><span class="sxs-lookup"><span data-stu-id="12a53-187">The `path` parameter should use the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="12a53-188">其中 `<physical log name>` 是記錄檔的有效路徑，而 `<log client name>` 則是唯一的用戶端識別項。</span><span class="sxs-lookup"><span data-stu-id="12a53-188">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="12a53-189">記錄存放區必須是實體記錄存放區或虛擬記錄存放區，但不會同時為這兩者。</span><span class="sxs-lookup"><span data-stu-id="12a53-189">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="12a53-190">一旦建立實體或虛擬記錄存放區，其狀態就會永久保持不變。</span><span class="sxs-lookup"><span data-stu-id="12a53-190">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="12a53-191">實體記錄存放區的建立方式是單獨指定實體記錄名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-191">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="12a53-192">虛擬記錄存放區的建立方式是同時指定實體記錄名稱和記錄用戶端名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-192">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="12a53-193">實體記錄名稱相同的用戶端，其延伸區集合和原則也會相同。</span><span class="sxs-lookup"><span data-stu-id="12a53-193">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="12a53-194"><paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-194"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-195"><paramref name="path" /> 為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="12a53-195"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="12a53-196">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-196">-or-</span></span> 
 <span data-ttu-id="12a53-197"><paramref name="path" /> 僅包含泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-197"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="12a53-198">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-198">-or-</span></span> 
 <span data-ttu-id="12a53-199"><paramref name="path" /> 包含一或多個無效的字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-199"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="12a53-200"><paramref name="mode" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-200"><paramref name="mode" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="12a53-201">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-201">-or</span></span> 
 <span data-ttu-id="12a53-202"><paramref name="access" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-202"><paramref name="access" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="12a53-203">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-203">-or-</span></span> 
 <span data-ttu-id="12a53-204"><paramref name="share" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-204"><paramref name="share" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="12a53-205">找不到檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-205">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-206">開啟記錄存放區時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-206">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-207">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-207">Access for the specified log store is denied by the operating system.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="12a53-208">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogStore" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-208"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="12a53-209">如果 CLFS 元件適用於您的平台，請加以安裝或改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span><span class="sxs-lookup"><span data-stu-id="12a53-209">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-210">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-210">There is not enough memory to continue the execution of a program.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LogStore(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.Log.LogStore : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.Security.AccessControl.FileSecurity -&gt; System.IO.Log.LogStore" Usage="new System.IO.Log.LogStore (path, mode, access, share, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="12a53-211">要開啟之記錄存放區基底檔案的相對或絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="12a53-211">A relative or absolute path for the base file of the log store to open.</span></span></param>
        <param name="mode"><span data-ttu-id="12a53-212">其中一個 <see cref="T:System.IO.FileMode" /> 值，可決定如何開啟或建立存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-212">One of the <see cref="T:System.IO.FileMode" /> values that determines how to open or create the store.</span></span></param>
        <param name="access"><span data-ttu-id="12a53-213">其中一個 <see cref="T:System.IO.FileAccess" /> 值，可決定 <see cref="T:System.IO.Log.LogStore" /> 可以如何存取檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-213">One of the <see cref="T:System.IO.FileAccess" /> values that determines how the file can be accessed by the <see cref="T:System.IO.Log.LogStore" />.</span></span></param>
        <param name="share"><span data-ttu-id="12a53-214">其中一個 <see cref="T:System.IO.FileShare" /> 值，可決定在處理序之間共用記錄存放區的方式。</span><span class="sxs-lookup"><span data-stu-id="12a53-214">One of the <see cref="T:System.IO.FileShare" /> values that determines how the log store will be shared among processes.</span></span></param>
        <param name="fileSecurity"><span data-ttu-id="12a53-215">其中一個 <see cref="T:System.Security.AccessControl.FileSecurity" /> 值，可指定要針對新建立的存放區設定的安全性 (如果必須建立存放區的話)。</span><span class="sxs-lookup"><span data-stu-id="12a53-215">One of the <see cref="T:System.Security.AccessControl.FileSecurity" /> value that specifies the security to set on the newly created store if the store must be created.</span></span></param>
        <summary><span data-ttu-id="12a53-216">初始化 <see cref="T:System.IO.Log.LogStore" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="12a53-216">Initializes a new instance of the <see cref="T:System.IO.Log.LogStore" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-217">這個建構函式會初始化新的 <xref:System.IO.Log.LogStore> 物件，而這個物件是以指定的路徑、模式和存取權限所開啟的。</span><span class="sxs-lookup"><span data-stu-id="12a53-217">This constructor initializes a new <xref:System.IO.Log.LogStore> object that it opens with the specified path, mode, and access.</span></span> <span data-ttu-id="12a53-218">存放區會開啟，並且共用指定的存取權限。</span><span class="sxs-lookup"><span data-stu-id="12a53-218">The store is opened sharing the specified access.</span></span> <span data-ttu-id="12a53-219">`path` 參數應遵循下列語法：</span><span class="sxs-lookup"><span data-stu-id="12a53-219">The `path` parameter should follow the following syntax:</span></span>  
  
 `log:<physical log name>[::<log client name>]`  
  
 <span data-ttu-id="12a53-220">其中 `<physical log name>` 是記錄檔的有效路徑，而 `<log client name>` 則是唯一的用戶端識別項。</span><span class="sxs-lookup"><span data-stu-id="12a53-220">where `<physical log name>` is a valid path to a log file, and `<log client name>` is a unique client identifier.</span></span> <span data-ttu-id="12a53-221">記錄存放區必須是實體記錄存放區或虛擬記錄存放區，但不會同時為這兩者。</span><span class="sxs-lookup"><span data-stu-id="12a53-221">A log store should be either a physical log store or a virtual log store, but not both.</span></span> <span data-ttu-id="12a53-222">一旦建立實體或虛擬記錄存放區，其狀態就會永久保持不變。</span><span class="sxs-lookup"><span data-stu-id="12a53-222">Once a log store has been created physically or virtually, it remains so for its lifetime.</span></span> <span data-ttu-id="12a53-223">實體記錄存放區的建立方式是單獨指定實體記錄名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-223">A physical log store is created by specifying only the physical log name.</span></span> <span data-ttu-id="12a53-224">虛擬記錄存放區的建立方式是同時指定實體記錄名稱和記錄用戶端名稱。</span><span class="sxs-lookup"><span data-stu-id="12a53-224">A virtual log store is created by specifying both the physical log name and the log client name.</span></span>  
  
 <span data-ttu-id="12a53-225">實體記錄名稱相同的用戶端，其延伸區集合和原則也會相同。</span><span class="sxs-lookup"><span data-stu-id="12a53-225">Clients that share the same physical log name share the same extents collection and policy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="12a53-226"><paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-226"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-227"><paramref name="path" /> 所指定的記錄存放區檔案名稱無效。</span><span class="sxs-lookup"><span data-stu-id="12a53-227">The log store file name specified by <paramref name="path" /> is not valid.</span></span>  
  
<span data-ttu-id="12a53-228">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-228">-or-</span></span> 
 <span data-ttu-id="12a53-229"><paramref name="Mode" /> 為 <see langword="CreateNew" />；因此，如果沒有寫入權限，就無法加以使用。</span><span class="sxs-lookup"><span data-stu-id="12a53-229"><paramref name="Mode" /> is <see langword="CreateNew" />, which cannot be used without write access.</span></span>  
  
<span data-ttu-id="12a53-230">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-230">-or-</span></span> 
 <span data-ttu-id="12a53-231"><paramref name="Mode" /> 為 <see langword="OpenOrCreate" />；因此，如果沒有寫入權限，就無法加以使用。</span><span class="sxs-lookup"><span data-stu-id="12a53-231"><paramref name="Mode" /> is <see langword="OpenOrCreate" />, which cannot be used without write access.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="12a53-232"><paramref name="mode" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-232"><paramref name="mode" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="12a53-233">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-233">-or</span></span> 
 <span data-ttu-id="12a53-234"><paramref name="access" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-234"><paramref name="access" /> contains an invalid value.</span></span>  
  
<span data-ttu-id="12a53-235">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-235">-or-</span></span> 
 <span data-ttu-id="12a53-236"><paramref name="share" /> 包含無效的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-236"><paramref name="share" /> contains an invalid value.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="12a53-237">找不到檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-237">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-238">開啟記錄存放區時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-238">An I/O error occurs when opening the log store.</span></span>  
  
<span data-ttu-id="12a53-239">因為另一個處理序正在使用 <paramref name="path" /> 所指定的檔案，所以無法存取該檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-239">The file specified by <paramref name="path" /> cannot be accessed because it is in use by another process.</span></span>  
  
<span data-ttu-id="12a53-240">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-240">-or-</span></span> 
<span data-ttu-id="12a53-241">因為檔案或目錄已存在，所以無法建立 <paramref name="path" /> 所指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-241">The file specified by <paramref name="path" /> cannot be created because the file or directory already exists.</span></span>  
  
<span data-ttu-id="12a53-242">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-242">-or-</span></span> 
<span data-ttu-id="12a53-243">記錄檔控制代碼無法繫結至執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="12a53-243">The log handle could not be bound to the thread pool.</span></span>  
  
<span data-ttu-id="12a53-244">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-244">-or-</span></span> 
<span data-ttu-id="12a53-245">指定的記錄檔格式或版本無效。</span><span class="sxs-lookup"><span data-stu-id="12a53-245">The specified log file format or version is invalid.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="12a53-246">因為尚未安裝所需的一般記錄檔系統 (CLFS) 元件，所以無法使用 <see cref="T:System.IO.Log.LogStore" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-246"><see cref="T:System.IO.Log.LogStore" /> cannot be used because the required Common Log File System (CLFS) component is not installed.</span></span> <span data-ttu-id="12a53-247">如果 CLFS 元件適用於您的平台，請加以安裝或改用 <see cref="T:System.IO.Log.FileRecordSequence" /> 類別。</span><span class="sxs-lookup"><span data-stu-id="12a53-247">Install the CLFS component if it is available for your platform or use the <see cref="T:System.IO.Log.FileRecordSequence" /> class instead.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-248">已在處置序列之後呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="12a53-248">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-249">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-249">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="12a53-250">記錄順序已滿。</span><span class="sxs-lookup"><span data-stu-id="12a53-250">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-251">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-251">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Archivable">
      <MemberSignature Language="C#" Value="public bool Archivable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archivable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Archivable" />
      <MemberSignature Language="VB.NET" Value="Public Property Archivable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archivable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archivable : bool with get, set" Usage="System.IO.Log.LogStore.Archivable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-252">取得用來表示是否可以封存這個 <see cref="T:System.IO.Log.LogStore" /> 執行個體的值。</span><span class="sxs-lookup"><span data-stu-id="12a53-252">Gets a value indicating whether this <see cref="T:System.IO.Log.LogStore" /> instance can be archived.</span></span></summary>
        <value><span data-ttu-id="12a53-253">如果可以封存這個 <see langword="true" /> 執行個體，則為 <see cref="T:System.IO.Log.LogStore" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-253"><see langword="true" /> if this <see cref="T:System.IO.Log.LogStore" /> instance can be archived; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-254">如果無法封存 <xref:System.IO.Log.LogStore>，呼叫 <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> 和 <xref:System.IO.Log.LogStore.SetArchiveTail%2A> 方法便會導致擲回 <xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="12a53-254">If a <xref:System.IO.Log.LogStore> is not archivable, calls to the <xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> and <xref:System.IO.Log.LogStore.SetArchiveTail%2A> methods result in a <xref:System.NotSupportedException> being thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-255">已在處置序列之後存取此屬性。</span><span class="sxs-lookup"><span data-stu-id="12a53-255">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber BaseSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber BaseSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.BaseSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-256">取得對應至這個 <see cref="T:System.IO.Log.LogStore" /> 執行個體中有效記錄的最小序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-256">Gets the lowest sequence number that corresponds to a valid record in this <see cref="T:System.IO.Log.LogStore" /> instance.</span></span></summary>
        <value><span data-ttu-id="12a53-257">對應至這個 <see cref="T:System.IO.Log.LogStore" /> 執行個體中有效記錄的最小序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-257">The lowest sequence number that corresponds to a valid record in this <see cref="T:System.IO.Log.LogStore" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-258">有效的序號會大於或等於 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>，而且小於 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>。</span><span class="sxs-lookup"><span data-stu-id="12a53-258">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-259">已在處置序列之後存取此屬性。</span><span class="sxs-lookup"><span data-stu-id="12a53-259">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateLogArchiveSnapshot">
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="12a53-260">取得製作備份所需的記錄存放區狀態快照 (Snapshot)。</span><span class="sxs-lookup"><span data-stu-id="12a53-260">Takes a snapshot of the log store state necessary to make a backup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot () As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot();" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : unit -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="12a53-261">取得記錄存放區狀態的快照 (Snapshot)，以便製作備份。</span><span class="sxs-lookup"><span data-stu-id="12a53-261">Takes a snapshot of the log store state for making a backup.</span></span></summary>
        <returns><span data-ttu-id="12a53-262"><see cref="T:System.IO.Log.LogArchiveSnapshot" /> 物件，其中包含製作封存檔所需的狀態。</span><span class="sxs-lookup"><span data-stu-id="12a53-262">A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="12a53-263">下列範例示範如何將 <xref:System.IO.Log.LogStore> 封存至 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="12a53-263">The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.</span></span>  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="12a53-264">無法封存記錄存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-264">The log store is not archivable.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-265">已在處置序列之後呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="12a53-265">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-266">建立封存快照時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-266">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-267">引數無效。</span><span class="sxs-lookup"><span data-stu-id="12a53-267">An argument is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="12a53-268">已經執行無效的作業。</span><span class="sxs-lookup"><span data-stu-id="12a53-268">An invalid operation has been executed.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-269">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-269">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="12a53-270">記錄順序已滿。</span><span class="sxs-lookup"><span data-stu-id="12a53-270">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-271">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-271">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateLogArchiveSnapshot">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot(valuetype System.IO.Log.SequenceNumber first, valuetype System.IO.Log.SequenceNumber last) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateLogArchiveSnapshot (first As SequenceNumber, last As SequenceNumber) As LogArchiveSnapshot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Log::LogArchiveSnapshot ^ CreateLogArchiveSnapshot(System::IO::Log::SequenceNumber first, System::IO::Log::SequenceNumber last);" />
      <MemberSignature Language="F#" Value="member this.CreateLogArchiveSnapshot : System.IO.Log.SequenceNumber * System.IO.Log.SequenceNumber -&gt; System.IO.Log.LogArchiveSnapshot" Usage="logStore.CreateLogArchiveSnapshot (first, last)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogArchiveSnapshot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="first" Type="System.IO.Log.SequenceNumber" />
        <Parameter Name="last" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="first"><span data-ttu-id="12a53-272">要封存之範圍的起始序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-272">The starting sequence number in the range to archive.</span></span></param>
        <param name="last"><span data-ttu-id="12a53-273">要封存之範圍的結束序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-273">The ending sequence number in the range to archive.</span></span></param>
        <summary><span data-ttu-id="12a53-274">取得介於指定之序號間的記錄存放區狀態快照 (Snapshot)，以便製作備份。</span><span class="sxs-lookup"><span data-stu-id="12a53-274">Takes a snapshot of the log store state between the specified sequence numbers for making a backup.</span></span></summary>
        <returns><span data-ttu-id="12a53-275"><see cref="T:System.IO.Log.LogArchiveSnapshot" /> 物件，其中包含製作封存檔所需的狀態。</span><span class="sxs-lookup"><span data-stu-id="12a53-275">A <see cref="T:System.IO.Log.LogArchiveSnapshot" /> object that contains the state necessary to make an archive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-276">這個方法所傳回的封存快照 (Snapshot) 包含由基底序號或封存序號 (較小者) 到最後一個序號的資訊，</span><span class="sxs-lookup"><span data-stu-id="12a53-276">The archive snapshot returned from this method encompasses information from either the base sequence number or the archive sequence number, whichever is lower, to the last sequence number.</span></span> <span data-ttu-id="12a53-277">其中不含最後一個序號，代表封存檔只包含直到最後一個之前的所有記錄。</span><span class="sxs-lookup"><span data-stu-id="12a53-277">It is not inclusive for the last sequence number, which means that the archive only includes records up to but not including last.</span></span> <span data-ttu-id="12a53-278">此外，使用這個方法時，起始的 SequenceNumber 必須等於 BaseSequenceNumber，才能讓這個封存保持一致。</span><span class="sxs-lookup"><span data-stu-id="12a53-278">In addition, when using this method, the start SequenceNumber must be equal to the BaseSequenceNumber in order for the archive to be consistent.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="12a53-279"><paramref name="first" /> 或 <paramref name="last" /> 不是介於這個順序的基底序號和最後一個序號之間。</span><span class="sxs-lookup"><span data-stu-id="12a53-279"><paramref name="first" /> or <paramref name="last" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-280"><paramref name="first" /> 大於 <paramref name="last" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-280"><paramref name="first" /> is larger than <paramref name="last" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="12a53-281">已經執行無效的作業。</span><span class="sxs-lookup"><span data-stu-id="12a53-281">An invalid operation has been executed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-282">建立封存快照時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-282">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="12a53-283">無法封存記錄存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-283">The log store is not archivable.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-284">已在處置序列之後呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="12a53-284">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-285">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-285">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.IO.Log.SequenceFullException"><span data-ttu-id="12a53-286">記錄順序已滿。</span><span class="sxs-lookup"><span data-stu-id="12a53-286">The record sequence is full.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-287">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-287">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Log.LogStore.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="12a53-288">要移除之記錄存放區基底檔案的相對或絕對路徑。</span><span class="sxs-lookup"><span data-stu-id="12a53-288">A relative or absolute path for the base file of the log store to remove.</span></span></param>
        <summary><span data-ttu-id="12a53-289">移除記錄存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-289">Removes the log store.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="12a53-290"><paramref name="path" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="12a53-290"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-291"><paramref name="path" /> 為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="12a53-291"><paramref name="path" /> is an empty string ("").</span></span>  
  
<span data-ttu-id="12a53-292">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-292">-or-</span></span> 
 <span data-ttu-id="12a53-293"><paramref name="path" /> 僅包含泛空白字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-293"><paramref name="path" /> contains only white space.</span></span>  
  
<span data-ttu-id="12a53-294">-或-</span><span class="sxs-lookup"><span data-stu-id="12a53-294">-or-</span></span> 
 <span data-ttu-id="12a53-295"><paramref name="path" /> 包含一或多個無效的字元。</span><span class="sxs-lookup"><span data-stu-id="12a53-295"><paramref name="path" /> contains one or more invalid characters.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="12a53-296">找不到檔案。</span><span class="sxs-lookup"><span data-stu-id="12a53-296">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-297">開啟記錄存放區時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-297">An I/O error occurs when opening the log store.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-298">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-298">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="logStore.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="12a53-299">釋放 <see cref="T:System.IO.Log.LogStore" /> 所使用的所有資源。</span><span class="sxs-lookup"><span data-stu-id="12a53-299">Releases all resources used by the <see cref="T:System.IO.Log.LogStore" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-300"><xref:System.IO.Log.LogStore.Dispose%2A> 使用完畢時，請呼叫 <xref:System.IO.Log.LogStore>。</span><span class="sxs-lookup"><span data-stu-id="12a53-300">Call <xref:System.IO.Log.LogStore.Dispose%2A> when you have finished using the <xref:System.IO.Log.LogStore>.</span></span> <span data-ttu-id="12a53-301"><xref:System.IO.Log.LogStore.Dispose%2A> 方法會將 <xref:System.IO.Log.LogStore> 保留在無法使用的狀態。</span><span class="sxs-lookup"><span data-stu-id="12a53-301">The <xref:System.IO.Log.LogStore.Dispose%2A> method leaves the <xref:System.IO.Log.LogStore> in an unusable state.</span></span> <span data-ttu-id="12a53-302">在呼叫 <xref:System.IO.Log.LogStore.Dispose%2A> 後，您必須釋放所有對 <xref:System.IO.Log.LogStore> 的參考，讓記憶體回收行程可以取回 <xref:System.IO.Log.LogStore> 佔用的記憶體。</span><span class="sxs-lookup"><span data-stu-id="12a53-302">After calling <xref:System.IO.Log.LogStore.Dispose%2A> , you must release all references to the <xref:System.IO.Log.LogStore> so the garbage collector can reclaim the memory that the <xref:System.IO.Log.LogStore> was occupying.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="12a53-303">在您釋放最後一個 <xref:System.IO.Log.LogStore.Dispose%2A> 參考之前，請務必呼叫 <xref:System.IO.Log.LogStore>。</span><span class="sxs-lookup"><span data-stu-id="12a53-303">Always call <xref:System.IO.Log.LogStore.Dispose%2A> before you release your last reference to the <xref:System.IO.Log.LogStore>.</span></span> <span data-ttu-id="12a53-304">否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.IO.Log.LogStore> 物件的 `Finalize` 方法。</span><span class="sxs-lookup"><span data-stu-id="12a53-304">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.IO.Log.LogStore> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-305">已在處置序列之後呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="12a53-305">The method was called after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Extents">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogExtentCollection Extents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogExtentCollection Extents" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Extents" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extents As LogExtentCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogExtentCollection ^ Extents { System::IO::Log::LogExtentCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extents : System.IO.Log.LogExtentCollection" Usage="System.IO.Log.LogStore.Extents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogExtentCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-306">取得包含這個記錄存放區資料的延伸記錄區集合。</span><span class="sxs-lookup"><span data-stu-id="12a53-306">Gets the collection of log extents that contain the data for this log store.</span></span></summary>
        <value><span data-ttu-id="12a53-307"><see cref="T:System.IO.Log.LogExtentCollection" /> 執行個體，其中包含封裝這個記錄存放區資料的延伸記錄區集合。</span><span class="sxs-lookup"><span data-stu-id="12a53-307">A <see cref="T:System.IO.Log.LogExtentCollection" /> instance containing the collection of log extents that encapsulates data for this log store.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-308"><xref:System.IO.Log.LogStore> 執行個體會將它的資料儲存在 <xref:System.IO.Log.LogExtent> 執行個體所代表的延伸磁碟區集合中。</span><span class="sxs-lookup"><span data-stu-id="12a53-308">A <xref:System.IO.Log.LogStore> instance stores its data in a collection of disk extents, represented by <xref:System.IO.Log.LogExtent> instances.</span></span> <span data-ttu-id="12a53-309">指定 <xref:System.IO.Log.LogStore> 執行個體中的延伸區大小均等，而在 <xref:System.IO.Log.LogStore> 執行個體中新增和移除空間時，將會以延伸區累加的方式來進行。</span><span class="sxs-lookup"><span data-stu-id="12a53-309">The extents in a given <xref:System.IO.Log.LogStore> instance are all of uniform size, and space is added to and removed from a <xref:System.IO.Log.LogStore> instance in extent increments.</span></span> <span data-ttu-id="12a53-310">若要新增及移除延伸記錄區，請使用 <xref:System.IO.Log.LogExtentCollection.Add%2A> 物件的 <xref:System.IO.Log.LogExtentCollection.Remove%2A> 和 <xref:System.IO.Log.LogExtentCollection> 方法，這個物件是由這個屬性所傳回的。</span><span class="sxs-lookup"><span data-stu-id="12a53-310">To add and remove log extents, use the <xref:System.IO.Log.LogExtentCollection.Add%2A> and <xref:System.IO.Log.LogExtentCollection.Remove%2A> methods of the <xref:System.IO.Log.LogExtentCollection> object, which is returned by this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeBytes">
      <MemberSignature Language="C#" Value="public long FreeBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 FreeBytes" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.FreeBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FreeBytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long FreeBytes { long get(); };" />
      <MemberSignature Language="F#" Value="member this.FreeBytes : int64" Usage="System.IO.Log.LogStore.FreeBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-311">取得記錄存放區中可用的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="12a53-311">Gets the number of bytes available in the log store.</span></span></summary>
        <value><span data-ttu-id="12a53-312">記錄存放區中可用的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="12a53-312">The number of bytes available in the log store.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-313">已在處置序列之後存取此屬性。</span><span class="sxs-lookup"><span data-stu-id="12a53-313">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeFileHandle ^ Handle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.Log.LogStore.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-314">取得目前 <see cref="T:System.IO.Log.LogStore" /> 執行個體所封裝之記錄檔的作業系統檔案控制代碼。</span><span class="sxs-lookup"><span data-stu-id="12a53-314">Gets the operating system file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> instance encapsulates.</span></span></summary>
        <value><span data-ttu-id="12a53-315">目前 <see cref="T:System.IO.Log.LogStore" /> 執行個體所封裝之記錄檔的作業系統檔案控制代碼。</span><span class="sxs-lookup"><span data-stu-id="12a53-315">The operating system file handle for the log file that the current <see cref="T:System.IO.Log.LogStore" /> instance encapsulates.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastSequenceNumber">
      <MemberSignature Language="C#" Value="public System.IO.Log.SequenceNumber LastSequenceNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Log.SequenceNumber LastSequenceNumber" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastSequenceNumber As SequenceNumber" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::SequenceNumber LastSequenceNumber { System::IO::Log::SequenceNumber get(); };" />
      <MemberSignature Language="F#" Value="member this.LastSequenceNumber : System.IO.Log.SequenceNumber" Usage="System.IO.Log.LogStore.LastSequenceNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.SequenceNumber</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-316">在衍生類別中覆寫時，取得要附加至記錄存放區之下一筆記錄的序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-316">When overridden in a derived class, gets the sequence number of the next record to be appended to the log store.</span></span></summary>
        <value><span data-ttu-id="12a53-317">要附加至記錄存放區之下一筆記錄的序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-317">The sequence number of the next record to be appended to the log store.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-318">有效的序號會大於或等於 <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>，而且小於 <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>。</span><span class="sxs-lookup"><span data-stu-id="12a53-318">Valid sequence numbers are greater than or equal to <xref:System.IO.Log.LogStore.BaseSequenceNumber%2A> and less than <xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-319">已在處置序列之後存取此屬性。</span><span class="sxs-lookup"><span data-stu-id="12a53-319">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Log.LogStore.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-320">取得記錄存放區的大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="12a53-320">Gets the size of the log store, in bytes.</span></span></summary>
        <value><span data-ttu-id="12a53-321">記錄存放區的大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="12a53-321">The size of the log store, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-322">記錄存放區的大小是延伸記錄區大小的總和。</span><span class="sxs-lookup"><span data-stu-id="12a53-322">The size of the log store is the sum of the sizes of the log extents.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-323">已在處置序列之後存取此屬性。</span><span class="sxs-lookup"><span data-stu-id="12a53-323">The property was accessed after the sequence has been disposed of.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Policy">
      <MemberSignature Language="C#" Value="public System.IO.Log.LogPolicy Policy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Log.LogPolicy Policy" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.Policy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Policy As LogPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Log::LogPolicy ^ Policy { System::IO::Log::LogPolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Policy : System.IO.Log.LogPolicy" Usage="System.IO.Log.LogStore.Policy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Log.LogPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-324">取得與此記錄存放區相關聯的原則。</span><span class="sxs-lookup"><span data-stu-id="12a53-324">Gets the policy associated with this log store.</span></span></summary>
        <value><span data-ttu-id="12a53-325"><see cref="T:System.IO.Log.LogPolicy" /> 執行個體，代表與此記錄存放區相關聯的原則。</span><span class="sxs-lookup"><span data-stu-id="12a53-325">A <see cref="T:System.IO.Log.LogPolicy" /> instance representing the policy associated with this log store.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-326">您可以使用這個屬性所傳回的 <xref:System.IO.Log.LogPolicy> 執行個體，檢查和操作與這個 <xref:System.IO.Log.LogStore> 相關聯的記錄原則。</span><span class="sxs-lookup"><span data-stu-id="12a53-326">You can use the <xref:System.IO.Log.LogPolicy> instance returned by this property to examine and manipulate the log policy associated with this <xref:System.IO.Log.LogStore>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetArchiveTail">
      <MemberSignature Language="C#" Value="public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetArchiveTail(valuetype System.IO.Log.SequenceNumber archiveTail) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetArchiveTail (archiveTail As SequenceNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetArchiveTail(System::IO::Log::SequenceNumber archiveTail);" />
      <MemberSignature Language="F#" Value="member this.SetArchiveTail : System.IO.Log.SequenceNumber -&gt; unit" Usage="logStore.SetArchiveTail archiveTail" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveTail" Type="System.IO.Log.SequenceNumber" />
      </Parameters>
      <Docs>
        <param name="archiveTail"><span data-ttu-id="12a53-327">封存結尾的序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-327">The sequence number of the archive tail.</span></span></param>
        <summary><span data-ttu-id="12a53-328">設定封存結尾的序號。</span><span class="sxs-lookup"><span data-stu-id="12a53-328">Sets the sequence number of the archive tail.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="12a53-329">基底序號和封存結尾這兩者中較小的，會決定記錄檔的結尾。</span><span class="sxs-lookup"><span data-stu-id="12a53-329">The smaller of the base sequence number and the archive tail determines the tail of the log.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="12a53-330">下列範例示範如何將 <xref:System.IO.Log.LogStore> 封存至 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="12a53-330">The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.</span></span>  
  
 [!code-csharp[logarchievesnapshot#0](~/samples/snippets/csharp/VS_Snippets_CFX/logarchievesnapshot/cs/logarchievesnapshot.cs#0)]
 [!code-vb[logarchievesnapshot#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/logarchievesnapshot/vb/logarchievesnapshot.vb#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="12a53-331"><paramref name="archiveTail" /> 不是介於這個順序的基底序號和最後一個序號之間。</span><span class="sxs-lookup"><span data-stu-id="12a53-331"><paramref name="archiveTail" /> is not between the base and last sequence numbers of this sequence.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="12a53-332"><paramref name="archiveTail" /> 對此順序無效。</span><span class="sxs-lookup"><span data-stu-id="12a53-332"><paramref name="archiveTail" /> is not valid for this sequence.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="12a53-333">已經執行無效的作業。</span><span class="sxs-lookup"><span data-stu-id="12a53-333">An invalid operation has been executed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="12a53-334">建立封存快照時發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="12a53-334">An I/O error occurs when creating the archive snapshot.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="12a53-335">無法封存記錄存放區。</span><span class="sxs-lookup"><span data-stu-id="12a53-335">The log store is not archivable.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="12a53-336">已在處置序列之後呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="12a53-336">The method was called after the sequence has been disposed of.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="12a53-337">沒有足夠的記憶體可以繼續執行程式。</span><span class="sxs-lookup"><span data-stu-id="12a53-337">There is not enough memory to continue the execution of a program.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="12a53-338">存取指定的記錄存放區遭作業系統拒絕。</span><span class="sxs-lookup"><span data-stu-id="12a53-338">Access for the specified log store is denied by the operating system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StreamCount">
      <MemberSignature Language="C#" Value="public int StreamCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StreamCount" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.LogStore.StreamCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StreamCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StreamCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.StreamCount : int" Usage="System.IO.Log.LogStore.StreamCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="12a53-339">取得這個記錄存放區的記錄資料流數目。</span><span class="sxs-lookup"><span data-stu-id="12a53-339">Gets the number of log streams in this log store.</span></span></summary>
        <value><span data-ttu-id="12a53-340">這個記錄存放區的記錄資料流數目。</span><span class="sxs-lookup"><span data-stu-id="12a53-340">The number of log streams in this log store.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>