<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e43a4dd2c8528c6d190424fabffcab286390dc80" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66007166" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可變動的字元字串。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此類別代表字串相似的物件，其值是可變動的一連串的字元。  
  
 本節內容：  
  
-   [String 和 StringBuilder 類型](#StringAndSB)  
  
-   [StringBuilder 的運作方式](#HowWorks)  
  
-   [記憶體配置](#Memory)  
  
-   [具現化 StringBuilder 物件](#Instantiating)  
  
-   [呼叫 StringBuilder 方法](#Calling)  
  
-   [執行 StringBuilder 作業](#Operations)  
  
    -   [逐一查看 StringBuilder 字元](#Iterating)  
  
    -   [將文字新增至的 StringBuilder 物件](#Adding)  
  
    -   [刪除文字自 StringBuilder 物件](#Deleting)  
  
    -   [修改 StringBuilder 物件中的文字](#Modifying)  
  
-   [StringBuilder 物件中搜尋文字](#Searching)  
  
-   [將 StringBuilder 物件轉換為字串](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>String 和 StringBuilder 類型  
 雖然<xref:System.Text.StringBuilder>和<xref:System.String>都代表序列的字元，它們的實作方式不同。 <xref:System.String> 是不可變的類型。 也就是每個作業顯示修改<xref:System.String>物件實際上會建立新的字串。  
  
 例如，呼叫<xref:System.String.Concat%2A?displayProperty=nameWithType>方法，在下列 C# 範例中會出現名為的字串變數的值變更`value`。 事實上，<xref:System.String.Concat%2A>方法會傳回`value`物件，具有不同的值和位址`value`已傳遞給方法的物件。 請注意，必須使用編譯範例`/unsafe`編譯器選項。  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 針對執行大量的字串操作 （例如修改許多時間在迴圈中的字串的應用程式） 的常式，重複修改字串可以精確顯著的效能負面影響。 替代方法是使用<xref:System.Text.StringBuilder>，這是可變動字串類別。 可變動性表示，一旦建立類別的執行個體，您可以進行修改所附加、 移除、 取代或插入的字元。 A<xref:System.Text.StringBuilder>物件會維護緩衝區來容納展開為字串。 新資料附加至緩衝區的空間是否可以使用;否則，新且較大的緩衝區配置、 從原始緩衝區的資料複製到新的緩衝區，和新的資料則會附加至新的緩衝區。  
  
> [!IMPORTANT]
>  雖然<xref:System.Text.StringBuilder>類別通常提供較佳的效能比<xref:System.String>類別，您應該不會自動取代<xref:System.String>使用<xref:System.Text.StringBuilder>每當您想要操作字串。 效能取決於字串時，要針對新的字串、 在其執行您的應用程式，系統的作業類型配置的記憶體數量的大小。 您應該已準備好測試您的應用程式，以判斷是否<xref:System.Text.StringBuilder>確實會提供顯著的效能改善。  
  
 請考慮使用<xref:System.String>在這些情況下的類別：  
  
-   當您的應用程式將會對字串進行的變更數目很小。 在這些情況下，<xref:System.Text.StringBuilder>可能不明顯的供應項目或沒有效能改進<xref:System.String>。  
  
-   當您執行固定的數目的串連作業中，特別是使用字串常值。 在此情況下，編譯器可能會串連作業結合成單一作業。  
  
-   當您必須執行完整的搜尋作業，而您要建置您的字串。 <xref:System.Text.StringBuilder>搜尋方法，例如類別缺少`IndexOf`或`StartsWith`。 您必須轉換<xref:System.Text.StringBuilder>物件至<xref:System.String>針對這些作業，而這可以變換正負號的效能優勢，從使用<xref:System.Text.StringBuilder>。 如需詳細資訊，請參閱 < [StringBuilder 物件中搜尋文字](#Searching)一節。  
  
 請考慮使用<xref:System.Text.StringBuilder>在這些情況下的類別：  
  
-   當您預期您的應用程式對字串進行的變更數目為 「 不明 」，在設計階段 （例如，當您使用迴圈來串連字串，包含使用者輸入的隨機數字）。  
  
-   當您預期您的應用程式對字串進行大量變更。  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>StringBuilder 的運作方式  
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType>屬性指示的字元數<xref:System.Text.StringBuilder>目前包含的物件。 如果您新增字元<xref:System.Text.StringBuilder>物件，其長度會增加，直到它等於大小<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>屬性，定義的物件可以包含的字元數。 如果加入的字元數的長度<xref:System.Text.StringBuilder>超過其目前的容量，新的記憶體配置物件，值<xref:System.Text.StringBuilder.Capacity%2A>屬性會增加一倍，新的字元會新增至<xref:System.Text.StringBuilder>物件和其<xref:System.Text.StringBuilder.Length%2A>屬性會進行調整。 額外的記憶體供<xref:System.Text.StringBuilder>物件，直到它到達所定義的值以動態方式配置<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>屬性。 當到達最大容量時，沒有進一步的記憶體可配置給<xref:System.Text.StringBuilder>物件，並嘗試新增的字元，或擴充到超過其最大的容量會擲回其中一個<xref:System.ArgumentOutOfRangeException>或<xref:System.OutOfMemoryException>例外狀況。  
  
 下列範例說明如何<xref:System.Text.StringBuilder>物件配置新的記憶體，並會以動態方式增加其容量，因為指派給物件的字串會展開。 程式碼會建立<xref:System.Text.StringBuilder>藉由呼叫其預設 （無參數） 建構函式的物件。 此物件的預設容量 16 個字元，且其最大容量為超過 2 億個字元。 附加字串"This is 句子"。 產生新的記憶體配置，因為字串長度 （19 個字元） 超過預設容量<xref:System.Text.StringBuilder>物件。 物件的容量加倍為 32 個字元、 加入新的字串，以及物件的長度現在等於 19 個字元。 程式碼則會附加字串"This is 其他句子"。 值<xref:System.Text.StringBuilder>物件 11 倍。 每當附加作業會導致長度<xref:System.Text.StringBuilder>超過其容量，其現有容量的物件會增加一倍和<xref:System.Text.StringBuilder.Append%2A>作業成功。  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>記憶體配置  
 預設容量<xref:System.Text.StringBuilder>物件是 16 個字元，而它的預設最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 如果您呼叫，會使用這些預設值<xref:System.Text.StringBuilder.%23ctor>和<xref:System.Text.StringBuilder.%23ctor%28System.String%29>建構函式。  
  
 您可以明確定義的初始容量<xref:System.Text.StringBuilder>物件如下：  
  
-   藉由呼叫任一<xref:System.Text.StringBuilder>建構函式，其中包含`capacity`參數，當您建立的物件。  
  
-   藉由明確地指派新的值，以<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>要展開的現有屬性<xref:System.Text.StringBuilder>物件。 請注意，屬性會擲回例外狀況的新容量是否小於現有容量或更高<xref:System.Text.StringBuilder>物件的最大容量。  
  
-   藉由呼叫<xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType>使用新的容量的方法。 新的容量不能大於<xref:System.Text.StringBuilder>物件的最大容量。 不過，與指派給不同<xref:System.Text.StringBuilder.Capacity%2A>屬性，<xref:System.Text.StringBuilder.EnsureCapacity%2A>如果不擲回例外狀況所需的新容量小於現有容量; 方法呼叫在此情況下，沒有任何作用。  
  
 如果字串的長度會指派給<xref:System.Text.StringBuilder>建構函式呼叫中的物件超過預設容量或指定的容量<xref:System.Text.StringBuilder.Capacity%2A>屬性設定為與指定之字串的長度`value`參數。  
  
 您可以明確定義的最大容量<xref:System.Text.StringBuilder>藉由呼叫物件<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>建構函式。 您無法變更的最大容量指派新值給<xref:System.Text.StringBuilder.MaxCapacity%2A>屬性，因為它是唯讀的。  
  
 如上一節所示，每當現有容量不足、 其他記憶體配置和容量<xref:System.Text.StringBuilder>物件所定義之值以前的雙精度浮點數<xref:System.Text.StringBuilder.MaxCapacity%2A>屬性。  
  
 一般情況下，預設的容量和最大容量是適合大部分的應用程式。 您可以考慮設定下列情況下的這些值：  
  
-   如果的最終大小<xref:System.Text.StringBuilder>物件很可能會變得非常大，通常會超過數個 mb。 在此情況下，可能會有一些效能優點，設定初始<xref:System.Text.StringBuilder.Capacity%2A>屬性設為高的值，以便不需要太多記憶體重新配置。  
  
-   如果記憶體有限的系統上執行您的應用程式。 在此情況下，您可能要考慮<xref:System.Text.StringBuilder.MaxCapacity%2A>屬性小於<xref:System.Int32.MaxValue?displayProperty=nameWithType>如果您的應用程式正在處理可能會導致它在記憶體限制的環境中執行的大型字串。  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>具現化 StringBuilder 物件  
 您具現化<xref:System.Text.StringBuilder>藉由呼叫其六個多載的類別建構函式下, 表中所列出的其中一個物件。 三個建構函式具現化<xref:System.Text.StringBuilder>物件，其值為空字串，但將其<xref:System.Text.StringBuilder.Capacity%2A>和<xref:System.Text.StringBuilder.MaxCapacity%2A>不同值。 其餘的三個建構函式定義<xref:System.Text.StringBuilder>具有特定的字串值和容量的物件。 兩個的三個建構函式使用的預設最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>，而第三個可讓您設定的最大容量。  
  
|建構函式|字串值|容量|最大容量|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|藉由定義`capacity`參數|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|藉由定義`capacity`參數|藉由定義`maxCapacity`參數|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|藉由定義`value`參數|16 或`value`。 <xref:System.String.Length%2A>為準|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|藉由定義`value`參數|藉由定義`capacity`參數或`value`。 <xref:System.String.Length%2A>為準。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|由 `value` 定義。 <xref:System.String.Substring%2A>(`startIndex`, `length`)|藉由定義`capacity`參數或`value`。 <xref:System.String.Length%2A>為準。|藉由定義`maxCapacity`參數|  
  
 下列範例會使用這些建構函式多載的三個具現化<xref:System.Text.StringBuilder>物件。  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>呼叫 StringBuilder 方法  
 大部分的方法，修改中的字串<xref:System.Text.StringBuilder>執行個體傳回該相同的執行個體的參考。 這可讓您呼叫<xref:System.Text.StringBuilder>有兩種方法：  
  
-   您可以進行個別的方法呼叫，並忽略傳回值，如下列範例所示。  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   您可以在單一陳述式的一系列的方法呼叫。 這樣很方便，如果您想要撰寫鏈結連續作業的單一陳述式。 下列範例會將上一個範例中的三個方法呼叫合併成單一行程式碼。  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>執行 StringBuilder 作業  
 您可以使用的方法<xref:System.Text.StringBuilder>類別來逐一查看、 新增、 刪除或修改中的字元<xref:System.Text.StringBuilder>物件。  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>逐一查看 StringBuilder 字元  
 您可以存取中的字元<xref:System.Text.StringBuilder>物件使用<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>屬性。 在 C# 中，<xref:System.Text.StringBuilder.Chars%2A>是索引子，就在 Visual Basic 中的預設屬性<xref:System.Text.StringBuilder>類別。 這可讓您設定或使用其索引，而不需要明確參考來擷取個別字元<xref:System.Text.StringBuilder.Chars%2A>屬性。 中的字元<xref:System.Text.StringBuilder>物件開始索引為 0 （零），並繼續編製索引<xref:System.Text.StringBuilder.Length%2A>-1。  
  
 下列範例說明<xref:System.Text.StringBuilder.Chars%2A>屬性。 它會將附加至 10 個隨機數字<xref:System.Text.StringBuilder>物件，然後再逐一查看每個字元。 如果是字元的 Unicode 分類<xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>，它表示數目減 1 （或其值為 0 會變成 9 的數字）。 此範例會顯示的內容<xref:System.Text.StringBuilder>物件兩者之前和之後的個別字元的值已變更。  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>將文字新增至的 StringBuilder 物件  
 <xref:System.Text.StringBuilder>類別包含下列方法來擴充內容<xref:System.Text.StringBuilder>物件：  
  
-   <xref:System.Text.StringBuilder.Append%2A>方法會將附加的字串、 子字串、 字元陣列、 在字元陣列的一部分的單一字元重複許多次，或基本資料的字串表示法輸入以<xref:System.Text.StringBuilder>物件。  
  
-   <xref:System.Text.StringBuilder.AppendLine%2A>方法會將行結束字元或行結束字元字串附加<xref:System.Text.StringBuilder>物件。  
  
-   <xref:System.Text.StringBuilder.AppendFormat%2A>方法會附加[複合格式字串](~/docs/standard/base-types/composite-formatting.md)至<xref:System.Text.StringBuilder>物件。 物件包含在結果字串的字串表示，可反映出目前系統文化特性或指定的文化特性的格式化慣例。  
  
-   <xref:System.Text.StringBuilder.Insert%2A>方法會將插入字串，子字串，將字串的多個重複項目中的指定位置的字元陣列、 在字元陣列的一部分或基本資料的字串表示法輸入<xref:System.Text.StringBuilder>物件。 以零為起始的索引所定義的位置。  
  
 下列範例會使用<xref:System.Text.StringBuilder.Append%2A>， <xref:System.Text.StringBuilder.AppendLine%2A>， <xref:System.Text.StringBuilder.AppendFormat%2A>，以及<xref:System.Text.StringBuilder.Insert%2A>方法，以展開的文字<xref:System.Text.StringBuilder>物件。  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>刪除文字自 StringBuilder 物件  
 <xref:System.Text.StringBuilder>類別包含方法，就目前的大小縮減<xref:System.Text.StringBuilder>執行個體。 <xref:System.Text.StringBuilder.Clear%2A>方法會移除所有字元，並設定<xref:System.Text.StringBuilder.Length%2A>屬性設為零。 <xref:System.Text.StringBuilder.Remove%2A>方法會刪除指定的特定索引位置開始的字元數。 此外，您可以從結尾移除字元<xref:System.Text.StringBuilder>物件，藉由設定其<xref:System.Text.StringBuilder.Length%2A>屬性設為小於目前的執行個體的長度的值。  
  
 下列範例會移除部分中的文字<xref:System.Text.StringBuilder>物件，其產生的容量、 最大容量和長度屬性值，會顯示，然後呼叫<xref:System.Text.StringBuilder.Clear%2A>方法來移除所有字元<xref:System.Text.StringBuilder>物件。  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>修改 StringBuilder 物件中的文字  
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType>方法會取代所有出現的字元或字串，以在整個<xref:System.Text.StringBuilder>物件或在特定的字元範圍。 下列範例會使用<xref:System.Text.StringBuilder.Replace%2A>方法以問號 （？） 取代所有的驚嘆號 （！），在<xref:System.Text.StringBuilder>物件。  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>StringBuilder 物件中搜尋文字  
 <xref:System.Text.StringBuilder>類別不包含方法類似於<xref:System.String.Contains%2A?displayProperty=nameWithType>， <xref:System.String.IndexOf%2A?displayProperty=nameWithType>，以及<xref:System.String.StartsWith%2A?displayProperty=nameWithType>所提供的方法<xref:System.String>類別，可讓您搜尋特定字元或子字串的物件。 判斷是否存在，或開始之子字串的字元位置，需要您搜尋<xref:System.String>使用字串搜尋方法或規則運算式方法的值。 有四種方式，來實作這類的搜尋，如下表所示。  
  
|技術|專業人員|缺點|  
|---------------|----------|----------|  
|搜尋字串值，再將它們加入至<xref:System.Text.StringBuilder>物件。|適用於判斷子字串是否存在。|子字串的索引位置都很重要時，無法使用。|  
|呼叫<xref:System.Text.StringBuilder.ToString%2A>並搜尋傳回<xref:System.String>物件。|簡單易用，如果您將指派到的所有文字<xref:System.Text.StringBuilder>物件，然後再開始進行修改。|重複地呼叫麻煩<xref:System.Text.StringBuilder.ToString%2A>如果所有的文字已加入之前，您必須先修改<xref:System.Text.StringBuilder>物件。<br /><br /> 從結尾時，您必須記得<xref:System.Text.StringBuilder>物件的文字，如果您這樣做的變更。|  
|使用<xref:System.Text.StringBuilder.Chars%2A>循序搜尋的字元範圍的屬性。|如果您所關心的個別字元或小型的子字串很有用。|如果要搜尋的字元數是大型或複雜的搜尋邏輯是否很麻煩。<br /><br />在核心重複的方法呼叫透過非常大型的物件的效能非常低落的結果。  |  
|轉換<xref:System.Text.StringBuilder>物件至<xref:System.String>物件，並在執行修改<xref:System.String>物件。|如果所做的修改數目少很有用。|否定的效能優勢<xref:System.Text.StringBuilder>類別所做的修改數目很大。|  
  
 讓我們來檢查詳細說明這些技術。  
  
-   如果搜尋的目標是要判斷是否為特定的子字串存在 （亦即，如果您不感興趣的子字串的位置），您可以搜尋字串，然後再將它們儲存在<xref:System.Text.StringBuilder>物件。 下列範例提供一個可能的實作。 它會定義`StringBuilderFinder`類別的建構函式的參考會傳遞給<xref:System.Text.StringBuilder>物件和要在字串中找到的子字串。 此範例在此情況下，會嘗試判斷是否已錄製的溫度華氏或攝氏溫度，以及將適當的簡介文字的開頭加入<xref:System.Text.StringBuilder>物件。 亂數產生器用來選取陣列，其中包含為攝氏或華氏的資料。  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   呼叫<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法，將轉換<xref:System.Text.StringBuilder>物件到<xref:System.String>物件。 您可以使用下列方法來搜尋字串<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>或是<xref:System.String.StartsWith%2A?displayProperty=nameWithType>，或者您可以使用規則運算式和<xref:System.Text.RegularExpressions.Regex>類別搜尋模式。 因為這兩<xref:System.Text.StringBuilder>和<xref:System.String>物件會使用 utf-16 編碼方式儲存的子字串的字元的索引位置的字元和規則運算式相符項目是在這兩個物件相同。 這可讓您使用<xref:System.Text.StringBuilder>方法，以變更該文字位於相同位置<xref:System.String>物件。  
  
    > [!NOTE]
    >  如果您採用這種方法，您都能從結尾<xref:System.Text.StringBuilder>物件，其開始，讓您不必重複轉換<xref:System.Text.StringBuilder>為字串的物件。  
  
     下列範例將示範這個方法。 它會儲存每個字母英文字母，在四個相符項目<xref:System.Text.StringBuilder>物件。 然後將轉換的文字<xref:System.String>物件，並使用規則運算式來識別每個四個字元序列的開始位置。 最後，它會新增第一個序列中，除了每四個字元序列前面，底線，然後將轉換成大寫序列的第一個字元。  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   使用<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>屬性，來循序搜尋中的字元範圍<xref:System.Text.StringBuilder>物件。 如果要搜尋的字元數目很大，或特別複雜的搜尋邏輯，這種方法可能不是實際。 如需效能含意，逐字元的索引為基礎的存取非常大型的區塊<xref:System.Text.StringBuilder>物件，請參閱文件<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>屬性。 
  
     下列範例是前一個範例相同的功能，但在實作不同。 它會使用<xref:System.Text.StringBuilder.Chars%2A>屬性，以偵測何時變更的字元值，該位置插入底線，並將新序列的第一個字元轉換成大寫。  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   存放區中的所有未修改的文字<xref:System.Text.StringBuilder>物件，請呼叫<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法，將轉換<xref:System.Text.StringBuilder>物件<xref:System.String>物件，並對所做的修改<xref:System.String>物件。 您可以使用這種方法，如果您有只有少數修改;否則，請使用不可變的字串的成本可能不利於效能使用<xref:System.Text.StringBuilder>物件。  
  
     下列範例與上述的兩個範例相同的功能，但在實作兩者不同。 它會建立<xref:System.Text.StringBuilder>物件，將它轉換成<xref:System.String>物件，並接著會使用規則運算式字串上執行所有剩餘的修改。 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法使用 lambda 運算式，以在每個相符項目上執行取代。  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>將 StringBuilder 物件轉換為字串  
 您必須先將 <xref:System.Text.StringBuilder> 物件轉換成 <xref:System.String> 物件，才能將 <xref:System.Text.StringBuilder> 物件所代表的字串傳遞給具有 <xref:System.String> 參數的方法，或在使用者介面中加以顯示。 您可以執行這項轉換藉由呼叫<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法。 如需圖例，請參閱上述的範例中，呼叫<xref:System.Text.StringBuilder.ToString%2A>方法，將轉換<xref:System.Text.StringBuilder>物件的字串，使它可以傳遞至規則運算式方法。  
  
   
  
## Examples  
 下列範例示範如何呼叫所定義之方法的許多<xref:System.Text.StringBuilder>類別。  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個執行個體的字串值設定為<xref:System.String.Empty?displayProperty=nameWithType>，而且容量設定為實作專屬的預設容量。  
  
   
  
## Examples  
 下列範例示範如何呼叫<xref:System.Text.StringBuilder.%23ctor%2A>不含任何參數的建構函式。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">這個執行個體建議的起始大小。</param>
        <summary>使用指定的容量來初始化 <see cref="T:System.Text.StringBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`參數定義的可儲存目前的執行個體所配置的記憶體中的字元數上限。 其值會指派給<xref:System.Text.StringBuilder.Capacity%2A>屬性。 若要儲存目前的執行個體中的字元數超過這`capacity`值，<xref:System.Text.StringBuilder>物件會配置額外的記憶體來儲存它們。  
  
 這個執行個體的字串值設定為<xref:System.String.Empty?displayProperty=nameWithType>。 如果`capacity`為零，使用實作專屬的預設容量。  
  
   
  
## Examples  
 下列範例示範如何呼叫<xref:System.Text.StringBuilder.%23ctor%2A>建構函式使用指定的容量。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小於零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">用來初始化執行個體值的字串。 如果 <paramref name="value" /> 為 <see langword="null" />，新的 <see cref="T:System.Text.StringBuilder" /> 將包含空字串 (即包含 <see cref="F:System.String.Empty" />)。</param>
        <summary>以指定的字串初始化 <see cref="T:System.Text.StringBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `value` 為 `null`，新的 <xref:System.Text.StringBuilder> 將包含空字串 (即包含 <xref:System.String.Empty>)。  
  
   
  
## Examples  
 下列範例示範如何呼叫<xref:System.Text.StringBuilder.%23ctor%2A>建構函式使用指定的字串。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 建議的起始大小。</param>
        <param name="maxCapacity">目前字串可以包含的最大字元數。</param>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 類別的新執行個體，將從指定的容量開始並且可以增加至指定的最大值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`參數定義的可儲存目前的執行個體所配置的記憶體中的字元數上限。 其值會指派給<xref:System.Text.StringBuilder.Capacity%2A>屬性。 若要儲存目前的執行個體中的字元數超過這`capacity`值，<xref:System.Text.StringBuilder>物件會配置額外的記憶體來儲存它們。  
  
 如果`capacity`為零，使用實作專屬的預設容量。  
  
 `maxCapacity`屬性會定義目前的執行個體可以容納的字元數目上限。 其值會指派給<xref:System.Text.StringBuilder.MaxCapacity%2A>屬性。 若要儲存目前的執行個體中的字元數超過這`maxCapacity`值，<xref:System.Text.StringBuilder>物件不會配置額外的記憶體，但改為擲回例外狀況。  
  
   
  
## Examples  
 下列範例示範如何呼叫<xref:System.Text.StringBuilder.%23ctor%2A>建構函式使用指定的容量和最大容量。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> 小於一，<paramref name="capacity" /> 小於零，或 <paramref name="capacity" /> 大於 <paramref name="maxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">用來初始化執行個體值的字串。 如果 <paramref name="value" /> 為 <see langword="null" />，新的 <see cref="T:System.Text.StringBuilder" /> 將包含空字串 (即包含 <see cref="F:System.String.Empty" />)。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 建議的起始大小。</param>
        <summary>使用指定的字串和容量，來初始化 <see cref="T:System.Text.StringBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`參數定義的可儲存目前的執行個體所配置的記憶體中的字元數上限。 其值會指派給<xref:System.Text.StringBuilder.Capacity%2A>屬性。 若要儲存目前的執行個體中的字元數超過這`capacity`值，<xref:System.Text.StringBuilder>物件會配置額外的記憶體來儲存它們。  
  
 如果`capacity`為零，使用實作專屬的預設容量。  
  
   
  
## Examples  
 下列範例示範如何呼叫<xref:System.Text.StringBuilder.%23ctor%2A>建構函式的初始字串與指定的容量。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小於零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字串，包含用來初始化此執行個體值的子字串。 如果 <paramref name="value" /> 為 <see langword="null" />，新的 <see cref="T:System.Text.StringBuilder" /> 將包含空字串 (即包含 <see cref="F:System.String.Empty" />)。</param>
        <param name="startIndex">在 <paramref name="value" /> 內子字串開始的位置。</param>
        <param name="length">子字串中的字元數。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 建議的起始大小。</param>
        <summary>以指定的子字串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`參數定義的可儲存目前的執行個體所配置的記憶體中的字元數上限。 其值會指派給<xref:System.Text.StringBuilder.Capacity%2A>屬性。 若要儲存目前的執行個體中的字元數超過這`capacity`值，<xref:System.Text.StringBuilder>物件會配置額外的記憶體來儲存它們。  
  
 如果`capacity`為零，使用實作專屬的預設容量。  
  
   
  
## Examples  
 下列範例示範如何呼叫<xref:System.Text.StringBuilder.%23ctor%2A>建構函式使用指定的字串。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> 加上 <paramref name="length" /> 不是 <paramref name="value" /> 內的位置。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定物件的字串表示附加至這個執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">要附加的布林值。</param>
        <summary>將指定的布林 (Boolean) 值之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法呼叫<xref:System.Boolean.ToString?displayProperty=nameWithType>方法來取得的字串表示`value`。 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 8 位元不帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法呼叫<xref:System.Byte.ToString%28System.IFormatProvider%29>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要附加的 UTF-16 編碼字碼單位。</param>
        <summary>將指定 <see cref="T:System.Char" /> 物件的字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">要附加的字元陣列。</param>
        <summary>將指定陣列中的 Unicode 字元的字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會附加至目前的執行個體的相同順序指定陣列中的所有字元濆婞剢謅`value`。 如果`value`是`null`，不會變更。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的小數位數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法呼叫<xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的雙精度浮點數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法呼叫<xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 16 位元帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法呼叫<xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 32 位元帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法呼叫<xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 64 位元帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法呼叫<xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>若要取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要附加的物件。</param>
        <summary>將指定物件的字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。 它會定義`Dog`類別中，建立`Dog`物件，並讓三次呼叫<xref:System.Text.StringBuilder.Append%2A>方法用來建立包含 dog 的名稱和品種的字串。  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法呼叫<xref:System.Object.ToString%2A?displayProperty=nameWithType>方法來取得的字串表示`value`。 如果`value`已`null`，不會變更至<xref:System.Text.StringBuilder>物件。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 8 位元帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法呼叫<xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的單精確度浮點數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法呼叫<xref:System.Single.ToString%2A?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要附加的字串。</param>
        <summary>將指定字串的複本附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 如果`value`是`null`，不會變更。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 16 位元不帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法呼叫<xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法來取得的字串表示`value`。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 32 位元不帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>呼叫<xref:System.UInt32.ToString%2A?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要附加的值。</param>
        <summary>將指定的 64 位元不帶正負號的整數之字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法呼叫<xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>方法來取得的字串表示`value`目前文化特性。 若要控制的格式`value`，呼叫<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要附加的字元。</param>
        <param name="repeatCount">要附加 <paramref name="value" /> 的次數。</param>
        <summary>將 Unicode 字元其字串表示的指定複本數附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> 小於零。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.OutOfMemoryException">記憶體不足。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">字元陣列的指標。</param>
        <param name="valueCount">陣列中的字元數。</param>
        <summary>將指定位址開頭的 Unicode 字元陣列附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會附加`valueCount`位址開頭的字元`value`目前執行個體。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> 小於零。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> 是 null 指標。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字元陣列。</param>
        <param name="startIndex"><paramref name="value" /> 中的開始位置。</param>
        <param name="charCount">要附加的字元數。</param>
        <summary>將 Unicode 字元之指定子陣列的字串表示附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會附加指定的範圍中的字元`value`目前執行個體。 如果`value`是`null`並`startIndex`和`count`兩者都是零，不會變更。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 是 <see langword="null" />，而 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不是零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> + <paramref name="charCount" /> 大於 <paramref name="value" /> 的長度。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">包含要附加之子字串的字串。</param>
        <param name="startIndex"><paramref name="value" /> 中子字串的開始位置。</param>
        <param name="count"><paramref name="value" /> 中要附加的字元數。</param>
        <summary>將指定子字串的複本附加至這個執行個體。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會附加指定的範圍中的字元`value`目前執行個體。 如果`value`是`null`並`startIndex`和`count`兩者都是零，不會變更。  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法會修改現有的執行個體，這個類別的; 它不會傳回新的類別執行個體。 因為這個緣故，呼叫方法或屬性上現有的參考，並沒有傳回值指派給<xref:System.Text.StringBuilder>物件，如下列範例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 是 <see langword="null" />，而 <paramref name="startIndex" /> 和 <paramref name="count" /> 不是零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> + <paramref name="count" /> 大於 <paramref name="value" /> 的長度。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 每一個格式項目會由對應之物件引數的字串表示所取代。</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">複合格式字串。</param>
        <param name="arg0">要格式化的物件。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 每一個格式項目都會取代為單一引數的字串表示。</summary>
        <returns>附加 <paramref name="format" /> 的執行個體參考。 <paramref name="format" /> 中的每一個格式項目都會取代為 <paramref name="arg0" /> 的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)物件的值轉換成其文字表示，並將該表示內嵌在目前的.NET framework<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目。 格式項目的索引必須是 0，以對應至`arg0`，這個方法的參數清單中的單一物件。 格式化的程序取代的字串表示法中的每個格式項目`arg0`。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 如果在沒有參數*index*位置，<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0` 表示要格式化的物件。 中的每個格式項目`format`的字串表示取代`arg0`。 如果格式項目包含`formatString`並`arg0`實作<xref:System.IFormattable>介面，然後`arg0.ToString(formatString, null)`定義的格式。 否則，`arg0.ToString()`定義的格式。  
  
 如果字串指派給`format`是 「 感謝您捐贈 {0: # # #} 罐食物給本慈善組織。 」 和`arg0`是一個整數值為 10，傳回的值會是 「 謝謝您捐贈 10 罐食物給本慈善組織。 」  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零) 或大於等於 1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">複合格式字串。</param>
        <param name="args">要格式化的物件陣列。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 每一個格式項目會由參數陣列中對應之引數的字串表示所取代。</summary>
        <returns>附加 <paramref name="format" /> 的執行個體參考。 <paramref name="format" /> 中的每一個格式項目會由對應之物件引數的字串表示所取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)物件的值轉換成其文字表示，並將該表示內嵌在目前的.NET framework<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目，對應至這個方法的參數清單中的物件。 格式化的程序會將每個格式項目取代對應的物件的字串表示。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 如果在沒有參數*index*位置，<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `args` 表示要格式化的物件。 中的每個格式項目`format`中的對應物件的字串表示取代`args`。 如果格式項目包含`formatString`中對應的物件`args`實作<xref:System.IFormattable>介面，然後`args[index].ToString(formatString, provider)`定義的格式。 否則，`args[index].ToString()`定義的格式。  
  
 如果字串指派給`format`是 「 感謝您捐贈 {0: # # #} 罐食物給本慈善組織。 」 和`arg0`是一個整數值為 10，傳回的值會是 「 謝謝您捐贈 10 罐食物給本慈善組織。 」  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 或 <paramref name="args" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零)，或大於或等於 <paramref name="args" /> 陣列的長度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">複合格式字串。</param>
        <param name="arg0">要格式化的物件。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 使用指定的格式提供者，將每個格式項目取代為單一引數的字串表示。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。 在附加作業之後，這個執行個體會包含作業前已經存在的所有資料，並後置有 <paramref name="format" /> 的複本，其中的任何格式規格都會由 <paramref name="arg0" /> 的字串表示所取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)的.NET Framework，才能將值轉換成`arg0`成其文字表示，而且在目前嵌入該表示法<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目。 每個格式項目的索引必須是零 (0)，因為這個方法包含使用單一引數的引數清單。 格式化的程序取代的字串表示法中的每個格式項目`arg0`。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 在此情況下，因為<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>方法中引數清單的值具有單一引數*index*必須一律為 0。 如果未列出，請<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`參數指定<xref:System.IFormatProvider>實作，可提供格式設定資訊中的物件`args`。 `provider` 可以是下列任何項目：  
  
-   A<xref:System.Globalization.CultureInfo>提供特定文化特性格式資訊的物件。  
  
-   A<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性格式資訊`arg0`如果它是一個數字值。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>物件，提供特定文化特性格式資訊`arg0`時的日期和時間值。  
  
-   自訂<xref:System.IFormatProvider>實作，提供格式設定資訊`arg0`。 一般而言，這類實作也會實作<xref:System.ICustomFormatter>介面。  
  
 如果`provider`參數是`null`、 格式資訊取自目前文化特性。  
  
 `arg0` 表示要格式化的物件。 中的每個格式項目`format`的字串表示取代`arg0`。 如果格式項目包含`formatString`並`arg0`實作<xref:System.IFormattable>介面，然後`arg0.ToString(formatString, provider)`定義的格式。 否則，`arg0.ToString()`定義的格式。  
  
   
  
## Examples  
 以下包含兩個呼叫<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>方法。 兩者都使用英文-英國 (EN-GB) 文化特性的格式化慣例。 第一個插入的字串表示<xref:System.Decimal>值結果字串中的貨幣。 第二個插入<xref:System.DateTime>字串在結果中的兩個位置的值，第一個包括僅限簡短日期字串和第二個短時間的字串。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零) 或大於等於 1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定義和使用自訂數值格式提供者</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">複合格式字串。</param>
        <param name="args">要格式化的物件陣列。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 每一個格式項目會由參數陣列 (此參數陣列使用所指定的格式提供者) 中對應之物件引數的字串表示所取代。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。 在附加作業之後，此執行個體會包含此作業之前已存在的所有資料，並後置有 <paramref name="format" /> 的複本，其中的任何格式規格都會由對應物件引數的字串表示所取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)物件的值轉換成其文字表示，並將該表示內嵌在目前的.NET framework<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目，對應至這個方法的參數清單中的物件。 格式化的程序會將每個格式項目取代對應的物件的字串表示。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|說明|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 如果在沒有參數*index*位置，<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`參數指定<xref:System.IFormatProvider>實作，可提供格式設定資訊中的物件`args`。 `provider` 可以是下列任何項目：  
  
-   A<xref:System.Globalization.CultureInfo>提供特定文化特性格式資訊的物件。  
  
-   A<xref:System.Globalization.NumberFormatInfo>物件，提供特定文化特性格式資訊的數值`args`。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>物件，提供特定文化特性格式資訊中的日期和時間值`args`。  
  
-   自訂<xref:System.IFormatProvider>實作，可提供一或多個物件中的格式資訊`args`。 一般而言，這類實作也會實作<xref:System.ICustomFormatter>介面。 在下一節中的第二個範例說明<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>使用自訂的方法呼叫<xref:System.IFormatProvider>實作。  
  
 如果`provider`參數是`null`，格式提供者資訊取自目前文化特性。  
  
 `args` 表示要格式化的物件。 中的每個格式項目`format`中的對應物件的字串表示取代`args`。 如果格式項目包含`formatString`中對應的物件`args`實作<xref:System.IFormattable>介面，然後`args[index].ToString(formatString, provider)`定義的格式。 否則，`args[index].ToString()`定義的格式。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 下列範例會定義自訂<xref:System.IFormatProvider>實作名為`CustomerFormatter`格式化 10 位數客戶編號，以連字號之後的第四個和第七個位數。 它會傳遞至<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>方法用來建立包含已格式化的客戶數目和客戶名稱的字串。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零)，或大於或等於 <paramref name="args" /> 陣列的長度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定義和使用自訂數值格式提供者</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">複合格式字串。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 每一個格式項目都會取代為兩個引數中任一個的字串表示。</summary>
        <returns>附加 <paramref name="format" /> 的執行個體參考。 <paramref name="format" /> 中的每一個格式項目會由對應之物件引數的字串表示所取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)物件的值轉換成其文字表示，並將該表示內嵌在目前的.NET framework<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目，對應至`arg0`和`arg1`，這個方法的參數清單中的兩個物件。 格式化的程序會將每個格式項目取代對應的物件的字串表示。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 如果在沒有參數*index*位置，<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0` 和`arg1`表示要格式化的物件。 中的每個格式項目`format`任一個的字串表示取代`arg0`或`arg1`。 如果格式項目包含`formatString`和對應的物件會實作<xref:System.IFormattable>介面，然後`arg` *x* `.ToString(formatString, provider)`會定義格式，其中*x*是引數的索引。 否則，請`arg` *x* `.ToString()`定義的格式。  
  
 如果字串指派給`format`是 「 感謝您捐贈 {0: # # #} 罐食物給本慈善組織。 」 和`arg0`是一個整數值為 10，傳回的值會是 「 謝謝您捐贈 10 罐食物給本慈善組織。 」  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零) 或大於等於 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">複合格式字串。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 使用指定的格式提供者，將每個格式項目取代為兩個引數中的其中一個字串表示。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。 在附加作業之後，此執行個體會包含此作業之前已存在的所有資料，並後置有 <paramref name="format" /> 的複本，其中的任何格式規格都會由對應物件引數的字串表示所取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)物件的值轉換成其文字表示，並將該表示內嵌在目前的.NET framework<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目，對應至這個方法的參數清單中的物件。 格式化的程序會將每個格式項目取代對應的物件的字串表示。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|說明|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 如果在沒有參數*index*位置，<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`參數指定<xref:System.IFormatProvider>實作，可提供格式設定資訊`arg0`和`arg1`。 `provider` 可以是下列任何項目：  
  
-   A<xref:System.Globalization.CultureInfo>提供特定文化特性格式資訊的物件。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供特定文化特性格式資訊的物件`arg0`或`arg1`如果它們是數值。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>提供特定文化特性格式資訊的物件`arg0`或`arg1`有日期和時間值。  
  
-   自訂<xref:System.IFormatProvider>實作，提供格式設定資訊`arg0`和`arg1`。 一般而言，這類實作也會實作<xref:System.ICustomFormatter>介面。  
  
 如果`provider`參數是`null`，格式提供者資訊取自目前文化特性。  
  
 `arg0` 和`arg1`表示要格式化的物件。 中的每個格式項目`format`會取代具有對應的索引之物件的字串表示。 如果格式項目包含`formatString`並實作相對應的引數<xref:System.IFormattable>介面，則該引數的`ToString(formatString, provider)`方法可讓您定義的格式。 否則，引數的`ToString()`方法可讓您定義的格式。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29>方法，以顯示儲存在一般時間和溫度資料<xref:System.Collections.Generic.Dictionary%602>物件。 請注意，格式字串三個格式項目，雖然有只能以要格式化的物件。 這是因為在清單中 （日期和時間值） 的第一個物件由兩個格式項目：第一個格式項目會顯示第二個情況下，就會顯示日期。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零) 或大於等於 2 (二)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定義和使用自訂數值格式提供者</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">複合格式字串。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <param name="arg2">要格式化的第三個物件。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 每一個格式項目都會取代為三個引數中任一個的字串表示。</summary>
        <returns>附加 <paramref name="format" /> 的執行個體參考。 <paramref name="format" /> 中的每一個格式項目會由對應之物件引數的字串表示所取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)物件的值轉換成其文字表示，並將該表示內嵌在目前的.NET framework<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目，對應至`arg0`透過`arg2`，這個方法的參數清單中的物件。 格式化的程序會將每個格式項目取代對應的物件的字串表示。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 如果在沒有參數*index*位置，<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0``arg1`，和`arg2`表示要格式化的物件。 中的每個格式項目`format`任一個的字串表示取代`arg0`， `arg1`，或`arg2`，視使用的格式項目的索引。 如果格式項目包含`formatString`中對應的物件`args`實作<xref:System.IFormattable>介面，然後`arg` *x* `.ToString(formatString, null)`其中定義的格式、 *x*是引數的索引。 否則，請`arg` *x* `.ToString()`定義的格式。  
  
 如果字串指派給`format`是 「 感謝您捐贈 {0: # # #} 罐食物給本慈善組織。 」 和`arg0`是一個整數值為 10，傳回的值會是 「 謝謝您捐贈 10 罐食物給本慈善組織。 」  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零) 或大於等於 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">物件，提供特定文化特性格式資訊。</param>
        <param name="format">複合格式字串。</param>
        <param name="arg0">要格式化的第一個物件。</param>
        <param name="arg1">要格式化的第二個物件。</param>
        <param name="arg2">要格式化的第三個物件。</param>
        <summary>將處理複合格式字串所傳回的字串 (其中包含零或更多的格式項目) 附加至這個執行個體。 使用指定的格式提供者，將每個格式項目取代為三個引數中的其中一個字串表示。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。 在附加作業之後，此執行個體會包含此作業之前已存在的所有資料，並後置有 <paramref name="format" /> 的複本，其中的任何格式規格都會由對應物件引數的字串表示所取代。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用[複合格式功能](~/docs/standard/base-types/composite-formatting.md)物件的值轉換成其文字表示，並將該表示內嵌在目前的.NET framework<xref:System.Text.StringBuilder>物件。  
  
 `format`參數是由零個或多個文字執行混合零或多個索引的預留位置，稱為格式項目，對應至這個方法的參數清單中的物件。 格式化的程序會將每個格式項目取代對應的物件的字串表示。  
  
 格式項目的語法如下所示：  
  
 {*index*[,*length*][:*formatString*]}  
  
 在方括號中的元素是選擇性的元素。 下表說明每個元素。  
  
|元素|描述|  
|-------------|-----------------|  
|*index*|參數清單中要格式化之物件的以零為起始位置。 如果所指定的物件*index*是`null`，格式項目取代為<xref:System.String.Empty?displayProperty=nameWithType>。 如果在沒有參數*index*位置，<xref:System.FormatException>就會擲回。|  
|,*length*|參數的字串表示法中的字元數目下限。 如果是正數，參數會靠右對齊;如果是負數，它是靠左對齊。|  
|:*formatString*|標準或自訂格式字串所支援的參數。|  
  
> [!NOTE]
>  搭配日期和時間值的標準和自訂格式字串，請參閱 <<c0> [ 標準日期和時間格式字串](~/docs/standard/base-types/standard-date-and-time-format-strings.md)並[自訂日期和時間格式字串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 針對搭配數值使用標準和自訂格式字串，請參閱[標準數值格式字串](~/docs/standard/base-types/standard-numeric-format-strings.md)並[自訂數值格式字串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 列舉型別搭配使用的標準格式字串，請參閱 <<c0> [ 列舉格式字串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `provider`參數指定<xref:System.IFormatProvider>實作，可提供格式設定資訊`arg0`和`arg1`。 `provider` 可以是下列任何項目：  
  
-   A<xref:System.Globalization.CultureInfo>提供特定文化特性格式資訊的物件。  
  
-   A<xref:System.Globalization.NumberFormatInfo>提供特定文化特性格式資訊的物件`arg0`或`arg1`如果它們是數值。  
  
-   A<xref:System.Globalization.DateTimeFormatInfo>提供特定文化特性格式資訊的物件`arg0`， `arg1`，或`arg2`有日期和時間值。  
  
-   自訂<xref:System.IFormatProvider>實作，提供格式設定資訊`arg0`， `arg1`，和`arg2`。 一般而言，這類實作也會實作<xref:System.ICustomFormatter>介面。  
  
 如果`provider`參數是`null`，格式提供者資訊取自目前文化特性。  
  
 `arg0``arg1`，和`arg2`表示要格式化的物件。 中的每個格式項目`format`會取代具有對應的索引之物件的字串表示。 如果格式項目包含`formatString`並實作相對應的引數<xref:System.IFormattable>介面，則該引數的`ToString(formatString, provider)`方法可讓您定義的格式。 否則，引數的`ToString()`方法可讓您定義的格式。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法，以說明的布林值結果`And`整數值的作業。 請注意，格式字串包含六個格式項目，此方法有三個項目在其引數清單中，因為每個項目兩種不同方式格式化。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 無效。  
  
-或- 
格式項目的索引小於 0 (零) 或大於等於 3 (三)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">展開後的字串長度會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">在 .NET 中將類型格式化</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合格式</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定義和使用自訂數值格式提供者</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自訂數值格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自訂日期和時間格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自訂 TimeSpan 格式字串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列舉格式字串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將預設行結束字元，或是指定字串的複本以及預設行結束字元，附加至這個執行個體的尾端。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將預設行結束字元附加至目前 <see cref="T:System.Text.StringBuilder" /> 物件的尾端。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設行結束字元是目前的值<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>屬性。  
  
 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.AppendLine%2A>方法。  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要附加的字串。</param>
        <summary>將後面接著預設行結束字元的指定字串複本附加至目前的 <see cref="T:System.Text.StringBuilder" /> 物件結尾。</summary>
        <returns>完成附加作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設行結束字元是目前的值<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>屬性。  
  
 視需要調整此執行個體的容量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<see cref="T:System.Text.StringBuilder" />藉由呼叫物件<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />建構函式，長度和容量<see cref="T:System.Text.StringBuilder" />執行個體可以成長的值超過其<see cref="P:System.Text.StringBuilder.MaxCapacity" />屬性。 這可能特別是當您呼叫<see cref="M:System.Text.StringBuilder.Append(System.String)" />和<see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />附加小字串的方法。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定由目前執行個體配置的記憶體可以包含的最大字元數。</summary>
        <value>目前執行個體配置的記憶體可以包含的最大字元數。 其值的範圍可從 <see cref="P:System.Text.StringBuilder.Length" /> 到 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> 不會影響目前的執行個體的字串值。 <xref:System.Text.StringBuilder.Capacity%2A> 只要不是您可以減少小於<xref:System.Text.StringBuilder.Length%2A>。  
  
 <xref:System.Text.StringBuilder>動態配置時所需的更多空間，並增加<xref:System.Text.StringBuilder.Capacity%2A>據此。 基於效能考量，<xref:System.Text.StringBuilder>可能會配置超出需要的記憶體。 配置數量是記憶體的實作而定。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Capacity%2A>屬性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於這個執行個體的目前長度。  
  
-或- 
為設定作業指定的值大於最大容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">字元的位置。</param>
        <summary>取得或設定這個執行個體中指定字元位置的字元。</summary>
        <value>位置 <paramref name="index" /> 上的 Unicode 字元。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `index`參數是位置內的字元<xref:System.Text.StringBuilder>。 第一個字元在字串中的位於索引 0。 字串的長度是它所包含的字元數目。 最後一個可存取字元<xref:System.Text.StringBuilder>執行個體位於索引<xref:System.Text.StringBuilder.Length%2A>-1。  
  
 <xref:System.Text.StringBuilder.Chars%2A> 預設屬性<xref:System.Text.StringBuilder>類別。 在 C# 中，它是索引子。 這表示可以擷取從的個別字元<xref:System.Text.StringBuilder.Chars%2A>屬性中所示下列的範例中，計算的數目是英文字母，泛空白字元和標點符號字元在字串中的。  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>效能和字元為主的索引

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定字元時，<paramref name="index" /> 超出這個執行個體的範圍。</exception>
        <exception cref="T:System.IndexOutOfRangeException">取得字元時，<paramref name="index" /> 超出這個執行個體的範圍。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從目前的 <see cref="T:System.Text.StringBuilder" /> 執行個體移除所有字元。</summary>
        <returns>其 <see cref="P:System.Text.StringBuilder.Length" /> 為 0 (零) 的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Text.StringBuilder.Clear%2A> 是一種便利方法，相當於設定<xref:System.Text.StringBuilder.Length%2A>屬性目前的執行個體設為 0 （零）。  
  
## Examples

下列範例會具現化<xref:System.Text.StringBuilder>物件是字串、 呼叫<xref:System.Text.StringBuilder.Clear%2A>方法，然後附加新的字串。  
  
[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">此執行個體中的開始位置，為字元的複製來源。 索引以零為起始。</param>
        <param name="destination">將複製其中字元的陣列。</param>
        <param name="destinationIndex"><paramref name="destination" /> 中開始複製字元的位置。 索引以零為起始。</param>
        <param name="count">要複製的字元數。</param>
        <summary>將此執行個體指定區段中的字元複製到目的端 <see cref="T:System.Char" /> 陣列的指定區段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.CopyTo%2A>方法是使用在罕見的情況下，當您需要有效率地複製的後續各節<xref:System.Text.StringBuilder>物件至陣列。 陣列應該是固定的大小，預先配置、 可重複使用，並可能是全域存取。  
  
 例如，擴展您的應用程式可能<xref:System.Text.StringBuilder>物件具有大量字元，然後使用<xref:System.Text.StringBuilder.CopyTo%2A>方法，將複製的小型的後續部分<xref:System.Text.StringBuilder>物件至陣列，其中可以處理項目。 當中的所有資料<xref:System.Text.StringBuilder>處理物件時，大小<xref:System.Text.StringBuilder>物件設定為零，並在重複循環。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.CopyTo%2A>方法。  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="sourceIndex" /> 大於這個執行個體的長度。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> 大於這個執行個體的長度。  
  
-或- 
 <paramref name="destinationIndex" /> + <paramref name="count" /> 大於 <paramref name="destination" /> 的長度。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">要確定的最大容量。</param>
        <summary>請確定這個 <see cref="T:System.Text.StringBuilder" /> 執行個體的容量至少是某一指定的值。</summary>
        <returns>這個執行個體的新容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的容量小於`capacity`參數，這個執行個體的記憶體重新配置到至少保留`capacity`字元數，否則會變更任何記憶體。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.EnsureCapacity%2A>方法。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小於零。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="span">與目前執行個體比較的字元範圍。</param>
        <summary>傳回值，指出此執行個體中的字元是否等於指定唯讀字元範圍的字元。</summary>
        <returns>如果此執行個體中的字元與 <paramref name="span" /> 相同，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`Equals`方法會執行序數比較，來決定是否在目前的執行個體中的字元和`span`相等。

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">與這個執行個體相比較的物件，或 <see langword="null" />。</param>
        <summary>傳回值，指出這個執行個體 (Instance) 是否和指定的物件相等。</summary>
        <returns>如果這個執行個體和 <see langword="true" /> 具有相同的字串、<paramref name="sb" /> 和 <see cref="P:System.Text.StringBuilder.Capacity" /> 值，則為 <see cref="P:System.Text.StringBuilder.MaxCapacity" />，否則是 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

**.NET framework 和.NET Core 2.2 和先前版本：** 目前的執行個體和`sb`它們具有相同的字串，如果相等<xref:System.Text.StringBuilder.Capacity>，和<xref:System.Text.StringBuilder.MaxCapacity>值。 `Equals`方法會使用序數比較，判斷字串是否相等。

**.NET core 3.0 和更新版本：** 目前的執行個體和`sb`是否相等，如果字串指派給兩者<xref:System.Text.StringBuilder>物件是否相同。  若要判斷是否相等，`Equals`方法會使用序數比較。 <xref:System.Text.StringBuilder.Capacity>和<xref:System.Text.StringBuilder.MaxCapacity>屬性值不會用在比較中。

## Examples  
 下列程式碼會使用<xref:System.Text.StringBuilder.Equals%2A>方法來檢查是否有兩個<xref:System.Text.StringBuilder>物件是否相等。 對每個物件，進行小變更後，主控台會顯示結果時，會重複呼叫的方法。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定的字元位置上將指定物件的字串表示插入這個執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置上將 Boolean 值的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置上將指定的 8 位元不帶正負號的整數之字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置上將指定的 Unicode 字元之字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的字元陣列。</param>
        <summary>在指定的字元位置上將指定的 Unicode 字元陣列之字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
 如果`value`已`null`，則<xref:System.Text.StringBuilder>則不會變更。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置上將小數位數的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置上將雙精度浮點數的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置，將所指定帶正負號之 16 位元整數的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置，將所指定帶正負號之 32 位元整數的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置上將指定的 64 位元帶正負號的整數之字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的物件或 <see langword="null" />。</param>
        <summary>在指定的字元位置上將物件的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
 如果`value`是`null`，這個執行個體的值不變。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置，將所指定帶正負號之 8 位元整數的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置上將單精確度浮點數的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的字串。</param>
        <summary>在指定的字元位置上將字串插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現有的字元被轉向以騰出空間給新的文字。 視需要調整容量。  
  
 這個執行個體<xref:System.Text.StringBuilder>則不會變更，如果`value`是`null`，或`value`不是`null`但其長度為零。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體目前的長度。  
  
-或- 
這個 <see cref="T:System.Text.StringBuilder" /> 物件目前的長度加上 <paramref name="value" /> 的長度，會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置，將所指定不帶正負號的 16 位元整數之字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置，將所指定不帶正負號的 32 位元整數之字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>在指定的字元位置，將所指定不帶正負號的 64 位元整數之字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> 用來取得的字串表示`value`。 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體的長度。</exception>
        <exception cref="T:System.OutOfMemoryException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]和舊版中，呼叫此方法會擲回<see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />會導致物件的總長度超過<see cref="P:System.Text.StringBuilder.MaxCapacity" />。 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，方法會擲回<see cref="T:System.OutOfMemoryException" />。</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">要插入的字串。</param>
        <param name="count">要插入 <paramref name="value" /> 的次數。</param>
        <summary>在指定的字元位置上將指定字串的一或多個複本插入這個執行個體。</summary>
        <returns>插入作業完成後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
 這<xref:System.Text.StringBuilder>物件不會變更，如果`value`是`null`，`value`不`null`但其長度為零，或`count`為零。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小於零或大於此執行個體目前的長度。  
  
-或- 
 <paramref name="count" /> 小於零。</exception>
        <exception cref="T:System.OutOfMemoryException">此 <see cref="T:System.Text.StringBuilder" /> 物件目前的長度加 <paramref name="count" /> 的 <paramref name="value" /> 倍長度，會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">這個執行個體中開始插入的位置。</param>
        <param name="value">字元陣列。</param>
        <param name="startIndex"><paramref name="value" /> 內的起始索引。</param>
        <param name="charCount">要插入的字元數。</param>
        <summary>在指定的字元位置上將 Unicode 字元之指定子陣列的字串表示插入這個執行個體。</summary>
        <returns>完成插入作業之後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現有的字元被轉向以騰出空間給新的文字。 視需要調整此執行個體的容量。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 是 <see langword="null" />，而 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不是零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />、<paramref name="startIndex" /> 或 <paramref name="charCount" /> 小於零。  
  
-或- 
 <paramref name="index" /> 大於這個執行個體的長度。  
  
-或- 
 <paramref name="startIndex" /> 加上 <paramref name="charCount" /> 不是 <paramref name="value" /> 內的位置。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前 <see cref="T:System.Text.StringBuilder" /> 物件的長度。</summary>
        <value>這個執行個體的長度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 長度<xref:System.Text.StringBuilder>物件由其數目<xref:System.Char>物件。  
  
 像是<xref:System.String.Length%2A?displayProperty=nameWithType>屬性，<xref:System.Text.StringBuilder.Length%2A>屬性會指出目前 string 物件的長度。 不同於<xref:System.String.Length%2A?displayProperty=nameWithType>屬性，這是唯讀，<xref:System.Text.StringBuilder.Length%2A>屬性可讓您修改儲存至字串的長度<xref:System.Text.StringBuilder>物件。  
  
 如果指定的長度小於目前長度，也就是目前<xref:System.Text.StringBuilder>物件會被截斷成指定的長度。 如果指定的長度大於目前的長度，目前的字串值的結尾<xref:System.Text.StringBuilder>物件會以 Unicode NULL 字元填補 (u+0000)。  
  
 如果指定的長度大於目前的容量，<xref:System.Text.StringBuilder.Capacity%2A>增加，因此它是大於或等於指定的長度。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Length%2A>屬性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於零或大於 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個執行個體的最大容量。</summary>
        <value>這個執行個體可以容納的最大字元數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這項實作的最大容量<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 不過，這個值是依實作，而且可能會在兩個實作中有其他或更新版本不同。 您可以明確設定的最大容量<xref:System.Text.StringBuilder>藉由呼叫物件<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>建構函式。  
  
在.NET Core 和.NET Framework 4.0 和更新版本中，當您具現化<xref:System.Text.StringBuilder>藉由呼叫物件<xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)>建構函式，長度和容量<xref:System.Text.StringBuilder>執行個體可以成長的值超過其<xref:System.Text.StringBuilder.MaxCapacity>屬性。 這可能特別是當您呼叫<xref:System.Text.StringBuilder.Append(System.String)>和<xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)>附加小字串的方法。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">這個執行個體中開始移除且以零為起始的位置。</param>
        <param name="length">要移除的字元數。</param>
        <summary>從這個執行個體移除指定的字元範圍。</summary>
        <returns>移除作業完成後，這個執行個體的參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的方法會從目前的執行個體移除指定的字元範圍。 在字元 (`startIndex` + `length`) 會移至`startIndex`，和目前的執行個體的字串值藉由縮短`length`。 目前的執行個體的容量會受到影響。  
  
> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A>方法會修改目前的值<xref:System.Text.StringBuilder>執行個體，並傳回該執行個體。 它不會建立並傳回新<xref:System.Text.StringBuilder>物件。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Remove%2A>方法。  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">如果 <paramref name="startIndex" /> 或 <paramref name="length" /> 小於零，或 <paramref name="startIndex" /> + <paramref name="length" /> 大於這個執行個體的長度。</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>以另一個指定的字元或字串，取代這個執行個體中指定的字元或字串的所有項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要取代的字元。</param>
        <param name="newChar">取代 <paramref name="oldChar" /> 的字元。</param>
        <summary>以另一個指定的字元，取代這個執行個體中指定字元的所有項目。</summary>
        <returns>其 <paramref name="oldChar" /> 已由 <paramref name="newChar" /> 取代的執行個體參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數、 區分大小寫的比較，以識別發生次數`oldChar`中目前的執行個體。 目前的大小<xref:System.Text.StringBuilder>更換之後，執行個體是不變。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要取代的字串。</param>
        <param name="newValue">取代 <paramref name="oldValue" /> 的字串或 <see langword="null" />。</param>
        <summary>將這個執行個體中所有出現的指定字串取代為另一個指定字串。</summary>
        <returns>這個執行個體的參考，但 <paramref name="oldValue" /> 的所有執行個體遭取代成 <paramref name="newValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數、 區分大小寫的比較，以識別發生次數`oldValue`中目前的執行個體。 如果`newValue`已`null`或是<xref:System.String.Empty?displayProperty=nameWithType>，所有出現的`oldValue`會移除。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 的長度為零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">要取代的字元。</param>
        <param name="newChar">取代 <paramref name="oldChar" /> 的字元。</param>
        <param name="startIndex">這個執行個體中子字串開始的位置。</param>
        <param name="count">子字串的長度。</param>
        <summary>將這個執行個體的子字串內所有出現的指定字元，取代為另一個指定的字元。</summary>
        <returns>參考這個執行個體，但 <paramref name="oldChar" /> 換成 <paramref name="newChar" />，範圍是 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數、 區分大小寫的比較，以識別發生次數`oldChar`中目前的執行個體。 目前的大小<xref:System.Text.StringBuilder>物件在更換之後並未變更。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> 大於這個執行個體值的長度。  
  
-或- 
 <paramref name="startIndex" /> 或 <paramref name="count" /> 小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">要取代的字串。</param>
        <param name="newValue">取代 <paramref name="oldValue" /> 的字串或 <see langword="null" />。</param>
        <param name="startIndex">這個執行個體中子字串開始的位置。</param>
        <param name="count">子字串的長度。</param>
        <summary>將這個執行個體的子字串內所有出現的指定字串，取代為另一個指定的字串。</summary>
        <returns>參考這個執行個體，但 <paramref name="oldValue" /> 的所有執行個體換成 <paramref name="newValue" />，範圍是 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會執行序數、 區分大小寫的比較，以識別發生次數`oldValue`中指定的子字串。 如果`newValue`已`null`或是<xref:System.String.Empty?displayProperty=nameWithType>，所有出現的`oldValue`會移除。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 的長度為零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="startIndex" /> 加上 <paramref name="count" /> 表示不在此執行個體中的字元位置。  
  
-或- 
加大此執行個體的值可能會超過 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">要使用序列化資訊來填入的物件。</param>
        <param name="context">要儲存並擷取序列化資料的位置。 保留供未來使用。</param>
        <summary>將還原序列化目前 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件所需的資料填入 (Populate) <see cref="T:System.Text.StringBuilder" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `context`參數保留供日後使用，並不會參與這項作業。  
  
 如需詳細資訊，請參閱 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Text.StringBuilder" /> 的值轉換為 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將這個執行個體的值轉換為 <see cref="T:System.String" />。</summary>
        <returns>其值和這個執行個體相同的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須呼叫<xref:System.Text.StringBuilder.ToString%2A>方法，將轉換<xref:System.Text.StringBuilder>物件<xref:System.String>物件，您可以傳遞所代表的字串才能<xref:System.Text.StringBuilder>物件的方法有<xref:System.String>參數或將它顯示在使用者介面。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫 <xref:System.Text.StringBuilder.ToString%2A> 方法。 這個範例是針對提供之較大範例的一部分<xref:System.Text.StringBuilder>類別。  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">這個執行個體中的子字串開始位置。</param>
        <param name="length">子字串的長度。</param>
        <summary>將這個執行個體的子字串值轉換為 <see cref="T:System.String" />。</summary>
        <returns>字串，此字串值與這個執行個體的指定子字串值相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須呼叫<xref:System.Text.StringBuilder.ToString%2A>方法，將轉換<xref:System.Text.StringBuilder>物件<xref:System.String>物件，您可以傳遞所代表的字串才能<xref:System.Text.StringBuilder>物件的方法有<xref:System.String>參數或將它顯示在使用者介面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小於零。  
  
-或- 
<paramref name="startIndex" /> 和 <paramref name="length" /> 總計大於目前執行個體的長度。</exception>
      </Docs>
    </Member>
  </Members>
</Type>