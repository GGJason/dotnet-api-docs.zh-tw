<Type Name="Decoder" FullName="System.Text.Decoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af988a5d852dff603b2e4e888be96288515f405e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531022" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Decoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Decoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Decoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Decoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Decoder abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>將編碼的位元組序列轉換成一組字元。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得之實作的執行個體<xref:System.Text.Decoder>類別，應用程式應該使用<xref:System.Text.Encoding.GetDecoder%2A>方法<xref:System.Text.Encoding>實作。  
  
 <xref:System.Text.Decoder.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Decoder.GetChars%2A>方法會執行實際的解碼。 這兩種方法的數個版本中有<xref:System.Text.Decoder>類別。 如需詳細資訊，請參閱<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>。 A<xref:System.Text.Decoder>物件會維護狀態資訊之間的後續呼叫`GetChars`或<xref:System.Text.Decoder.Convert%2A>方法，讓它可以正確解碼位元組序列跨越區塊。 <xref:System.Text.Decoder>也會保留資料區塊的結尾的後隨位元組，並在下一步解碼作業中使用尾端位元組。 因此，<xref:System.Text.Encoding.GetDecoder%2A>和<xref:System.Text.Encoding.GetEncoder%2A>網路傳輸和檔案作業很實用是因為這些作業經常要處理而不是完整的資料流的資料區塊。  
  
> [!NOTE]
>  當應用程式已完成的資料流時，它應該確定的狀態資訊會藉由設定排清`flush`參數`true`適當的方法呼叫中。 如果發生例外狀況，或如果應用程式切換資料流時，它應該呼叫<xref:System.Text.Decoder.Reset%2A>清除的內部狀態`Decoder`物件。  
  
## <a name="version-considerations"></a>版本的考量  
 A<xref:System.Text.Decoder>或<xref:System.Text.Encoder>物件可以序列化期間的轉換作業。 物件的狀態會保留在相同版本的.NET Framework 中，還原序列化，但在另一個版本中還原序列化時遺失。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Text.Decoder>將兩個不同的位元組陣列轉換成字元陣列。 其中一個字元的位元組會展開陣列。 這是類似於<xref:System.IO.StreamReader>物件未在內部時讀取資料流。  
  
 [!code-cpp[Classic Decoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Decoder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Decoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Decoder Example/CS/source.cs#1)]
 [!code-vb[Classic Decoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Decoder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>當您的應用程式會繼承自這個類別時，它必須覆寫所有成員。</para>
    </block>
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Decoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Decoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.Decoder" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得之這個類別實作的執行個體，應用程式應該使用<xref:System.Text.Encoding.GetDecoder%2A>方法<xref:System.Text.Encoding>實作。  
  
   
  
## Examples  
 下列範例會示範兩種技術來初始化新<xref:System.Text.Decoder>執行個體。  
  
 [!code-cpp[System.Text.Decoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Decoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Decoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將編碼的位元組序列轉換成字串或字元陣列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">緩衝區位址，包含要轉換的位元組序列。</param>
        <param name="byteCount">
          <c>bytes</c> 中要轉換的位元組數。</param>
        <param name="chars">緩衝區位址，用來儲存已轉換的字元。</param>
        <param name="charCount">
          <c>chars</c> 中要用於轉換的字元數上限。</param>
        <param name="flush">
          若表示不進行任何其他資料轉換即為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="bytesUsed">傳回此方法時，包含轉換所產生的位元組數目。 這個參數會以未初始化的狀態傳遞。</param>
        <param name="charsUsed">傳回此方法時，會包含 <c>chars</c> 中用於轉換的字元數目。 這個參數會以未初始化的狀態傳遞。</param>
        <param name="completed">傳回此方法時，若所有 <c>byteCount</c> 指定的字元皆已轉換則包含 <see langword="true" />；否則為 <see langword="false" />。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>將已編碼位元組的緩衝區轉換成 UTF-16 編碼的字元，並將結果儲存在另一個緩衝區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請記住，<xref:System.Text.Decoder>物件儲存呼叫之間的狀態<xref:System.Text.Decoder.Convert%2A>。 當應用程式已完成的資料流時，它應該設定`flush`參數`true`以確定會排清狀態資訊。 使用此設定，解碼器會忽略無效位元組的資料區塊的結尾，並清除內部緩衝區。 屬於邏輯的單位，例如之高 surrogate 的 surrogate 字組的任何其餘處理過的資料會根據目前的後援設定轉換。  
  
 `Convert`方法設計用來在迴圈中用於解碼任意數量的輸入，例如從檔案或資料流讀取的資料。 它會將解碼作業的輸出儲存在固定大小的緩衝區。 <xref:System.Text.Decoder.GetChars%2A> 如果輸出緩衝區不夠大，無法，便會擲回例外狀況，但<xref:System.Text.Decoder.Convert%2A>會填滿的空間越好，並傳回的位元組讀取和寫入的字元。 另請參閱<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>主題的多個註解。  
  
 `completed`輸出參數會指出是否轉換並儲存在輸出緩衝區中，輸入緩衝區中的所有資料。 此參數設為`false`如果所指定的位元組數目`byteCount`無法轉換參數，但不超過指定的字元數目`charCount`參數。 在此情況下，應用程式應該使用輸出緩衝區的內容，或提供新的輸出緩衝區，遞增`bytes`參數所指定的位元組數`bytesUsed`參數，然後呼叫`Convert`方法一次程序的其餘輸入。  
  
 `completed`參數也會設定為`false`，即使`bytesUsed`和`byteCount`參數是否相等。 如果仍然中的資料，就會發生這種情況下<xref:System.Text.Decoder>物件未儲存在`bytes`緩衝區。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 或 <paramref name="bytes" /> 是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> 或 <paramref name="byteCount" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">輸出緩衝區太小而無法包含任何已轉換的輸入。 輸出緩衝區應大於或等於 <see cref="Overload:System.Text.Decoder.GetCharCount" /> 方法所指出的大小。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, charCount As Integer, flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">要轉換的位元組陣列。</param>
        <param name="byteIndex">
          <c>bytes</c> 中要轉換的第一個項目。</param>
        <param name="byteCount">
          <c>bytes</c> 中要轉換的位元組數。</param>
        <param name="chars">要儲存已轉換字元的陣列。</param>
        <param name="charIndex">
          <c>chars</c> 中要儲存資料的第一個項目。</param>
        <param name="charCount">
          <c>chars</c> 中要用於轉換的項目數上限。</param>
        <param name="flush">
          <see langword="true" /> 表示不轉換任何其他資料，否則為 <see langword="false" />。</param>
        <param name="bytesUsed">傳回此方法時，包含轉換所使用的位元組數目。 這個參數會以未初始化的狀態傳遞。</param>
        <param name="charsUsed">傳回此方法時，會包含轉換作業所產生之 <c>chars</c> 的字元數。 這個參數會以未初始化的狀態傳遞。</param>
        <param name="completed">傳回此方法時，若所有 <c>byteCount</c> 指定的字元皆已轉換則包含 <see langword="true" />；否則為 <see langword="false" />。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>將已編碼位元組的陣列轉換成 UTF-16 編碼的字元，並將結果儲存在另一個字元陣列中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請記住，<xref:System.Text.Decoder>物件儲存呼叫之間的狀態<xref:System.Text.Decoder.Convert%2A>。 當應用程式已完成的資料流時，它應該設定`flush`參數`true`以確定會排清狀態資訊。 使用此設定，解碼器會忽略無效位元組的資料區塊的結尾，並清除內部緩衝區。 屬於邏輯的單位，例如之高 surrogate 的 surrogate 字組的任何其餘處理過的資料會根據目前的後援設定轉換。  
  
 `Convert`方法設計用來在迴圈中用於解碼任意數量的輸入，例如從檔案或資料流讀取的資料。 它會將解碼作業的輸出儲存在固定大小的緩衝區。 <xref:System.Text.Decoder.GetChars%2A> 如果輸出緩衝區不夠大，無法，便會擲回例外狀況，但<xref:System.Text.Decoder.Convert%2A>會填滿的空間越好，並傳回的位元組讀取和寫入的字元。 另請參閱<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>主題的多個註解。  
  
 `completed`輸出參數會指出是否轉換並儲存在輸出緩衝區中，輸入緩衝區中的所有資料。 此參數設為`false`如果所指定的位元組數目`byteCount`無法轉換參數，但不超過指定的字元數目`charCount`參數。 在此情況下，應用程式應該使用輸出緩衝區的內容，或提供新的輸出緩衝區，遞增`bytes`參數所指定的位元組數`bytesUsed`參數，然後呼叫`Convert`方法一次程序的其餘輸入。  
  
 `completed`參數也會設定為`false`，即使`bytesUsed`和`byteCount`參數是否相等。 如果仍然中的資料，就會發生這種情況下<xref:System.Text.Decoder>物件未儲存在`bytes`緩衝區。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Text.Encoder.Convert%2A>方法，將 utf-16 字元的檔案轉換為 utf-8。 然後它會使用<xref:System.Text.Decoder.Convert%2A>回 utf-16 字元的 utf-8 字元轉換的方法。  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 或 <paramref name="bytes" /> 是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" />、<paramref name="byteIndex" /> 或 <paramref name="byteCount" /> 小於零。  
  
 -或-  
  
 <paramref name="chars" /> - <paramref name="charIndex" /> 的長度小於 <paramref name="charCount" />。  
  
 -或-  
  
 <paramref name="bytes" /> - <paramref name="byteIndex" /> 的長度小於 <paramref name="byteCount" />。</exception>
        <exception cref="T:System.ArgumentException">輸出緩衝區太小而無法包含任何已轉換的輸入。 輸出緩衝區應大於或等於 <see cref="Overload:System.Text.Decoder.GetCharCount" /> 方法所指出的大小。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ Fallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前 <see cref="T:System.Text.DecoderFallback" /> 物件的 <see cref="T:System.Text.Decoder" /> 物件。</summary>
        <value>
          <see cref="T:System.Text.DecoderFallback" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback>物件都代表編碼的位元組序列無法轉換成字元時叫用錯誤處理常式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定作業中的值是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentException">設定作業中無法指派新的值，因為目前的 <see cref="T:System.Text.DecoderFallbackBuffer" /> 物件包含尚未解碼的資料。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As DecoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallbackBuffer ^ FallbackBuffer { System::Text::DecoderFallbackBuffer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與目前 <see cref="T:System.Text.DecoderFallbackBuffer" /> 物件關聯的 <see cref="T:System.Text.Decoder" /> 物件。</summary>
        <value>
          <see cref="T:System.Text.DecoderFallbackBuffer" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallbackBuffer>物件都代表所使用的資料<xref:System.Text.DecoderFallback>物件。 <xref:System.Text.DecoderFallback>物件都代表編碼的位元組序列無法轉換成字元時叫用錯誤處理常式。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，計算解碼位元組序列所產生的字元數目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">要解碼的第一個位元組指標。</param>
        <param name="count">要解碼的位元組數。</param>
        <param name="flush">
          <see langword="true" /> 模擬在計算後清除編碼器的內部狀態，否則為 <see langword="false" />。</param>
        <summary>在衍生類別中覆寫時，計算從指定的位元組指標開始，解碼位元組序列所產生的字元數目。 參數，指出計算後是否要清除解碼器的內部狀態。</summary>
        <returns>解碼指定的位元組以及內部緩衝區中任何位元組序列所產生的字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會影響解碼器的狀態。  
  
 若要計算確切的陣列大小的<xref:System.Text.Decoder.GetChars%2A>需要應用程式應該使用來儲存產生的字元， <xref:System.Text.Decoder.GetCharCount%2A>。  
  
 如果`GetChars`呼叫`flush`設`false`，解碼器內部緩衝區中儲存的資料區塊的結尾的後隨位元組，並在下一步解碼作業中使用它們。 應用程式應該呼叫`GetCharCount`之前呼叫的資料區塊上`GetChars`上相同的區塊，以便從上一個區塊的任何尾端位元組會納入計算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 是 <see langword="null" /> (在 Visual Basic .NET 中為 <see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小於零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="index">要解碼的第一個位元組索引。</param>
        <param name="count">要解碼的位元組數。</param>
        <summary>在衍生類別中覆寫時，計算從指定的位元組陣列解碼位元組序列所產生的字元數目。</summary>
        <returns>解碼指定的位元組以及內部緩衝區中任何位元組序列所產生的字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會影響解碼器的狀態。  
  
 若要計算確切的陣列大小的<xref:System.Text.Decoder.GetChars%2A>需要應用程式應該使用來儲存產生的字元， <xref:System.Text.Decoder.GetCharCount%2A>。  
  
 如果`GetChars`呼叫`flush`設`false`，解碼器內部緩衝區中儲存的資料區塊的結尾的後隨位元組，並在下一步解碼作業中使用它們。 應用程式應該呼叫`GetCharCount`之前呼叫的資料區塊上`GetChars`上相同的區塊，以便從上一個區塊的任何尾端位元組會納入計算。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Text.Decoder.GetCharCount%2A>方法來計算解碼指定的位元組陣列中的範圍時所需的字元數。  
  
 [!code-cpp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小於零。  
  
 -或-  
  
 <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="index">要解碼的第一個位元組索引。</param>
        <param name="count">要解碼的位元組數。</param>
        <param name="flush">
          <see langword="true" /> 模擬在計算後清除編碼器的內部狀態，否則為 <see langword="false" />。</param>
        <summary>在衍生類別中覆寫時，計算從指定的位元組陣列解碼位元組序列所產生的字元數目。 參數，指出計算後是否要清除解碼器的內部狀態。</summary>
        <returns>解碼指定的位元組以及內部緩衝區中任何位元組序列所產生的字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會影響解碼器的狀態。  
  
 若要計算確切的陣列大小的<xref:System.Text.Decoder.GetChars%2A>需要應用程式應該使用來儲存產生的字元， <xref:System.Text.Decoder.GetCharCount%2A>。  
  
 如果`GetChars`呼叫`flush`設`false`，解碼器內部緩衝區中儲存的資料區塊的結尾的後隨位元組，並在下一步解碼作業中使用它們。 應用程式應該呼叫`GetCharCount`之前呼叫的資料區塊上`GetChars`上相同的區塊，以便從上一個區塊的任何尾端位元組會納入計算。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小於零。  
  
 -或-  
  
 <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，將位元組序列解碼成一組字元。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">要解碼的第一個位元組指標。</param>
        <param name="byteCount">要解碼的位元組數。</param>
        <param name="chars">開始寫入產生的一組字元之位置指標。</param>
        <param name="charCount">要寫入的最大字元數。</param>
        <param name="flush">
          <see langword="true" /> 表示要在轉換之後清除解碼器的內部狀態，否則為 <see langword="false" />。</param>
        <summary>在衍生類別中覆寫時，會將由指定位元組指標開始的位元組序列以及內部緩衝區內的任何位元組，解碼成一組字元 (會從指定的字元指標開始存放這些字元)。 參數會指示，在轉換之後是否要清除解碼器的內部狀態。</summary>
        <returns>
          <paramref name="chars" /> 參數所指示位置上寫入的實際字元數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請記住，<xref:System.Text.Decoder>物件儲存呼叫之間的狀態<xref:System.Text.Decoder.GetChars%2A>。 當應用程式已完成的資料流時，它應該設定`flush`參數`true`以確定會排清狀態資訊。 使用此設定，解碼器會忽略無效位元組的資料區塊的結尾，並清除內部緩衝區。  
  
 若要計算確切的緩衝區大小的`GetChars`需要應用程式應該使用來儲存產生的字元， <xref:System.Text.Decoder.GetCharCount%2A>。  
  
 如果`GetChars`呼叫`flush`設`false`，解碼器內部緩衝區中儲存的資料區塊的結尾的後隨位元組，並在下一步解碼作業中使用它們。 應用程式應該呼叫`GetCharCount`之前呼叫的資料區塊上`GetChars`上相同的區塊，以便從上一個區塊的任何尾端位元組會納入計算。  
  
 如果您的應用程式来轉換的輸入資料流的許多區段中，請考慮使用<xref:System.Text.Decoder.Convert%2A>方法。 <xref:System.Text.Decoder.GetChars%2A> 如果輸出緩衝區不夠大，無法，便會擲回例外狀況，但<xref:System.Text.Decoder.Convert%2A>會填滿的空間越好，並傳回的位元組讀取和寫入的字元。 另請參閱<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>主題的多個註解。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 是 <see langword="null" /> (<see langword="Nothing" />)。  
  
 -或-  
  
 <paramref name="chars" /> 是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> 或 <paramref name="charCount" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> 小於結果字元數。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="byteIndex">要解碼的第一個位元組索引。</param>
        <param name="byteCount">要解碼的位元組數。</param>
        <param name="chars">包含產生的一組字元之字元陣列。</param>
        <param name="charIndex">要開始寫入產生的一組字元之索引。</param>
        <summary>在衍生類別中覆寫時，將指定位元組陣列中的位元組序列以及內部緩衝區內的任何位元組，解碼成指定的字元陣列。</summary>
        <returns>寫入 <paramref name="chars" /> 的實際字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請記住，<xref:System.Text.Decoder>物件儲存呼叫之間的狀態<xref:System.Text.Decoder.GetChars%2A>。 當應用程式已完成的資料流時，它應該設定`flush`參數`true`以確定會排清狀態資訊。 使用此設定，解碼器會忽略無效位元組的資料區塊的結尾，並清除內部緩衝區。  
  
 若要計算確切的陣列大小的`GetChars`需要應用程式應該使用來儲存產生的字元， <xref:System.Text.Decoder.GetCharCount%2A>。  
  
 如果`GetChars`呼叫`flush`設`false`，解碼器內部緩衝區中儲存的資料區塊的結尾的後隨位元組，並在下一步解碼作業中使用它們。 應用程式應該呼叫`GetCharCount`之前呼叫的資料區塊上`GetChars`上相同的區塊，以便從上一個區塊的任何尾端位元組會納入計算。  
  
 如果您的應用程式来轉換的輸入資料流的許多區段中，請考慮使用<xref:System.Text.Decoder.Convert%2A>方法。 <xref:System.Text.Decoder.GetChars%2A> 如果輸出緩衝區不夠大，無法，便會擲回例外狀況，但<xref:System.Text.Decoder.Convert%2A>會填滿的空間越好，並傳回的位元組讀取和寫入的字元。 另請參閱<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>主題的多個註解。  
  
   
  
## Examples  
 下列範例會示範如何解碼位元組陣列中的項目範圍，並將其儲存在 Unicode 字元陣列。 <xref:System.Text.Decoder.GetCharCount%2A>方法用來計算陣列中儲存的已解碼的項目所需的字元數`bytes`。 <xref:System.Text.Decoder.GetChars%2A>方法解碼位元組陣列中指定的項目，並將它們儲存在新字元陣列。  
  
 [!code-cpp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 是 <see langword="null" /> (<see langword="Nothing" />)。  
  
 -或-  
  
 <paramref name="chars" /> 是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />、<paramref name="byteCount" /> 或 <paramref name="charIndex" /> 小於零。  
  
 -或-  
  
 <paramref name="byteindex" /> 與 <paramref name="byteCount" /> 不代表 <paramref name="bytes" /> 中有效的範圍。  
  
 -或-  
  
 <paramref name="charIndex" /> 在 <paramref name="chars" /> 中不是有效的索引。</exception>
        <exception cref="T:System.ArgumentException">
          從 <paramref name="chars" /> 到陣列結尾處，<paramref name="charIndex" /> 沒有足夠的容量容納結果字元。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, bool flush);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="byteIndex">要解碼的第一個位元組索引。</param>
        <param name="byteCount">要解碼的位元組數。</param>
        <param name="chars">包含產生的一組字元之字元陣列。</param>
        <param name="charIndex">要開始寫入產生的一組字元之索引。</param>
        <param name="flush">
          <see langword="true" /> 表示要在轉換之後清除解碼器的內部狀態，否則為 <see langword="false" />。</param>
        <summary>在衍生類別中覆寫時，將指定位元組陣列中的位元組序列以及內部緩衝區內的任何位元組，解碼成指定的字元陣列。 參數會指示，在轉換之後是否要清除解碼器的內部狀態。</summary>
        <returns>實際寫入 <paramref name="chars" /> 參數的字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請記住，<xref:System.Text.Decoder>物件儲存呼叫之間的狀態<xref:System.Text.Decoder.GetChars%2A>。 當應用程式已完成的資料流時，它應該設定`flush`參數`true`以確定會排清狀態資訊。 使用此設定，解碼器會忽略無效位元組的資料區塊的結尾，並清除內部緩衝區。  
  
 若要計算確切的陣列大小的`GetChars`需要應用程式應該使用來儲存產生的字元， <xref:System.Text.Decoder.GetCharCount%2A>。  
  
 如果`GetChars`呼叫`flush`設`false`，解碼器內部緩衝區中儲存的資料區塊的結尾的後隨位元組，並在下一步解碼作業中使用它們。 應用程式應該呼叫`GetCharCount`之前呼叫的資料區塊上`GetChars`上相同的區塊，以便從上一個區塊的任何尾端位元組會納入計算。  
  
 如果您的應用程式来轉換的輸入資料流的許多區段中，請考慮使用<xref:System.Text.Decoder.Convert%2A>方法。 <xref:System.Text.Decoder.GetChars%2A> 如果輸出緩衝區不夠大，無法，便會擲回例外狀況，但<xref:System.Text.Decoder.Convert%2A>會填滿的空間越好，並傳回的位元組讀取和寫入的字元。 另請參閱<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>主題的多個註解。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 是 <see langword="null" /> (<see langword="Nothing" />)。  
  
 -或-  
  
 <paramref name="chars" /> 是 <see langword="null" /> (<see langword="Nothing" />)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />、<paramref name="byteCount" /> 或 <paramref name="charIndex" /> 小於零。  
  
 -或-  
  
 <paramref name="byteindex" /> 與 <paramref name="byteCount" /> 不代表 <paramref name="bytes" /> 中有效的範圍。  
  
 -或-  
  
 <paramref name="charIndex" /> 在 <paramref name="chars" /> 中不是有效的索引。</exception>
        <exception cref="T:System.ArgumentException">
          從 <paramref name="chars" /> 到陣列結尾處，<paramref name="charIndex" /> 沒有足夠的容量容納結果字元。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需更完整的說明，請參閱 [.NET Framework 中的字元編碼方式](~/docs/standard/base-types/character-encoding.md))  
  
 -和-  
  
 <see cref="P:System.Text.Decoder.Fallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，將解碼器設定回其初始狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會清除的內部狀態<xref:System.Text.Decoder>物件。 方法會清除所有先前呼叫所保留的狀態資訊<xref:System.Text.Decoder.GetChars%2A>或<xref:System.Text.Decoder.Convert%2A>，包括結尾的位元組在前一個資料區塊的結尾。  
  
 您的應用程式應該呼叫<xref:System.Text.Decoder.Reset%2A>方法，如果它要重複使用相同的解碼器，所擲回例外狀況時，即使<xref:System.Text.Decoder.GetChars%2A>， <xref:System.Text.Decoder.Convert%2A>，或<xref:System.Text.Decoder.GetCharCount%2A>，或如果解碼器切換資料流，並開始另一個資料流解碼。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>