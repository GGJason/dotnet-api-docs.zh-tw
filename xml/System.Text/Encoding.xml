<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="95471ea1cd06b4d172c2cb1dbaa217926e96a39f" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52246107" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示字元編碼方式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編碼是將一組 Unicode 字元轉換成位元組序列的處理程序。 相反地，解碼則是將編碼的位元組序列轉換成一組 Unicode 字元的程序。 如需 Unicode 轉換格式 (UTFs) 和其他支援的編碼資訊<xref:System.Text.Encoding>，請參閱 < [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。  
  
 請注意，<xref:System.Text.Encoding>旨在對 Unicode 字元，而不是任意二進位資料的詳細資訊，例如位元組陣列。 如果您必須將任意的二進位資料編碼成文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 .NET 提供的下列實作<xref:System.Text.Encoding>類別，以支援目前的 Unicode 編碼方式和其他編碼：  
  
-   <xref:System.Text.ASCIIEncoding> 將 Unicode 字元編碼為單一 7 位元 ASCII 字元。 這個編碼僅支援之間的字元值 U + 0000 和 U + 007F。 已核取 20127 的字碼頁。 也可透過<xref:System.Text.Encoding.ASCII%2A>屬性。  
  
-   <xref:System.Text.UTF7Encoding> 使用 utf-7 編碼的 Unicode 字元編碼。 這種編碼方式支援所有 Unicode 字元值。 65000 的字碼頁。 也可透過<xref:System.Text.Encoding.UTF7%2A>屬性。  
  
-   <xref:System.Text.UTF8Encoding> 使用 utf-8 編碼的 Unicode 字元編碼。 這種編碼方式支援所有 Unicode 字元值。 字碼頁 65001。 也可透過<xref:System.Text.Encoding.UTF8%2A>屬性。  
  
-   <xref:System.Text.UnicodeEncoding> 使用 utf-16 編碼的 Unicode 字元編碼。 支援這兩個小到小，而且其大小位元組由小到大位元組順序。 也可透過<xref:System.Text.Encoding.Unicode%2A>屬性和<xref:System.Text.Encoding.BigEndianUnicode%2A>屬性。  
  
-   <xref:System.Text.UTF32Encoding> 使用 UTF-32 編碼的 Unicode 字元編碼。 同時位元組由小到大 （字碼頁 12000） 和 big endian （字碼頁 12001） 位元組會支援順序。 也可透過<xref:System.Text.Encoding.UTF32%2A>屬性。  
  
 <xref:System.Text.Encoding>類別主要是以不同的編碼方式和 Unicode 間轉換。 通常的其中一個衍生的 Unicode 類別是您的應用程式的正確選擇。  
  
 使用<xref:System.Text.Encoding.GetEncoding%2A>方法，以取得其他編碼，並呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得一份所有編碼方式。  
  
 下表列出.NET Framework 和.NET Core 所支援的編碼方式。 它會列出每個編碼的字碼頁編號和編碼方式的值<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>和<xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType>屬性。 中的核取記號 **.NET Framework 支援**並 **.NET Core 支援**資料行表示.NET 實作，不論基礎平台原生支援的字碼頁。 .NET Framework 中，表所列的其他編碼的可用性取決於作業系統。 適用於.NET Core，其他編碼，則可使用<xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType>類別，或藉由衍生自<xref:System.Text.EncodingProvider?displayProperty=nameWithType>類別。  

> [!NOTE]
> 字碼頁的<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>屬性會對應至國際標準不一定符合該標準的完整。 

|字碼頁|名稱|顯示名稱|.NET framework 支援| .NET Core 支援 | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC （美國和加拿大）|||  
|437|IBM437|OEM-Usa|||  
|500|IBM500|IBM EBCDIC （國際）|||  
|708|ASMO-708|阿拉伯文 (ASMO 708)|||  
|720|DOS-720|阿拉伯文 (DOS)|||  
|737|ibm737|希臘文 (DOS)|||  
|775|ibm775|波羅的海文 (DOS)|||  
|850|ibm850|西歐語系 (DOS)|||  
|852|ibm852|中歐語系 (DOS)|||  
|855|IBM855|Cyrilice OEM|||  
|857|ibm857|Turečtina (DOS)|||  
|858|IBM00858|OEM 多語系拉丁文 I|||  
|860|IBM860|Portugalština (DOS)|||  
|861|ibm861|Islandština (DOS)|||  
|862|DOS-862|Hebrejština (DOS)|||  
|863|IBM863|加拿大法文 (DOS)|||  
|864|IBM864|阿拉伯文 (864)|||  
|865|IBM865|北歐字母 (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|希臘文，現代 (DOS)|||  
|870|IBM870|IBM EBCDIC (多語系拉丁文-2)|||  
|874|windows-874|Thajština (Windows)|||  
|875|cp875|IBM EBCDIC （希臘文現代）|||  
|932|shift_jis|日文 (SHIFT-JIS)|||  
|936|gb2312|簡體中文 (GB2312)|✓||  
|949|ks_c_5601-1987|韓文|||  
|950|big5|繁體中文 (Big5)|||  
|1026|IBM1026|IBM EBCDIC (Turečtina-Latin 5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC （美國-加拿大-歐洲）|||  
|1141|IBM01141|IBM EBCDIC (Německo-Euro)|||  
|1142|IBM01142|IBM EBCDIC （丹麥-挪威-歐洲）|||  
|1143|IBM01143|IBM EBCDIC （芬蘭-瑞典-歐洲）|||  
|1144|IBM01144|IBM EBCDIC （義大利-歐洲）|||  
|1145|IBM01145|IBM EBCDIC (西班牙-Euro)|||  
|1146|IBM01146|IBM EBCDIC （英國-歐洲）|||  
|1147|IBM01147|IBM EBCDIC (Francie-Euro)|||  
|1148|IBM01148|IBM EBCDIC （國際-歐洲）|||  
|1149|IBM01149|IBM EBCDIC (Island-Euro)|||  
|1200|utf-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|windows-1250|中歐語系 (Windows)|||  
|1251|windows-1251|Cyrilice (Windows)|||  
|1252|Windows-1252|西歐語系 (Windows)|✓||  
|1253|windows-1253|希臘文 (Windows)|||  
|1254|windows-1254|土耳其文 (Windows)|||  
|1255|windows-1255|希伯來文 (Windows)|||  
|1256|windows-1256|阿拉伯文 (Windows)|||  
|1257|windows-1257|波羅的海文 (Windows)|||  
|1258|windows-1258|越南文 (Windows)|||  
|1361|Johab|Korejština (Johab)|||  
|10000|macintosh|西歐語系 (Mac)|||  
|10001|x-mac-日文|Japonština (Mac)|||  
|10002|x-mac-chinesetrad|繁體中文 (Mac)|||  
|10003|x-mac-韓文|Korejština (Mac)|✓||  
|10004|x-mac-阿拉伯文|Arabština (Mac)|||  
|10005|x-mac-希伯來文|Hebrejština (Mac)|||  
|10006|x-mac-希臘文|希臘文 (Mac)|||  
|10007|x-mac-斯拉夫文|Cyrilice (Mac)|||  
|10008|x-mac-chinesesimp|簡體中文 (Mac)|✓||  
|10010|x-mac-羅馬尼亞文|Rumunština (Mac)|||  
|10017|烏克蘭文-x-mac|Ukrajinština (Mac)|||  
|10021|x-mac-泰文|Thajština (Mac)|||  
|10029|x-mac-ce|中歐語系 (Mac)|||  
|10079|x-mac-冰島文|Islandština (Mac)|||  
|10081|x-mac-土耳其文|Turečtina (Mac)|||  
|10082|x-mac-克羅埃西亞文|Chorvatština (Mac)|||  
|12000|utf-32|Unicode (UTF-32)|✓|✓|  
|12001|utf-32BE|Unicode (UTF-32 Big endian)|✓|✓|  
|20000|x-中文-CN|繁體中文 (CNS)|||  
|20001|x-cp20001|Tchaj-wan Tca|||  
|20002|x-中文-倚天|繁體中文 （倚天）|||  
|20003|x-cp20003|Tchaj-wan Ibm5550|||  
|20004|x-cp20004|Tchaj-wan teleText|||  
|20005|x-cp20005|Tchaj-wan Wang|||  
|20105|x-IA5|西歐語系 (IA5)|||  
|20106|x-IA5-德文|Němčina (IA5)|||  
|20107|x-IA5-瑞典文|瑞典文 (IA5)|||  
|20108|x-IA5-Norwegian|挪威文 (IA5)|||  
|20127|我們 ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Německo)|||  
|20277|IBM277|IBM EBCDIC （丹麥-挪威）|||  
|20278|IBM278|IBM EBCDIC （芬蘭-瑞典）|||  
|20280|IBM280|IBM EBCDIC （義大利）|||  
|20284|IBM284|IBM EBCDIC （西班牙）|||  
|20285|IBM285|IBM EBCDIC （英國）|||  
|20290|IBM290|IBM EBCDIC （日文片假名）|||  
|20297|IBM297|IBM EBCDIC (Francie)|||  
|20420|IBM420|IBM EBCDIC （阿拉伯文）|||  
|20423|IBM423|IBM EBCDIC （希臘文）|||  
|20424|IBM424|IBM EBCDIC (Hebrejština)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC （韓文擴充）|||  
|20838|IBM-泰文|IBM EBCDIC (Thajština)|||  
|20866|koi8-r|Cyrilice (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (Islandština)|||  
|20880|IBM880|IBM EBCDIC （斯拉夫俄文）|||  
|20905|IBM905|IBM EBCDIC (Turečtina)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|Japonština (JIS 0208 1990年和 0212年 1990年)|||  
|20936|x-cp20936|簡體中文 (GB2312-80)|✓||  
|20949|x-cp20949|韓文 Wansung|✓||  
|21025|cp1025|IBM EBCDIC （斯拉夫塞爾維亞文-保加利亞文）|||  
|21866|koi8-u|Cyrilice (KOI8-U)|||  
|28591|iso-8859-1|西歐語系 (ISO)|✓|✓|  
|28592|iso-8859-2|中歐語系 (ISO)|||  
|28593|iso-8859-3|拉丁文 3 (ISO)|||  
|28594|iso-8859-4|波羅的海文 (ISO)|||  
|28595|iso-8859-5|Cyrilice (ISO)|||  
|28596|iso-8859-6|Arabština (ISO)|||  
|28597|iso-8859-7|希臘文 (ISO)|||  
|28598|iso-8859-8|希伯來文 (So-visual)|✓||  
|28599|iso-8859-9|Turečtina (ISO)|||  
|28603|iso-8859-13|Estonština (ISO)|||  
|28605|iso-8859-15|拉丁文 9 (ISO)|||  
|29001|x-Europa|Europa|||  
|38598|iso-8859-8-i|Hebrejština (Iso-logical)|✓||  
|50220|iso-2022年-jp|Japonština (JIS)|✓||  
|50221|csISO2022JP|日文 (JIS-Povolen 1 bajt Kana)|✓||  
|50222|iso-2022年-jp|日文 (JIS-Povolen 1 bajt Kana-因此 / SI)|✓||  
|50225|iso-2022年-韓國|Korejština (ISO)|✓||  
|50227|x-cp50227|簡體中文 (ISO-2022)|✓||  
|51932|euc jp|Japonština (EUC)|✓||  
|51936|EUC CN|簡體中文 (EUC)|✓||  
|51949|euc 韓國|Korejština (EUC)|✓||  
|52936|hz-gb-2312|簡體中文 (HZ)|✓||  
|54936|GB18030|簡體中文 (GB18030)|✓||  
|57002|x-iscii-de|ISCII 梵文字母|✓||  
|57003|iscii-是 x|ISCII 孟加拉文|✓||  
|57004|x-iscii-ta|Iscii-Tamilština|✓||  
|57005|x-iscii-te|Iscii-Telugština|✓||  
|57006|x iscii 身分|ISCII 阿薩姆文|✓||  
|57007|或 x iscii|Iscii-Urijština|✓||  
|57008|x-iscii-ka|Iscii-Kannadština|✓||  
|57009|x-iscii-ma|ISCII 馬來亞拉姆文|✓||  
|57010|x-iscii-gu|ISCII 古吉拉特文|✓||  
|57011|x-iscii-pa|ISCII 旁遮普文|✓||  
|65000|utf-7|Unicode (utf-7)|✓|✓|  
|65001|utf-8|Unicode (UTF-8)|✓|✓|  
  
 下列範例會呼叫<xref:System.Text.Encoding.GetEncoding%28System.Int32%29>和<xref:System.Text.Encoding.GetEncoding%28System.String%29>方法，以取得希臘文 (Windows) 程式碼頁面的編碼方式。 它會比較<xref:System.Text.Encoding>顯示相等，並接著對應會顯示的 Unicode 字碼指標及相對應的字碼頁值，每個字元希臘文字母中的方法呼叫所傳回的物件。  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 Utf-16 和 UTF-32 編碼器可以使用位元組由大到小位元組順序 (最大顯著性位元組第一次) 或小小的位元組由小到大位元組順序 (最小顯著性位元組第一次)。 例如，(u+0041) 序列化為 Latin Capital Letter 如下 （以十六進位方式）：  
  
-   Utf-16 位元組由大到小位元組順序： 00 41  
  
-   Utf-16 少位元組由小到大位元組順序： 41 00  
  
-   UTF-32 位元組由大到小位元組順序： 00 00 00 41  
  
-   UTF-32 少位元組由小到大位元組順序： 41 00 00 00  
  
 它會儲存使用原生的位元組順序的 Unicode 字元通常更有效率。 比方說，最好使用位元組由小到大的位元組順序少位元組由小到大的平台，例如 Intel 的電腦上。  
  
 <xref:System.Text.Encoding.GetPreamble%2A>方法會擷取的位元組陣列，其中包含位元組順序標記 (BOM)。 如果這個位元組陣列，做為編碼的資料流前置詞，它可協助找出所使用的編碼格式的解碼器。  
  
 如需有關位元組順序和位元組順序標記的詳細資訊，請參閱 Unicode Standard > [Unicode 首頁](https://go.microsoft.com/fwlink/?LinkId=37123)。  
  
 請注意，編碼的類別可讓錯誤：  
  
-   以無訊息模式變更為"？"字元。  
  
-   使用"best fit"的字元。  
  
-   透過使用特定應用程式的行為變更<xref:System.Text.EncoderFallback>和<xref:System.Text.DecoderFallback>U + FFFD Unicode replacement character 類別。  
  
 您應該在發生任何資料流的錯誤會擲回例外狀況。 應用程式會使用"throwonerror 」 旗標適用時，或使用<xref:System.Text.EncoderExceptionFallback>和<xref:System.Text.DecoderExceptionFallback>類別。 通常不建議使用自動調整的後援，因為它可能會導致資料遺失或造成混淆且低於簡單的字元取代。 ANSI 編碼，則自動調整的行為是預設值。  
  
   
  
## Examples  
 下列範例會將字串轉換到另一個編碼方式。  
  
> [!NOTE]
>  Byte [] 陣列是唯一的型別，在此範例中，其中包含編碼的資料。 .NET Char 和字串型別是本身是使用 Unicode，因此<xref:System.Text.Encoding.GetChars%2A>呼叫解碼 Unicode 資料。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生的類別覆寫這個建構函式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">慣用編碼方式的字碼頁識別項。  
  
-或- 
0，表示使用預設的編碼方式。</param>
        <summary>初始化對應到指定字碼頁之 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在衍生的類別覆寫這個建構函式。  
  
 從衍生類別呼叫這個建構函式建立<xref:System.Text.Encoding>編碼和解碼作業中使用自動調整的後援的物件。 同時<xref:System.Text.Encoding.DecoderFallback%2A>和<xref:System.Text.Encoding.EncoderFallback%2A>屬性是唯讀的而且無法修改。 若要控制後援策略類別衍生自<xref:System.Text.Encoding>，呼叫<xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> 小於零。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">編碼方式字碼頁識別項。</param>
        <param name="encoderFallback">物件，該物件會在無法以目前編碼方式將字元編碼時提供錯誤處理程序。</param>
        <param name="decoderFallback">物件，該物件會在無法以目前編碼方式將位元組序列解碼時提供錯誤處理程序。</param>
        <summary>使用指定的編碼器和解碼器後援策略，初始化對應到指定字碼頁之 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式`protected`; 衍生類別覆寫它。  
  
 您可以呼叫這個建構函式從衍生的類別，來控制此後援編碼和解碼策略。 <xref:System.Text.Encoding>類別建構函式建立唯讀編碼器或解碼器後援物件建立之後，設定不允許的編碼物件。  
  
 如果有任一`encoderFallback`或`decoderFallback`為 null，自動調整的後援作為相對應的後援策略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> 小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 ASCII (7 位元) 字元集 (Character Set) 的編碼方式。</summary>
        <value>ASCII (7 位元) 字元集的編碼方式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII 字元僅限於從 u+0000 到 U + 007F 最低 128 個 Unicode 字元中，項目。  
  
 選取您的應用程式的 ASCII 編碼方式，請考慮下列各項：  
  
-   ASCII 編碼的是，這通常適用於需要 ASCII 的通訊協定。  
  
-   如果您需要 8 位元編碼 （這有時會錯誤地稱為 「 ASCII 」），將 ASCII 建議 utf-8 編碼的編碼方式。 字元 0 7F，結果都一樣，但使用 utf-8 避免資料遺失，藉由使用可顯示的所有 Unicode 字元表示法。 請注意，ASCII 編碼的 8 位元的模稜兩可，可以讓惡意使用，但 utf-8 編碼方式移除相關的 8 位元的模稜兩可。  
  
-   .NET Framework 2.0 版之前的.NET Framework 會允許詐騙略過的 8 位元。 從.NET Framework 2.0 開始，非 ASCII 碼點切換回在解碼期間。  
  
 <xref:System.Text.ASCIIEncoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。 它會使用取代後援來取代無法編碼的每個字串和無法解碼的每個位元組以問號 ("？") 字元。 相反地，您可以呼叫<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>方法具現化<xref:System.Text.ASCIIEncoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 下列範例示範的 ASCII 編碼字元的 ASCII 範圍之外的效果。  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 UTF-16 格式的編碼方式，其使用由大到小的位元組順序。</summary>
        <value>UTF-16 格式的編碼物件，這個格式使用位元組由大到小的位元組順序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。 它會使用取代後援來取代無法編碼的每個字串和無法解碼的每個位元組以問號 ("？") 字元。 相反地，您可以呼叫<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化 big endian<xref:System.Text.UnicodeEncoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 傳回<xref:System.Text.UnicodeEncoding>物件具有<xref:System.Text.Encoding.BodyName%2A>， <xref:System.Text.Encoding.HeaderName%2A>，和<xref:System.Text.Encoding.WebName%2A>產生名稱"unicodeFFFE"的屬性。 雖然 utf-16 位元組由大到小位元組順序標記是十六進位 FEFF，名稱"unicodeFFFE 」 已選擇，因為位元順序標記會顯示為十六進位 7C94:FFFE 少位元組由小到大的 Windows 電腦上。  
  
   
  
## Examples  
 下列範例會讀取文字檔案，以位元組由大到小位元組的順序，使用 utf-16 編碼方式。  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得可以與郵件代理程式主體標籤一起使用的目前編碼方式名稱。</summary>
        <value>可以與郵件代理程式主體標籤一起使用的目前 <see cref="T:System.Text.Encoding" /> 名稱。  
  
-或- 
如果無法使用目前的 <see cref="T:System.Text.Encoding" />，則為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您需要的主體名稱的編碼方式，您應該呼叫<xref:System.Text.Encoding.GetEncoding%2A>與<xref:System.Text.Encoding.BodyName%2A>屬性。 通常方法會擷取不同的呼叫中提供的測試編碼所用的編碼。 通常只有電子郵件應用程式必須擷取這類的編碼方式;大部分需要描述的編碼方式的其他應用程式應該使用其<xref:System.Text.Encoding.WebName%2A>。  
  
 在某些情況下，值<xref:System.Text.Encoding.BodyName%2A>屬性會對應至國際標準，可定義該編碼。 這並不表示實作符合該標準的完整。  
  
   
  
## Examples  
 下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，會建立目前 <see cref="T:System.Text.Encoding" /> 物件的淺層複本。</summary>
        <returns>目前 <see cref="T:System.Text.Encoding" /> 的複本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複製為可寫入即使原始<xref:System.Text.Encoding>物件是唯讀的。 因此，您可修改複製品的屬性。  
  
 物件的淺層複本是物件的一份只有。 如果物件包含其他物件的參考，則淺層複製不會建立參考物件的複本。 它改為參考原始物件。 相較之下，物件的深層複本建立一份物件和一份直接或間接參考該物件的所有項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前 <see cref="T:System.Text.Encoding" /> 的字碼頁識別項。</summary>
        <value>目前 <see cref="T:System.Text.Encoding" /> 的字碼頁識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將位元組陣列由一種編碼方式轉換成另一種編碼方式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">
          <paramref name="bytes" /> 的編碼格式。</param>
        <param name="dstEncoding">目標編碼格式。</param>
        <param name="bytes">要轉換的位元組。</param>
        <summary>將整個位元組陣列從一種編碼方式轉換成另一種編碼方式。</summary>
        <returns>
          <see cref="T:System.Byte" /> 類型的陣列，包含將 <paramref name="bytes" /> 從 <paramref name="srcEncoding" /> 轉換成 <paramref name="dstEncoding" /> 的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會將 Unicode 編碼的字串轉換成 ASCII 編碼的字串。 因為所傳回的 ASCII 編碼物件<xref:System.Text.Encoding.ASCII%2A>屬性使用取代後援，且 Pi 字元不是 ASCII 字元集的一部分，Pi 字元取代為問號，範例所示的輸出。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="dstEncoding" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 **srcEncoding。** <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 **dstEncoding。** <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">來源陣列 <paramref name="bytes" /> 的編碼方式。</param>
        <param name="dstEncoding">輸出陣列的編碼方式。</param>
        <param name="bytes">要進行轉換的位元組陣列。</param>
        <param name="index">
          <paramref name="bytes" /> 中要轉換的第一個項目索引。</param>
        <param name="count">要轉換的位元組數。</param>
        <summary>將位元組陣列中的某一位元組範圍由一種編碼方式轉換成另一種編碼方式。</summary>
        <returns>
          <see cref="T:System.Byte" /> 類型的陣列，包含將 <paramref name="bytes" /> 中的某個位元組範圍從 <paramref name="srcEncoding" /> 轉換成 <paramref name="dstEncoding" /> 的結果。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="dstEncoding" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 和 <paramref name="count" /> 不會指定位元組陣列中的有效範圍。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 **srcEncoding。** <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 **dstEncoding。** <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前 <see cref="T:System.Text.DecoderFallback" /> 物件的 <see cref="T:System.Text.Encoding" /> 物件。</summary>
        <value>目前 <see cref="T:System.Text.Encoding" /> 物件的解碼器後援物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback>物件都代表編碼的位元組序列無法解碼成字元時，會叫用錯誤處理常式。 支援下列處理常式類型的任何一個：  
  
-   自動調整後援處理常式，這會取代一些合適的替代字元取代無法解碼的位元組。  
  
-   取代後援處理常式，其中某些任意的取代字元來取代無法解碼的位元組。 .NET 包含一個取代後援處理常式， <xref:System.Text.DecoderFallback>，依預設以問號取代無法解碼的位元組 ("？") 字元。  
  
-   例外狀況後援處理常式，它無法解碼位元組時，會擲回例外狀況。 .NET 包含一個例外狀況後援處理常式， <xref:System.Text.DecoderExceptionFallback>，哪些則會擲回<xref:System.Text.DecoderFallbackException>時無法解碼的位元組。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">在設定作業中，此值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法在設定作業中指派值，因為目前的 <see cref="T:System.Text.Encoding" /> 物件是唯讀的。</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此 .NET 實作的預設編碼。</summary>
        <value>預設的編碼此.NET 實作。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  不同的電腦可以使用不同的編碼預設值，而且預設的編碼方式可以在單一電腦上的方式來變更。 如果您使用<xref:System.Text.Encoding.Default%2A>編碼進行編碼和解碼資料流處理的電腦之間或在同一部電腦上的不同時間擷取資料，它可能會轉譯該資料不正確。 此外，編碼傳回<xref:System.Text.Encoding.Default%2A>屬性會自動調整的後援使用不支援的字元對應到字碼頁所支援的字元。 基於這些理由，不建議使用預設的編碼方式。 若要確保正確解碼已編碼的位元組，您應該使用 Unicode 編碼，例如<xref:System.Text.UTF8Encoding>或<xref:System.Text.UnicodeEncoding>。 您也可以使用較高層級的通訊協定，以確保相同的格式用於編碼和解碼。  

### <a name="the-default-property-in-the-net-framework"></a>.NET Framework 中的預設屬性

在 Windows 桌面上，.NET Framework 中<xref:System.Text.Encoding.Default%2A>屬性一律會取得系統的使用中的字碼頁，並建立<xref:System.Text.Encoding>對應至它的物件。 作用中的字碼頁可能包含字碼頁來設定以及不同的其他字元的 ASCII 字元的 ANSI 字碼頁。 因為所有<xref:System.Text.Encoding.Default%2A>根據 ANSI 字碼頁的編碼會遺失資料，請考慮使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>改為編碼。 Utf-8 通常的 U + 00 到 U + 7F 範圍相同，但可以編碼而不會遺失 ASCII 範圍之外的字元。

## <a name="the-default-property-on-net-core"></a>在.NET Core 上的預設屬性

在.NET Core<xref:System.Text.Encoding.Default%2A>屬性一律會傳回<xref:System.Text.UTF8Encoding>。 Utf-8 支援的所有作業系統 （Windows、 Linux 和最大 OS X） 上執行的.NET Core 應用程式。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前 <see cref="T:System.Text.EncoderFallback" /> 物件的 <see cref="T:System.Text.Encoding" /> 物件。</summary>
        <value>目前 <see cref="T:System.Text.Encoding" /> 物件的解碼器後援物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback>物件都代表一個字元無法轉換成編碼的位元組序列時所叫用錯誤處理常式。 支援下列處理常式類型的任何一個：  
  
-   自動調整後援處理常式，這會取代一些合適的替代字元取代無法編碼的字元。  
  
-   取代後援處理常式，這會取代某些任意的取代字元無法編碼的字元。 .NET 包含一個取代後援處理常式， <xref:System.Text.EncoderFallback>，其預設值取代無法編碼的字元以問號 ("？") 字元。  
  
-   例外狀況後援處理常式，它會在無法編碼字元時擲回例外狀況。 .NET 包含一個例外狀況後援處理常式， <xref:System.Text.EncoderExceptionFallback>，哪些則會擲回<xref:System.Text.EncoderFallbackException>無法解碼字元時。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">在設定作業中，此值為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法在設定作業中指派值，因為目前的 <see cref="T:System.Text.Encoding" /> 物件是唯讀的。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得目前編碼方式的人們可讀取 (Human-Readable) 的描述。</summary>
        <value>目前 <see cref="T:System.Text.Encoding" /> 的人們可讀取的描述。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A>屬性供顯示。 若要尋找的名稱，可以傳遞至<xref:System.Text.Encoding.GetEncoding%2A>方法，請使用<xref:System.Text.Encoding.WebName%2A>屬性。  
  
   
  
## Examples  
 下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要與目前執行個體比較的 <see cref="T:System.Object" />。</param>
        <summary>判斷指定的 <see cref="T:System.Object" /> 和目前的執行個體是否相等。</summary>
        <returns>如果 <paramref name="value" /> 是 <see cref="T:System.Text.Encoding" /> 的執行個體，並且等於目前的執行個體，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 兩個執行個體<xref:System.Text.Encoding>會被視為相等，如果它們對應到相同的字碼頁和他們`EncoderFallback`和`DecoderFallback`物件是否相等。 特別是，所有的衍生的字碼頁有字碼頁為 0，而且其後援會正常`null`(`Nothing`在 Visual Basic.NET)。 因此，全部都視為等於另一個。 一種結果是，當<xref:System.Text.Encoding.Equals%2A>用來填入雜湊表，所有衍生相等的編碼方式比較屬於相同的雜湊表位置。  
  
   
  
## Examples  
 下列範例會取得兩個相同的編碼 （字碼頁的一個），依名稱的另一個執行個體，並檢查它們相等。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，計算編碼一組字元所產生的位元組數目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">字元陣列，包含要編碼的字元。</param>
        <summary>在衍生類別中覆寫時，計算編碼指定字元陣列中所有字元所產生的位元組數目。</summary>
        <returns>編碼指定字元陣列中所有字元所產生的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>若要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。  
  
-   如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>方法。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，您應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要編碼的一組字元。</param>
        <summary>在衍生類別中覆寫時，計算編碼指定的字串字元所產生的位元組數目。</summary>
        <returns>編碼指定字元所產生的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>若要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。  
  
-   如果您的應用程式會處理字串輸入的字串版本<xref:System.Text.Encoding.GetBytes%2A>建議。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼的字串或字串中的範圍所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">要編碼的第一個字元指標。</param>
        <param name="count">要編碼的字元數。</param>
        <summary>在衍生類別中覆寫時，計算從指定的字元指標開始，編碼一組字元所產生的位元組數目。</summary>
        <returns>編碼指定字元所產生的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>需要儲存產生的位元組，您應該呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 以下是使用這些方法的一些考量：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。  
  
-   如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>方法。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%2A>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小於零。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要解碼之一組字元的字元陣列。</param>
        <param name="index">要編碼的第一個字元索引。</param>
        <param name="count">要編碼的字元數。</param>
        <summary>在衍生類別中覆寫時，計算從指定的字元陣列編碼一組字元所產生的位元組數目。</summary>
        <returns>編碼指定字元所產生的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>若要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。  
  
-   如果您的應用程式會處理字串輸入的字串版本<xref:System.Text.Encoding.GetBytes%2A>建議。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼字元陣列中的三個字元所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="chars" /> 中有效的範圍。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，將一組字元編碼成位元組序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">字元陣列，包含要編碼的字元。</param>
        <summary>在衍生類別中覆寫時，將指定字元陣列中的所有字元編碼成位元組序列。</summary>
        <returns>位元組陣列，包含將指定之一組字元編碼之後的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。 （例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。 <xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。 <xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)  
  
-   如果您的應用程式會處理字串輸入，您應該呼叫的字串版本<xref:System.Text.Encoding.GetBytes%2A>方法。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要編碼的字元。</param>
        <summary>在衍生類別中覆寫時，將指定字串中的所有字元編碼成位元組序列。</summary>
        <returns>位元組陣列，包含將指定之一組字元編碼之後的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。 （例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。 <xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。 <xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)  
  
-   如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼的字串或字串中的範圍所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要解碼之一組字元的字元陣列。</param>
        <param name="index">要編碼的第一個字元索引。</param>
        <param name="count">要編碼的字元數。</param>
        <summary>在衍生類別中覆寫時，將指定字元陣列中的一組字元編碼成位元組序列。</summary>
        <returns>位元組陣列，包含將指定之一組字元編碼之後的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。 （例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。 <xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。 <xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)  
  
-   如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼字元陣列中的三個字元所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="chars" /> 中有效的範圍。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">要編碼的第一個字元指標。</param>
        <param name="charCount">要編碼的字元數。</param>
        <param name="bytes">開始寫入結果位元組序列的位置指標。</param>
        <param name="byteCount">寫入的最大位元組數。</param>
        <summary>在衍生類別中覆寫時，從指定字元指標開始將一組字元編碼成位元組序列 (會從指定的位元組指標開始存放這些位元組)。</summary>
        <returns>
          <paramref name="bytes" /> 參數所指示位置上寫入的實際位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>需要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 如果要轉換的數據僅在順序塊中可用（例如從流中讀取的數據），或者如果數據量太大以至於需要將其分成較小的塊，則應使用提供的<xref:System.Text.Decoder>或<xref:System.Text.Encoder>對象 分別由<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>種方法派生的類。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。 （例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。 <xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。 <xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)  
  
-   如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> 或 <paramref name="byteCount" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> 小於結果位元組數。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">包含要解碼之一組字元的字元陣列。</param>
        <param name="charIndex">要編碼的第一個字元索引。</param>
        <param name="charCount">要編碼的字元數。</param>
        <param name="bytes">要包含結果位元組序列的位元組陣列。</param>
        <param name="byteIndex">要開始寫入結果位元組序列的索引。</param>
        <summary>在衍生類別中覆寫時，將指定字元陣列中的一組字元編碼成指定的位元組陣列。</summary>
        <returns>寫入 <paramref name="bytes" /> 的實際位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>來儲存產生的位元組，您應該呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。 （例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。 <xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。 <xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)  
  
-   如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼字元陣列中的三個字元所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小於零。  
  
-或- 
 <paramref name="charIndex" /> 與 <paramref name="charCount" /> 不代表 <paramref name="chars" /> 中有效的範圍。  
  
-或- 
 <paramref name="byteIndex" /> 在 <paramref name="bytes" /> 中不是有效的索引。</exception>
        <exception cref="T:System.ArgumentException">從 <paramref name="bytes" /> 到陣列結尾處，<paramref name="byteIndex" /> 沒有足夠的容量容納結果位元組。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">字串，包含要編碼的一組字元。</param>
        <param name="charIndex">要編碼的第一個字元索引。</param>
        <param name="charCount">要編碼的字元數。</param>
        <param name="bytes">要包含結果位元組序列的位元組陣列。</param>
        <param name="byteIndex">要開始寫入結果位元組序列的索引。</param>
        <summary>在衍生類別中覆寫時，將指定字串中的一組字元編碼成指定的位元組陣列。</summary>
        <returns>寫入 <paramref name="bytes" /> 的實際位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>來儲存產生的位元組，您應該呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。  
  
 數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。 在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。 （例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。 <xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。 <xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)  
  
-   如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。  
  
-   Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。 轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。 如果是連續資料流的編碼，此方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會決定編碼的字串或字串中的範圍所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小於零。  
  
-或- 
 <paramref name="charIndex" /> 與 <paramref name="charCount" /> 不代表 <paramref name="chars" /> 中有效的範圍。  
  
-或- 
 <paramref name="byteIndex" /> 在 <paramref name="bytes" /> 中不是有效的索引。</exception>
        <exception cref="T:System.ArgumentException">從 <paramref name="bytes" /> 到陣列結尾處，<paramref name="byteIndex" /> 沒有足夠的容量容納結果位元組。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，計算解碼位元組序列所產生的字元數目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <summary>在衍生類別中覆寫時，計算解碼指定位元組陣列中所有位元組所產生的字元數目。</summary>
        <returns>解碼指定位元組序列所產生的字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法。 若要計算最大陣列大小，您應該使用<xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29>方法。 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>方法會執行實際的解碼。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。  
  
 數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。 在此情況下，您可能需要維護呼叫之間的狀態。  
  
-   如果您的應用程式會處理字串輸出，您應該使用<xref:System.Text.Encoding.GetString%2A>方法。 由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。  
  
-   位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。 轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。 連續解碼資料流，這個方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會將字串編碼成位元組陣列，並接著將位元組解碼成字元陣列。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">要解碼的第一個位元組指標。</param>
        <param name="count">要解碼的位元組數。</param>
        <summary>在衍生類別中覆寫時，計算從指定的位元組指標開始，解碼位元組序列所產生的字元數目。</summary>
        <returns>解碼指定位元組序列所產生的字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>需要儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。 <xref:System.Text.Encoding.GetChars%2A>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。  
  
 數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。 在此情況下，您可能需要維護呼叫之間的狀態。  
  
-   如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。 由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。  
  
-   位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。 轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。 連續解碼資料流，這個方法通常是最佳選擇。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> 小於零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="index">要解碼的第一個位元組索引。</param>
        <param name="count">要解碼的位元組數。</param>
        <summary>在衍生類別中覆寫時，計算從指定的位元組陣列解碼位元組序列所產生的字元數目。</summary>
        <returns>解碼指定位元組序列所產生的字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。 <xref:System.Text.Encoding.GetChars%2A>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。  
  
 數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。 在此情況下，您可能需要維護呼叫之間的狀態。  
  
-   如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。 由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。  
  
-   位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。 轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。 連續解碼資料流，這個方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會將字串轉換到另一個編碼方式。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 下列範例會將字串編碼成位元組陣列，然後再將的位元組範圍解碼成字元陣列。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，將位元組序列解碼成一組字元。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <summary>在衍生類別中覆寫時，將指定位元組陣列中的所有位元組解碼成一組字元。</summary>
        <returns>字元陣列，包含解碼指定位元組序列的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 取得從的輸入的位元組序列的字元。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個行程上的單一輸入資料流。  
  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 **請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。 如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。  
  
 數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。 在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。 (例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個<xref:System.Text.Encoding.GetChars%2A>呼叫，並繼續進行下一步 開始<xref:System.Text.Encoding.GetChars%2A>呼叫。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)  
  
-   如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。 由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。  
  
-   位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。 轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。 連續解碼資料流，這個方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會將字串編碼成位元組陣列，並接著將位元組解碼成字元陣列。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="index">要解碼的第一個位元組索引。</param>
        <param name="count">要解碼的位元組數。</param>
        <summary>在衍生類別中覆寫時，將指定位元組陣列中的位元組序列解碼成一組字元。</summary>
        <returns>字元陣列，包含解碼指定位元組序列的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 取得從的輸入的位元組序列的字元。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個行程上的單一輸入資料流。  
  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 **請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。 如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。  
  
 數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。 在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。 (例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個<xref:System.Text.Encoding.GetChars%2A>呼叫，並繼續進行下一步 開始<xref:System.Text.Encoding.GetChars%2A>呼叫。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)  
  
-   如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。 由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。  
  
-   位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。 轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。 連續解碼資料流，這個方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會將字串編碼成位元組陣列，然後再將的位元組範圍解碼成字元陣列。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">要解碼的第一個位元組指標。</param>
        <param name="byteCount">要解碼的位元組數。</param>
        <param name="chars">開始寫入產生的一組字元之位置指標。</param>
        <param name="charCount">要寫入的最大字元數。</param>
        <summary>在衍生類別中覆寫時，從指定位元組指標開始將位元組序列解碼成一組字元 (會從指定的字元指標開始存放這些字元)。</summary>
        <returns>
          <paramref name="chars" /> 參數所指示位置上寫入的實際字元數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>需要儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 取得從的輸入的位元組序列的字元。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個行程上的單一輸入資料流。  
  
 如果要轉換的數據僅在順序塊中可用（例如從流中讀取的數據），或者如果數據量太大以至於需要將其分成較小的塊，則應使用提供的<xref:System.Text.Decoder>或<xref:System.Text.Encoder>對象 分別由<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>種方法派生的類。  
  
 **請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。 如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。  
  
 數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。 在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。 (例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個<xref:System.Text.Encoding.GetChars%2A>呼叫，並繼續進行下一步 開始<xref:System.Text.Encoding.GetChars%2A>呼叫。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)  
  
-   如果您的應用程式會處理字串輸出<xref:System.Text.Encoding.GetString%2A>建議方法。 由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。  
  
-   位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。 轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。 連續解碼資料流，這個方法通常是最佳選擇。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="chars" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> 或 <paramref name="charCount" /> 小於零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> 小於結果字元數。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="byteIndex">要解碼的第一個位元組索引。</param>
        <param name="byteCount">要解碼的位元組數。</param>
        <param name="chars">包含產生的一組字元之字元陣列。</param>
        <param name="charIndex">要開始寫入產生的一組字元之索引。</param>
        <summary>在衍生類別中覆寫時，將指定位元組陣列中的位元組序列解碼成指定的字元陣列。</summary>
        <returns>寫入 <paramref name="chars" /> 的實際字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。  
  
 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 取得從的輸入的位元組序列的字元。 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 不同<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個傳遞單一的輸入資料流。  
  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 **請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。 如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。  
  
 數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。 使用這些方法的一些程式設計考量如下：  
  
-   您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。 在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。 (例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A > 呼叫，並繼續進行下一步 開始 [\]，Int32，Int32，Char\<xref: System.Text.Encoding.GetChars%2A > 呼叫。 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)  
  
-   如果您的應用程式會處理字串輸出<xref:System.Text.Encoding.GetString%2A>建議方法。 由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。  
  
-   位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。 請記住，不過，這個版本的方法是有時不安全，因為所需的指標。  
  
-   如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。 在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。  
  
-   請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。 轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。 連續解碼資料流，這個方法通常是最佳選擇。  
  
   
  
## Examples  
 下列範例會將字串轉換到另一個編碼方式。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 下列範例會將字串編碼成位元組陣列，然後再將的位元組範圍解碼成字元陣列。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="chars" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />、<paramref name="byteCount" /> 或 <paramref name="charIndex" /> 小於零。  
  
-或- 
 <paramref name="byteindex" /> 與 <paramref name="byteCount" /> 不代表 <paramref name="bytes" /> 中有效的範圍。  
  
-或- 
 <paramref name="charIndex" /> 在 <paramref name="chars" /> 中不是有效的索引。</exception>
        <exception cref="T:System.ArgumentException">從 <paramref name="chars" /> 到陣列結尾處，<paramref name="charIndex" /> 沒有足夠的容量容納結果字元。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，取得會將編碼的位元組序列轉換成字元序列的解碼器。</summary>
        <returns>
          <see cref="T:System.Text.Decoder" />，會將編碼的位元組序列轉換成字元序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法會將序列的位元組的區塊轉換成循序區塊中的字元，以類似的方式<xref:System.Text.Encoding.GetChars%2A>這個類別的方法。 不過，<xref:System.Text.Decoder>維護呼叫，因此它會正確解碼位元組序列跨越區塊之間的狀態資訊。 <xref:System.Text.Decoder>也會保留尾端位元組的資料區塊的結尾，並在下一步 的解碼作業中使用尾端位元組。 因此，<xref:System.Text.Encoding.GetDecoder%2A>和<xref:System.Text.Encoding.GetEncoder%2A>適合用於網路傳輸和檔案作業，因為這些作業經常要處理的資料，而不是完整的資料流區塊。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>預設實作會傳回<see cref="T:System.Text.Decoder" />它會呼叫<see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />並<see cref="M:System.Text.Encoding.GetChars(System.Byte[])" />方法在目前的<see cref="T:System.Text.Encoding" />。 您必須覆寫此方法以傳回<see cref="T:System.Text.Decoder" />，維護它呼叫之間的狀態。</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，取得會將 Unicode 字元序列轉換成編碼的位元組序列的編碼器。</summary>
        <returns>
          <see cref="T:System.Text.Encoder" />，會將 Unicode 字元序列轉換成編碼的位元組序列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法會將字元的循序區塊轉換成循序區塊中的位元組，以類似的方式<xref:System.Text.Encoding.GetBytes%2A>這個類別的方法。 不過，<xref:System.Text.Encoder>維護讓它正確編碼的字元序列跨越區塊的呼叫之間的狀態資訊。 <xref:System.Text.Encoder>也保留尾端字元的資料區塊的結尾，並在下一步 的編碼作業中使用尾端的字元。 比方說，資料區塊可能會以無對應的高 surrogate，結尾，而且下一個資料區塊可能會比對的低 surrogate。 因此，<xref:System.Text.Encoding.GetDecoder%2A>和<xref:System.Text.Encoding.GetEncoder%2A>適合用於網路傳輸和檔案作業，因為這些作業經常要處理的資料，而不是完整的資料流區塊。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>預設實作會傳回<see cref="T:System.Text.Encoder" />它會呼叫<see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />並<see cref="M:System.Text.Encoding.GetBytes(System.Char[])" />方法在目前的<see cref="T:System.Text.Encoding" />。 您必須覆寫此方法以傳回<see cref="T:System.Text.Encoder" />，維護它呼叫之間的狀態。</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回指定字碼頁的編碼方式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">慣用編碼方式的字碼頁識別項。 <see cref="T:System.Text.Encoding" /> 類別主題中表格的「字碼頁」欄會列出可能值。  
  
-或- 
0 (零)，表示使用預設的編碼方式。</param>
        <summary>傳回與指定字碼頁識別項相關聯的編碼方式。</summary>
        <returns>與指定字碼頁相關聯的編碼方式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編碼方式類型取決於後援處理常式`codepage`。 如果`codepage`程式碼頁面或雙位元組字元集 (DBCS) 編碼，會使用自動調整後援處理常式。 否則，會使用取代後援處理常式。 這些後援處理常式可能不適合您的應用程式。 若要指定所指定的編碼使用後援處理常式`codepage`，您可以呼叫<xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>多載。  
  
 在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。 不過，.NET Framework 原本就支援一些編碼方式。 如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。 在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。 在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。 

 除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。 如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。  

您也可以提供的值為 0`codepage`引數。 精確的行為取決於是否任何的編碼方式已有可用的註冊<xref:System.Text.EncodingProvider>物件：

- 如果已註冊一或多個編碼提供者，它就會傳回最後一個已註冊的提供者傳回編碼時選擇的編碼方式<xref:System.Text.Encoding.GetEncoding%2A>方法會傳遞`codepage`引數為 0。     

- 在.NET Framework 中，如果沒有編碼提供者已註冊之後，如果<xref:System.Text.CodePagesEncodingProvider>是已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回作業系統的作用中的字碼頁。 若要判斷在 Windows 系統上的作用中的字碼頁，呼叫 Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)從.NET Framework 在 Windows 桌面上的函式。

- 在.NET Core，如果有任何已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回<xref:System.Text.UTF8Encoding>。
  
> [!NOTE]
>  某些不支援的字碼頁的原因<xref:System.ArgumentException>擲回，而其他人會造成<xref:System.NotSupportedException>。 因此，您的程式碼必須攔截所有例外狀況的例外狀況 」 一節所示。  
  
> [!NOTE]
>  ANSI 字碼頁不同的電腦上可能有不同，而且可以變更的單一電腦上，導致資料損毀。 基於這個理由，如果作用中的字碼頁為 ANSI 字碼頁編碼和解碼使用的預設字碼頁資料所傳回`Encoding.GetEncoding(0)`不建議使用。 為了最一致的結果，您應該使用 Unicode 編碼，例如 utf-8 （字碼頁 65001） 或 utf-16，而不特定字碼頁。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。 您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。 比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。  

   
  
## Examples  
 下列範例會取得兩個相同的編碼 （字碼頁所一個），依名稱的另一個執行個體，並檢查它們相等。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> 小於零或大於 65535。</exception>
        <exception cref="T:System.ArgumentException">基礎的平台並不支援 <paramref name="codepage" />。</exception>
        <exception cref="T:System.NotSupportedException">基礎的平台並不支援 <paramref name="codepage" />。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">慣用編碼方式的字碼頁名稱。 <see cref="P:System.Text.Encoding.WebName" /> 屬性傳回的任何值都是有效值。 <see cref="T:System.Text.Encoding" /> 類別主題中表格的「名稱」欄會列出可能值。</param>
        <summary>傳回與指定字碼頁名稱相關聯的編碼方式。</summary>
        <returns>與指定字碼頁相關聯的編碼方式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編碼方式類型取決於後援處理常式`name`。 如果`name`程式碼頁面或雙位元組字元集 (DBCS) 編碼，會使用自動調整後援處理常式。 否則，會使用取代後援處理常式。 這些後援處理常式可能不適合您的應用程式。 若要指定所指定的編碼使用後援處理常式`name`，您可以呼叫<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>多載。  

在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。 不過，.NET Framework 原本就支援一些編碼方式。 如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。 在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。 在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。 

 除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。 如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。  
   
> [!NOTE]
>  ANSI 字碼頁不同的電腦上可能有不同，也可以變更為單一電腦，導致資料損毀。 為了最一致的結果，您應該使用 Unicode，例如 utf-8 （字碼頁 65001） 或 utf-16，而不是特定字碼頁。  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。 您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。 比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。  
  
## Examples  
 下列範例會取得兩個相同的編碼 （字碼頁所一個），依名稱的另一個執行個體，並檢查它們相等。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的字碼頁名稱。  
  
-或- 
主要平台尚不支援以 <paramref name="name" /> 所指示的字碼頁。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">慣用編碼方式的字碼頁識別項。 <see cref="T:System.Text.Encoding" /> 類別主題中表格的「字碼頁」欄會列出可能值。  
  
-或- 
0 (零)，表示使用預設的編碼方式。</param>
        <param name="encoderFallback">物件，該物件會在無法以目前編碼方式將字元編碼時提供錯誤處理程序。</param>
        <param name="decoderFallback">物件，該物件會在無法以目前編碼方式將位元組序列解碼時提供錯誤處理程序。</param>
        <summary>傳回與指定字碼頁識別項相關聯的編碼方式。 參數會針對無法編碼的字元以及無法解碼的位元組序列指定錯誤處理常式。</summary>
        <returns>與指定字碼頁相關聯的編碼方式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  某些不支援的字碼頁會導致例外狀況<xref:System.ArgumentException>擲回，而其他人會造成<xref:System.NotSupportedException>。 因此，您的程式碼必須攔截所有例外狀況的例外狀況 」 一節所示。  

在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。 不過，.NET Framework 原本就支援一些編碼方式。 如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。 在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。 在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。 

 除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。 如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。  

您也可以提供的值為 0`codepage`引數。 精確的行為取決於是否任何的編碼方式已有可用的註冊<xref:System.Text.EncodingProvider>物件：

- 如果已註冊一或多個編碼提供者，它就會傳回最後一個已註冊的提供者傳回編碼時選擇的編碼方式<xref:System.Text.Encoding.GetEncoding%2A>方法會傳遞`codepage`引數為 0。     

- 在.NET Framework 中，如果沒有編碼提供者已註冊之後，如果<xref:System.Text.CodePagesEncodingProvider>是已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回使用中的字碼頁。

- 在.NET Core，如果有任何已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回<xref:System.Text.UTF8Encoding>編碼方式。

> [!NOTE]
>  ANSI 字碼頁不同的電腦上可能有不同，而且可以變更的單一電腦上，導致資料損毀。 基於這個理由，如果作用中的字碼頁為 ANSI 字碼頁編碼和解碼使用的預設字碼頁資料所傳回`Encoding.GetEncoding(0)`不建議使用。 為了最一致的結果，您應該使用 Unicode，例如 utf-8 （字碼頁 65001） 或 utf-16，而不是特定字碼頁。 
  
 若要取得相關聯的作用中的字碼頁的編碼方式，您可以提供的值為 0`codepage`引數或，如果您的程式碼執行以.NET Framework 在 Windows 桌面上，擷取的值<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>屬性。 若要判斷目前作用中的字碼頁，呼叫 Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)從.NET Framework 在 Windows 桌面上的函式。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。 您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。 比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>方法。  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> 小於零或大於 65535。</exception>
        <exception cref="T:System.ArgumentException">基礎的平台並不支援 <paramref name="codepage" />。</exception>
        <exception cref="T:System.NotSupportedException">基礎的平台並不支援 <paramref name="codepage" />。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">慣用編碼方式的字碼頁名稱。 <see cref="P:System.Text.Encoding.WebName" /> 屬性傳回的任何值都是有效值。 <see cref="T:System.Text.Encoding" /> 類別主題中表格的「名稱」欄會列出可能值。</param>
        <param name="encoderFallback">物件，該物件會在無法以目前編碼方式將字元編碼時提供錯誤處理程序。</param>
        <param name="decoderFallback">物件，該物件會在無法以目前編碼方式將位元組序列解碼時提供錯誤處理程序。</param>
        <summary>傳回與指定字碼頁名稱相關聯的編碼方式。 參數會針對無法編碼的字元以及無法解碼的位元組序列指定錯誤處理常式。</summary>
        <returns>與指定字碼頁相關聯的編碼方式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。 不過，.NET Framework 原本就支援一些編碼方式。 如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。 在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。 在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。 

 除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。 如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。  
  
> [!NOTE]
>  ANSI 字碼頁不同的電腦上可能有不同，而且可以變更的單一電腦上，導致資料損毀。 為了最一致的結果，您應該使用 Unicode 編碼，例如 utf-8 （字碼頁 65001） 或 utf-16，而不特定字碼頁。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。 您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。 比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。  
  
   
  
## Examples  
 下列範例示範<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>方法。  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的字碼頁名稱。  
  
-或- 
主要平台尚不支援以 <paramref name="name" /> 所指示的字碼頁。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回包含所有編碼方式的陣列。</summary>
        <returns>包含所有編碼方式的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會傳回一份支援的編碼，唯一辨別依字碼頁。 如需列出支援的編碼方式的表格，請參閱<xref:System.Text.Encoding>類別主題。  
  
> [!NOTE]
>  支援的編碼所傳回的清單<xref:System.Text.Encoding.GetEncodings%2A>方法不包含任何額外的編碼方式，可由任何<xref:System.Text.EncodingProvider>呼叫已登錄的實作<xref:System.Text.Encoding.RegisterProvider%2A>方法。  
  
 在.NET Framework 中，編碼 50220 和 50222 會為兩者相關聯的名稱"iso-2022年-jp"，但並不相同。 編碼 50220 將半形片假名字元轉換為全形片假名字元，而編碼 50222 使用 shift 鍵輸入/shift out 序列來編碼半形片假名字元。 編碼 50222 的顯示名稱是 「 日文 (JIS-Povolen 1 bajt Kana-因此 / SI) 」 以區分它與編碼 50220，具有顯示名稱 「 日文 (JIS) 」。  
  
 如果您要求編碼名稱"iso-2022年-jp"50220 的編碼方式在.NET Framework 傳回。 不過，適用於您的應用程式的編碼方式取決於半形片假名字元的慣用的處理方式。  
  
 若要取得特定的編碼方式，您應該使用<xref:System.Text.Encoding.GetEncoding%2A>方法。  
  
 <xref:System.Text.Encoding.GetEncodings%2A> 有時候用來顯示給使用者的檔案中的編碼方式清單**將儲存為** 對話方塊。 不過，許多非 Unicode 編碼都是不完整，而且轉譯到許多字元"？"，或在不同的平台上有稍微不同的行為。 請考慮使用 utf-8 或 utf-16 為預設值。  
  
   
  
## Examples  
 下列範例會檢查每個編碼的布林屬性值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前執行個體的雜湊碼。</summary>
        <returns>目前執行個體的雜湊碼。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">要編碼的字元數。</param>
        <summary>在衍生類別中覆寫時，計算編碼指定的字元數所產生的最大位元組數目。</summary>
        <returns>編碼指定字元數所產生的最大位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount`參數實際上會指定數目<xref:System.Char>代表 Unicode 字元編碼，因為.NET 在內部使用 utf-16 來代表 Unicode 字元的物件。 因此，大部分的 Unicode 字元可以表示逐一<xref:System.Char>物件，但由 surrogate 字組，例如，將 Unicode 字元需要兩個<xref:System.Char>物件。  
  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>來儲存產生的位元組，您應該使用<xref:System.Text.Encoding.GetByteCount%2A>方法。 若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。 <xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 擷取最壞情況的數目，包括目前所選最壞的情況<xref:System.Text.EncoderFallback>。 如果後援會選擇使用可能很大的字串、<xref:System.Text.Encoding.GetMaxByteCount%2A>擷取大數值，特別是在最壞的情況的編碼方式涉及切換模式，針對每個字元的情況下。 比方說，這種情形的 ISO-2022年-JP。 如需詳細資訊，請參閱部落格文章 「[Encoding.GetMaxByteCount() 與 Encoding.GetMaxCharCount() 是什麼？](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 在大部分情況下，這個方法會擷取對小型字串合理的值。 針對大型的字串，您可能選擇使用極大的緩衝區，更合理的緩衝區太小而時，在罕見的情況下攔截錯誤。 您也可以在不同的方法使用，請考慮<xref:System.Text.Encoding.GetByteCount%2A>或<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>。  
  
 當使用<xref:System.Text.Encoding.GetMaxByteCount%2A>，您應該配置輸出緩衝區的輸入緩衝區的大小上限為基礎。 如果輸出緩衝區的大小限制，您可能會使用<xref:System.Text.Encoding.Convert%2A>方法。  
  
 請注意，<xref:System.Text.Encoding.GetMaxByteCount%2A>會考量先前的解碼器作業可能剩餘的 surrogate。 解碼器，因為傳遞至方法的值為 1 會擷取到 2，代表單一位元組編碼，例如 ASCII。 您應該使用<xref:System.Text.ASCIIEncoding.IsSingleByte%2A>如果這項資訊是必要的屬性。  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 不一定是相同的值`N* GetMaxByteCount(1)`。  
  
   
  
## Examples  
 下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> 小於零。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</exception>
        <block subset="none" type="overrides">
          <para>所有<see cref="T:System.Text.Encoding" />實作必須保證如果緩衝區的大小根據此方法的計算結果，會發生任何緩衝區溢位例外狀況。</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">要解碼的位元組數。</param>
        <summary>在衍生類別中覆寫時，計算解碼指定的位元組數目所產生的最大字元數目。</summary>
        <returns>解碼指定位元組數所產生的最大字元數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。 若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。 <xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 擷取最壞情況的數目，包括目前所選最壞的情況<xref:System.Text.DecoderFallback>。 如果後援會選擇使用可能很大的字串、<xref:System.Text.Encoding.GetMaxCharCount%2A>擷取較大的值。  
  
 在大部分情況下，這個方法會擷取對小型字串合理的數字。 針對大型的字串，您可能選擇使用非常大的緩衝區，在罕見的情況下，更合理的緩衝區太小而攔截錯誤。 您也可以在不同的方法使用，請考慮<xref:System.Text.Encoding.GetCharCount%2A>或<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 沒有任何關聯<xref:System.Text.Encoding.GetBytes%2A>。 如果您需要類似的函式，以搭配<xref:System.Text.Encoding.GetBytes%2A>，您應該使用<xref:System.Text.Encoding.GetMaxByteCount%2A>。  
  
 當使用<xref:System.Text.Encoding.GetMaxCharCount%2A>，您應該配置輸出緩衝區的輸入緩衝區的大小上限為基礎。 如果輸出緩衝區的大小限制，您可能會使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法。  
  
 請注意，<xref:System.Text.Encoding.GetMaxCharCount%2A>會考量先前的編碼器作業的剩餘位元組最壞的情況。 對於大部分的字碼頁，0 的值傳遞至這個方法會擷取大於或等於 1 的值。  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 不一定是相同的值`N* GetMaxCharCount(1)`。  
  
   
  
## Examples  
 下列範例會將字串編碼成位元組陣列，並接著將位元組解碼成字元陣列。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> 小於零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <block subset="none" type="overrides">
          <para>所有<see cref="T:System.Text.Encoding" />實作必須保證如果緩衝區的大小根據此方法的計算結果，會發生任何緩衝區溢位例外狀況。</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中覆寫時，傳回可指定所用編碼方式的位元組序列。</summary>
        <returns>位元組陣列，包含可指定所用編碼方式的位元組序列。  
  
-或- 
如果不需要前序編碼，則位元組陣列的長度為零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 （選擇性）<xref:System.Text.Encoding>物件所提供的是可以加在編碼程序所產生的位元組序列的位元組陣列的前序編碼。 如果前序編碼包含位元組順序標記 （在 Unicode 字碼指標 U + FEFF)，它可以協助判斷位元組順序的轉換格式或 UTF 解碼器。  
  
 Unicode 位元組順序標記 (BOM) （以十六進位方式） 的序列化，如下所示：  
  
-   UTF-8: EF BB BF  
  
-   Utf-16 位元組由大到小位元組順序： FE FF  
  
-   Utf-16 少位元組由小到大位元組順序： FF FE  
  
-   UTF-32 位元組由大到小位元組順序： 00 00 FE FF  
  
-   UTF-32 少位元組由小到大位元組順序： FF FE 00 00  
  
 因為它提供幾乎特定編碼的檔案，否則為已中斷參考的識別碼，您應該使用 BOM，<xref:System.Text.Encoding>物件，例如，未標記，或不正確標記 web 資料或儲存時企業的隨機文字檔案不提供支援有國際考量或其他資料。 如果資料的一致且正確地標示，最好是 utf-8 或 utf-16，可能會避免通常使用者的問題。  
  
 提供編碼類型的標準，BOM 是多餘的。 不過，它可以用來傳送正確的編碼方式標頭的伺服器。 或者，它可用來當做後援萬一編碼遺失時。  
  
 有一些缺點，若要使用 BOM。 比方說，了解如何限制使用 BOM 的資料庫欄位可以是很困難。 串連的檔案可以也會是問題，比方說，當檔案會合併，例如某種程度的不必要的字元可以得到中間的資料。 儘管幾個缺點，不過，BOM 是強烈建議使用。  
  
 如需有關位元組順序和位元組順序標記的詳細資訊，請參閱 Unicode Standard > [Unicode 首頁](https://go.microsoft.com/fwlink/?LinkId=37123)。  
  
> [!CAUTION]
>  若要確保正確解碼的編碼的位元組，您應該前置詞與前序編碼的位元組。 不過，大部分的編碼方式不會提供前序編碼。 若要確保正確解碼的編碼的位元組，您應該使用 Unicode 編碼方式，亦即<xref:System.Text.UTF8Encoding>， <xref:System.Text.UnicodeEncoding>，或<xref:System.Text.UTF32Encoding>，與前序編碼。  
  
   
  
## Examples  
 下列範例會判斷前序編碼為基礎的編碼方式的位元組順序。  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，將位元組序列解碼成字串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <summary>在衍生類別中覆寫時，將指定位元組陣列中的所有位元組解碼成字串。</summary>
        <returns>字串，包含將指定之位元組序列解碼的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>所傳回的物件<xref:System.Text.Encoding.GetDecoder%2A>衍生方法攝影類別。  
  
 請參閱 < 備註 > 一節的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解碼技術和考量的討論的參考主題。  
  
 請注意，精確的行為<xref:System.Text.Encoding.GetString%2A>特定的方法<xref:System.Text.Encoding>實作取決於該定義的後援策略<xref:System.Text.Encoding>物件。 如需詳細資訊，請參閱 「 選擇後援策略 」 一節[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)主題。  
  
   
  
## Examples  
 下列範例會將 utf-8 編碼字串讀取所表示的二進位檔案<xref:System.IO.FileStream>物件。 對於小於 2048 個位元組的檔案，它會讀取整個檔案的內容至位元組陣列和呼叫<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29>方法進行解碼。 較大的檔案，它 2,048 個位元組一次讀取的位元組陣列，呼叫<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以判斷的字元數包含陣列中，然後呼叫<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>方法進行解碼。  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 此範例會使用下列文字，應儲存至名為 Utf8Example.txt utf-8 編碼檔案。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">位元組陣列包含無效的 Unicode 字碼指標。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">位元組陣列的指標。</param>
        <param name="byteCount">要解碼的位元組數。</param>
        <summary>在衍生類別中覆寫時，將指定位址開頭之指定數目的位元組解碼為字串。</summary>
        <returns>字串，包含將指定之位元組序列解碼的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A>方法設計用來最佳化效能，當您有原生指標的位元組陣列。 而不是建立受管理的位元組陣列，並再將其解碼，您可以改為呼叫這個方法而不需要建立任何中繼物件。  
  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>所傳回的物件<xref:System.Text.Encoding.GetDecoder%2A>衍生方法攝影類別。  
  
 請參閱 < 備註 > 一節的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解碼技術和考量的討論的參考主題。  
  
 請注意，精確的行為<xref:System.Text.Encoding.GetString%2A>特定的方法<xref:System.Text.Encoding>實作取決於該定義的後援策略<xref:System.Text.Encoding>物件。 如需詳細資訊，請參閱 「 選擇後援策略 」 一節[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)主題。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 是 null 指標。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> 小於零。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">包含要解碼之位元組序列的位元組陣列。</param>
        <param name="index">要解碼的第一個位元組索引。</param>
        <param name="count">要解碼的位元組數。</param>
        <summary>在衍生類別中覆寫時，將指定位元組陣列中的位元組序列解碼成字串。</summary>
        <returns>字串，包含將指定之位元組序列解碼的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。  
  
 請參閱 < 備註 > 一節的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解碼技術和考量的討論的參考主題。  
  
   
  
## Examples  
 下列範例會將 utf-8 編碼字串讀取所表示的二進位檔案<xref:System.IO.FileStream>物件。 對於小於 2048 個位元組的檔案，它會讀取整個檔案的內容至位元組陣列和呼叫<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法進行解碼。 較大的檔案，它 2,048 個位元組一次讀取的位元組陣列，呼叫<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以判斷的字元數包含陣列中，然後呼叫<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>方法進行解碼。  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 此範例會使用下列文字，應儲存至名為 Utf8Example.txt utf-8 編碼檔案。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">位元組陣列包含無效的 Unicode 字碼指標。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小於零。  
  
-或- 
 <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)) 
-和- 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得可以與郵件代理程式標頭標籤一起使用的目前編碼方式名稱。</summary>
        <value>目前 <see cref="T:System.Text.Encoding" /> 的名稱，與郵件代理程式標頭標記一起使用。  
  
-或- 
如果無法使用目前的 <see cref="T:System.Text.Encoding" />，則為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您需要的標頭名稱的編碼方式，您應該呼叫<xref:System.Text.Encoding.GetEncoding%2A>方法使用<xref:System.Text.Encoding.HeaderName%2A>屬性。 通常方法會擷取不同的呼叫中提供的測試編碼所用的編碼。 通常只有電子郵件應用程式必須擷取這類的編碼方式。  
  
 在某些情況下，值<xref:System.Text.Encoding.BodyName%2A>屬性會對應至國際標準，可定義該編碼。 這並不表示實作符合該標準的完整。  
  
 請注意，<xref:System.Text.Encoding.WebName%2A>傳回要用來描述的編碼方式名稱。 <xref:System.Text.Encoding.HeaderName%2A>屬性會定義不同的編碼方式，可能比較適合進行電子郵件應用程式，例如。 不過，不建議使用這個屬性來定義的編碼方式。  
  
   
  
## Examples  
 下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得值，指出目前的編碼方式是否永遠都是正規化。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得值，指出目前的編碼方式是否永遠都是使用預設的正規化表單進行正規化。</summary>
        <returns>如果目前的 <see cref="T:System.Text.Encoding" /> 永遠都是正規化，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設的正規化表單是<xref:System.Text.NormalizationForm.FormC>，它會使用完整標準分解進行，如果可能的話後面的主要複合，序列取代。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">其中一個 <see cref="T:System.Text.NormalizationForm" /> 值。</param>
        <summary>在衍生類別中覆寫時取得值，指出目前的編碼方式是否永遠都是使用指定的正規化表單進行正規化。</summary>
        <returns>如果目前的 <see langword="true" /> 物件一律使用指定的 <see cref="T:System.Text.Encoding" /> 值進行正規化，則為 <see cref="T:System.Text.NormalizationForm" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設的正規化表單是<xref:System.Text.NormalizationForm.FormC>，它會使用完整標準分解進行，如果可能的話後面的主要複合，序列取代。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得值，指出瀏覽器用戶端是否可以使用目前的編碼方式來顯示內容。</summary>
        <value>如果瀏覽器用戶端可以使用目前的 <see cref="T:System.Text.Encoding" /> 來顯示內容，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查每個編碼的布林屬性值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得值，指出瀏覽器用戶端是否可以使用目前的編碼方式來儲存內容。</summary>
        <value>如果瀏覽器用戶端可以使用目前的 <see cref="T:System.Text.Encoding" /> 來儲存內容，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查每個編碼的布林屬性值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得值，指出郵件和新聞用戶端是否可以使用目前的編碼方式來顯示內容。</summary>
        <value>如果郵件和新聞用戶端可以使用目前的 <see cref="T:System.Text.Encoding" /> 來顯示內容，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查每個編碼的布林屬性值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得值，指出郵件和新聞用戶端是否可以使用目前的編碼方式來儲存內容。</summary>
        <value>如果郵件和新聞用戶端可以使用目前的 <see langword="true" /> 來儲存內容，則為 <see cref="T:System.Text.Encoding" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會檢查每個編碼的布林屬性值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得值，指出目前的編碼方式是否為唯讀。</summary>
        <value>如果目前 <see langword="true" /> 是唯讀，則為 <see cref="T:System.Text.Encoding" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，取得值，指出目前的編碼方式是否使用單一位元組字碼指標。</summary>
        <value>如果目前的 <see langword="true" /> 使用單一位元組字碼指標，則為 <see cref="T:System.Text.Encoding" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 單一位元組編碼，例如<xref:System.Text.ASCIIEncoding>，此屬性會擷取`true`。  
  
> [!CAUTION]
>  您應該要特別小心，在您的應用程式未使用的值<xref:System.Text.Encoding.IsSingleByte%2A>。 編碼方式將繼續假設可能仍有誤。 比方說，Windows 1252 其值為`true`針對<xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>，但 Encoding.GetMaxByteCount(1) 傳回 2。 這是因為方法會考量先前的解碼器作業可能剩餘的 surrogate。  
  
   
  
## Examples  
 下列範例會檢查每個編碼的布林屬性值。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <see cref="T:System.Text.EncodingProvider" /> 的子類別，提供其他字元編碼方式的存取權。</param>
        <summary>註冊編碼提供者。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A>方法可讓您註冊類別，衍生自<xref:System.Text.EncodingProvider>讓字元不會不支援這些平台上可用的編碼方式。 一旦註冊編碼提供者，可以擷取它所支援的編碼方式呼叫任何<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>多載。 如果有多個編碼提供者，<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>方法會嘗試擷取指定的編碼方式，就從開頭為最近註冊的每個提供者。

使用登錄其編碼提供者<xref:System.Text.Encoding.RegisterProvider%2A>方法也會修改的行為[Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)和[EncodingProvider.GetEncoding (Int32，EncoderFallback，DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))方法時傳遞的引數`0`:

- 如果已註冊的提供者<xref:System.Text.CodePagesEncodingProvider>，此方法會傳回 Windows 作業系統上執行時，符合系統作用中的字碼頁的編碼方式。

- 自訂編碼提供者可以選擇哪一種編碼傳回當任一<xref:System.Text.Encoding.GetEncoding%2A>方法多載會傳遞的引數`0`。 提供者也可以選擇不會傳回所需要的編碼方式<xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType>方法會傳回`null`。 
  
從.NET Framework 4.6 開始，.NET Framework 包含一個編碼提供者， <xref:System.Text.CodePagesEncodingProvider>，如此可用編碼，會出現在完整的.NET Framework，但不適用於通用 Windows 平台。 根據預設，通用 Windows 平台僅支援 Unicode 編碼方式、 ASCII 和字碼頁 28591。  
  
 如果相同的編碼提供者會使用多個呼叫<xref:System.Text.Encoding.RegisterProvider%2A>的第一個方法呼叫的方法，註冊提供者。 後續呼叫都會被忽略。  
  
 如果<xref:System.Text.Encoding.RegisterProvider%2A>註冊處理相同的編碼方式的多個提供者會呼叫方法，最後一個已註冊的提供者是用於所有的編碼和解碼作業。 任何先前已註冊的提供者會被忽略。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以位元組由小到大位元組順序取得 UTF-16 格式的編碼方式。</summary>
        <value>UTF-16 格式的編碼方式，使用位元組由小到大的位元組順序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支援的.NET，並討論使用編碼的 Unicode 編碼的相關資訊，請參閱[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。  
  
 <xref:System.Text.UnicodeEncoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。 它會使用取代後援來取代無法編碼的每個字串和無法解碼的每個位元組以問號 ("？") 字元。 相反地，您可以呼叫<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化由小到大<xref:System.Text.UnicodeEncoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以位元組由小到大位元組順序取得 UTF-32 格式的編碼方式。</summary>
        <value>UTF-32 格式的編碼物件，使用位元組由小到大的位元組順序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。 它會使用取代後援，來取代 Unicode REPLACEMENT CHARACTER (U + 7C94:FFFE) 中的每一個無法編碼的字串和無法解碼的每個位元組。 相反地，您可以呼叫<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化<xref:System.Text.UTF32Encoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 如需少位元組由小到大位元組順序的討論，請參閱<xref:System.Text.Encoding>類別主題。  
  
 支援的.NET，並討論使用編碼的 Unicode 編碼的相關資訊，請參閱[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。  
  
   
  
## Examples  
 下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 UTF-7 格式的編碼方式。</summary>
        <value>UTF-7 格式的編碼方式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在過去有已限制為 7 個位元，例如 NNTP 和某些電子郵件應用程式的環境中，主要會使用 utf-7 編碼。 強固性和安全性問題，因為您不應該使用 UTF7 8 位元環境中的編碼方式，utf-8 編碼方式可以使用。  
  
   
  
## Examples  
 下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 UTF-8 格式的編碼方式。</summary>
        <value>UTF-8 格式的編碼方式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回<xref:System.Text.UTF8Encoding>物件可將 Unicode （UTF 16 編碼） 的字元編碼為一到四個位元組，每個字元序列，並會解碼為 Unicode （UTF 16 編碼） 個字元的 UTF-8 編碼的位元組陣列。 支援的.NET，並討論使用編碼的 Unicode 字元編碼的相關資訊，請參閱[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。  
  
 <xref:System.Text.UTF8Encoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。  
  
-   它會傳回<xref:System.Text.UTF8Encoding>提供 Unicode 位元組順序標記 (BOM) 的物件。 若要具現化並不提供 BOM UTF8 編碼方式，呼叫的任何多載<xref:System.Text.UTF8Encoding.%23ctor%2A>建構函式。  
  
-   它會傳回<xref:System.Text.UTF8Encoding>會使用取代後援，以問號取代無法編碼的每個字串和無法解碼的每個位元組的物件 ("？") 字元。 相反地，您可以呼叫<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化<xref:System.Text.UTF8Encoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 下列範例會定義陣列，其中包含下列字元：  
  
-   拉丁文小寫字母 Z (U + 007A)  
  
-   拉丁文小型字母 (U + 0061)  
  
-   結合音符 (U + 0306)  
  
-   拉丁文小寫字母 AE 與嚴重 (U + 01FD)  
  
-   希臘文小寫字母 BETA (U + 03B2)  
  
-   Surrogate 字組 (範圍從 U+D800 U + DD54) 形成希臘 ACROPHONIC ATTIC 一個千位 STATERS (U + 10154)。  
  
 它會顯示每個字元的 utf-16 程式碼單位，並決定 utf-8 編碼器編碼的字元陣列所需的位元組數目。 然後將字元編碼，並顯示結果的 UTF-8 編碼位元組。  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">了解編碼</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，若要取得目前的編碼方式，請取得向 Internet Assigned Numbers Authority (IANA) 註冊的名稱。</summary>
        <value>目前 <see cref="T:System.Text.Encoding" /> 的 IANA 名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A>屬性是相同<xref:System.Text.EncodingInfo.Name%2A>屬性。  
  
 請注意，<xref:System.Text.Encoding.WebName%2A>傳回 IANA 註冊名稱的編碼方式。 當其值為一項標準的名稱時，編碼方式的實作可能會不符合該標準的完整。 <xref:System.Text.Encoding.HeaderName%2A>屬性會定義不同的編碼方式，可能比較適合進行電子郵件標頭。 不過，大部分的應用程式應該使用<xref:System.Text.Encoding.WebName%2A>改。  
  
 如需有關 IANA 的詳細資訊，請移至[www.iana.org](https://www.iana.org/)。  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType>等同<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>所傳回<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>。 部分網站名稱會在重複的項目;請參閱的 < 備註 ><xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>如需詳細資訊。  
  
   
  
## Examples  
 下列範例會加入<xref:System.Text.Encoding.WebName%2A>HTML 標頭中。  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。 它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在衍生類別中覆寫時，請取得最能符合目前編碼方式的 Windows 作業系統字碼頁。</summary>
        <value>最能符合目前 <see cref="T:System.Text.Encoding" /> 的 Windows 作業系統字碼頁。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供這個屬性是與 Windows 多語系 (MLang) Api 相容性，例如判斷字型系列。 全球化，使用 Unicode 編碼方式的其中一個建議改為。 也建議使用<xref:System.Text.Encoding.WebName%2A>而不是<xref:System.Text.Encoding.WindowsCodePage%2A>來識別的字碼頁。  
  
   
  
## Examples  
 下列範例會決定最能符合每個編碼 Windows 字碼頁。  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>