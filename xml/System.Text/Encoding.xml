<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d95c61143e58621b3de218589a87909c382856a6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39903181" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="d4c2c-101">表示字元編碼方式。</span>
      <span class="sxs-lookup">
        <span data-stu-id="d4c2c-101">Represents a character encoding.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-102">編碼是將一組 Unicode 字元轉換成位元組序列的處理程序。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="d4c2c-103">相反地，解碼則是將編碼的位元組序列轉換成一組 Unicode 字元的程序。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-103">In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span> <span data-ttu-id="d4c2c-104">如需 Unicode 轉換格式 (UTFs) 和其他支援的編碼資訊<xref:System.Text.Encoding>，請參閱 < [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-104">For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="d4c2c-105">請注意，<xref:System.Text.Encoding>旨在對 Unicode 字元，而不是任意二進位資料的詳細資訊，例如位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-105">Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="d4c2c-106">如果您必須將任意的二進位資料編碼成文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-106">If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d4c2c-107">.NET 提供的下列實作<xref:System.Text.Encoding>類別，以支援目前的 Unicode 編碼方式和其他編碼：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-107">.NET provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:</span></span>  
  
-   <span data-ttu-id="d4c2c-108"><xref:System.Text.ASCIIEncoding> 將 Unicode 字元編碼為單一 7 位元 ASCII 字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-108"><xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters.</span></span> <span data-ttu-id="d4c2c-109">這個編碼僅支援之間的字元值 U + 0000 和 U + 007F。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-109">This encoding only supports character values between U+0000 and U+007F.</span></span> <span data-ttu-id="d4c2c-110">已核取 20127 的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-110">Code page 20127.</span></span> <span data-ttu-id="d4c2c-111">也可透過<xref:System.Text.Encoding.ASCII%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-111">Also available through the <xref:System.Text.Encoding.ASCII%2A> property.</span></span>  
  
-   <span data-ttu-id="d4c2c-112"><xref:System.Text.UTF7Encoding> 使用 utf-7 編碼的 Unicode 字元編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-112"><xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding.</span></span> <span data-ttu-id="d4c2c-113">這種編碼方式支援所有 Unicode 字元值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-113">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="d4c2c-114">65000 的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-114">Code page 65000.</span></span> <span data-ttu-id="d4c2c-115">也可透過<xref:System.Text.Encoding.UTF7%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-115">Also available through the <xref:System.Text.Encoding.UTF7%2A> property.</span></span>  
  
-   <span data-ttu-id="d4c2c-116"><xref:System.Text.UTF8Encoding> 使用 utf-8 編碼的 Unicode 字元編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-116"><xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding.</span></span> <span data-ttu-id="d4c2c-117">這種編碼方式支援所有 Unicode 字元值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-117">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="d4c2c-118">字碼頁 65001。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-118">Code page 65001.</span></span> <span data-ttu-id="d4c2c-119">也可透過<xref:System.Text.Encoding.UTF8%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-119">Also available through the <xref:System.Text.Encoding.UTF8%2A> property.</span></span>  
  
-   <span data-ttu-id="d4c2c-120"><xref:System.Text.UnicodeEncoding> 使用 utf-16 編碼的 Unicode 字元編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-120"><xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding.</span></span> <span data-ttu-id="d4c2c-121">支援這兩個小到小，而且其大小位元組由小到大位元組順序。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-121">Both little endian and big endian byte orders are supported.</span></span> <span data-ttu-id="d4c2c-122">也可透過<xref:System.Text.Encoding.Unicode%2A>屬性和<xref:System.Text.Encoding.BigEndianUnicode%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-122">Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.</span></span>  
  
-   <span data-ttu-id="d4c2c-123"><xref:System.Text.UTF32Encoding> 使用 UTF-32 編碼的 Unicode 字元編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-123"><xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding.</span></span> <span data-ttu-id="d4c2c-124">同時位元組由小到大 （字碼頁 12000） 和 big endian （字碼頁 12001） 位元組會支援順序。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-124">Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</span></span> <span data-ttu-id="d4c2c-125">也可透過<xref:System.Text.Encoding.UTF32%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-125">Also available through the <xref:System.Text.Encoding.UTF32%2A> property.</span></span>  
  
 <span data-ttu-id="d4c2c-126"><xref:System.Text.Encoding>類別主要是以不同的編碼方式和 Unicode 間轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-126">The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode.</span></span> <span data-ttu-id="d4c2c-127">通常的其中一個衍生的 Unicode 類別是您的應用程式的正確選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-127">Often one of the derived Unicode classes is the correct choice for your app.</span></span>  
  
 <span data-ttu-id="d4c2c-128">使用<xref:System.Text.Encoding.GetEncoding%2A>方法，以取得其他編碼，並呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得一份所有編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-128">Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.</span></span>  
  
 <span data-ttu-id="d4c2c-129">下表列出.NET Framework 和.NET Core 所支援的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-129">The following table lists the encodings supported by .NET Framework and .NET Core.</span></span> <span data-ttu-id="d4c2c-130">它會列出每個編碼的字碼頁編號和編碼方式的值<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>和<xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-130">It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="d4c2c-131">中的核取記號 **.NET Framework 支援**並 **.NET Core 支援**資料行表示.NET 實作，不論基礎平台原生支援的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-131">A check mark in the **.NET Framework support** and **.NET Core support** columns indicates that the code page is natively supported by that .NET implementation, regardless of the underlying platform.</span></span> <span data-ttu-id="d4c2c-132">.NET Framework 中，表所列的其他編碼的可用性取決於作業系統。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-132">For .NET Framework, the availability of other encodings listed in the table depends on the operating system.</span></span> <span data-ttu-id="d4c2c-133">適用於.NET Core，其他編碼，則可使用<xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType>類別，或藉由衍生自<xref:System.Text.EncodingProvider?displayProperty=nameWithType>類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-133">For .NET Core, other encodings are available by using the <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> class or by deriving from the <xref:System.Text.EncodingProvider?displayProperty=nameWithType> class.</span></span>  

> [!NOTE]
> <span data-ttu-id="d4c2c-134">字碼頁的<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>屬性會對應至國際標準不一定符合該標準的完整。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-134">Code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> property corresponds to an international standard do not necessarily comply in full with that standard.</span></span> 

|<span data-ttu-id="d4c2c-135">字碼頁</span><span class="sxs-lookup"><span data-stu-id="d4c2c-135">Code page</span></span>|<span data-ttu-id="d4c2c-136">名稱</span><span class="sxs-lookup"><span data-stu-id="d4c2c-136">Name</span></span>|<span data-ttu-id="d4c2c-137">顯示名稱</span><span class="sxs-lookup"><span data-stu-id="d4c2c-137">Display name</span></span>|<span data-ttu-id="d4c2c-138">.NET framework 支援</span><span class="sxs-lookup"><span data-stu-id="d4c2c-138">.NET Framework support</span></span>| <span data-ttu-id="d4c2c-139">.NET core 支援</span><span class="sxs-lookup"><span data-stu-id="d4c2c-139">.NET Core support</span></span> | 
|---------|----|------------|----------------------|-------------------|    
|<span data-ttu-id="d4c2c-140">37</span><span class="sxs-lookup"><span data-stu-id="d4c2c-140">37</span></span>|<span data-ttu-id="d4c2c-141">IBM037</span><span class="sxs-lookup"><span data-stu-id="d4c2c-141">IBM037</span></span>|<span data-ttu-id="d4c2c-142">IBM EBCDIC （美國和加拿大）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-142">IBM EBCDIC (US-Canada)</span></span>|||  
|<span data-ttu-id="d4c2c-143">437</span><span class="sxs-lookup"><span data-stu-id="d4c2c-143">437</span></span>|<span data-ttu-id="d4c2c-144">IBM437</span><span class="sxs-lookup"><span data-stu-id="d4c2c-144">IBM437</span></span>|<span data-ttu-id="d4c2c-145">OEM-Usa</span><span class="sxs-lookup"><span data-stu-id="d4c2c-145">OEM United States</span></span>|||  
|<span data-ttu-id="d4c2c-146">500</span><span class="sxs-lookup"><span data-stu-id="d4c2c-146">500</span></span>|<span data-ttu-id="d4c2c-147">IBM500</span><span class="sxs-lookup"><span data-stu-id="d4c2c-147">IBM500</span></span>|<span data-ttu-id="d4c2c-148">IBM EBCDIC （國際）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-148">IBM EBCDIC (International)</span></span>|||  
|<span data-ttu-id="d4c2c-149">708</span><span class="sxs-lookup"><span data-stu-id="d4c2c-149">708</span></span>|<span data-ttu-id="d4c2c-150">ASMO-708</span><span class="sxs-lookup"><span data-stu-id="d4c2c-150">ASMO-708</span></span>|<span data-ttu-id="d4c2c-151">阿拉伯文 (ASMO 708)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-151">Arabic (ASMO 708)</span></span>|||  
|<span data-ttu-id="d4c2c-152">720</span><span class="sxs-lookup"><span data-stu-id="d4c2c-152">720</span></span>|<span data-ttu-id="d4c2c-153">DOS-720</span><span class="sxs-lookup"><span data-stu-id="d4c2c-153">DOS-720</span></span>|<span data-ttu-id="d4c2c-154">阿拉伯文 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-154">Arabic (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-155">737</span><span class="sxs-lookup"><span data-stu-id="d4c2c-155">737</span></span>|<span data-ttu-id="d4c2c-156">ibm737</span><span class="sxs-lookup"><span data-stu-id="d4c2c-156">ibm737</span></span>|<span data-ttu-id="d4c2c-157">希臘文 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-157">Greek (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-158">775</span><span class="sxs-lookup"><span data-stu-id="d4c2c-158">775</span></span>|<span data-ttu-id="d4c2c-159">ibm775</span><span class="sxs-lookup"><span data-stu-id="d4c2c-159">ibm775</span></span>|<span data-ttu-id="d4c2c-160">波羅的海文 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-160">Baltic (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-161">850</span><span class="sxs-lookup"><span data-stu-id="d4c2c-161">850</span></span>|<span data-ttu-id="d4c2c-162">ibm850</span><span class="sxs-lookup"><span data-stu-id="d4c2c-162">ibm850</span></span>|<span data-ttu-id="d4c2c-163">西歐語系 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-163">Western European (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-164">852</span><span class="sxs-lookup"><span data-stu-id="d4c2c-164">852</span></span>|<span data-ttu-id="d4c2c-165">ibm852</span><span class="sxs-lookup"><span data-stu-id="d4c2c-165">ibm852</span></span>|<span data-ttu-id="d4c2c-166">中歐語系 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-166">Central European (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-167">855</span><span class="sxs-lookup"><span data-stu-id="d4c2c-167">855</span></span>|<span data-ttu-id="d4c2c-168">IBM855</span><span class="sxs-lookup"><span data-stu-id="d4c2c-168">IBM855</span></span>|<span data-ttu-id="d4c2c-169">Cyrilice OEM</span><span class="sxs-lookup"><span data-stu-id="d4c2c-169">OEM Cyrillic</span></span>|||  
|<span data-ttu-id="d4c2c-170">857</span><span class="sxs-lookup"><span data-stu-id="d4c2c-170">857</span></span>|<span data-ttu-id="d4c2c-171">ibm857</span><span class="sxs-lookup"><span data-stu-id="d4c2c-171">ibm857</span></span>|<span data-ttu-id="d4c2c-172">Turečtina (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-172">Turkish (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-173">858</span><span class="sxs-lookup"><span data-stu-id="d4c2c-173">858</span></span>|<span data-ttu-id="d4c2c-174">IBM00858</span><span class="sxs-lookup"><span data-stu-id="d4c2c-174">IBM00858</span></span>|<span data-ttu-id="d4c2c-175">OEM 多語系拉丁文 I</span><span class="sxs-lookup"><span data-stu-id="d4c2c-175">OEM Multilingual Latin I</span></span>|||  
|<span data-ttu-id="d4c2c-176">860</span><span class="sxs-lookup"><span data-stu-id="d4c2c-176">860</span></span>|<span data-ttu-id="d4c2c-177">IBM860</span><span class="sxs-lookup"><span data-stu-id="d4c2c-177">IBM860</span></span>|<span data-ttu-id="d4c2c-178">Portugalština (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-178">Portuguese (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-179">861</span><span class="sxs-lookup"><span data-stu-id="d4c2c-179">861</span></span>|<span data-ttu-id="d4c2c-180">ibm861</span><span class="sxs-lookup"><span data-stu-id="d4c2c-180">ibm861</span></span>|<span data-ttu-id="d4c2c-181">Islandština (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-181">Icelandic (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-182">862</span><span class="sxs-lookup"><span data-stu-id="d4c2c-182">862</span></span>|<span data-ttu-id="d4c2c-183">DOS-862</span><span class="sxs-lookup"><span data-stu-id="d4c2c-183">DOS-862</span></span>|<span data-ttu-id="d4c2c-184">Hebrejština (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-184">Hebrew (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-185">863</span><span class="sxs-lookup"><span data-stu-id="d4c2c-185">863</span></span>|<span data-ttu-id="d4c2c-186">IBM863</span><span class="sxs-lookup"><span data-stu-id="d4c2c-186">IBM863</span></span>|<span data-ttu-id="d4c2c-187">加拿大法文 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-187">French Canadian (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-188">864</span><span class="sxs-lookup"><span data-stu-id="d4c2c-188">864</span></span>|<span data-ttu-id="d4c2c-189">IBM864</span><span class="sxs-lookup"><span data-stu-id="d4c2c-189">IBM864</span></span>|<span data-ttu-id="d4c2c-190">阿拉伯文 (864)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-190">Arabic (864)</span></span>|||  
|<span data-ttu-id="d4c2c-191">865</span><span class="sxs-lookup"><span data-stu-id="d4c2c-191">865</span></span>|<span data-ttu-id="d4c2c-192">IBM865</span><span class="sxs-lookup"><span data-stu-id="d4c2c-192">IBM865</span></span>|<span data-ttu-id="d4c2c-193">北歐字母 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-193">Nordic (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-194">866</span><span class="sxs-lookup"><span data-stu-id="d4c2c-194">866</span></span>|<span data-ttu-id="d4c2c-195">cp866</span><span class="sxs-lookup"><span data-stu-id="d4c2c-195">cp866</span></span>|<span data-ttu-id="d4c2c-196">Cyrilice (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-196">Cyrillic (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-197">869</span><span class="sxs-lookup"><span data-stu-id="d4c2c-197">869</span></span>|<span data-ttu-id="d4c2c-198">ibm869</span><span class="sxs-lookup"><span data-stu-id="d4c2c-198">ibm869</span></span>|<span data-ttu-id="d4c2c-199">希臘文，現代 (DOS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-199">Greek, Modern (DOS)</span></span>|||  
|<span data-ttu-id="d4c2c-200">870</span><span class="sxs-lookup"><span data-stu-id="d4c2c-200">870</span></span>|<span data-ttu-id="d4c2c-201">IBM870</span><span class="sxs-lookup"><span data-stu-id="d4c2c-201">IBM870</span></span>|<span data-ttu-id="d4c2c-202">IBM EBCDIC (多語系拉丁文-2)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-202">IBM EBCDIC (Multilingual Latin-2)</span></span>|||  
|<span data-ttu-id="d4c2c-203">874</span><span class="sxs-lookup"><span data-stu-id="d4c2c-203">874</span></span>|<span data-ttu-id="d4c2c-204">windows-874</span><span class="sxs-lookup"><span data-stu-id="d4c2c-204">windows-874</span></span>|<span data-ttu-id="d4c2c-205">Thajština (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-205">Thai (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-206">875</span><span class="sxs-lookup"><span data-stu-id="d4c2c-206">875</span></span>|<span data-ttu-id="d4c2c-207">cp875</span><span class="sxs-lookup"><span data-stu-id="d4c2c-207">cp875</span></span>|<span data-ttu-id="d4c2c-208">IBM EBCDIC （希臘文現代）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-208">IBM EBCDIC (Greek Modern)</span></span>|||  
|<span data-ttu-id="d4c2c-209">932</span><span class="sxs-lookup"><span data-stu-id="d4c2c-209">932</span></span>|<span data-ttu-id="d4c2c-210">shift_jis</span><span class="sxs-lookup"><span data-stu-id="d4c2c-210">shift_jis</span></span>|<span data-ttu-id="d4c2c-211">日文 (SHIFT-JIS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-211">Japanese (Shift-JIS)</span></span>|||  
|<span data-ttu-id="d4c2c-212">936</span><span class="sxs-lookup"><span data-stu-id="d4c2c-212">936</span></span>|<span data-ttu-id="d4c2c-213">gb2312</span><span class="sxs-lookup"><span data-stu-id="d4c2c-213">gb2312</span></span>|<span data-ttu-id="d4c2c-214">簡體中文 (GB2312)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-214">Chinese Simplified (GB2312)</span></span>|<span data-ttu-id="d4c2c-215">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-215">✓</span></span>||  
|<span data-ttu-id="d4c2c-216">949</span><span class="sxs-lookup"><span data-stu-id="d4c2c-216">949</span></span>|<span data-ttu-id="d4c2c-217">ks_c_5601-1987</span><span class="sxs-lookup"><span data-stu-id="d4c2c-217">ks_c_5601-1987</span></span>|<span data-ttu-id="d4c2c-218">韓文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-218">Korean</span></span>|||  
|<span data-ttu-id="d4c2c-219">950</span><span class="sxs-lookup"><span data-stu-id="d4c2c-219">950</span></span>|<span data-ttu-id="d4c2c-220">big5</span><span class="sxs-lookup"><span data-stu-id="d4c2c-220">big5</span></span>|<span data-ttu-id="d4c2c-221">繁體中文 (Big5)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-221">Chinese Traditional (Big5)</span></span>|||  
|<span data-ttu-id="d4c2c-222">1026</span><span class="sxs-lookup"><span data-stu-id="d4c2c-222">1026</span></span>|<span data-ttu-id="d4c2c-223">IBM1026</span><span class="sxs-lookup"><span data-stu-id="d4c2c-223">IBM1026</span></span>|<span data-ttu-id="d4c2c-224">IBM EBCDIC (Turečtina-Latin 5)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-224">IBM EBCDIC (Turkish Latin-5)</span></span>|||  
|<span data-ttu-id="d4c2c-225">1047</span><span class="sxs-lookup"><span data-stu-id="d4c2c-225">1047</span></span>|<span data-ttu-id="d4c2c-226">IBM01047</span><span class="sxs-lookup"><span data-stu-id="d4c2c-226">IBM01047</span></span>|<span data-ttu-id="d4c2c-227">IBM Latin 1</span><span class="sxs-lookup"><span data-stu-id="d4c2c-227">IBM Latin-1</span></span>|||  
|<span data-ttu-id="d4c2c-228">1140</span><span class="sxs-lookup"><span data-stu-id="d4c2c-228">1140</span></span>|<span data-ttu-id="d4c2c-229">IBM01140</span><span class="sxs-lookup"><span data-stu-id="d4c2c-229">IBM01140</span></span>|<span data-ttu-id="d4c2c-230">IBM EBCDIC （美國-加拿大-歐洲）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-230">IBM EBCDIC (US-Canada-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-231">1141</span><span class="sxs-lookup"><span data-stu-id="d4c2c-231">1141</span></span>|<span data-ttu-id="d4c2c-232">IBM01141</span><span class="sxs-lookup"><span data-stu-id="d4c2c-232">IBM01141</span></span>|<span data-ttu-id="d4c2c-233">IBM EBCDIC (Německo-Euro)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-233">IBM EBCDIC (Germany-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-234">1142</span><span class="sxs-lookup"><span data-stu-id="d4c2c-234">1142</span></span>|<span data-ttu-id="d4c2c-235">IBM01142</span><span class="sxs-lookup"><span data-stu-id="d4c2c-235">IBM01142</span></span>|<span data-ttu-id="d4c2c-236">IBM EBCDIC （丹麥-挪威-歐洲）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-236">IBM EBCDIC (Denmark-Norway-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-237">1143</span><span class="sxs-lookup"><span data-stu-id="d4c2c-237">1143</span></span>|<span data-ttu-id="d4c2c-238">IBM01143</span><span class="sxs-lookup"><span data-stu-id="d4c2c-238">IBM01143</span></span>|<span data-ttu-id="d4c2c-239">IBM EBCDIC （芬蘭-瑞典-歐洲）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-239">IBM EBCDIC (Finland-Sweden-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-240">1144</span><span class="sxs-lookup"><span data-stu-id="d4c2c-240">1144</span></span>|<span data-ttu-id="d4c2c-241">IBM01144</span><span class="sxs-lookup"><span data-stu-id="d4c2c-241">IBM01144</span></span>|<span data-ttu-id="d4c2c-242">IBM EBCDIC （義大利-歐洲）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-242">IBM EBCDIC (Italy-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-243">1145</span><span class="sxs-lookup"><span data-stu-id="d4c2c-243">1145</span></span>|<span data-ttu-id="d4c2c-244">IBM01145</span><span class="sxs-lookup"><span data-stu-id="d4c2c-244">IBM01145</span></span>|<span data-ttu-id="d4c2c-245">IBM EBCDIC (西班牙-Euro)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-245">IBM EBCDIC (Spain-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-246">1146</span><span class="sxs-lookup"><span data-stu-id="d4c2c-246">1146</span></span>|<span data-ttu-id="d4c2c-247">IBM01146</span><span class="sxs-lookup"><span data-stu-id="d4c2c-247">IBM01146</span></span>|<span data-ttu-id="d4c2c-248">IBM EBCDIC （英國-歐洲）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-248">IBM EBCDIC (UK-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-249">1147</span><span class="sxs-lookup"><span data-stu-id="d4c2c-249">1147</span></span>|<span data-ttu-id="d4c2c-250">IBM01147</span><span class="sxs-lookup"><span data-stu-id="d4c2c-250">IBM01147</span></span>|<span data-ttu-id="d4c2c-251">IBM EBCDIC (Francie-Euro)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-251">IBM EBCDIC (France-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-252">1148</span><span class="sxs-lookup"><span data-stu-id="d4c2c-252">1148</span></span>|<span data-ttu-id="d4c2c-253">IBM01148</span><span class="sxs-lookup"><span data-stu-id="d4c2c-253">IBM01148</span></span>|<span data-ttu-id="d4c2c-254">IBM EBCDIC （國際-歐洲）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-254">IBM EBCDIC (International-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-255">1149</span><span class="sxs-lookup"><span data-stu-id="d4c2c-255">1149</span></span>|<span data-ttu-id="d4c2c-256">IBM01149</span><span class="sxs-lookup"><span data-stu-id="d4c2c-256">IBM01149</span></span>|<span data-ttu-id="d4c2c-257">IBM EBCDIC (Island-Euro)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-257">IBM EBCDIC (Icelandic-Euro)</span></span>|||  
|<span data-ttu-id="d4c2c-258">1200</span><span class="sxs-lookup"><span data-stu-id="d4c2c-258">1200</span></span>|<span data-ttu-id="d4c2c-259">utf-16</span><span class="sxs-lookup"><span data-stu-id="d4c2c-259">utf-16</span></span>|<span data-ttu-id="d4c2c-260">Unicode</span><span class="sxs-lookup"><span data-stu-id="d4c2c-260">Unicode</span></span>|<span data-ttu-id="d4c2c-261">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-261">✓</span></span>|<span data-ttu-id="d4c2c-262">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-262">✓</span></span>|  
|<span data-ttu-id="d4c2c-263">1201</span><span class="sxs-lookup"><span data-stu-id="d4c2c-263">1201</span></span>|<span data-ttu-id="d4c2c-264">unicodeFFFE</span><span class="sxs-lookup"><span data-stu-id="d4c2c-264">unicodeFFFE</span></span>|<span data-ttu-id="d4c2c-265">Unicode (Big endian)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-265">Unicode (Big endian)</span></span>|<span data-ttu-id="d4c2c-266">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-266">✓</span></span>|<span data-ttu-id="d4c2c-267">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-267">✓</span></span>|  
|<span data-ttu-id="d4c2c-268">1250</span><span class="sxs-lookup"><span data-stu-id="d4c2c-268">1250</span></span>|<span data-ttu-id="d4c2c-269">windows-1250</span><span class="sxs-lookup"><span data-stu-id="d4c2c-269">windows-1250</span></span>|<span data-ttu-id="d4c2c-270">中歐語系 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-270">Central European (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-271">1251</span><span class="sxs-lookup"><span data-stu-id="d4c2c-271">1251</span></span>|<span data-ttu-id="d4c2c-272">windows-1251</span><span class="sxs-lookup"><span data-stu-id="d4c2c-272">windows-1251</span></span>|<span data-ttu-id="d4c2c-273">Cyrilice (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-273">Cyrillic (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-274">1252</span><span class="sxs-lookup"><span data-stu-id="d4c2c-274">1252</span></span>|<span data-ttu-id="d4c2c-275">Windows-1252</span><span class="sxs-lookup"><span data-stu-id="d4c2c-275">Windows-1252</span></span>|<span data-ttu-id="d4c2c-276">西歐語系 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-276">Western European (Windows)</span></span>|<span data-ttu-id="d4c2c-277">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-277">✓</span></span>||  
|<span data-ttu-id="d4c2c-278">1253</span><span class="sxs-lookup"><span data-stu-id="d4c2c-278">1253</span></span>|<span data-ttu-id="d4c2c-279">windows-1253</span><span class="sxs-lookup"><span data-stu-id="d4c2c-279">windows-1253</span></span>|<span data-ttu-id="d4c2c-280">希臘文 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-280">Greek (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-281">1254</span><span class="sxs-lookup"><span data-stu-id="d4c2c-281">1254</span></span>|<span data-ttu-id="d4c2c-282">windows-1254</span><span class="sxs-lookup"><span data-stu-id="d4c2c-282">windows-1254</span></span>|<span data-ttu-id="d4c2c-283">土耳其文 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-283">Turkish (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-284">1255</span><span class="sxs-lookup"><span data-stu-id="d4c2c-284">1255</span></span>|<span data-ttu-id="d4c2c-285">windows-1255</span><span class="sxs-lookup"><span data-stu-id="d4c2c-285">windows-1255</span></span>|<span data-ttu-id="d4c2c-286">希伯來文 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-286">Hebrew (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-287">1256</span><span class="sxs-lookup"><span data-stu-id="d4c2c-287">1256</span></span>|<span data-ttu-id="d4c2c-288">windows-1256</span><span class="sxs-lookup"><span data-stu-id="d4c2c-288">windows-1256</span></span>|<span data-ttu-id="d4c2c-289">阿拉伯文 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-289">Arabic (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-290">1257</span><span class="sxs-lookup"><span data-stu-id="d4c2c-290">1257</span></span>|<span data-ttu-id="d4c2c-291">windows-1257</span><span class="sxs-lookup"><span data-stu-id="d4c2c-291">windows-1257</span></span>|<span data-ttu-id="d4c2c-292">波羅的海文 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-292">Baltic (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-293">1258</span><span class="sxs-lookup"><span data-stu-id="d4c2c-293">1258</span></span>|<span data-ttu-id="d4c2c-294">windows-1258</span><span class="sxs-lookup"><span data-stu-id="d4c2c-294">windows-1258</span></span>|<span data-ttu-id="d4c2c-295">越南文 (Windows)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-295">Vietnamese (Windows)</span></span>|||  
|<span data-ttu-id="d4c2c-296">1361</span><span class="sxs-lookup"><span data-stu-id="d4c2c-296">1361</span></span>|<span data-ttu-id="d4c2c-297">Johab</span><span class="sxs-lookup"><span data-stu-id="d4c2c-297">Johab</span></span>|<span data-ttu-id="d4c2c-298">Korejština (Johab)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-298">Korean (Johab)</span></span>|||  
|<span data-ttu-id="d4c2c-299">10000</span><span class="sxs-lookup"><span data-stu-id="d4c2c-299">10000</span></span>|<span data-ttu-id="d4c2c-300">macintosh</span><span class="sxs-lookup"><span data-stu-id="d4c2c-300">macintosh</span></span>|<span data-ttu-id="d4c2c-301">西歐語系 (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-301">Western European (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-302">10001</span><span class="sxs-lookup"><span data-stu-id="d4c2c-302">10001</span></span>|<span data-ttu-id="d4c2c-303">x-mac-日文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-303">x-mac-japanese</span></span>|<span data-ttu-id="d4c2c-304">Japonština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-304">Japanese (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-305">10002</span><span class="sxs-lookup"><span data-stu-id="d4c2c-305">10002</span></span>|<span data-ttu-id="d4c2c-306">x-mac-chinesetrad</span><span class="sxs-lookup"><span data-stu-id="d4c2c-306">x-mac-chinesetrad</span></span>|<span data-ttu-id="d4c2c-307">繁體中文 (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-307">Chinese Traditional (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-308">10003</span><span class="sxs-lookup"><span data-stu-id="d4c2c-308">10003</span></span>|<span data-ttu-id="d4c2c-309">x-mac-韓文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-309">x-mac-korean</span></span>|<span data-ttu-id="d4c2c-310">Korejština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-310">Korean (Mac)</span></span>|<span data-ttu-id="d4c2c-311">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-311">✓</span></span>||  
|<span data-ttu-id="d4c2c-312">10004</span><span class="sxs-lookup"><span data-stu-id="d4c2c-312">10004</span></span>|<span data-ttu-id="d4c2c-313">x-mac-阿拉伯文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-313">x-mac-arabic</span></span>|<span data-ttu-id="d4c2c-314">Arabština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-314">Arabic (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-315">10005</span><span class="sxs-lookup"><span data-stu-id="d4c2c-315">10005</span></span>|<span data-ttu-id="d4c2c-316">x-mac-希伯來文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-316">x-mac-hebrew</span></span>|<span data-ttu-id="d4c2c-317">Hebrejština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-317">Hebrew (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-318">10006</span><span class="sxs-lookup"><span data-stu-id="d4c2c-318">10006</span></span>|<span data-ttu-id="d4c2c-319">x-mac-希臘文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-319">x-mac-greek</span></span>|<span data-ttu-id="d4c2c-320">希臘文 (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-320">Greek (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-321">10007</span><span class="sxs-lookup"><span data-stu-id="d4c2c-321">10007</span></span>|<span data-ttu-id="d4c2c-322">x-mac-斯拉夫文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-322">x-mac-cyrillic</span></span>|<span data-ttu-id="d4c2c-323">Cyrilice (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-323">Cyrillic (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-324">10008</span><span class="sxs-lookup"><span data-stu-id="d4c2c-324">10008</span></span>|<span data-ttu-id="d4c2c-325">x-mac-chinesesimp</span><span class="sxs-lookup"><span data-stu-id="d4c2c-325">x-mac-chinesesimp</span></span>|<span data-ttu-id="d4c2c-326">簡體中文 (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-326">Chinese Simplified (Mac)</span></span>|<span data-ttu-id="d4c2c-327">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-327">✓</span></span>||  
|<span data-ttu-id="d4c2c-328">10010</span><span class="sxs-lookup"><span data-stu-id="d4c2c-328">10010</span></span>|<span data-ttu-id="d4c2c-329">x-mac-羅馬尼亞文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-329">x-mac-romanian</span></span>|<span data-ttu-id="d4c2c-330">Rumunština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-330">Romanian (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-331">10017</span><span class="sxs-lookup"><span data-stu-id="d4c2c-331">10017</span></span>|<span data-ttu-id="d4c2c-332">烏克蘭文-x-mac</span><span class="sxs-lookup"><span data-stu-id="d4c2c-332">x-mac-ukrainian</span></span>|<span data-ttu-id="d4c2c-333">Ukrajinština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-333">Ukrainian (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-334">10021</span><span class="sxs-lookup"><span data-stu-id="d4c2c-334">10021</span></span>|<span data-ttu-id="d4c2c-335">x-mac-泰文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-335">x-mac-thai</span></span>|<span data-ttu-id="d4c2c-336">Thajština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-336">Thai (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-337">10029</span><span class="sxs-lookup"><span data-stu-id="d4c2c-337">10029</span></span>|<span data-ttu-id="d4c2c-338">x-mac-ce</span><span class="sxs-lookup"><span data-stu-id="d4c2c-338">x-mac-ce</span></span>|<span data-ttu-id="d4c2c-339">中歐語系 (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-339">Central European (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-340">10079</span><span class="sxs-lookup"><span data-stu-id="d4c2c-340">10079</span></span>|<span data-ttu-id="d4c2c-341">x-mac-冰島文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-341">x-mac-icelandic</span></span>|<span data-ttu-id="d4c2c-342">Islandština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-342">Icelandic (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-343">10081</span><span class="sxs-lookup"><span data-stu-id="d4c2c-343">10081</span></span>|<span data-ttu-id="d4c2c-344">x-mac-土耳其文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-344">x-mac-turkish</span></span>|<span data-ttu-id="d4c2c-345">Turečtina (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-345">Turkish (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-346">10082</span><span class="sxs-lookup"><span data-stu-id="d4c2c-346">10082</span></span>|<span data-ttu-id="d4c2c-347">x-mac-克羅埃西亞文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-347">x-mac-croatian</span></span>|<span data-ttu-id="d4c2c-348">Chorvatština (Mac)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-348">Croatian (Mac)</span></span>|||  
|<span data-ttu-id="d4c2c-349">12000</span><span class="sxs-lookup"><span data-stu-id="d4c2c-349">12000</span></span>|<span data-ttu-id="d4c2c-350">utf-32</span><span class="sxs-lookup"><span data-stu-id="d4c2c-350">utf-32</span></span>|<span data-ttu-id="d4c2c-351">Unicode (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-351">Unicode (UTF-32)</span></span>|<span data-ttu-id="d4c2c-352">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-352">✓</span></span>|<span data-ttu-id="d4c2c-353">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-353">✓</span></span>|  
|<span data-ttu-id="d4c2c-354">12001</span><span class="sxs-lookup"><span data-stu-id="d4c2c-354">12001</span></span>|<span data-ttu-id="d4c2c-355">utf-32BE</span><span class="sxs-lookup"><span data-stu-id="d4c2c-355">utf-32BE</span></span>|<span data-ttu-id="d4c2c-356">Unicode (UTF-32 Big endian)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-356">Unicode (UTF-32 Big endian)</span></span>|<span data-ttu-id="d4c2c-357">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-357">✓</span></span>|<span data-ttu-id="d4c2c-358">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-358">✓</span></span>|  
|<span data-ttu-id="d4c2c-359">20000</span><span class="sxs-lookup"><span data-stu-id="d4c2c-359">20000</span></span>|<span data-ttu-id="d4c2c-360">x-中文-CN</span><span class="sxs-lookup"><span data-stu-id="d4c2c-360">x-Chinese-CNS</span></span>|<span data-ttu-id="d4c2c-361">繁體中文 (CNS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-361">Chinese Traditional (CNS)</span></span>|||  
|<span data-ttu-id="d4c2c-362">20001</span><span class="sxs-lookup"><span data-stu-id="d4c2c-362">20001</span></span>|<span data-ttu-id="d4c2c-363">x-cp20001</span><span class="sxs-lookup"><span data-stu-id="d4c2c-363">x-cp20001</span></span>|<span data-ttu-id="d4c2c-364">Tchaj-wan Tca</span><span class="sxs-lookup"><span data-stu-id="d4c2c-364">TCA Taiwan</span></span>|||  
|<span data-ttu-id="d4c2c-365">20002</span><span class="sxs-lookup"><span data-stu-id="d4c2c-365">20002</span></span>|<span data-ttu-id="d4c2c-366">x-中文-倚天</span><span class="sxs-lookup"><span data-stu-id="d4c2c-366">x-Chinese-Eten</span></span>|<span data-ttu-id="d4c2c-367">繁體中文 （倚天）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-367">Chinese Traditional (Eten)</span></span>|||  
|<span data-ttu-id="d4c2c-368">20003</span><span class="sxs-lookup"><span data-stu-id="d4c2c-368">20003</span></span>|<span data-ttu-id="d4c2c-369">x-cp20003</span><span class="sxs-lookup"><span data-stu-id="d4c2c-369">x-cp20003</span></span>|<span data-ttu-id="d4c2c-370">Tchaj-wan Ibm5550</span><span class="sxs-lookup"><span data-stu-id="d4c2c-370">IBM5550 Taiwan</span></span>|||  
|<span data-ttu-id="d4c2c-371">20004</span><span class="sxs-lookup"><span data-stu-id="d4c2c-371">20004</span></span>|<span data-ttu-id="d4c2c-372">x-cp20004</span><span class="sxs-lookup"><span data-stu-id="d4c2c-372">x-cp20004</span></span>|<span data-ttu-id="d4c2c-373">Tchaj-wan teleText</span><span class="sxs-lookup"><span data-stu-id="d4c2c-373">TeleText Taiwan</span></span>|||  
|<span data-ttu-id="d4c2c-374">20005</span><span class="sxs-lookup"><span data-stu-id="d4c2c-374">20005</span></span>|<span data-ttu-id="d4c2c-375">x-cp20005</span><span class="sxs-lookup"><span data-stu-id="d4c2c-375">x-cp20005</span></span>|<span data-ttu-id="d4c2c-376">Tchaj-wan Wang</span><span class="sxs-lookup"><span data-stu-id="d4c2c-376">Wang Taiwan</span></span>|||  
|<span data-ttu-id="d4c2c-377">20105</span><span class="sxs-lookup"><span data-stu-id="d4c2c-377">20105</span></span>|<span data-ttu-id="d4c2c-378">x-IA5</span><span class="sxs-lookup"><span data-stu-id="d4c2c-378">x-IA5</span></span>|<span data-ttu-id="d4c2c-379">西歐語系 (IA5)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-379">Western European (IA5)</span></span>|||  
|<span data-ttu-id="d4c2c-380">20106</span><span class="sxs-lookup"><span data-stu-id="d4c2c-380">20106</span></span>|<span data-ttu-id="d4c2c-381">x-IA5-德文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-381">x-IA5-German</span></span>|<span data-ttu-id="d4c2c-382">Němčina (IA5)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-382">German (IA5)</span></span>|||  
|<span data-ttu-id="d4c2c-383">20107</span><span class="sxs-lookup"><span data-stu-id="d4c2c-383">20107</span></span>|<span data-ttu-id="d4c2c-384">x-IA5-瑞典文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-384">x-IA5-Swedish</span></span>|<span data-ttu-id="d4c2c-385">瑞典文 (IA5)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-385">Swedish (IA5)</span></span>|||  
|<span data-ttu-id="d4c2c-386">20108</span><span class="sxs-lookup"><span data-stu-id="d4c2c-386">20108</span></span>|<span data-ttu-id="d4c2c-387">x-IA5-Norwegian</span><span class="sxs-lookup"><span data-stu-id="d4c2c-387">x-IA5-Norwegian</span></span>|<span data-ttu-id="d4c2c-388">挪威文 (IA5)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-388">Norwegian (IA5)</span></span>|||  
|<span data-ttu-id="d4c2c-389">20127</span><span class="sxs-lookup"><span data-stu-id="d4c2c-389">20127</span></span>|<span data-ttu-id="d4c2c-390">我們 ascii</span><span class="sxs-lookup"><span data-stu-id="d4c2c-390">us-ascii</span></span>|<span data-ttu-id="d4c2c-391">US-ASCII</span><span class="sxs-lookup"><span data-stu-id="d4c2c-391">US-ASCII</span></span>|<span data-ttu-id="d4c2c-392">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-392">✓</span></span>|<span data-ttu-id="d4c2c-393">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-393">✓</span></span>|  
|<span data-ttu-id="d4c2c-394">20261</span><span class="sxs-lookup"><span data-stu-id="d4c2c-394">20261</span></span>|<span data-ttu-id="d4c2c-395">x-cp20261</span><span class="sxs-lookup"><span data-stu-id="d4c2c-395">x-cp20261</span></span>|<span data-ttu-id="d4c2c-396">T.61</span><span class="sxs-lookup"><span data-stu-id="d4c2c-396">T.61</span></span>|||  
|<span data-ttu-id="d4c2c-397">20269</span><span class="sxs-lookup"><span data-stu-id="d4c2c-397">20269</span></span>|<span data-ttu-id="d4c2c-398">x-cp20269</span><span class="sxs-lookup"><span data-stu-id="d4c2c-398">x-cp20269</span></span>|<span data-ttu-id="d4c2c-399">ISO-6937</span><span class="sxs-lookup"><span data-stu-id="d4c2c-399">ISO-6937</span></span>|||  
|<span data-ttu-id="d4c2c-400">20273</span><span class="sxs-lookup"><span data-stu-id="d4c2c-400">20273</span></span>|<span data-ttu-id="d4c2c-401">IBM273</span><span class="sxs-lookup"><span data-stu-id="d4c2c-401">IBM273</span></span>|<span data-ttu-id="d4c2c-402">IBM EBCDIC (Německo)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-402">IBM EBCDIC (Germany)</span></span>|||  
|<span data-ttu-id="d4c2c-403">20277</span><span class="sxs-lookup"><span data-stu-id="d4c2c-403">20277</span></span>|<span data-ttu-id="d4c2c-404">IBM277</span><span class="sxs-lookup"><span data-stu-id="d4c2c-404">IBM277</span></span>|<span data-ttu-id="d4c2c-405">IBM EBCDIC （丹麥-挪威）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-405">IBM EBCDIC (Denmark-Norway)</span></span>|||  
|<span data-ttu-id="d4c2c-406">20278</span><span class="sxs-lookup"><span data-stu-id="d4c2c-406">20278</span></span>|<span data-ttu-id="d4c2c-407">IBM278</span><span class="sxs-lookup"><span data-stu-id="d4c2c-407">IBM278</span></span>|<span data-ttu-id="d4c2c-408">IBM EBCDIC （芬蘭-瑞典）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-408">IBM EBCDIC (Finland-Sweden)</span></span>|||  
|<span data-ttu-id="d4c2c-409">20280</span><span class="sxs-lookup"><span data-stu-id="d4c2c-409">20280</span></span>|<span data-ttu-id="d4c2c-410">IBM280</span><span class="sxs-lookup"><span data-stu-id="d4c2c-410">IBM280</span></span>|<span data-ttu-id="d4c2c-411">IBM EBCDIC （義大利）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-411">IBM EBCDIC (Italy)</span></span>|||  
|<span data-ttu-id="d4c2c-412">20284</span><span class="sxs-lookup"><span data-stu-id="d4c2c-412">20284</span></span>|<span data-ttu-id="d4c2c-413">IBM284</span><span class="sxs-lookup"><span data-stu-id="d4c2c-413">IBM284</span></span>|<span data-ttu-id="d4c2c-414">IBM EBCDIC （西班牙）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-414">IBM EBCDIC (Spain)</span></span>|||  
|<span data-ttu-id="d4c2c-415">20285</span><span class="sxs-lookup"><span data-stu-id="d4c2c-415">20285</span></span>|<span data-ttu-id="d4c2c-416">IBM285</span><span class="sxs-lookup"><span data-stu-id="d4c2c-416">IBM285</span></span>|<span data-ttu-id="d4c2c-417">IBM EBCDIC （英國）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-417">IBM EBCDIC (UK)</span></span>|||  
|<span data-ttu-id="d4c2c-418">20290</span><span class="sxs-lookup"><span data-stu-id="d4c2c-418">20290</span></span>|<span data-ttu-id="d4c2c-419">IBM290</span><span class="sxs-lookup"><span data-stu-id="d4c2c-419">IBM290</span></span>|<span data-ttu-id="d4c2c-420">IBM EBCDIC （日文片假名）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-420">IBM EBCDIC (Japanese katakana)</span></span>|||  
|<span data-ttu-id="d4c2c-421">20297</span><span class="sxs-lookup"><span data-stu-id="d4c2c-421">20297</span></span>|<span data-ttu-id="d4c2c-422">IBM297</span><span class="sxs-lookup"><span data-stu-id="d4c2c-422">IBM297</span></span>|<span data-ttu-id="d4c2c-423">IBM EBCDIC (Francie)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-423">IBM EBCDIC (France)</span></span>|||  
|<span data-ttu-id="d4c2c-424">20420</span><span class="sxs-lookup"><span data-stu-id="d4c2c-424">20420</span></span>|<span data-ttu-id="d4c2c-425">IBM420</span><span class="sxs-lookup"><span data-stu-id="d4c2c-425">IBM420</span></span>|<span data-ttu-id="d4c2c-426">IBM EBCDIC （阿拉伯文）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-426">IBM EBCDIC (Arabic)</span></span>|||  
|<span data-ttu-id="d4c2c-427">20423</span><span class="sxs-lookup"><span data-stu-id="d4c2c-427">20423</span></span>|<span data-ttu-id="d4c2c-428">IBM423</span><span class="sxs-lookup"><span data-stu-id="d4c2c-428">IBM423</span></span>|<span data-ttu-id="d4c2c-429">IBM EBCDIC （希臘文）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-429">IBM EBCDIC (Greek)</span></span>|||  
|<span data-ttu-id="d4c2c-430">20424</span><span class="sxs-lookup"><span data-stu-id="d4c2c-430">20424</span></span>|<span data-ttu-id="d4c2c-431">IBM424</span><span class="sxs-lookup"><span data-stu-id="d4c2c-431">IBM424</span></span>|<span data-ttu-id="d4c2c-432">IBM EBCDIC (Hebrejština)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-432">IBM EBCDIC (Hebrew)</span></span>|||  
|<span data-ttu-id="d4c2c-433">20833</span><span class="sxs-lookup"><span data-stu-id="d4c2c-433">20833</span></span>|<span data-ttu-id="d4c2c-434">x-EBCDIC-KoreanExtended</span><span class="sxs-lookup"><span data-stu-id="d4c2c-434">x-EBCDIC-KoreanExtended</span></span>|<span data-ttu-id="d4c2c-435">IBM EBCDIC （韓文擴充）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-435">IBM EBCDIC (Korean Extended)</span></span>|||  
|<span data-ttu-id="d4c2c-436">20838</span><span class="sxs-lookup"><span data-stu-id="d4c2c-436">20838</span></span>|<span data-ttu-id="d4c2c-437">IBM-泰文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-437">IBM-Thai</span></span>|<span data-ttu-id="d4c2c-438">IBM EBCDIC (Thajština)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-438">IBM EBCDIC (Thai)</span></span>|||  
|<span data-ttu-id="d4c2c-439">20866</span><span class="sxs-lookup"><span data-stu-id="d4c2c-439">20866</span></span>|<span data-ttu-id="d4c2c-440">koi8-r</span><span class="sxs-lookup"><span data-stu-id="d4c2c-440">koi8-r</span></span>|<span data-ttu-id="d4c2c-441">Cyrilice (KOI8-R)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-441">Cyrillic (KOI8-R)</span></span>|||  
|<span data-ttu-id="d4c2c-442">20871</span><span class="sxs-lookup"><span data-stu-id="d4c2c-442">20871</span></span>|<span data-ttu-id="d4c2c-443">IBM871</span><span class="sxs-lookup"><span data-stu-id="d4c2c-443">IBM871</span></span>|<span data-ttu-id="d4c2c-444">IBM EBCDIC (Islandština)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-444">IBM EBCDIC (Icelandic)</span></span>|||  
|<span data-ttu-id="d4c2c-445">20880</span><span class="sxs-lookup"><span data-stu-id="d4c2c-445">20880</span></span>|<span data-ttu-id="d4c2c-446">IBM880</span><span class="sxs-lookup"><span data-stu-id="d4c2c-446">IBM880</span></span>|<span data-ttu-id="d4c2c-447">IBM EBCDIC （斯拉夫俄文）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-447">IBM EBCDIC (Cyrillic Russian)</span></span>|||  
|<span data-ttu-id="d4c2c-448">20905</span><span class="sxs-lookup"><span data-stu-id="d4c2c-448">20905</span></span>|<span data-ttu-id="d4c2c-449">IBM905</span><span class="sxs-lookup"><span data-stu-id="d4c2c-449">IBM905</span></span>|<span data-ttu-id="d4c2c-450">IBM EBCDIC (Turečtina)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-450">IBM EBCDIC (Turkish)</span></span>|||  
|<span data-ttu-id="d4c2c-451">20924</span><span class="sxs-lookup"><span data-stu-id="d4c2c-451">20924</span></span>|<span data-ttu-id="d4c2c-452">IBM00924</span><span class="sxs-lookup"><span data-stu-id="d4c2c-452">IBM00924</span></span>|<span data-ttu-id="d4c2c-453">IBM Latin 1</span><span class="sxs-lookup"><span data-stu-id="d4c2c-453">IBM Latin-1</span></span>|||  
|<span data-ttu-id="d4c2c-454">20932</span><span class="sxs-lookup"><span data-stu-id="d4c2c-454">20932</span></span>|<span data-ttu-id="d4c2c-455">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="d4c2c-455">EUC-JP</span></span>|<span data-ttu-id="d4c2c-456">Japonština (JIS 0208 1990年和 0212年 1990年)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-456">Japanese (JIS 0208-1990 and 0212-1990)</span></span>|||  
|<span data-ttu-id="d4c2c-457">20936</span><span class="sxs-lookup"><span data-stu-id="d4c2c-457">20936</span></span>|<span data-ttu-id="d4c2c-458">x-cp20936</span><span class="sxs-lookup"><span data-stu-id="d4c2c-458">x-cp20936</span></span>|<span data-ttu-id="d4c2c-459">簡體中文 (GB2312-80)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-459">Chinese Simplified (GB2312-80)</span></span>|<span data-ttu-id="d4c2c-460">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-460">✓</span></span>||  
|<span data-ttu-id="d4c2c-461">20949</span><span class="sxs-lookup"><span data-stu-id="d4c2c-461">20949</span></span>|<span data-ttu-id="d4c2c-462">x-cp20949</span><span class="sxs-lookup"><span data-stu-id="d4c2c-462">x-cp20949</span></span>|<span data-ttu-id="d4c2c-463">韓文 Wansung</span><span class="sxs-lookup"><span data-stu-id="d4c2c-463">Korean Wansung</span></span>|<span data-ttu-id="d4c2c-464">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-464">✓</span></span>||  
|<span data-ttu-id="d4c2c-465">21025</span><span class="sxs-lookup"><span data-stu-id="d4c2c-465">21025</span></span>|<span data-ttu-id="d4c2c-466">cp1025</span><span class="sxs-lookup"><span data-stu-id="d4c2c-466">cp1025</span></span>|<span data-ttu-id="d4c2c-467">IBM EBCDIC （斯拉夫塞爾維亞文-保加利亞文）</span><span class="sxs-lookup"><span data-stu-id="d4c2c-467">IBM EBCDIC (Cyrillic Serbian-Bulgarian)</span></span>|||  
|<span data-ttu-id="d4c2c-468">21866</span><span class="sxs-lookup"><span data-stu-id="d4c2c-468">21866</span></span>|<span data-ttu-id="d4c2c-469">koi8-u</span><span class="sxs-lookup"><span data-stu-id="d4c2c-469">koi8-u</span></span>|<span data-ttu-id="d4c2c-470">Cyrilice (KOI8-U)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-470">Cyrillic (KOI8-U)</span></span>|||  
|<span data-ttu-id="d4c2c-471">28591</span><span class="sxs-lookup"><span data-stu-id="d4c2c-471">28591</span></span>|<span data-ttu-id="d4c2c-472">iso-8859-1</span><span class="sxs-lookup"><span data-stu-id="d4c2c-472">iso-8859-1</span></span>|<span data-ttu-id="d4c2c-473">西歐語系 (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-473">Western European (ISO)</span></span>|<span data-ttu-id="d4c2c-474">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-474">✓</span></span>|<span data-ttu-id="d4c2c-475">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-475">✓</span></span>|  
|<span data-ttu-id="d4c2c-476">28592</span><span class="sxs-lookup"><span data-stu-id="d4c2c-476">28592</span></span>|<span data-ttu-id="d4c2c-477">iso-8859-2</span><span class="sxs-lookup"><span data-stu-id="d4c2c-477">iso-8859-2</span></span>|<span data-ttu-id="d4c2c-478">中歐語系 (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-478">Central European (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-479">28593</span><span class="sxs-lookup"><span data-stu-id="d4c2c-479">28593</span></span>|<span data-ttu-id="d4c2c-480">iso-8859-3</span><span class="sxs-lookup"><span data-stu-id="d4c2c-480">iso-8859-3</span></span>|<span data-ttu-id="d4c2c-481">拉丁文 3 (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-481">Latin 3 (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-482">28594</span><span class="sxs-lookup"><span data-stu-id="d4c2c-482">28594</span></span>|<span data-ttu-id="d4c2c-483">iso-8859-4</span><span class="sxs-lookup"><span data-stu-id="d4c2c-483">iso-8859-4</span></span>|<span data-ttu-id="d4c2c-484">波羅的海文 (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-484">Baltic (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-485">28595</span><span class="sxs-lookup"><span data-stu-id="d4c2c-485">28595</span></span>|<span data-ttu-id="d4c2c-486">iso-8859-5</span><span class="sxs-lookup"><span data-stu-id="d4c2c-486">iso-8859-5</span></span>|<span data-ttu-id="d4c2c-487">Cyrilice (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-487">Cyrillic (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-488">28596</span><span class="sxs-lookup"><span data-stu-id="d4c2c-488">28596</span></span>|<span data-ttu-id="d4c2c-489">iso-8859-6</span><span class="sxs-lookup"><span data-stu-id="d4c2c-489">iso-8859-6</span></span>|<span data-ttu-id="d4c2c-490">Arabština (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-490">Arabic (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-491">28597</span><span class="sxs-lookup"><span data-stu-id="d4c2c-491">28597</span></span>|<span data-ttu-id="d4c2c-492">iso-8859-7</span><span class="sxs-lookup"><span data-stu-id="d4c2c-492">iso-8859-7</span></span>|<span data-ttu-id="d4c2c-493">希臘文 (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-493">Greek (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-494">28598</span><span class="sxs-lookup"><span data-stu-id="d4c2c-494">28598</span></span>|<span data-ttu-id="d4c2c-495">iso-8859-8</span><span class="sxs-lookup"><span data-stu-id="d4c2c-495">iso-8859-8</span></span>|<span data-ttu-id="d4c2c-496">希伯來文 (So-visual)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-496">Hebrew (ISO-Visual)</span></span>|<span data-ttu-id="d4c2c-497">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-497">✓</span></span>||  
|<span data-ttu-id="d4c2c-498">28599</span><span class="sxs-lookup"><span data-stu-id="d4c2c-498">28599</span></span>|<span data-ttu-id="d4c2c-499">iso-8859-9</span><span class="sxs-lookup"><span data-stu-id="d4c2c-499">iso-8859-9</span></span>|<span data-ttu-id="d4c2c-500">Turečtina (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-500">Turkish (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-501">28603</span><span class="sxs-lookup"><span data-stu-id="d4c2c-501">28603</span></span>|<span data-ttu-id="d4c2c-502">iso-8859-13</span><span class="sxs-lookup"><span data-stu-id="d4c2c-502">iso-8859-13</span></span>|<span data-ttu-id="d4c2c-503">Estonština (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-503">Estonian (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-504">28605</span><span class="sxs-lookup"><span data-stu-id="d4c2c-504">28605</span></span>|<span data-ttu-id="d4c2c-505">iso-8859-15</span><span class="sxs-lookup"><span data-stu-id="d4c2c-505">iso-8859-15</span></span>|<span data-ttu-id="d4c2c-506">拉丁文 9 (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-506">Latin 9 (ISO)</span></span>|||  
|<span data-ttu-id="d4c2c-507">29001</span><span class="sxs-lookup"><span data-stu-id="d4c2c-507">29001</span></span>|<span data-ttu-id="d4c2c-508">x-Europa</span><span class="sxs-lookup"><span data-stu-id="d4c2c-508">x-Europa</span></span>|<span data-ttu-id="d4c2c-509">Europa</span><span class="sxs-lookup"><span data-stu-id="d4c2c-509">Europa</span></span>|||  
|<span data-ttu-id="d4c2c-510">38598</span><span class="sxs-lookup"><span data-stu-id="d4c2c-510">38598</span></span>|<span data-ttu-id="d4c2c-511">iso-8859-8-i</span><span class="sxs-lookup"><span data-stu-id="d4c2c-511">iso-8859-8-i</span></span>|<span data-ttu-id="d4c2c-512">Hebrejština (Iso-logical)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-512">Hebrew (ISO-Logical)</span></span>|<span data-ttu-id="d4c2c-513">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-513">✓</span></span>||  
|<span data-ttu-id="d4c2c-514">50220</span><span class="sxs-lookup"><span data-stu-id="d4c2c-514">50220</span></span>|<span data-ttu-id="d4c2c-515">iso-2022年-jp</span><span class="sxs-lookup"><span data-stu-id="d4c2c-515">iso-2022-jp</span></span>|<span data-ttu-id="d4c2c-516">Japonština (JIS)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-516">Japanese (JIS)</span></span>|<span data-ttu-id="d4c2c-517">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-517">✓</span></span>||  
|<span data-ttu-id="d4c2c-518">50221</span><span class="sxs-lookup"><span data-stu-id="d4c2c-518">50221</span></span>|<span data-ttu-id="d4c2c-519">csISO2022JP</span><span class="sxs-lookup"><span data-stu-id="d4c2c-519">csISO2022JP</span></span>|<span data-ttu-id="d4c2c-520">日文 (JIS-Povolen 1 bajt Kana)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-520">Japanese (JIS-Allow 1 byte Kana)</span></span>|<span data-ttu-id="d4c2c-521">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-521">✓</span></span>||  
|<span data-ttu-id="d4c2c-522">50222</span><span class="sxs-lookup"><span data-stu-id="d4c2c-522">50222</span></span>|<span data-ttu-id="d4c2c-523">iso-2022年-jp</span><span class="sxs-lookup"><span data-stu-id="d4c2c-523">iso-2022-jp</span></span>|<span data-ttu-id="d4c2c-524">日文 (JIS-Povolen 1 bajt Kana-因此 / SI)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-524">Japanese (JIS-Allow 1 byte Kana - SO/SI)</span></span>|<span data-ttu-id="d4c2c-525">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-525">✓</span></span>||  
|<span data-ttu-id="d4c2c-526">50225</span><span class="sxs-lookup"><span data-stu-id="d4c2c-526">50225</span></span>|<span data-ttu-id="d4c2c-527">iso-2022年-韓國</span><span class="sxs-lookup"><span data-stu-id="d4c2c-527">iso-2022-kr</span></span>|<span data-ttu-id="d4c2c-528">Korejština (ISO)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-528">Korean (ISO)</span></span>|<span data-ttu-id="d4c2c-529">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-529">✓</span></span>||  
|<span data-ttu-id="d4c2c-530">50227</span><span class="sxs-lookup"><span data-stu-id="d4c2c-530">50227</span></span>|<span data-ttu-id="d4c2c-531">x-cp50227</span><span class="sxs-lookup"><span data-stu-id="d4c2c-531">x-cp50227</span></span>|<span data-ttu-id="d4c2c-532">簡體中文 (ISO-2022)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-532">Chinese Simplified (ISO-2022)</span></span>|<span data-ttu-id="d4c2c-533">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-533">✓</span></span>||  
|<span data-ttu-id="d4c2c-534">51932</span><span class="sxs-lookup"><span data-stu-id="d4c2c-534">51932</span></span>|<span data-ttu-id="d4c2c-535">euc jp</span><span class="sxs-lookup"><span data-stu-id="d4c2c-535">euc-jp</span></span>|<span data-ttu-id="d4c2c-536">Japonština (EUC)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-536">Japanese (EUC)</span></span>|<span data-ttu-id="d4c2c-537">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-537">✓</span></span>||  
|<span data-ttu-id="d4c2c-538">51936</span><span class="sxs-lookup"><span data-stu-id="d4c2c-538">51936</span></span>|<span data-ttu-id="d4c2c-539">EUC CN</span><span class="sxs-lookup"><span data-stu-id="d4c2c-539">EUC-CN</span></span>|<span data-ttu-id="d4c2c-540">簡體中文 (EUC)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-540">Chinese Simplified (EUC)</span></span>|<span data-ttu-id="d4c2c-541">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-541">✓</span></span>||  
|<span data-ttu-id="d4c2c-542">51949</span><span class="sxs-lookup"><span data-stu-id="d4c2c-542">51949</span></span>|<span data-ttu-id="d4c2c-543">euc 韓國</span><span class="sxs-lookup"><span data-stu-id="d4c2c-543">euc-kr</span></span>|<span data-ttu-id="d4c2c-544">Korejština (EUC)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-544">Korean (EUC)</span></span>|<span data-ttu-id="d4c2c-545">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-545">✓</span></span>||  
|<span data-ttu-id="d4c2c-546">52936</span><span class="sxs-lookup"><span data-stu-id="d4c2c-546">52936</span></span>|<span data-ttu-id="d4c2c-547">hz-gb-2312</span><span class="sxs-lookup"><span data-stu-id="d4c2c-547">hz-gb-2312</span></span>|<span data-ttu-id="d4c2c-548">簡體中文 (HZ)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-548">Chinese Simplified (HZ)</span></span>|<span data-ttu-id="d4c2c-549">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-549">✓</span></span>||  
|<span data-ttu-id="d4c2c-550">54936</span><span class="sxs-lookup"><span data-stu-id="d4c2c-550">54936</span></span>|<span data-ttu-id="d4c2c-551">GB18030</span><span class="sxs-lookup"><span data-stu-id="d4c2c-551">GB18030</span></span>|<span data-ttu-id="d4c2c-552">簡體中文 (GB18030)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-552">Chinese Simplified (GB18030)</span></span>|<span data-ttu-id="d4c2c-553">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-553">✓</span></span>||  
|<span data-ttu-id="d4c2c-554">57002</span><span class="sxs-lookup"><span data-stu-id="d4c2c-554">57002</span></span>|<span data-ttu-id="d4c2c-555">x-iscii-de</span><span class="sxs-lookup"><span data-stu-id="d4c2c-555">x-iscii-de</span></span>|<span data-ttu-id="d4c2c-556">ISCII 梵文字母</span><span class="sxs-lookup"><span data-stu-id="d4c2c-556">ISCII Devanagari</span></span>|<span data-ttu-id="d4c2c-557">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-557">✓</span></span>||  
|<span data-ttu-id="d4c2c-558">57003</span><span class="sxs-lookup"><span data-stu-id="d4c2c-558">57003</span></span>|<span data-ttu-id="d4c2c-559">iscii-是 x</span><span class="sxs-lookup"><span data-stu-id="d4c2c-559">x-iscii-be</span></span>|<span data-ttu-id="d4c2c-560">ISCII 孟加拉文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-560">ISCII Bengali</span></span>|<span data-ttu-id="d4c2c-561">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-561">✓</span></span>||  
|<span data-ttu-id="d4c2c-562">57004</span><span class="sxs-lookup"><span data-stu-id="d4c2c-562">57004</span></span>|<span data-ttu-id="d4c2c-563">x-iscii-ta</span><span class="sxs-lookup"><span data-stu-id="d4c2c-563">x-iscii-ta</span></span>|<span data-ttu-id="d4c2c-564">Iscii-Tamilština</span><span class="sxs-lookup"><span data-stu-id="d4c2c-564">ISCII Tamil</span></span>|<span data-ttu-id="d4c2c-565">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-565">✓</span></span>||  
|<span data-ttu-id="d4c2c-566">57005</span><span class="sxs-lookup"><span data-stu-id="d4c2c-566">57005</span></span>|<span data-ttu-id="d4c2c-567">x-iscii-te</span><span class="sxs-lookup"><span data-stu-id="d4c2c-567">x-iscii-te</span></span>|<span data-ttu-id="d4c2c-568">Iscii-Telugština</span><span class="sxs-lookup"><span data-stu-id="d4c2c-568">ISCII Telugu</span></span>|<span data-ttu-id="d4c2c-569">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-569">✓</span></span>||  
|<span data-ttu-id="d4c2c-570">57006</span><span class="sxs-lookup"><span data-stu-id="d4c2c-570">57006</span></span>|<span data-ttu-id="d4c2c-571">x iscii 身分</span><span class="sxs-lookup"><span data-stu-id="d4c2c-571">x-iscii-as</span></span>|<span data-ttu-id="d4c2c-572">ISCII 阿薩姆文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-572">ISCII Assamese</span></span>|<span data-ttu-id="d4c2c-573">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-573">✓</span></span>||  
|<span data-ttu-id="d4c2c-574">57007</span><span class="sxs-lookup"><span data-stu-id="d4c2c-574">57007</span></span>|<span data-ttu-id="d4c2c-575">或 x iscii</span><span class="sxs-lookup"><span data-stu-id="d4c2c-575">x-iscii-or</span></span>|<span data-ttu-id="d4c2c-576">Iscii-Urijština</span><span class="sxs-lookup"><span data-stu-id="d4c2c-576">ISCII Oriya</span></span>|<span data-ttu-id="d4c2c-577">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-577">✓</span></span>||  
|<span data-ttu-id="d4c2c-578">57008</span><span class="sxs-lookup"><span data-stu-id="d4c2c-578">57008</span></span>|<span data-ttu-id="d4c2c-579">x-iscii-ka</span><span class="sxs-lookup"><span data-stu-id="d4c2c-579">x-iscii-ka</span></span>|<span data-ttu-id="d4c2c-580">Iscii-Kannadština</span><span class="sxs-lookup"><span data-stu-id="d4c2c-580">ISCII Kannada</span></span>|<span data-ttu-id="d4c2c-581">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-581">✓</span></span>||  
|<span data-ttu-id="d4c2c-582">57009</span><span class="sxs-lookup"><span data-stu-id="d4c2c-582">57009</span></span>|<span data-ttu-id="d4c2c-583">x-iscii-ma</span><span class="sxs-lookup"><span data-stu-id="d4c2c-583">x-iscii-ma</span></span>|<span data-ttu-id="d4c2c-584">ISCII 馬來亞拉姆文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-584">ISCII Malayalam</span></span>|<span data-ttu-id="d4c2c-585">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-585">✓</span></span>||  
|<span data-ttu-id="d4c2c-586">57010</span><span class="sxs-lookup"><span data-stu-id="d4c2c-586">57010</span></span>|<span data-ttu-id="d4c2c-587">x-iscii-gu</span><span class="sxs-lookup"><span data-stu-id="d4c2c-587">x-iscii-gu</span></span>|<span data-ttu-id="d4c2c-588">ISCII 古吉拉特文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-588">ISCII Gujarati</span></span>|<span data-ttu-id="d4c2c-589">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-589">✓</span></span>||  
|<span data-ttu-id="d4c2c-590">57011</span><span class="sxs-lookup"><span data-stu-id="d4c2c-590">57011</span></span>|<span data-ttu-id="d4c2c-591">x-iscii-pa</span><span class="sxs-lookup"><span data-stu-id="d4c2c-591">x-iscii-pa</span></span>|<span data-ttu-id="d4c2c-592">ISCII 旁遮普文</span><span class="sxs-lookup"><span data-stu-id="d4c2c-592">ISCII Punjabi</span></span>|<span data-ttu-id="d4c2c-593">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-593">✓</span></span>||  
|<span data-ttu-id="d4c2c-594">65000</span><span class="sxs-lookup"><span data-stu-id="d4c2c-594">65000</span></span>|<span data-ttu-id="d4c2c-595">utf-7</span><span class="sxs-lookup"><span data-stu-id="d4c2c-595">utf-7</span></span>|<span data-ttu-id="d4c2c-596">Unicode (utf-7)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-596">Unicode (UTF-7)</span></span>|<span data-ttu-id="d4c2c-597">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-597">✓</span></span>|<span data-ttu-id="d4c2c-598">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-598">✓</span></span>|  
|<span data-ttu-id="d4c2c-599">65001</span><span class="sxs-lookup"><span data-stu-id="d4c2c-599">65001</span></span>|<span data-ttu-id="d4c2c-600">utf-8</span><span class="sxs-lookup"><span data-stu-id="d4c2c-600">utf-8</span></span>|<span data-ttu-id="d4c2c-601">Unicode (UTF-8)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-601">Unicode (UTF-8)</span></span>|<span data-ttu-id="d4c2c-602">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-602">✓</span></span>|<span data-ttu-id="d4c2c-603">✓</span><span class="sxs-lookup"><span data-stu-id="d4c2c-603">✓</span></span>|  
  
 <span data-ttu-id="d4c2c-604">下列範例會呼叫<xref:System.Text.Encoding.GetEncoding%28System.Int32%29>和<xref:System.Text.Encoding.GetEncoding%28System.String%29>方法，以取得希臘文 (Windows) 程式碼頁面的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-604">The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding.</span></span> <span data-ttu-id="d4c2c-605">它會比較<xref:System.Text.Encoding>顯示相等，並接著對應會顯示的 Unicode 字碼指標及相對應的字碼頁值，每個字元希臘文字母中的方法呼叫所傳回的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-605">It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</span></span>  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 <span data-ttu-id="d4c2c-606">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-606">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-607">Utf-16 和 UTF-32 編碼器可以使用位元組由大到小位元組順序 (最大顯著性位元組第一次) 或小小的位元組由小到大位元組順序 (最小顯著性位元組第一次)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-607">The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</span></span> <span data-ttu-id="d4c2c-608">例如，(u+0041) 序列化為 Latin Capital Letter 如下 （以十六進位方式）：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-608">For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="d4c2c-609">Utf-16 位元組由大到小位元組順序： 00 41</span><span class="sxs-lookup"><span data-stu-id="d4c2c-609">UTF-16 big endian byte order: 00 41</span></span>  
  
-   <span data-ttu-id="d4c2c-610">Utf-16 少位元組由小到大位元組順序： 41 00</span><span class="sxs-lookup"><span data-stu-id="d4c2c-610">UTF-16 little endian byte order: 41 00</span></span>  
  
-   <span data-ttu-id="d4c2c-611">UTF-32 位元組由大到小位元組順序： 00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="d4c2c-611">UTF-32 big endian byte order: 00 00 00 41</span></span>  
  
-   <span data-ttu-id="d4c2c-612">UTF-32 少位元組由小到大位元組順序： 41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="d4c2c-612">UTF-32 little endian byte order: 41 00 00 00</span></span>  
  
 <span data-ttu-id="d4c2c-613">它會儲存使用原生的位元組順序的 Unicode 字元通常更有效率。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-613">It is generally more efficient to store Unicode characters using the native byte order.</span></span> <span data-ttu-id="d4c2c-614">比方說，最好使用位元組由小到大的位元組順序少位元組由小到大的平台，例如 Intel 的電腦上。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-614">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span>  
  
 <span data-ttu-id="d4c2c-615"><xref:System.Text.Encoding.GetPreamble%2A>方法會擷取的位元組陣列，其中包含位元組順序標記 (BOM)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-615">The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM).</span></span> <span data-ttu-id="d4c2c-616">如果這個位元組陣列，做為編碼的資料流前置詞，它可協助找出所使用的編碼格式的解碼器。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-616">If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</span></span>  
  
 <span data-ttu-id="d4c2c-617">如需有關位元組順序和位元組順序標記的詳細資訊，請參閱 Unicode Standard > [Unicode 首頁](http://go.microsoft.com/fwlink/?LinkId=37123)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-617">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
 <span data-ttu-id="d4c2c-618">請注意，編碼的類別可讓錯誤：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-618">Note that the encoding classes allow errors to:</span></span>  
  
-   <span data-ttu-id="d4c2c-619">以無訊息模式變更為"？"字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-619">Silently change to a "?" character.</span></span>  
  
-   <span data-ttu-id="d4c2c-620">使用"best fit"的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-620">Use a "best fit" character.</span></span>  
  
-   <span data-ttu-id="d4c2c-621">透過使用特定應用程式的行為變更<xref:System.Text.EncoderFallback>和<xref:System.Text.DecoderFallback>U + FFFD Unicode replacement character 類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-621">Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.</span></span>  
  
 <span data-ttu-id="d4c2c-622">您應該在發生任何資料流的錯誤會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-622">You should throw an exception on any data stream error.</span></span> <span data-ttu-id="d4c2c-623">應用程式會使用"throwonerror 」 旗標適用時，或使用<xref:System.Text.EncoderExceptionFallback>和<xref:System.Text.DecoderExceptionFallback>類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-623">An app either uses a "throwonerror" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes.</span></span> <span data-ttu-id="d4c2c-624">通常不建議使用自動調整的後援，因為它可能會導致資料遺失或造成混淆且低於簡單的字元取代。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-624">Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</span></span> <span data-ttu-id="d4c2c-625">ANSI 編碼，則自動調整的行為是預設值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-625">For ANSI encodings, the best fit behavior is the default.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-626">下列範例會將字串轉換到另一個編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-626">The following example converts a string from one encoding to another.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-627">Byte [] 陣列是唯一的型別，在此範例中，其中包含編碼的資料。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-627">The byte[] array is the only type in this example that contains the encoded data.</span></span> <span data-ttu-id="d4c2c-628">.NET Char 和字串型別是本身是使用 Unicode，因此<xref:System.Text.Encoding.GetChars%2A>呼叫解碼 Unicode 資料。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-628">The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-629">初始化 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-629">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-630">初始化 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-630">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-631">在衍生的類別覆寫這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-631">Derived classes override this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">
          <span data-ttu-id="d4c2c-632">慣用編碼方式的字碼頁識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-632">The code page identifier of the preferred encoding.</span>
          </span>
          <span data-ttu-id="d4c2c-633">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-633">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-634">0，表示使用預設的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-634">0, to use the default encoding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-635">初始化對應到指定字碼頁之 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-635">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-636">在衍生的類別覆寫這個建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-636">Derived classes override this constructor.</span></span>  
  
 <span data-ttu-id="d4c2c-637">從衍生類別呼叫這個建構函式建立<xref:System.Text.Encoding>編碼和解碼作業中使用自動調整的後援的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-637">Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations.</span></span> <span data-ttu-id="d4c2c-638">同時<xref:System.Text.Encoding.DecoderFallback%2A>和<xref:System.Text.Encoding.EncoderFallback%2A>屬性是唯讀的而且無法修改。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-638">Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified.</span></span> <span data-ttu-id="d4c2c-639">若要控制後援策略類別衍生自<xref:System.Text.Encoding>，呼叫<xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-639">To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-640">
            <paramref name="codePage" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-640">
              <paramref name="codePage" /> is less than zero.</span>
          </span>
        </exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">
          <span data-ttu-id="d4c2c-641">編碼方式字碼頁識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-641">The encoding code page identifier.</span>
          </span>
        </param>
        <param name="encoderFallback">
          <span data-ttu-id="d4c2c-642">物件，該物件會在無法以目前編碼方式將字元編碼時提供錯誤處理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-642">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span>
          </span>
        </param>
        <param name="decoderFallback">
          <span data-ttu-id="d4c2c-643">物件，該物件會在無法以目前編碼方式將位元組序列解碼時提供錯誤處理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-643">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-644">使用指定的編碼器和解碼器後援策略，初始化對應到指定字碼頁之 <see cref="T:System.Text.Encoding" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-644">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-645">這個建構函式`protected`; 衍生類別覆寫它。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-645">This constructor is `protected`; derived classes override it.</span></span>  
  
 <span data-ttu-id="d4c2c-646">您可以呼叫這個建構函式從衍生的類別，來控制此後援編碼和解碼策略。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-646">You call this constructor from a derived class to control the fallback encoding and decoding strategies.</span></span> <span data-ttu-id="d4c2c-647"><xref:System.Text.Encoding>類別建構函式建立唯讀編碼器或解碼器後援物件建立之後，設定不允許的編碼物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-647">The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</span></span>  
  
 <span data-ttu-id="d4c2c-648">如果有任一`encoderFallback`或`decoderFallback`為 null，自動調整的後援作為相對應的後援策略。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-648">If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-649">
            <paramref name="codePage" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-649">
              <paramref name="codePage" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-650">取得 ASCII (7 位元) 字元集 (Character Set) 的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-650">Gets an encoding for the ASCII (7-bit) character set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-651">ASCII (7 位元) 字元集的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-651">An  encoding for the ASCII (7-bit) character set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-652">ASCII 字元僅限於從 u+0000 到 U + 007F 最低 128 個 Unicode 字元中，項目。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-652">ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</span></span>  
  
 <span data-ttu-id="d4c2c-653">選取您的應用程式的 ASCII 編碼方式，請考慮下列各項：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-653">When selecting the ASCII encoding for your app, consider the following:</span></span>  
  
-   <span data-ttu-id="d4c2c-654">ASCII 編碼的是，這通常適用於需要 ASCII 的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-654">The ASCII encoding is usually appropriate for protocols that require ASCII.</span></span>  
  
-   <span data-ttu-id="d4c2c-655">如果您需要 8 位元編碼 （這有時會錯誤地稱為 「 ASCII 」），將 ASCII 建議 utf-8 編碼的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-655">If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</span></span> <span data-ttu-id="d4c2c-656">字元 0 7F，結果都一樣，但使用 utf-8 避免資料遺失，藉由使用可顯示的所有 Unicode 字元表示法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-656">For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</span></span> <span data-ttu-id="d4c2c-657">請注意，ASCII 編碼的 8 位元的模稜兩可，可以讓惡意使用，但 utf-8 編碼方式移除相關的 8 位元的模稜兩可。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-657">Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</span></span>  
  
-   <span data-ttu-id="d4c2c-658">.NET Framework 2.0 版之前的.NET Framework 會允許詐騙略過的 8 位元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-658">Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</span></span> <span data-ttu-id="d4c2c-659">從.NET Framework 2.0 開始，非 ASCII 碼點切換回在解碼期間。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-659">Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</span></span>  
  
 <span data-ttu-id="d4c2c-660"><xref:System.Text.ASCIIEncoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-660">The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span> <span data-ttu-id="d4c2c-661">它會使用取代後援來取代無法編碼的每個字串和無法解碼的每個位元組以問號 ("？") 字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-661">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="d4c2c-662">相反地，您可以呼叫<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>方法具現化<xref:System.Text.ASCIIEncoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-662">Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-663">下列範例示範的 ASCII 編碼字元的 ASCII 範圍之外的效果。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-663">The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</span></span>  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-664">取得 UTF-16 格式的編碼方式，其使用由大到小的位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-664">Gets an encoding for the UTF-16 format that uses the big endian byte order.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-665">UTF-16 格式的編碼物件，這個格式使用位元組由大到小的位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-665">An encoding object for the UTF-16 format that uses the big endian byte order.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-666"><xref:System.Text.UnicodeEncoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-666">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="d4c2c-667">它會使用取代後援來取代無法編碼的每個字串和無法解碼的每個位元組以問號 ("？") 字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-667">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="d4c2c-668">相反地，您可以呼叫<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化 big endian<xref:System.Text.UnicodeEncoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-668">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 <span data-ttu-id="d4c2c-669">傳回<xref:System.Text.UnicodeEncoding>物件具有<xref:System.Text.Encoding.BodyName%2A>， <xref:System.Text.Encoding.HeaderName%2A>，和<xref:System.Text.Encoding.WebName%2A>產生名稱"unicodeFFFE"的屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-669">The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name "unicodeFFFE".</span></span> <span data-ttu-id="d4c2c-670">雖然 utf-16 位元組由大到小位元組順序標記是十六進位 FEFF，名稱"unicodeFFFE 」 已選擇，因為位元順序標記會顯示為十六進位 7C94:FFFE 少位元組由小到大的 Windows 電腦上。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-670">Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-671">下列範例會讀取文字檔案，以位元組由大到小位元組的順序，使用 utf-16 編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-671">The following example reads a text file with a UTF-16 encoding using the big endian byte order.</span></span>  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 <span data-ttu-id="d4c2c-672">下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-672">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-673">在衍生類別中覆寫時，取得可以與郵件代理程式主體標籤一起使用的目前編碼方式名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-673">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-674">可以與郵件代理程式主體標籤一起使用的目前 <see cref="T:System.Text.Encoding" /> 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-674">A name for the current <see cref="T:System.Text.Encoding" /> that can be used with mail agent body tags.</span>
          </span>
          <span data-ttu-id="d4c2c-675">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-675">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-676">如果無法使用目前的 <see cref="T:System.Text.Encoding" />，則為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-676">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-677">如果您需要的主體名稱的編碼方式，您應該呼叫<xref:System.Text.Encoding.GetEncoding%2A>與<xref:System.Text.Encoding.BodyName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-677">If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property.</span></span> <span data-ttu-id="d4c2c-678">通常方法會擷取不同的呼叫中提供的測試編碼所用的編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-678">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="d4c2c-679">通常只有電子郵件應用程式必須擷取這類的編碼方式;大部分需要描述的編碼方式的其他應用程式應該使用其<xref:System.Text.Encoding.WebName%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-679">Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.</span></span>  
  
 <span data-ttu-id="d4c2c-680">在某些情況下，值<xref:System.Text.Encoding.BodyName%2A>屬性會對應至國際標準，可定義該編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-680">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="d4c2c-681">這並不表示實作符合該標準的完整。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-681">This doesn't mean that the implementation complies in full with that standard.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-682">下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-682">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4c2c-683">它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-683">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-684">在衍生類別中覆寫時，會建立目前 <see cref="T:System.Text.Encoding" /> 物件的淺層複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-684">When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-685">目前 <see cref="T:System.Text.Encoding" /> 的複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-685">A copy of the current <see cref="T:System.Text.Encoding" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-686">複製為可寫入即使原始<xref:System.Text.Encoding>物件是唯讀的。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-686">The clone is writable even if the original <xref:System.Text.Encoding> object is read-only.</span></span> <span data-ttu-id="d4c2c-687">因此，您可修改複製品的屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-687">Therefore, the properties of the clone can be modified.</span></span>  
  
 <span data-ttu-id="d4c2c-688">物件的淺層複本是物件的一份只有。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-688">A shallow copy of an object is a copy of the object only.</span></span> <span data-ttu-id="d4c2c-689">如果物件包含其他物件的參考，則淺層複製不會建立參考物件的複本。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-689">If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</span></span> <span data-ttu-id="d4c2c-690">它改為參考原始物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-690">It refers to the original objects instead.</span></span> <span data-ttu-id="d4c2c-691">相較之下，物件的深層複本建立一份物件和一份直接或間接參考該物件的所有項目。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-691">In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-692">在衍生類別中覆寫時，取得目前 <see cref="T:System.Text.Encoding" /> 的字碼頁識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-692">When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-693">目前 <see cref="T:System.Text.Encoding" /> 的字碼頁識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-693">The code page identifier of the current <see cref="T:System.Text.Encoding" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4c2c-694">下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-694">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4c2c-695">它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-695">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-696">將位元組陣列由一種編碼方式轉換成另一種編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-696">Converts a byte array from one encoding to another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">
          <span data-ttu-id="d4c2c-697">
            <c>bytes</c> 的編碼格式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-697">The encoding format of <c>bytes</c>.</span>
          </span>
        </param>
        <param name="dstEncoding">
          <span data-ttu-id="d4c2c-698">目標編碼格式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-698">The target encoding format.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="d4c2c-699">要轉換的位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-699">The bytes to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-700">將整個位元組陣列從一種編碼方式轉換成另一種編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-700">Converts an entire byte array from one encoding to another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-701">
            <see cref="T:System.Byte" /> 類型的陣列，包含將 <paramref name="bytes" /> 從 <paramref name="srcEncoding" /> 轉換成 <paramref name="dstEncoding" /> 的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-701">An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4c2c-702">下列範例會將 Unicode 編碼的字串轉換成 ASCII 編碼的字串。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-702">The following example converts a Unicode-encoded string to an ASCII-encoded string.</span></span> <span data-ttu-id="d4c2c-703">因為所傳回的 ASCII 編碼物件<xref:System.Text.Encoding.ASCII%2A>屬性使用取代後援，且 Pi 字元不是 ASCII 字元集的一部分，Pi 字元取代為問號，範例所示的輸出。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-703">Because the ASCII encoding object returned by the <xref:System.Text.Encoding.ASCII%2A> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-704">
            <paramref name="srcEncoding" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-704">
              <paramref name="srcEncoding" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-705">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-705">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-706">
            <paramref name="dstEncoding" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-706">
              <paramref name="dstEncoding" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-707">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-707">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-708">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-708">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-709">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-709">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-710">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-710">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-711">**srcEncoding。**</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-711">**srcEncoding.**</span>
          </span>
          <span data-ttu-id="d4c2c-712">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-712">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-713">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-713">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-714">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-714">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-715">**dstEncoding。**</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-715">**dstEncoding.**</span>
          </span>
          <span data-ttu-id="d4c2c-716">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-716">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">
          <span data-ttu-id="d4c2c-717">來源陣列 <c>bytes</c> 的編碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-717">The encoding of the source array, <c>bytes</c>.</span>
          </span>
        </param>
        <param name="dstEncoding">
          <span data-ttu-id="d4c2c-718">輸出陣列的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-718">The encoding of the output array.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="d4c2c-719">要進行轉換的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-719">The array of bytes to convert.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="d4c2c-720">
            <c>bytes</c> 中要轉換的第一個項目索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-720">The index of the first element of <c>bytes</c> to convert.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-721">要轉換的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-721">The number of bytes to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-722">將位元組陣列中的某一位元組範圍由一種編碼方式轉換成另一種編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-722">Converts a range of bytes in a byte array from one encoding to another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-723">
            <see cref="T:System.Byte" /> 類型的陣列，包含將 <paramref name="bytes" /> 中的某個位元組範圍從 <paramref name="srcEncoding" /> 轉換成 <paramref name="dstEncoding" /> 的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-723">An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-724">
            <paramref name="srcEncoding" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-724">
              <paramref name="srcEncoding" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-725">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-725">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-726">
            <paramref name="dstEncoding" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-726">
              <paramref name="dstEncoding" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-727">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-727">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-728">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-728">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-729">
            <paramref name="index" /> 和 <paramref name="count" /> 不會指定位元組陣列中的有效範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-729">
              <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-730">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-730">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-731">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-731">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-732">**srcEncoding。**</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-732">**srcEncoding.**</span>
          </span>
          <span data-ttu-id="d4c2c-733">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-733">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-734">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-734">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-735">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-735">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-736">**dstEncoding。**</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-736">**dstEncoding.**</span>
          </span>
          <span data-ttu-id="d4c2c-737">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-737">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-738">取得或設定目前 <see cref="T:System.Text.DecoderFallback" /> 物件的 <see cref="T:System.Text.Encoding" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-738">Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-739">目前 <see cref="T:System.Text.Encoding" /> 物件的解碼器後援物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-739">The decoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-740"><xref:System.Text.DecoderFallback>物件都代表編碼的位元組序列無法解碼成字元時，會叫用錯誤處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-740">The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</span></span> <span data-ttu-id="d4c2c-741">支援下列處理常式類型的任何一個：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-741">Any one of the following handler types is supported:</span></span>  
  
-   <span data-ttu-id="d4c2c-742">自動調整後援處理常式，這會取代一些合適的替代字元取代無法解碼的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-742">A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</span></span>  
  
-   <span data-ttu-id="d4c2c-743">取代後援處理常式，其中某些任意的取代字元來取代無法解碼的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-743">A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</span></span> <span data-ttu-id="d4c2c-744">.NET 包含一個取代後援處理常式， <xref:System.Text.DecoderFallback>，依預設以問號取代無法解碼的位元組 ("？") 字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-744">.NET includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</span></span>  
  
-   <span data-ttu-id="d4c2c-745">例外狀況後援處理常式，它無法解碼位元組時，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-745">An exception fallback handler, which throws an exception when bytes cannot be decoded.</span></span> <span data-ttu-id="d4c2c-746">.NET 包含一個例外狀況後援處理常式， <xref:System.Text.DecoderExceptionFallback>，哪些則會擲回<xref:System.Text.DecoderFallbackException>時無法解碼的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-746">.NET includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-747">設定作業中的值是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-747">The value in a set operation is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d4c2c-748">無法在設定作業中指派值，因為目前的 <see cref="T:System.Text.Encoding" /> 物件是唯讀的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-748">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-749">取得此 .NET 實作的預設編碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-749">Gets the default encoding for this .NET implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-750">預設的編碼此.NET 實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-750">The default encoding for this .NET implementation.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  <span data-ttu-id="d4c2c-751">不同的電腦可以使用不同的編碼預設值，而且預設的編碼方式可以在單一電腦上的方式來變更。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-751">Different computers can use different encodings as the default, and the default encoding can change on a single computer.</span></span> <span data-ttu-id="d4c2c-752">如果您使用<xref:System.Text.Encoding.Default%2A>編碼進行編碼和解碼資料流處理的電腦之間或在同一部電腦上的不同時間擷取資料，它可能會轉譯該資料不正確。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-752">If you use the <xref:System.Text.Encoding.Default%2A> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</span></span> <span data-ttu-id="d4c2c-753">此外，編碼傳回<xref:System.Text.Encoding.Default%2A>屬性會自動調整的後援使用不支援的字元對應到字碼頁所支援的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-753">In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</span></span> <span data-ttu-id="d4c2c-754">基於這些理由，不建議使用預設的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-754">For these reasons, using the default encoding is not recommended.</span></span> <span data-ttu-id="d4c2c-755">若要確保正確解碼已編碼的位元組，您應該使用 Unicode 編碼，例如<xref:System.Text.UTF8Encoding>或<xref:System.Text.UnicodeEncoding>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-755">To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>.</span></span> <span data-ttu-id="d4c2c-756">您也可以使用較高層級的通訊協定，以確保相同的格式用於編碼和解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-756">You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</span></span>  

### <a name="the-default-property-in-the-net-framework"></a><span data-ttu-id="d4c2c-757">.NET Framework 中的預設屬性</span><span class="sxs-lookup"><span data-stu-id="d4c2c-757">The Default property in the .NET Framework</span></span>

<span data-ttu-id="d4c2c-758">在 Windows 桌面上，.NET Framework 中<xref:System.Text.Encoding.Default%2A>屬性一律會取得系統的使用中的字碼頁，並建立<xref:System.Text.Encoding>對應至它的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-758">In the .NET Framework on the Windows desktop, the <xref:System.Text.Encoding.Default%2A> property always gets the system's active code page and creates a <xref:System.Text.Encoding> object that corresponds to it.</span></span> <span data-ttu-id="d4c2c-759">作用中的字碼頁可能包含字碼頁來設定以及不同的其他字元的 ASCII 字元的 ANSI 字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-759">The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</span></span> <span data-ttu-id="d4c2c-760">因為所有<xref:System.Text.Encoding.Default%2A>根據 ANSI 字碼頁的編碼會遺失資料，請考慮使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>改為編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-760">Because all <xref:System.Text.Encoding.Default%2A> encodings based on ANSI code pages lose data, consider using the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encoding instead.</span></span> <span data-ttu-id="d4c2c-761">Utf-8 通常的 U + 00 到 U + 7F 範圍相同，但可以編碼而不會遺失 ASCII 範圍之外的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-761">UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</span></span>

## <a name="the-default-property-on-net-core"></a><span data-ttu-id="d4c2c-762">在.NET Core 上的預設屬性</span><span class="sxs-lookup"><span data-stu-id="d4c2c-762">The Default property on .NET Core</span></span>

<span data-ttu-id="d4c2c-763">在.NET Core<xref:System.Text.Encoding.Default%2A>屬性一律會傳回<xref:System.Text.UTF8Encoding>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-763">On .NET Core, the <xref:System.Text.Encoding.Default%2A> property always returns the <xref:System.Text.UTF8Encoding>.</span></span> <span data-ttu-id="d4c2c-764">Utf-8 支援的所有作業系統 （Windows、 Linux 和最大 OS X） 上執行的.NET Core 應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-764">UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-765">取得或設定目前 <see cref="T:System.Text.EncoderFallback" /> 物件的 <see cref="T:System.Text.Encoding" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-765">Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-766">目前 <see cref="T:System.Text.Encoding" /> 物件的解碼器後援物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-766">The encoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-767"><xref:System.Text.EncoderFallback>物件都代表一個字元無法轉換成編碼的位元組序列時所叫用錯誤處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-767">The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</span></span> <span data-ttu-id="d4c2c-768">支援下列處理常式類型的任何一個：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-768">Any one of the following handler types is supported:</span></span>  
  
-   <span data-ttu-id="d4c2c-769">自動調整後援處理常式，這會取代一些合適的替代字元取代無法編碼的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-769">A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</span></span>  
  
-   <span data-ttu-id="d4c2c-770">取代後援處理常式，這會取代某些任意的取代字元無法編碼的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-770">A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</span></span> <span data-ttu-id="d4c2c-771">.NET 包含一個取代後援處理常式， <xref:System.Text.EncoderFallback>，其預設值取代無法編碼的字元以問號 ("？") 字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-771">.NET includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</span></span>  
  
-   <span data-ttu-id="d4c2c-772">例外狀況後援處理常式，它會在無法編碼字元時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-772">An exception fallback handler, which throws an exception when characters cannot be encoded.</span></span> <span data-ttu-id="d4c2c-773">.NET 包含一個例外狀況後援處理常式， <xref:System.Text.EncoderExceptionFallback>，哪些則會擲回<xref:System.Text.EncoderFallbackException>無法解碼字元時。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-773">.NET includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-774">設定作業中的值是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-774">The value in a set operation is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d4c2c-775">無法在設定作業中指派值，因為目前的 <see cref="T:System.Text.Encoding" /> 物件是唯讀的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-775">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-776">在衍生類別中覆寫時，取得目前編碼方式的人們可讀取 (Human-Readable) 的描述。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-776">When overridden in a derived class, gets the human-readable description of the current encoding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-777">目前 <see cref="T:System.Text.Encoding" /> 的人們可讀取的描述。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-777">The human-readable description of the current <see cref="T:System.Text.Encoding" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-778"><xref:System.Text.Encoding.EncodingName%2A>屬性供顯示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-778">The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display.</span></span> <span data-ttu-id="d4c2c-779">若要尋找的名稱，可以傳遞至<xref:System.Text.Encoding.GetEncoding%2A>方法，請使用<xref:System.Text.Encoding.WebName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-779">To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-780">下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-780">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4c2c-781">它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-781">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="d4c2c-782">要與目前執行個體比較的 <see cref="T:System.Object" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-782">The <see cref="T:System.Object" /> to compare with the current instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-783">判斷指定的 <see cref="T:System.Object" /> 和目前的執行個體是否相等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-783">Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-784">如果 <paramref name="value" /> 是 <see cref="T:System.Text.Encoding" /> 的執行個體，並且等於目前的執行個體，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-784">
              <see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-785">兩個執行個體<xref:System.Text.Encoding>會被視為相等，如果它們對應到相同的字碼頁和他們`EncoderFallback`和`DecoderFallback`物件是否相等。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-785">Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal.</span></span> <span data-ttu-id="d4c2c-786">特別是，所有的衍生的字碼頁有字碼頁為 0，而且其後援會正常`null`(`Nothing`在 Visual Basic.NET)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-786">In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET).</span></span> <span data-ttu-id="d4c2c-787">因此，全部都視為等於另一個。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-787">Thus they are all considered equal to one another.</span></span> <span data-ttu-id="d4c2c-788">一種結果是，當<xref:System.Text.Encoding.Equals%2A>用來填入雜湊表，所有衍生相等的編碼方式比較屬於相同的雜湊表位置。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-788">One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-789">下列範例會取得兩個相同的編碼 （字碼頁的一個），依名稱的另一個執行個體，並檢查它們相等。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-789">The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-790">在衍生類別中覆寫時，計算編碼一組字元所產生的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-790">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="d4c2c-791">字元陣列，包含要編碼的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-791">The character array containing the characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-792">在衍生類別中覆寫時，計算編碼指定字元陣列中所有字元所產生的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-792">When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-793">編碼指定字元陣列中所有字元所產生的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-793">The number of bytes produced by encoding all the characters in the specified character array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-794">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>若要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-794">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-795">若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-795">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-796"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-796">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-797"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-797">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-798"><xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-798">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-799">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-799">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-800">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-800">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-801">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-801">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-802">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-802">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="d4c2c-803">如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-803">If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="d4c2c-804">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-804">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-805">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-805">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-806">如果您的應用程式必須轉換大量資料，您應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-806">If your app must convert a large amount of data, you should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-807">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-807">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-808">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-808">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-809">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-809">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-810">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-810">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-811">下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-811">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-812">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-812">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-813">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-813">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-814">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-814">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-815">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-815">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="d4c2c-816">字串，包含要編碼的一組字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-816">The string containing the set of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-817">在衍生類別中覆寫時，計算編碼指定的字串字元所產生的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-817">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-818">編碼指定字元所產生的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-818">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-819">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>若要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-819">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-820">若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-820">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-821"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-821">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-822"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-822">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-823"><xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-823">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-824">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-824">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-825">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-825">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-826">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-826">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-827">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-827">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="d4c2c-828">如果您的應用程式會處理字串輸入的字串版本<xref:System.Text.Encoding.GetBytes%2A>建議。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-828">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>  
  
-   <span data-ttu-id="d4c2c-829">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-829">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-830">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-830">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-831">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-831">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-832">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-832">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-833">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-833">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-834">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-834">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-835">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-835">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-836">下列範例會決定編碼的字串或字串中的範圍所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-836">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-837">
            <paramref name="s" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-837">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-838">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-838">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-839">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-839">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-840">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-840">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="d4c2c-841">要編碼的第一個字元指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-841">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-842">要編碼的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-842">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-843">在衍生類別中覆寫時，計算從指定的字元指標開始，編碼一組字元所產生的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-843">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-844">編碼指定字元所產生的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-844">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-845">若要計算確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>需要儲存產生的位元組，您應該呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-845">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-846">若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-846">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-847"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-847">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-848"><xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-848">The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-849"><xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-849">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-850">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-850">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-851">以下是使用這些方法的一些考量：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-851">The following are some considerations for using these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-852">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-852">Your app may need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-853">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-853">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="d4c2c-854">如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-854">If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="d4c2c-855">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%2A>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-855">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-856">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-856">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-857">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-857">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-858">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-858">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-859">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-859">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-860">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-860">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-861">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-861">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-862">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-862">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-863">
            <paramref name="count" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-863">
              <paramref name="count" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-864">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-864">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-865">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-865">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-866">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-866">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d4c2c-867">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-867">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d4c2c-868">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-868">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="d4c2c-869">包含要解碼之一組字元的字元陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-869">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="d4c2c-870">要編碼的第一個字元索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-870">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-871">要編碼的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-871">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-872">在衍生類別中覆寫時，計算從指定的字元陣列編碼一組字元所產生的位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-872">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-873">編碼指定字元所產生的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-873">The number of bytes produced by encoding the specified characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-874">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>若要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-874">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-875">若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-875">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-876"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-876">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-877"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-877">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-878"><xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-878">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-879">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-879">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-880">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-880">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-881">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-881">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-882">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-882">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>  
  
-   <span data-ttu-id="d4c2c-883">如果您的應用程式會處理字串輸入的字串版本<xref:System.Text.Encoding.GetBytes%2A>建議。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-883">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>  
  
-   <span data-ttu-id="d4c2c-884">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-884">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-885">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-885">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-886">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-886">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-887">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-887">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-888">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-888">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-889">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-889">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-890">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-890">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-891">下列範例會決定編碼字元陣列中的三個字元所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-891">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-892">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-892">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-893">
            <paramref name="index" /> 或 <paramref name="count" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-893">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-894">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-894">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-895">
            <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="chars" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-895">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-896">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-896">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-897">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-897">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-898">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-898">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-899">在衍生類別中覆寫時，將一組字元編碼成位元組序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-899">When overridden in a derived class, encodes a set of characters into a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="d4c2c-900">字元陣列，包含要編碼的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-900">The character array containing the characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-901">在衍生類別中覆寫時，將指定字元陣列中的所有字元編碼成位元組序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-901">When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-902">位元組陣列，包含將指定之一組字元編碼之後的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-902">A byte array containing the results of encoding the specified set of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-903">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-903">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-904"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-904">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-905"><xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-905">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-906">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-906">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-907">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-907">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-908">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-908">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-909">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-909">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="d4c2c-910">（例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-910">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="d4c2c-911"><xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-911">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="d4c2c-912"><xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-912"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="d4c2c-913">如果您的應用程式會處理字串輸入，您應該呼叫的字串版本<xref:System.Text.Encoding.GetBytes%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-913">If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>  
  
-   <span data-ttu-id="d4c2c-914">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-914">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-915">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-915">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-916">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-916">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-917">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-917">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-918">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-918">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-919">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-919">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-920">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-920">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-921">下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-921">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-922">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-922">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-923">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-923">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-924">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-924">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-925">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-925">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="d4c2c-926">字串，包含要編碼的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-926">The string containing the characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-927">在衍生類別中覆寫時，將指定字串中的所有字元編碼成位元組序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-927">When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-928">位元組陣列，包含將指定之一組字元編碼之後的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-928">A byte array containing the results of encoding the specified set of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-929">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-929">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-930"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-930">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-931"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-931">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-932">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-932">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-933">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-933">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-934">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-934">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-935">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-935">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="d4c2c-936">（例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-936">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="d4c2c-937"><xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-937">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="d4c2c-938"><xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-938"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="d4c2c-939">如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-939">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="d4c2c-940">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-940">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-941">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-941">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-942">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-942">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-943">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-943">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-944">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-944">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-945">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-945">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-946">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-946">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-947">下列範例會決定編碼的字串或字串中的範圍所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-947">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-948">
            <paramref name="s" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-948">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-949">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-949">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-950">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-950">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-951">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-951">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="d4c2c-952">包含要解碼之一組字元的字元陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-952">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="d4c2c-953">要編碼的第一個字元索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-953">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-954">要編碼的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-954">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-955">在衍生類別中覆寫時，將指定字元陣列中的一組字元編碼成位元組序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-955">When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-956">位元組陣列，包含將指定之一組字元編碼之後的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-956">A byte array containing the results of encoding the specified set of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-957">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-957">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-958"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-958">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-959"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-959">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-960">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-960">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-961">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-961">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-962">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-962">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-963">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-963">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="d4c2c-964">（例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-964">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="d4c2c-965"><xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-965">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="d4c2c-966"><xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-966"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="d4c2c-967">如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-967">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="d4c2c-968">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-968">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-969">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-969">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-970">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-970">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-971">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-971">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-972">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-972">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-973">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-973">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-974">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-974">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-975">下列範例會決定編碼字元陣列中的三個字元所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-975">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-976">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-976">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-977">
            <paramref name="index" /> 或 <paramref name="count" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-977">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-978">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-978">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-979">
            <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="chars" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-979">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-980">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-980">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-981">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-981">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-982">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-982">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="d4c2c-983">要編碼的第一個字元指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-983">A pointer to the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="d4c2c-984">要編碼的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-984">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="d4c2c-985">開始寫入結果位元組序列的位置指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-985">A pointer to the location at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="d4c2c-986">寫入的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-986">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-987">在衍生類別中覆寫時，從指定字元指標開始將一組字元編碼成位元組序列 (會從指定的位元組指標開始存放這些位元組)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-987">When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-988">
            <paramref name="bytes" /> 參數所指示位置上寫入的實際位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-988">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-989">若要計算確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>需要儲存產生的位元組，呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-989">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-990">若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-990">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-991"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-991">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-992">如果要轉換的數據僅在順序塊中可用（例如從流中讀取的數據），或者如果數據量太大以至於需要將其分成較小的塊，則應使用提供的<xref:System.Text.Decoder>或<xref:System.Text.Encoder>對象 分別由<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>種方法派生的類。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-992">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-993"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-993">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-994"><xref:System.Text.Encoding.GetBytes%2A>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-994">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-995">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-995">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-996">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-996">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-997">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-997">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-998">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-998">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="d4c2c-999">（例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-999">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="d4c2c-1000"><xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1000">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="d4c2c-1001"><xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1001"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="d4c2c-1002">如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1002">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="d4c2c-1003">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1003">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-1004">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1004">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1005">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1005">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1006">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1006">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1007">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1007">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-1008">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1008">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1009">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1009">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1010">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1010">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1011">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1011">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1012">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1012">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1013">
            <paramref name="charCount" /> 或 <paramref name="byteCount" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1013">
              <paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1014">
            <paramref name="byteCount" /> 小於結果位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1014">
              <paramref name="byteCount" /> is less than the resulting number of bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-1015">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1015">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1016">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1016">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1017">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1017">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d4c2c-1018">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1018">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d4c2c-1019">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1019">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">
          <span data-ttu-id="d4c2c-1020">包含要解碼之一組字元的字元陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1020">The character array containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="d4c2c-1021">要編碼的第一個字元索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1021">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="d4c2c-1022">要編碼的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1022">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1023">要包含結果位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1023">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="d4c2c-1024">要開始寫入結果位元組序列的索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1024">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1025">在衍生類別中覆寫時，將指定字元陣列中的一組字元編碼成指定的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1025">When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1026">寫入 <paramref name="bytes" /> 的實際位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1026">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1027">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>來儲存產生的位元組，您應該呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1027">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1028">若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1028">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1029"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1029">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1030">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1030">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1031"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1031">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-1032"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1032">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1033">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1033">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1034">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1034">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1035">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1035">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-1036">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1036">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="d4c2c-1037">（例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1037">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="d4c2c-1038"><xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1038">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="d4c2c-1039"><xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1039"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="d4c2c-1040">如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1040">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="d4c2c-1041">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1041">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-1042">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1042">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1043">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1043">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1044">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1044">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1045">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1045">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-1046">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1046">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1047">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1047">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1048">下列範例會決定編碼字元陣列中的三個字元所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1048">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1049">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1049">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1050">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1050">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1051">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1051">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1052">
            <paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1052">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-1053">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1053">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1054">
            <paramref name="charIndex" /> 與 <paramref name="charCount" /> 不代表 <paramref name="chars" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1054">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1055">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1055">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1056">
            <paramref name="byteIndex" /> 在 <paramref name="bytes" /> 中不是有效的索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1056">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1057">從 <paramref name="bytes" /> 到陣列結尾處，<paramref name="byteIndex" /> 沒有足夠的容量容納結果位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1057">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-1058">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1058">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1059">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1059">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1060">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1060">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <span data-ttu-id="d4c2c-1061">字串，包含要編碼的一組字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1061">The string containing the set of characters to encode.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="d4c2c-1062">要編碼的第一個字元索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1062">The index of the first character to encode.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="d4c2c-1063">要編碼的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1063">The number of characters to encode.</span>
          </span>
        </param>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1064">要包含結果位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1064">The byte array to contain the resulting sequence of bytes.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="d4c2c-1065">要開始寫入結果位元組序列的索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1065">The index at which to start writing the resulting sequence of bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1066">在衍生類別中覆寫時，將指定字串中的一組字元編碼成指定的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1066">When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1067">寫入 <paramref name="bytes" /> 的實際位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1067">The actual number of bytes written into <paramref name="bytes" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1068">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>來儲存產生的位元組，您應該呼叫<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1068">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1069">若要計算最大陣列大小，請呼叫<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1069">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1070"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1070">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1071">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1071">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1072"><xref:System.Text.Encoding.GetByteCount%2A>方法會判斷多少個位元組會導致一組 Unicode 字元的編碼方式和<xref:System.Text.Encoding.GetBytes%2A>方法會執行實際的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1072">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="d4c2c-1073"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法，用來處理單一的輸入資料流的多個轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1073">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1074">數個版本的<xref:System.Text.Encoding.GetByteCount%2A>和<xref:System.Text.Encoding.GetBytes%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1074">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1075">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1075">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1076">您的應用程式可能需要許多輸入的字元，為字碼頁編碼與處理使用多個呼叫的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1076">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="d4c2c-1077">在此案例中，您可能需要呼叫，並考量保存的狀態之間維持狀態<xref:System.Text.Encoder>物件所使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1077">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="d4c2c-1078">（例如，字元序列，其中包含 surrogate 字組可能的結尾為高 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1078">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="d4c2c-1079"><xref:System.Text.Encoder>會記住該高 surrogate，以便它可以結合下列的呼叫開頭為低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1079">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="d4c2c-1080"><xref:System.Text.Encoding> 將無法維護狀態，因此該字元將會傳送至<xref:System.Text.EncoderFallback>。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1080"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>  
  
-   <span data-ttu-id="d4c2c-1081">如果您的應用程式會處理字串輸入，您應該使用的字串版本<xref:System.Text.Encoding.GetBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1081">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>  
  
-   <span data-ttu-id="d4c2c-1082">Unicode 字元的緩衝區版本<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用多個呼叫使用<xref:System.Text.Encoder>物件或插入現有的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1082">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="d4c2c-1083">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1083">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1084">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1084">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1085">在此情況下，<xref:System.Text.Encoding.GetBytes%2A>支援位元組陣列的版本是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1085">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1086">請考慮使用<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1086">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="d4c2c-1087">轉換方法將盡可能的情況下，最多資料，並會擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1087">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1088">如果是連續資料流的編碼，此方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1088">For continuous encoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1089">下列範例會決定編碼的字串或字串中的範圍所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1089">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1090">
            <paramref name="s" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1090">
              <paramref name="s" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1091">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1091">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1092">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1092">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1093">
            <paramref name="charIndex" />、<paramref name="charCount" /> 或 <paramref name="byteIndex" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1093">
              <paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-1094">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1094">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1095">
            <paramref name="charIndex" /> 與 <paramref name="charCount" /> 不代表 <paramref name="chars" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1095">
              <paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1096">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1096">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1097">
            <paramref name="byteIndex" /> 在 <paramref name="bytes" /> 中不是有效的索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1097">
              <paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1098">從 <paramref name="bytes" /> 到陣列結尾處，<paramref name="byteIndex" /> 沒有足夠的容量容納結果位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1098">
              <paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-1099">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1099">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1100">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1100">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1101">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1101">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1102">在衍生類別中覆寫時，計算解碼位元組序列所產生的字元數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1102">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1103">包含要解碼之位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1103">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1104">在衍生類別中覆寫時，計算解碼指定位元組陣列中所有位元組所產生的字元數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1104">When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1105">解碼指定位元組序列所產生的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1105">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1106">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1106">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method.</span></span> <span data-ttu-id="d4c2c-1107">若要計算最大陣列大小，您應該使用<xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1107">To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method.</span></span> <span data-ttu-id="d4c2c-1108"><xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1108">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1109"><xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>方法會執行實際的解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1109">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding.</span></span> <span data-ttu-id="d4c2c-1110"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1110">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1111">數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1111">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1112">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1112">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1113">您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1113">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="d4c2c-1114">在此情況下，您可能需要維護呼叫之間的狀態。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1114">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="d4c2c-1115">如果您的應用程式會處理字串輸出，您應該使用<xref:System.Text.Encoding.GetString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1115">If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="d4c2c-1116">由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1116">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="d4c2c-1117">位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1117">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="d4c2c-1118">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1118">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1119">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1119">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1120">在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1120">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1121">請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1121">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="d4c2c-1122">轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1122">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1123">連續解碼資料流，這個方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1123">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1124">下列範例會將字串編碼成位元組陣列，並接著將位元組解碼成字元陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1124">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1125">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1125">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1126">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1126">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1127">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1127">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1128">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1128">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1129">要解碼的第一個位元組指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1129">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-1130">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1130">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1131">在衍生類別中覆寫時，計算從指定的位元組指標開始，解碼位元組序列所產生的字元數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1131">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1132">解碼指定位元組序列所產生的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1132">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1133">若要計算確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>需要儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1133">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1134">若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1134">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1135"><xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1135">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1136"><xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1136">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="d4c2c-1137"><xref:System.Text.Encoding.GetChars%2A>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1137">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1138">數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1138">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1139">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1139">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1140">您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1140">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="d4c2c-1141">在此情況下，您可能需要維護呼叫之間的狀態。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1141">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="d4c2c-1142">如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1142">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="d4c2c-1143">由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1143">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="d4c2c-1144">位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1144">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="d4c2c-1145">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1145">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1146">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1146">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1147">在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1147">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1148">請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1148">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="d4c2c-1149">轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1149">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1150">連續解碼資料流，這個方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1150">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1151">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1151">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1152">
            <paramref name="count" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1152">
              <paramref name="count" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1153">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1153">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1154">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1154">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1155">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1155">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d4c2c-1156">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1156">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d4c2c-1157">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1157">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1158">包含要解碼之位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1158">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="d4c2c-1159">要解碼的第一個位元組索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1159">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-1160">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1160">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1161">在衍生類別中覆寫時，計算從指定的位元組陣列解碼位元組序列所產生的字元數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1161">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1162">解碼指定位元組序列所產生的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1162">The number of characters produced by decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1163">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1163">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1164">若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1164">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1165"><xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1165">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1166"><xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1166">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="d4c2c-1167"><xref:System.Text.Encoding.GetChars%2A>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1167">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1168">數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1168">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1169">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1169">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1170">您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1170">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="d4c2c-1171">在此情況下，您可能需要維護呼叫之間的狀態。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1171">In this case, you probably need to maintain state between calls.</span></span>  
  
-   <span data-ttu-id="d4c2c-1172">如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1172">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="d4c2c-1173">由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1173">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="d4c2c-1174">位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1174">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="d4c2c-1175">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1175">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1176">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1176">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1177">在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1177">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1178">請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1178">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="d4c2c-1179">轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1179">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1180">連續解碼資料流，這個方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1180">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1181">下列範例會將字串轉換到另一個編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1181">The following example converts a string from one encoding to another.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 <span data-ttu-id="d4c2c-1182">下列範例會將字串編碼成位元組陣列，然後再將的位元組範圍解碼成字元陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1182">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1183">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1183">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1184">
            <paramref name="index" /> 或 <paramref name="count" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1184">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-1185">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1185">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1186">
            <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1186">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1187">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1187">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1188">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1188">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1189">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1189">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1190">在衍生類別中覆寫時，將位元組序列解碼成一組字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1190">When overridden in a derived class, decodes a sequence of bytes into a set of characters.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1191">包含要解碼之位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1191">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1192">在衍生類別中覆寫時，將指定位元組陣列中的所有位元組解碼成一組字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1192">When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1193">字元陣列，包含解碼指定位元組序列的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1193">A character array containing the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1194"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 取得從的輸入的位元組序列的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1194"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="d4c2c-1195"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1195"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1196">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1196">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1197">**請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1197">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="d4c2c-1198">如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1198">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d4c2c-1199"><xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1199">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="d4c2c-1200"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1200">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1201">數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1201">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1202">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1202">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1203">您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1203">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="d4c2c-1204">在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1204">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="d4c2c-1205">(例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個<xref:System.Text.Encoding.GetChars%2A>呼叫，並繼續進行下一步 開始<xref:System.Text.Encoding.GetChars%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1205">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="d4c2c-1206"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1206"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="d4c2c-1207">如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1207">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="d4c2c-1208">由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1208">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="d4c2c-1209">位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1209">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="d4c2c-1210">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1210">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1211">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1211">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1212">在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1212">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1213">請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1213">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="d4c2c-1214">轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1214">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1215">連續解碼資料流，這個方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1215">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1216">下列範例會將字串編碼成位元組陣列，並接著將位元組解碼成字元陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1216">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1217">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1217">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1218">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1218">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1219">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1219">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1220">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1220">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1221">包含要解碼之位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1221">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="d4c2c-1222">要解碼的第一個位元組索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1222">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-1223">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1223">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1224">在衍生類別中覆寫時，將指定位元組陣列中的位元組序列解碼成一組字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1224">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1225">字元陣列，包含解碼指定位元組序列的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1225">A character array containing the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1226"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 取得從的輸入的位元組序列的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1226"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="d4c2c-1227"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1227"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1228">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1228">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1229">**請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1229">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="d4c2c-1230">如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1230">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d4c2c-1231"><xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1231">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="d4c2c-1232"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1232">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1233">數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1233">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1234">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1234">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1235">您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1235">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="d4c2c-1236">在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1236">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="d4c2c-1237">(例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個<xref:System.Text.Encoding.GetChars%2A>呼叫，並繼續進行下一步 開始<xref:System.Text.Encoding.GetChars%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1237">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="d4c2c-1238"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1238"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="d4c2c-1239">如果您的應用程式會處理字串輸出，則建議使用<xref:System.Text.Encoding.GetString%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1239">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="d4c2c-1240">由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1240">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="d4c2c-1241">位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1241">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="d4c2c-1242">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1242">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1243">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1243">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1244">在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1244">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1245">請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1245">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="d4c2c-1246">轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1246">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1247">連續解碼資料流，這個方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1247">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1248">下列範例會將字串編碼成位元組陣列，然後再將的位元組範圍解碼成字元陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1248">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1249">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1249">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1250">
            <paramref name="index" /> 或 <paramref name="count" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1250">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-1251">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1251">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1252">
            <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1252">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1253">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1253">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1254">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1254">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1255">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1255">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1256">要解碼的第一個位元組指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1256">A pointer to the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="d4c2c-1257">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1257">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="d4c2c-1258">開始寫入產生的一組字元之位置指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1258">A pointer to the location at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <param name="charCount">
          <span data-ttu-id="d4c2c-1259">要寫入的最大字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1259">The maximum number of characters to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1260">在衍生類別中覆寫時，從指定位元組指標開始將位元組序列解碼成一組字元 (會從指定的字元指標開始存放這些字元)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1260">When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1261">
            <paramref name="chars" /> 參數所指示位置上寫入的實際字元數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1261">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1262">若要計算確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>需要儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1262">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1263">若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1263">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1264"><xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1264">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1265"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 取得從的輸入的位元組序列的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1265"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="d4c2c-1266"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不同於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1266"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1267">如果要轉換的數據僅在順序塊中可用（例如從流中讀取的數據），或者如果數據量太大以至於需要將其分成較小的塊，則應使用提供的<xref:System.Text.Decoder>或<xref:System.Text.Encoder>對象 分別由<xref:System.Text.Encoding.GetDecoder%2A>或<xref:System.Text.Encoding.GetEncoder%2A>種方法派生的類。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1267">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1268">**請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1268">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="d4c2c-1269">如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1269">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d4c2c-1270"><xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1270">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="d4c2c-1271"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1271">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1272">數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1272">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1273">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1273">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1274">您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1274">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="d4c2c-1275">在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1275">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="d4c2c-1276">(例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個<xref:System.Text.Encoding.GetChars%2A>呼叫，並繼續進行下一步 開始<xref:System.Text.Encoding.GetChars%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1276">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="d4c2c-1277"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1277"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="d4c2c-1278">如果您的應用程式會處理字串輸出<xref:System.Text.Encoding.GetString%2A>建議方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1278">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="d4c2c-1279">由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1279">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="d4c2c-1280">位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1280">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="d4c2c-1281">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1281">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1282">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1282">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1283">在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1283">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1284">請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1284">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="d4c2c-1285">轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1285">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1286">連續解碼資料流，這個方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1286">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1287">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1287">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1288">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1288">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1289">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1289">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1290">
            <paramref name="byteCount" /> 或 <paramref name="charCount" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1290">
              <paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1291">
            <paramref name="charCount" /> 小於結果字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1291">
              <paramref name="charCount" /> is less than the resulting number of characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1292">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1292">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1293">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1293">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1294">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1294">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d4c2c-1295">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1295">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d4c2c-1296">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1296">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1297">包含要解碼之位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1297">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="byteIndex">
          <span data-ttu-id="d4c2c-1298">要解碼的第一個位元組索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1298">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="d4c2c-1299">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1299">The number of bytes to decode.</span>
          </span>
        </param>
        <param name="chars">
          <span data-ttu-id="d4c2c-1300">包含產生的一組字元之字元陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1300">The character array to contain the resulting set of characters.</span>
          </span>
        </param>
        <param name="charIndex">
          <span data-ttu-id="d4c2c-1301">要開始寫入產生的一組字元之索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1301">The index at which to start writing the resulting set of characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1302">在衍生類別中覆寫時，將指定位元組陣列中的位元組序列解碼成指定的字元陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1302">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1303">寫入 <paramref name="chars" /> 的實際字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1303">The actual number of characters written into <paramref name="chars" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1304">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1304">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1305">若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1305">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1306"><xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1306">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1307">[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 取得從的輸入的位元組序列的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1307">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="d4c2c-1308">[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 不同<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>因為<xref:System.Text.Encoding>預期離散的轉換，而<xref:System.Text.Decoder>專為多個傳遞單一的輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1308">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1309">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1309">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1310">**請注意**這個方法要對 Unicode 字元，不會在任意二進位資料的詳細資訊，例如位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1310">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="d4c2c-1311">如果您需要將任意的二進位資料編碼為文字，您應該使用的通訊協定，例如 uuencode，例如實作方法<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1311">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d4c2c-1312"><xref:System.Text.Encoding.GetCharCount%2A>方法會判斷多少個字元產生的位元組序列解碼和<xref:System.Text.Encoding.GetChars%2A>方法會執行實際的解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1312">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="d4c2c-1313"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>方法會預期離散的轉換，相對於<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法，用來處理多個行程上的單一輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1313">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>  
  
 <span data-ttu-id="d4c2c-1314">數個版本的<xref:System.Text.Encoding.GetCharCount%2A>和<xref:System.Text.Encoding.GetChars%2A>支援。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1314">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="d4c2c-1315">使用這些方法的一些程式設計考量如下：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1315">The following are some programming considerations for use of these methods:</span></span>  
  
-   <span data-ttu-id="d4c2c-1316">您的應用程式可能要解碼的字碼頁從多個輸入的位元組，並處理使用多個呼叫的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1316">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="d4c2c-1317">在此情況下，您可能需要維護狀態之間的呼叫，因為在批次中處理時，可以被中斷的位元組序列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1317">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="d4c2c-1318">(例如，ISO-2022 shift 鍵順序的一部分可能會結束其中一個 [\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A > 呼叫，並繼續進行下一步 開始 [\]，Int32，Int32，Char\<xref: System.Text.Encoding.GetChars%2A > 呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1318">(For example, part of an ISO-2022 shift sequence may end one [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="d4c2c-1319">[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > 會呼叫此後援的那些未完成的順序，但<xref:System.Text.Decoder>會記住這些時序的下一個呼叫。)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1319">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>  
  
-   <span data-ttu-id="d4c2c-1320">如果您的應用程式會處理字串輸出<xref:System.Text.Encoding.GetString%2A>建議方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1320">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="d4c2c-1321">由於這個方法必須檢查字串長度，而且配置緩衝區，它會稍微慢一點，但產生<xref:System.String>型別是會優先。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1321">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>  
  
-   <span data-ttu-id="d4c2c-1322">位元組版本<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>可讓一些快速的技術，特別是使用大型緩衝區的多個呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1322">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="d4c2c-1323">請記住，不過，這個版本的方法是有時不安全，因為所需的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1323">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>  
  
-   <span data-ttu-id="d4c2c-1324">如果您的應用程式必須轉換大量資料，它應該重複使用輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1324">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="d4c2c-1325">在此情況下，[\]，Int32，Int32，Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > 支援輸出字元的版本緩衝區是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1325">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>  
  
-   <span data-ttu-id="d4c2c-1326">請考慮使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法，而非<xref:System.Text.Encoding.GetCharCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1326">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="d4c2c-1327">轉換方法會將盡可能最多資料，並擲回例外狀況，如果輸出緩衝區太小。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1327">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="d4c2c-1328">連續解碼資料流，這個方法通常是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1328">For continuous decoding of a stream, this method is often the best choice.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1329">下列範例會將字串轉換到另一個編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1329">The following example converts a string from one encoding to another.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 <span data-ttu-id="d4c2c-1330">下列範例會將字串編碼成位元組陣列，然後再將的位元組範圍解碼成字元陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1330">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1331">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1331">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1332">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1332">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1333">
            <paramref name="chars" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1333">
              <paramref name="chars" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1334">
            <paramref name="byteIndex" />、<paramref name="byteCount" /> 或 <paramref name="charIndex" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1334">
              <paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-1335">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1335">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1336">
            <paramref name="byteindex" /> 與 <paramref name="byteCount" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1336">
              <paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1337">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1337">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1338">
            <paramref name="charIndex" /> 在 <paramref name="chars" /> 中不是有效的索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1338">
              <paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1339">從 <paramref name="chars" /> 到陣列結尾處，<paramref name="charIndex" /> 沒有足夠的容量容納結果字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1339">
              <paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1340">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1340">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1341">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1341">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1342">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1342">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1343">在衍生類別中覆寫時，取得會將編碼的位元組序列轉換成字元序列的解碼器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1343">When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1344">
            <see cref="T:System.Text.Decoder" />，會將編碼的位元組序列轉換成字元序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1344">A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1345"><xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>方法會將序列的位元組的區塊轉換成循序區塊中的字元，以類似的方式<xref:System.Text.Encoding.GetChars%2A>這個類別的方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1345">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class.</span></span> <span data-ttu-id="d4c2c-1346">不過，<xref:System.Text.Decoder>維護呼叫，因此它會正確解碼位元組序列跨越區塊之間的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1346">However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks.</span></span> <span data-ttu-id="d4c2c-1347"><xref:System.Text.Decoder>也會保留尾端位元組的資料區塊的結尾，並在下一步 的解碼作業中使用尾端位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1347">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="d4c2c-1348">因此，<xref:System.Text.Encoding.GetDecoder%2A>和<xref:System.Text.Encoding.GetEncoder%2A>適合用於網路傳輸和檔案作業，因為這些作業經常要處理的資料，而不是完整的資料流區塊。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1348">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d4c2c-1349">
            <para>預設實作會傳回<see cref="T:System.Text.Decoder" />它會呼叫<see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />並<see cref="M:System.Text.Encoding.GetChars(System.Byte[])" />方法在目前的<see cref="T:System.Text.Encoding" />。您必須覆寫此方法以傳回<see cref="T:System.Text.Decoder" />，維護它呼叫之間的狀態。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1349">
              <para>The default implementation returns a <see cref="T:System.Text.Decoder" /> that calls the <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> methods of the current <see cref="T:System.Text.Encoding" />. You must override this method to return a <see cref="T:System.Text.Decoder" /> that maintains its state between calls.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1350">在衍生類別中覆寫時，取得會將 Unicode 字元序列轉換成編碼的位元組序列的編碼器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1350">When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1351">
            <see cref="T:System.Text.Encoder" />，會將 Unicode 字元序列轉換成編碼的位元組序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1351">A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1352"><xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>方法會將字元的循序區塊轉換成循序區塊中的位元組，以類似的方式<xref:System.Text.Encoding.GetBytes%2A>這個類別的方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1352">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="d4c2c-1353">不過，<xref:System.Text.Encoder>維護讓它正確編碼的字元序列跨越區塊的呼叫之間的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1353">However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks.</span></span> <span data-ttu-id="d4c2c-1354"><xref:System.Text.Encoder>也保留尾端字元的資料區塊的結尾，並在下一步 的編碼作業中使用尾端的字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1354">The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="d4c2c-1355">比方說，資料區塊可能會以無對應的高 surrogate，結尾，而且下一個資料區塊可能會比對的低 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1355">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="d4c2c-1356">因此，<xref:System.Text.Encoding.GetDecoder%2A>和<xref:System.Text.Encoding.GetEncoder%2A>適合用於網路傳輸和檔案作業，因為這些作業經常要處理的資料，而不是完整的資料流區塊。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1356">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="d4c2c-1357">
            <para>預設實作會傳回<see cref="T:System.Text.Encoder" />它會呼叫<see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />並<see cref="M:System.Text.Encoding.GetBytes(System.Char[])" />方法在目前的<see cref="T:System.Text.Encoding" />。您必須覆寫此方法以傳回<see cref="T:System.Text.Encoder" />，維護它呼叫之間的狀態。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1357">
              <para>The default implementation returns a <see cref="T:System.Text.Encoder" /> that calls the <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> methods of the current <see cref="T:System.Text.Encoding" />. You must override this method to return a <see cref="T:System.Text.Encoder" /> that maintains its state between calls.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1358">傳回指定字碼頁的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1358">Returns an encoding for the specified code page.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">
          <span data-ttu-id="d4c2c-1359">慣用編碼方式的字碼頁識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1359">The code page identifier of the preferred encoding.</span>
          </span>
          <span data-ttu-id="d4c2c-1360">
            <see cref="T:System.Text.Encoding" /> 類別主題中表格的「字碼頁」欄會列出可能值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1360">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span>
          </span>
          <span data-ttu-id="d4c2c-1361">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1361">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1362">0 (零)，表示使用預設的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1362">0 (zero), to use the default encoding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1363">傳回與指定字碼頁識別項相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1363">Returns the encoding associated with the specified code page identifier.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1364">與指定字碼頁相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1364">The encoding that is associated with the specified code page.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1365">編碼方式類型取決於後援處理常式`codepage`。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1365">The fallback handler depends on the encoding type of `codepage`.</span></span> <span data-ttu-id="d4c2c-1366">如果`codepage`程式碼頁面或雙位元組字元集 (DBCS) 編碼，會使用自動調整後援處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1366">If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="d4c2c-1367">否則，會使用取代後援處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1367">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="d4c2c-1368">這些後援處理常式可能不適合您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1368">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="d4c2c-1369">若要指定所指定的編碼使用後援處理常式`codepage`，您可以呼叫<xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>多載。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1369">To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>  
  
 <span data-ttu-id="d4c2c-1370">在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1370">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="d4c2c-1371">不過，.NET Framework 原本就支援一些編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1371">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="d4c2c-1372">如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1372">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="d4c2c-1373">在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1373">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="d4c2c-1374">在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1374">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="d4c2c-1375">除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1375">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="d4c2c-1376">如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1376">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  

<span data-ttu-id="d4c2c-1377">您也可以提供的值為 0`codepage`引數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1377">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="d4c2c-1378">精確的行為取決於是否任何的編碼方式已有可用的註冊<xref:System.Text.EncodingProvider>物件：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1378">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="d4c2c-1379">如果已註冊一或多個編碼提供者，它就會傳回最後一個已註冊的提供者傳回編碼時選擇的編碼方式<xref:System.Text.Encoding.GetEncoding%2A>方法會傳遞`codepage`引數為 0。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1379">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>     

- <span data-ttu-id="d4c2c-1380">在.NET Framework 中，如果沒有編碼提供者已註冊之後，如果<xref:System.Text.CodePagesEncodingProvider>是已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回作業系統的作用中的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1380">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the operating system's active code page.</span></span> <span data-ttu-id="d4c2c-1381">若要判斷在 Windows 系統上的作用中的字碼頁，呼叫 Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)從.NET Framework 在 Windows 桌面上的函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1381">To determine the active code page on Windows systems, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

- <span data-ttu-id="d4c2c-1382">在.NET Core，如果有任何已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回<xref:System.Text.UTF8Encoding>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1382">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-1383">某些不支援的字碼頁的原因<xref:System.ArgumentException>擲回，而其他人會造成<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1383">Some unsupported code pages cause an <xref:System.ArgumentException> to be thrown, whereas others cause a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="d4c2c-1384">因此，您的程式碼必須攔截所有例外狀況的例外狀況 」 一節所示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1384">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-1385">ANSI 字碼頁不同的電腦上可能有不同，而且可以變更的單一電腦上，導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1385">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="d4c2c-1386">基於這個理由，如果作用中的字碼頁為 ANSI 字碼頁編碼和解碼使用的預設字碼頁資料所傳回`Encoding.GetEncoding(0)`不建議使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1386">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="d4c2c-1387">為了最一致的結果，您應該使用 Unicode 編碼，例如 utf-8 （字碼頁 65001） 或 utf-16，而不特定字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1387">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
  
 <span data-ttu-id="d4c2c-1388"><xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1388"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="d4c2c-1389">您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1389">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="d4c2c-1390">比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1390">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  

   
  
## Examples  
 <span data-ttu-id="d4c2c-1391">下列範例會取得兩個相同的編碼 （字碼頁所一個），依名稱的另一個執行個體，並檢查它們相等。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1391">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1392">
            <paramref name="codepage" /> 小於零或大於 65535。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1392">
              <paramref name="codepage" /> is less than zero or greater than 65535.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1393">基礎的平台並不支援 <paramref name="codepage" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1393">
              <paramref name="codepage" /> is not supported by the underlying platform.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d4c2c-1394">基礎的平台並不支援 <paramref name="codepage" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1394">
              <paramref name="codepage" /> is not supported by the underlying platform.</span>
          </span>
        </exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="d4c2c-1395">慣用編碼方式的字碼頁名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1395">The code page name of the preferred encoding.</span>
          </span>
          <span data-ttu-id="d4c2c-1396">
            <see cref="P:System.Text.Encoding.WebName" /> 屬性傳回的任何值都是有效值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1396">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span>
          </span>
          <span data-ttu-id="d4c2c-1397">
            <see cref="T:System.Text.Encoding" /> 類別主題中表格的「名稱」欄會列出可能值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1397">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1398">傳回與指定字碼頁名稱相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1398">Returns the encoding associated with the specified code page name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1399">與指定字碼頁相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1399">The encoding  associated with the specified code page.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1400">編碼方式類型取決於後援處理常式`name`。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1400">The fallback handler depends on the encoding type of `name`.</span></span> <span data-ttu-id="d4c2c-1401">如果`name`程式碼頁面或雙位元組字元集 (DBCS) 編碼，會使用自動調整後援處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1401">If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="d4c2c-1402">否則，會使用取代後援處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1402">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="d4c2c-1403">這些後援處理常式可能不適合您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1403">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="d4c2c-1404">若要指定所指定的編碼使用後援處理常式`name`，您可以呼叫<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>多載。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1404">To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>  

<span data-ttu-id="d4c2c-1405">在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1405">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="d4c2c-1406">不過，.NET Framework 原本就支援一些編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1406">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="d4c2c-1407">如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1407">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="d4c2c-1408">在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1408">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="d4c2c-1409">在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1409">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="d4c2c-1410">除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1410">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="d4c2c-1411">如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1411">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  
   
> [!NOTE]
>  <span data-ttu-id="d4c2c-1412">ANSI 字碼頁不同的電腦上可能有不同，也可以變更為單一電腦，導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1412">The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</span></span> <span data-ttu-id="d4c2c-1413">為了最一致的結果，您應該使用 Unicode，例如 utf-8 （字碼頁 65001） 或 utf-16，而不是特定字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1413">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
 
  
 <span data-ttu-id="d4c2c-1414"><xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1414"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="d4c2c-1415">您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1415">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="d4c2c-1416">比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1416">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
## Examples  
 <span data-ttu-id="d4c2c-1417">下列範例會取得兩個相同的編碼 （字碼頁所一個），依名稱的另一個執行個體，並檢查它們相等。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1417">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1418">
            <paramref name="name" /> 不是有效的字碼頁名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1418">
              <paramref name="name" /> is not a valid code page name.</span>
          </span>
          <span data-ttu-id="d4c2c-1419">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1419">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1420">主要平台尚不支援以 <paramref name="name" /> 所指示的字碼頁。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1420">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span>
          </span>
        </exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">
          <span data-ttu-id="d4c2c-1421">慣用編碼方式的字碼頁識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1421">The code page identifier of the preferred encoding.</span>
          </span>
          <span data-ttu-id="d4c2c-1422">
            <see cref="T:System.Text.Encoding" /> 類別主題中表格的「字碼頁」欄會列出可能值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1422">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span>
          </span>
          <span data-ttu-id="d4c2c-1423">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1423">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1424">0 (零)，表示使用預設的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1424">0 (zero), to use the default encoding.</span>
          </span>
        </param>
        <param name="encoderFallback">
          <span data-ttu-id="d4c2c-1425">物件，該物件會在無法以目前編碼方式將字元編碼時提供錯誤處理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1425">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span>
          </span>
        </param>
        <param name="decoderFallback">
          <span data-ttu-id="d4c2c-1426">物件，該物件會在無法以目前編碼方式將位元組序列解碼時提供錯誤處理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1426">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1427">傳回與指定字碼頁識別項相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1427">Returns the encoding associated with the specified code page identifier.</span>
          </span>
          <span data-ttu-id="d4c2c-1428">參數會針對無法編碼的字元以及無法解碼的位元組序列指定錯誤處理常式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1428">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1429">與指定字碼頁相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1429">The encoding that is associated with the specified code page.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-1430">某些不支援的字碼頁會導致例外狀況<xref:System.ArgumentException>擲回，而其他人會造成<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1430">Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="d4c2c-1431">因此，您的程式碼必須攔截所有例外狀況的例外狀況 」 一節所示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1431">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>  

<span data-ttu-id="d4c2c-1432">在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1432">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="d4c2c-1433">不過，.NET Framework 原本就支援一些編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1433">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="d4c2c-1434">如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1434">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="d4c2c-1435">在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1435">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="d4c2c-1436">在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1436">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="d4c2c-1437">除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1437">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="d4c2c-1438">如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1438">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  

<span data-ttu-id="d4c2c-1439">您也可以提供的值為 0`codepage`引數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1439">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="d4c2c-1440">精確的行為取決於是否任何的編碼方式已有可用的註冊<xref:System.Text.EncodingProvider>物件：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1440">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="d4c2c-1441">如果已註冊一或多個編碼提供者，它就會傳回最後一個已註冊的提供者傳回編碼時選擇的編碼方式<xref:System.Text.Encoding.GetEncoding%2A>方法會傳遞`codepage`引數為 0。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1441">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>     

- <span data-ttu-id="d4c2c-1442">在.NET Framework 中，如果沒有編碼提供者已註冊之後，如果<xref:System.Text.CodePagesEncodingProvider>是已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回使用中的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1442">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the active code page.</span></span>

- <span data-ttu-id="d4c2c-1443">在.NET Core，如果有任何已註冊編碼提供者，或如果沒有已註冊編碼提供者會處理`codepage`值為 0 時，它會傳回<xref:System.Text.UTF8Encoding>編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1443">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding> encoding.</span></span>

> [!NOTE]
>  <span data-ttu-id="d4c2c-1444">ANSI 字碼頁不同的電腦上可能有不同，而且可以變更的單一電腦上，導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1444">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="d4c2c-1445">基於這個理由，如果作用中的字碼頁為 ANSI 字碼頁編碼和解碼使用的預設字碼頁資料所傳回`Encoding.GetEncoding(0)`不建議使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1445">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="d4c2c-1446">為了最一致的結果，您應該使用 Unicode，例如 utf-8 （字碼頁 65001） 或 utf-16，而不是特定字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1446">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span> 
  
 <span data-ttu-id="d4c2c-1447">若要取得相關聯的作用中的字碼頁的編碼方式，您可以提供的值為 0`codepage`引數或，如果您的程式碼執行以.NET Framework 在 Windows 桌面上，擷取的值<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1447">To get the encoding associated with the active code page, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d4c2c-1448">若要判斷目前作用中的字碼頁，呼叫 Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)從.NET Framework 在 Windows 桌面上的函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1448">To determine the current active code page, call the Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>  
  
 <span data-ttu-id="d4c2c-1449"><xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1449"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="d4c2c-1450">您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1450">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="d4c2c-1451">比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1451">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1452">下列範例示範<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1452">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1453">
            <paramref name="codepage" /> 小於零或大於 65535。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1453">
              <paramref name="codepage" /> is less than zero or greater than 65535.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1454">基礎的平台並不支援 <paramref name="codepage" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1454">
              <paramref name="codepage" /> is not supported by the underlying platform.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="d4c2c-1455">基礎的平台並不支援 <paramref name="codepage" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1455">
              <paramref name="codepage" /> is not supported by the underlying platform.</span>
          </span>
        </exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="d4c2c-1456">慣用編碼方式的字碼頁名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1456">The code page name of the preferred encoding.</span>
          </span>
          <span data-ttu-id="d4c2c-1457">
            <see cref="P:System.Text.Encoding.WebName" /> 屬性傳回的任何值都是有效值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1457">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span>
          </span>
          <span data-ttu-id="d4c2c-1458">
            <see cref="T:System.Text.Encoding" /> 類別主題中表格的「名稱」欄會列出可能值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1458">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span>
          </span>
        </param>
        <param name="encoderFallback">
          <span data-ttu-id="d4c2c-1459">物件，該物件會在無法以目前編碼方式將字元編碼時提供錯誤處理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1459">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span>
          </span>
        </param>
        <param name="decoderFallback">
          <span data-ttu-id="d4c2c-1460">物件，該物件會在無法以目前編碼方式將位元組序列解碼時提供錯誤處理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1460">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1461">傳回與指定字碼頁名稱相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1461">Returns the encoding associated with the specified code page name.</span>
          </span>
          <span data-ttu-id="d4c2c-1462">參數會針對無法編碼的字元以及無法解碼的位元組序列指定錯誤處理常式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1462">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1463">與指定字碼頁相關聯的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1463">The encoding that is associated with the specified code page.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="d4c2c-1464">在.NET Framework 中，<xref:System.Text.Encoding.GetEncoding%2A>方法需仰賴基礎平台，以支援大部分的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1464">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="d4c2c-1465">不過，.NET Framework 原本就支援一些編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1465">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="d4c2c-1466">如需字碼頁的清單，請參閱<xref:System.Text.Encoding>類別主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1466">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="d4c2c-1467">在.NET Core<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回原生支援的.NET Core 的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1467">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="d4c2c-1468">在這兩個.NET 實作中，您可以呼叫<xref:System.Text.Encoding.GetEncodings%2A>方法來取得各種<xref:System.Text.EncodingInfo>包含所有可用編碼的相關資訊的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1468">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span> 

 <span data-ttu-id="d4c2c-1469">除了在.NET Core 上的原生功能，或在特定平台版本的.NET Framework 中，本質上支援的編碼<xref:System.Text.Encoding.GetEncoding%2A>方法會傳回所能使用註冊任何其他編碼<xref:System.Text.EncodingProvider>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1469">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="d4c2c-1470">如果多個已註冊的相同編碼<xref:System.Text.EncodingProvider>物件，這個方法會傳回已註冊的最後一個。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1470">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-1471">ANSI 字碼頁不同的電腦上可能有不同，而且可以變更的單一電腦上，導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1471">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="d4c2c-1472">為了最一致的結果，您應該使用 Unicode 編碼，例如 utf-8 （字碼頁 65001） 或 utf-16，而不特定字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1472">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>  
  
 <span data-ttu-id="d4c2c-1473"><xref:System.Text.Encoding.GetEncoding%2A> 傳回具有預設設定的快取執行個體。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1473"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="d4c2c-1474">您應該使用衍生類別的建構函式來取得執行個體使用不同的設定。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1474">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="d4c2c-1475">比方說，<xref:System.Text.UTF32Encoding>類別提供可讓您啟用錯誤偵測的建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1475">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1476">下列範例示範<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1476">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1477">
            <paramref name="name" /> 不是有效的字碼頁名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1477">
              <paramref name="name" /> is not a valid code page name.</span>
          </span>
          <span data-ttu-id="d4c2c-1478">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1478">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1479">主要平台尚不支援以 <paramref name="name" /> 所指示的字碼頁。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1479">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span>
          </span>
        </exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1480">傳回包含所有編碼方式的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1480">Returns an array that contains all encodings.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1481">包含所有編碼方式的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1481">An array that contains all encodings.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1482">這個方法會傳回一份支援的編碼，唯一辨別依字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1482">This method returns a list of supported encodings, uniquely distinguished by code page.</span></span> <span data-ttu-id="d4c2c-1483">如需列出支援的編碼方式的表格，請參閱<xref:System.Text.Encoding>類別主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1483">For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-1484">支援的編碼所傳回的清單<xref:System.Text.Encoding.GetEncodings%2A>方法不包含任何額外的編碼方式，可由任何<xref:System.Text.EncodingProvider>呼叫已登錄的實作<xref:System.Text.Encoding.RegisterProvider%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1484">The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.</span></span>  
  
 <span data-ttu-id="d4c2c-1485">在.NET Framework 中，編碼 50220 和 50222 會為兩者相關聯的名稱"iso-2022年-jp"，但並不相同。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1485">On the .NET Framework, encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</span></span> <span data-ttu-id="d4c2c-1486">編碼 50220 將半形片假名字元轉換為全形片假名字元，而編碼 50222 使用 shift 鍵輸入/shift out 序列來編碼半形片假名字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1486">Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</span></span> <span data-ttu-id="d4c2c-1487">編碼 50222 的顯示名稱是 「 日文 (JIS-Povolen 1 bajt Kana-因此 / SI) 」 以區分它與編碼 50220，具有顯示名稱 「 日文 (JIS) 」。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1487">The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</span></span>  
  
 <span data-ttu-id="d4c2c-1488">如果您要求編碼名稱"iso-2022年-jp"50220 的編碼方式在.NET Framework 傳回。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1488">If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</span></span> <span data-ttu-id="d4c2c-1489">不過，適用於您的應用程式的編碼方式取決於半形片假名字元的慣用的處理方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1489">However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</span></span>  
  
 <span data-ttu-id="d4c2c-1490">若要取得特定的編碼方式，您應該使用<xref:System.Text.Encoding.GetEncoding%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1490">To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.</span></span>  
  
 <span data-ttu-id="d4c2c-1491"><xref:System.Text.Encoding.GetEncodings%2A> 有時候用來顯示給使用者的檔案中的編碼方式清單**將儲存為** 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1491"><xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box.</span></span> <span data-ttu-id="d4c2c-1492">不過，許多非 Unicode 編碼都是不完整，而且轉譯到許多字元"？"，或在不同的平台上有稍微不同的行為。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1492">However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</span></span> <span data-ttu-id="d4c2c-1493">請考慮使用 utf-8 或 utf-16 為預設值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1493">Consider using UTF-8 or UTF-16 as the default.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1494">下列範例會檢查每個編碼的布林屬性值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1494">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1495">傳回目前執行個體的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1495">Returns the hash code for the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1496">目前執行個體的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1496">The hash code for the current instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">
          <span data-ttu-id="d4c2c-1497">要編碼的字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1497">The number of characters to encode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1498">在衍生類別中覆寫時，計算編碼指定的字元數所產生的最大位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1498">When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1499">編碼指定字元數所產生的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1499">The maximum number of bytes produced by encoding the specified number of characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1500">`charCount`參數實際上會指定數目<xref:System.Char>代表 Unicode 字元編碼，因為.NET 在內部使用 utf-16 來代表 Unicode 字元的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1500">The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because .NET internally uses UTF-16 to represent Unicode characters.</span></span> <span data-ttu-id="d4c2c-1501">因此，大部分的 Unicode 字元可以表示逐一<xref:System.Char>物件，但由 surrogate 字組，例如，將 Unicode 字元需要兩個<xref:System.Char>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1501">Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.</span></span>  
  
 <span data-ttu-id="d4c2c-1502">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetBytes%2A>來儲存產生的位元組，您應該使用<xref:System.Text.Encoding.GetByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1502">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1503">若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxByteCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1503">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1504"><xref:System.Text.Encoding.GetByteCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxByteCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1504">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1505"><xref:System.Text.Encoding.GetMaxByteCount%2A> 擷取最壞情況的數目，包括目前所選最壞的情況<xref:System.Text.EncoderFallback>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1505"><xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="d4c2c-1506">如果後援會選擇使用可能很大的字串、<xref:System.Text.Encoding.GetMaxByteCount%2A>擷取大數值，特別是在最壞的情況的編碼方式涉及切換模式，針對每個字元的情況下。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1506">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</span></span> <span data-ttu-id="d4c2c-1507">比方說，這種情形的 ISO-2022年-JP。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1507">For example, this can happen for ISO-2022-JP.</span></span> <span data-ttu-id="d4c2c-1508">如需詳細資訊，請參閱部落格文章 「[Encoding.GetMaxByteCount() 與 Encoding.GetMaxCharCount() 是什麼？](http://go.microsoft.com/fwlink/?LinkId=153702)"</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1508">For more information, see the blog entry "[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)"</span></span> <span data-ttu-id="d4c2c-1509">(http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1509">(http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).</span></span>  
  
 <span data-ttu-id="d4c2c-1510">在大部分情況下，這個方法會擷取對小型字串合理的值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1510">In most cases, this method retrieves reasonable values for small strings.</span></span> <span data-ttu-id="d4c2c-1511">針對大型的字串，您可能選擇使用極大的緩衝區，更合理的緩衝區太小而時，在罕見的情況下攔截錯誤。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1511">For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</span></span> <span data-ttu-id="d4c2c-1512">您也可以在不同的方法使用，請考慮<xref:System.Text.Encoding.GetByteCount%2A>或<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1512">You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d4c2c-1513">當使用<xref:System.Text.Encoding.GetMaxByteCount%2A>，您應該配置輸出緩衝區的輸入緩衝區的大小上限為基礎。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1513">When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="d4c2c-1514">如果輸出緩衝區的大小限制，您可能會使用<xref:System.Text.Encoding.Convert%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1514">If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.</span></span>  
  
 <span data-ttu-id="d4c2c-1515">請注意，<xref:System.Text.Encoding.GetMaxByteCount%2A>會考量先前的解碼器作業可能剩餘的 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1515">Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation.</span></span> <span data-ttu-id="d4c2c-1516">解碼器，因為傳遞至方法的值為 1 會擷取到 2，代表單一位元組編碼，例如 ASCII。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1516">Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</span></span> <span data-ttu-id="d4c2c-1517">您應該使用<xref:System.Text.ASCIIEncoding.IsSingleByte%2A>如果這項資訊是必要的屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1517">You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-1518">`GetMaxByteCount(N)` 不一定是相同的值`N* GetMaxByteCount(1)`。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1518">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1519">下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1519">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1520">
            <paramref name="charCount" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1520">
              <paramref name="charCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.EncoderFallbackException">
          <span data-ttu-id="d4c2c-1521">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1521">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1522">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1522">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1523">
            <see cref="P:System.Text.Encoding.EncoderFallback" /> 設定為 <see cref="T:System.Text.EncoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1523">
              <see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d4c2c-1524">
            <para>所有<see cref="T:System.Text.Encoding" />實作必須保證如果緩衝區的大小根據此方法的計算結果，會發生任何緩衝區溢位例外狀況。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1524">
              <para>All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">
          <span data-ttu-id="d4c2c-1525">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1525">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1526">在衍生類別中覆寫時，計算解碼指定的位元組數目所產生的最大字元數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1526">When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1527">解碼指定位元組數所產生的最大字元數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1527">The maximum number of characters produced by decoding the specified number of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1528">若要計算所需的確切的陣列大小<xref:System.Text.Encoding.GetChars%2A>來儲存產生的字元，您應該使用<xref:System.Text.Encoding.GetCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1528">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1529">若要計算最大陣列大小，請使用<xref:System.Text.Encoding.GetMaxCharCount%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1529">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="d4c2c-1530"><xref:System.Text.Encoding.GetCharCount%2A>方法通常可讓較少的記憶體配置而<xref:System.Text.Encoding.GetMaxCharCount%2A>方法通常執行速度更快。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1530">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>  
  
 <span data-ttu-id="d4c2c-1531"><xref:System.Text.Encoding.GetMaxCharCount%2A> 擷取最壞情況的數目，包括目前所選最壞的情況<xref:System.Text.DecoderFallback>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1531"><xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="d4c2c-1532">如果後援會選擇使用可能很大的字串、<xref:System.Text.Encoding.GetMaxCharCount%2A>擷取較大的值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1532">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.</span></span>  
  
 <span data-ttu-id="d4c2c-1533">在大部分情況下，這個方法會擷取對小型字串合理的數字。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1533">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="d4c2c-1534">針對大型的字串，您可能選擇使用非常大的緩衝區，在罕見的情況下，更合理的緩衝區太小而攔截錯誤。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1534">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</span></span> <span data-ttu-id="d4c2c-1535">您也可以在不同的方法使用，請考慮<xref:System.Text.Encoding.GetCharCount%2A>或<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1535">You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d4c2c-1536"><xref:System.Text.Encoding.GetMaxCharCount%2A> 沒有任何關聯<xref:System.Text.Encoding.GetBytes%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1536"><xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>.</span></span> <span data-ttu-id="d4c2c-1537">如果您需要類似的函式，以搭配<xref:System.Text.Encoding.GetBytes%2A>，您應該使用<xref:System.Text.Encoding.GetMaxByteCount%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1537">If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span></span>  
  
 <span data-ttu-id="d4c2c-1538">當使用<xref:System.Text.Encoding.GetMaxCharCount%2A>，您應該配置輸出緩衝區的輸入緩衝區的大小上限為基礎。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1538">When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="d4c2c-1539">如果輸出緩衝區的大小限制，您可能會使用<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1539">If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="d4c2c-1540">請注意，<xref:System.Text.Encoding.GetMaxCharCount%2A>會考量先前的編碼器作業的剩餘位元組最壞的情況。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1540">Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation.</span></span> <span data-ttu-id="d4c2c-1541">對於大部分的字碼頁，0 的值傳遞至這個方法會擷取大於或等於 1 的值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1541">For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d4c2c-1542">`GetMaxCharCount(N)` 不一定是相同的值`N* GetMaxCharCount(1)`。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1542">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1543">下列範例會將字串編碼成位元組陣列，並接著將位元組解碼成字元陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1543">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1544">
            <paramref name="byteCount" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1544">
              <paramref name="byteCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1545">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1545">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1546">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1546">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1547">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1547">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="d4c2c-1548">
            <para>所有<see cref="T:System.Text.Encoding" />實作必須保證如果緩衝區的大小根據此方法的計算結果，會發生任何緩衝區溢位例外狀況。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1548">
              <para>All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1549">在衍生類別中覆寫時，傳回可指定所用編碼方式的位元組序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1549">When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1550">位元組陣列，包含可指定所用編碼方式的位元組序列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1550">A byte array containing a sequence of bytes that specifies the encoding used.</span>
          </span>
          <span data-ttu-id="d4c2c-1551">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1551">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1552">如果不需要前序編碼，則位元組陣列的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1552">A byte array of length zero, if a preamble is not required.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1553">（選擇性）<xref:System.Text.Encoding>物件所提供的是可以加在編碼程序所產生的位元組序列的位元組陣列的前序編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1553">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="d4c2c-1554">如果前序編碼包含位元組順序標記 （在 Unicode 字碼指標 U + FEFF)，它可以協助判斷位元組順序的轉換格式或 UTF 解碼器。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1554">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>  
  
 <span data-ttu-id="d4c2c-1555">Unicode 位元組順序標記 (BOM) （以十六進位方式） 的序列化，如下所示：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1555">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>  
  
-   <span data-ttu-id="d4c2c-1556">UTF-8: EF BB BF</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1556">UTF-8: EF BB BF</span></span>  
  
-   <span data-ttu-id="d4c2c-1557">Utf-16 位元組由大到小位元組順序： FE FF</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1557">UTF-16 big endian byte order: FE FF</span></span>  
  
-   <span data-ttu-id="d4c2c-1558">Utf-16 少位元組由小到大位元組順序： FF FE</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1558">UTF-16 little endian byte order: FF FE</span></span>  
  
-   <span data-ttu-id="d4c2c-1559">UTF-32 位元組由大到小位元組順序： 00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1559">UTF-32 big endian byte order: 00 00 FE FF</span></span>  
  
-   <span data-ttu-id="d4c2c-1560">UTF-32 少位元組由小到大位元組順序： FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1560">UTF-32 little endian byte order: FF FE 00 00</span></span>  
  
 <span data-ttu-id="d4c2c-1561">因為它提供幾乎特定編碼的檔案，否則為已中斷參考的識別碼，您應該使用 BOM，<xref:System.Text.Encoding>物件，例如，未標記，或不正確標記 web 資料或儲存時企業的隨機文字檔案不提供支援有國際考量或其他資料。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1561">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="d4c2c-1562">如果資料的一致且正確地標示，最好是 utf-8 或 utf-16，可能會避免通常使用者的問題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1562">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>  
  
 <span data-ttu-id="d4c2c-1563">提供編碼類型的標準，BOM 是多餘的。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1563">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="d4c2c-1564">不過，它可以用來傳送正確的編碼方式標頭的伺服器。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1564">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="d4c2c-1565">或者，它可用來當做後援萬一編碼遺失時。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1565">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>  
  
 <span data-ttu-id="d4c2c-1566">有一些缺點，若要使用 BOM。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1566">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="d4c2c-1567">比方說，了解如何限制使用 BOM 的資料庫欄位可以是很困難。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1567">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="d4c2c-1568">串連的檔案可以也會是問題，比方說，當檔案會合併，例如某種程度的不必要的字元可以得到中間的資料。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1568">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="d4c2c-1569">儘管幾個缺點，不過，BOM 是強烈建議使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1569">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>  
  
 <span data-ttu-id="d4c2c-1570">如需有關位元組順序和位元組順序標記的詳細資訊，請參閱 Unicode Standard > [Unicode 首頁](http://go.microsoft.com/fwlink/?LinkId=37123)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1570">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="d4c2c-1571">若要確保正確解碼的編碼的位元組，您應該前置詞與前序編碼的位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1571">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="d4c2c-1572">不過，大部分的編碼方式不會提供前序編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1572">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="d4c2c-1573">若要確保正確解碼的編碼的位元組，您應該使用 Unicode 編碼方式，亦即<xref:System.Text.UTF8Encoding>， <xref:System.Text.UnicodeEncoding>，或<xref:System.Text.UTF32Encoding>，與前序編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1573">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1574">下列範例會判斷前序編碼為基礎的編碼方式的位元組順序。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1574">The following example determines the byte order of the encoding based on the preamble.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1575">在衍生類別中覆寫時，將位元組序列解碼成字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1575">When overridden in a derived class, decodes a sequence of bytes into a string.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1576">包含要解碼之位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1576">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1577">在衍生類別中覆寫時，將指定位元組陣列中的所有位元組解碼成字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1577">When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1578">字串，包含將指定之位元組序列解碼的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1578">A string that contains the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1579">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>所傳回的物件<xref:System.Text.Encoding.GetDecoder%2A>衍生方法攝影類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1579">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1580">請參閱 < 備註 > 一節的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解碼技術和考量的討論的參考主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1580">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
 <span data-ttu-id="d4c2c-1581">請注意，精確的行為<xref:System.Text.Encoding.GetString%2A>特定的方法<xref:System.Text.Encoding>實作取決於該定義的後援策略<xref:System.Text.Encoding>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1581">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="d4c2c-1582">如需詳細資訊，請參閱 「 選擇後援策略 」 一節[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1582">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1583">下列範例會將 utf-8 編碼字串讀取所表示的二進位檔案<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1583">The following example reads a UTF-8 encoded string from a binary file represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="d4c2c-1584">對於小於 2048 個位元組的檔案，它會讀取整個檔案的內容至位元組陣列和呼叫<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29>方法進行解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1584">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> method to perform the decoding.</span></span> <span data-ttu-id="d4c2c-1585">較大的檔案，它 2,048 個位元組一次讀取的位元組陣列，呼叫<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以判斷的字元數包含陣列中，然後呼叫<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>方法進行解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1585">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 <span data-ttu-id="d4c2c-1586">此範例會使用下列文字，應儲存至名為 Utf8Example.txt utf-8 編碼檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1586">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1587">位元組陣列包含無效的 Unicode 字碼指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1587">The byte array contains invalid Unicode code points.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1588">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1588">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1589">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1589">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1590">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1590">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1591">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1591">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1592">位元組陣列的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1592">A pointer to a byte array.</span>
          </span>
        </param>
        <param name="byteCount">
          <span data-ttu-id="d4c2c-1593">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1593">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1594">在衍生類別中覆寫時，將指定位址開頭之指定數目的位元組解碼為字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1594">When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1595">字串，包含將指定之位元組序列解碼的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1595">A string that contains the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1596"><xref:System.Text.Encoding.GetString%2A>方法設計用來最佳化效能，當您有原生指標的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1596">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array.</span></span> <span data-ttu-id="d4c2c-1597">而不是建立受管理的位元組陣列，並再將其解碼，您可以改為呼叫這個方法而不需要建立任何中繼物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1597">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>  
  
 <span data-ttu-id="d4c2c-1598">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>所傳回的物件<xref:System.Text.Encoding.GetDecoder%2A>衍生方法攝影類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1598">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1599">請參閱 < 備註 > 一節的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解碼技術和考量的討論的參考主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1599">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
 <span data-ttu-id="d4c2c-1600">請注意，精確的行為<xref:System.Text.Encoding.GetString%2A>特定的方法<xref:System.Text.Encoding>實作取決於該定義的後援策略<xref:System.Text.Encoding>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1600">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="d4c2c-1601">如需詳細資訊，請參閱 「 選擇後援策略 」 一節[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1601">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1602">
            <paramref name="bytes" /> 是 null 指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1602">
              <paramref name="bytes" /> is a null pointer.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1603">
            <paramref name="byteCount" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1603">
              <paramref name="byteCount" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1604">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1604">A   fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for a complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1605">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1605">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1606">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1606">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">
          <span data-ttu-id="d4c2c-1607">包含要解碼之位元組序列的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1607">The byte array containing the sequence of bytes to decode.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="d4c2c-1608">要解碼的第一個位元組索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1608">The index of the first byte to decode.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="d4c2c-1609">要解碼的位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1609">The number of bytes to decode.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1610">在衍生類別中覆寫時，將指定位元組陣列中的位元組序列解碼成字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1610">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1611">字串，包含將指定之位元組序列解碼的結果。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1611">A string that contains the results of decoding the specified sequence of bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1612">如果要轉換的資料是僅適用於循序區塊 （例如從資料流讀取的資料），或如果資料總量很大，它必須將其分成較小的區塊，您應該使用<xref:System.Text.Decoder>或<xref:System.Text.Encoder>所提供<xref:System.Text.Encoding.GetDecoder%2A>方法或<xref:System.Text.Encoding.GetEncoder%2A>方法，分別的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1612">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>  
  
 <span data-ttu-id="d4c2c-1613">請參閱 < 備註 > 一節的<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>解碼技術和考量的討論的參考主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1613">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1614">下列範例會將 utf-8 編碼字串讀取所表示的二進位檔案<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1614">The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="d4c2c-1615">對於小於 2048 個位元組的檔案，它會讀取整個檔案的內容至位元組陣列和呼叫<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法進行解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1615">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to perform the decoding.</span></span> <span data-ttu-id="d4c2c-1616">較大的檔案，它 2,048 個位元組一次讀取的位元組陣列，呼叫<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>方法，以判斷的字元數包含陣列中，然後呼叫<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>方法進行解碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1616">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 <span data-ttu-id="d4c2c-1617">此範例會使用下列文字，應儲存至名為 Utf8Example.txt utf-8 編碼檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1617">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d4c2c-1618">位元組陣列包含無效的 Unicode 字碼指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1618">The byte array contains invalid Unicode code points.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1619">
            <paramref name="bytes" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1619">
              <paramref name="bytes" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d4c2c-1620">
            <paramref name="index" /> 或 <paramref name="count" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1620">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="d4c2c-1621">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1621">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1622">
            <paramref name="index" /> 與 <paramref name="count" /> 不代表 <paramref name="bytes" /> 中有效的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1622">
              <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Text.DecoderFallbackException">
          <span data-ttu-id="d4c2c-1623">發生後援 (如需完整說明，請參閱 [.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md))</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1623">A fallback occurred (see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) for complete explanation)</span>
          </span>
          <span data-ttu-id="d4c2c-1624">-和-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1624">-and-</span>
          </span>
          <span data-ttu-id="d4c2c-1625">
            <see cref="P:System.Text.Encoding.DecoderFallback" /> 設定為 <see cref="T:System.Text.DecoderExceptionFallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1625">
              <see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1626">在衍生類別中覆寫時，取得可以與郵件代理程式標頭標籤一起使用的目前編碼方式名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1626">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1627">目前 <see cref="T:System.Text.Encoding" /> 的名稱，與郵件代理程式標頭標記一起使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1627">A name for the current <see cref="T:System.Text.Encoding" /> to use with mail agent header tags.</span>
          </span>
          <span data-ttu-id="d4c2c-1628">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1628">-or-</span>
          </span>
          <span data-ttu-id="d4c2c-1629">如果無法使用目前的 <see cref="T:System.Text.Encoding" />，則為空字串 ("")。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1629">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1630">如果您需要的標頭名稱的編碼方式，您應該呼叫<xref:System.Text.Encoding.GetEncoding%2A>方法使用<xref:System.Text.Encoding.HeaderName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1630">If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property.</span></span> <span data-ttu-id="d4c2c-1631">通常方法會擷取不同的呼叫中提供的測試編碼所用的編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1631">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="d4c2c-1632">通常只有電子郵件應用程式必須擷取這類的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1632">Generally only email applications need to retrieve such an encoding.</span></span>  
  
 <span data-ttu-id="d4c2c-1633">在某些情況下，值<xref:System.Text.Encoding.BodyName%2A>屬性會對應至國際標準，可定義該編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1633">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="d4c2c-1634">這並不表示實作符合該標準的完整。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1634">This doesn't mean that the implementation complies in full with that standard.</span></span>  
  
 <span data-ttu-id="d4c2c-1635">請注意，<xref:System.Text.Encoding.WebName%2A>傳回要用來描述的編碼方式名稱。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1635">Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding.</span></span> <span data-ttu-id="d4c2c-1636"><xref:System.Text.Encoding.HeaderName%2A>屬性會定義不同的編碼方式，可能比較適合進行電子郵件應用程式，例如。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1636">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an email application, for example.</span></span> <span data-ttu-id="d4c2c-1637">不過，不建議使用這個屬性來定義的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1637">However, use of the property to define the encoding is not recommended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1638">下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1638">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4c2c-1639">它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1639">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1640">取得值，指出目前的編碼方式是否永遠都是正規化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1640">Gets a value indicating whether the current encoding is always normalized.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1641">取得值，指出目前的編碼方式是否永遠都是使用預設的正規化表單進行正規化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1641">Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1642">如果目前的 <see cref="T:System.Text.Encoding" /> 永遠都是正規化，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1642">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1643">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1643">The default is <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1644">預設的正規化表單是<xref:System.Text.NormalizationForm.FormC>，它會使用完整標準分解進行，如果可能的話後面的主要複合，序列取代。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1644">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">
          <span data-ttu-id="d4c2c-1645">其中一個 <see cref="T:System.Text.NormalizationForm" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1645">One of the <see cref="T:System.Text.NormalizationForm" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1646">在衍生類別中覆寫時取得值，指出目前的編碼方式是否永遠都是使用指定的正規化表單進行正規化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1646">When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d4c2c-1647">如果目前的 <see langword="true" /> 物件一律使用指定的 <see cref="T:System.Text.Encoding" /> 值進行正規化，則為 <see cref="T:System.Text.NormalizationForm" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1647">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1648">預設值為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1648">The default is <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1649">預設的正規化表單是<xref:System.Text.NormalizationForm.FormC>，它會使用完整標準分解進行，如果可能的話後面的主要複合，序列取代。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1649">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1650">在衍生類別中覆寫時，取得值，指出瀏覽器用戶端是否可以使用目前的編碼方式來顯示內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1650">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1651">如果瀏覽器用戶端可以使用目前的 <see cref="T:System.Text.Encoding" /> 來顯示內容，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1651">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for displaying content; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4c2c-1652">下列範例會檢查每個編碼的布林屬性值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1652">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1653">在衍生類別中覆寫時，取得值，指出瀏覽器用戶端是否可以使用目前的編碼方式來儲存內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1653">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1654">如果瀏覽器用戶端可以使用目前的 <see cref="T:System.Text.Encoding" /> 來儲存內容，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1654">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for saving content; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4c2c-1655">下列範例會檢查每個編碼的布林屬性值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1655">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1656">在衍生類別中覆寫時，取得值，指出郵件和新聞用戶端是否可以使用目前的編碼方式來顯示內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1656">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1657">如果郵件和新聞用戶端可以使用目前的 <see cref="T:System.Text.Encoding" /> 來顯示內容，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1657">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for displaying content; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4c2c-1658">下列範例會檢查每個編碼的布林屬性值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1658">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1659">在衍生類別中覆寫時，取得值，指出郵件和新聞用戶端是否可以使用目前的編碼方式來儲存內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1659">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1660">如果郵件和新聞用戶端可以使用目前的 <see langword="true" /> 來儲存內容，則為 <see cref="T:System.Text.Encoding" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1660">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for saving content; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d4c2c-1661">下列範例會檢查每個編碼的布林屬性值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1661">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1662">在衍生類別中覆寫時，取得值，指出目前的編碼方式是否為唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1662">When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1663">如果目前 <see langword="true" /> 是唯讀，則為 <see cref="T:System.Text.Encoding" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1663">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is read-only; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d4c2c-1664">預設值為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1664">The default is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1665">在衍生類別中覆寫時，取得值，指出目前的編碼方式是否使用單一位元組字碼指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1665">When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1666">如果目前的 <see langword="true" /> 使用單一位元組字碼指標，則為 <see cref="T:System.Text.Encoding" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1666">
              <see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> uses single-byte code points; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1667">單一位元組編碼，例如<xref:System.Text.ASCIIEncoding>，此屬性會擷取`true`。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1667">For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="d4c2c-1668">您應該要特別小心，在您的應用程式未使用的值<xref:System.Text.Encoding.IsSingleByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1668">You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>.</span></span> <span data-ttu-id="d4c2c-1669">編碼方式將繼續假設可能仍有誤。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1669">An assumption of how an Encoding will proceed may still be wrong.</span></span> <span data-ttu-id="d4c2c-1670">比方說，Windows 1252 其值為`true`針對<xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>，但 Encoding.GetMaxByteCount(1) 傳回 2。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1670">For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, but Encoding.GetMaxByteCount(1) returns 2.</span></span> <span data-ttu-id="d4c2c-1671">這是因為方法會考量先前的解碼器作業可能剩餘的 surrogate。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1671">This is because the method considers potential leftover surrogates from a previous decoder operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1672">下列範例會檢查每個編碼的布林屬性值。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1672">The following example checks the values of the Boolean properties of each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="d4c2c-1673">
            <see cref="T:System.Text.EncodingProvider" /> 的子類別，提供其他字元編碼方式的存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1673">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d4c2c-1674">註冊編碼提供者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1674">Registers an encoding provider.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1675"><xref:System.Text.Encoding.RegisterProvider%2A>方法可讓您註冊類別，衍生自<xref:System.Text.EncodingProvider>讓字元不會不支援這些平台上可用的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1675">The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them.</span></span> <span data-ttu-id="d4c2c-1676">一旦註冊編碼提供者，可以擷取它所支援的編碼方式呼叫任何<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>多載。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1676">Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> overload.</span></span> <span data-ttu-id="d4c2c-1677">如果有多個編碼提供者，<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>方法會嘗試擷取指定的編碼方式，就從開頭為最近註冊的每個提供者。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1677">If there are multiple encoding providers, the <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</span></span>

<span data-ttu-id="d4c2c-1678">使用登錄其編碼提供者<xref:System.Text.Encoding.RegisterProvider%2A>方法也會修改的行為[Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)和[EncodingProvider.GetEncoding (Int32，EncoderFallback，DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))方法時傳遞的引數`0`:</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1678">Registering an encoding provider by using the <xref:System.Text.Encoding.RegisterProvider%2A> method also modifies the behavior of the [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) and [EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) methods when passed an argument of `0`:</span></span>

- <span data-ttu-id="d4c2c-1679">如果已註冊的提供者<xref:System.Text.CodePagesEncodingProvider>，此方法會傳回 Windows 作業系統上執行時，符合系統作用中的字碼頁的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1679">If the registered provider is the <xref:System.Text.CodePagesEncodingProvider>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</span></span>

- <span data-ttu-id="d4c2c-1680">自訂編碼提供者可以選擇哪一種編碼傳回當任一<xref:System.Text.Encoding.GetEncoding%2A>方法多載會傳遞的引數`0`。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1680">A custom encoding provider can choose which encoding to return when either of these <xref:System.Text.Encoding.GetEncoding%2A> method overloads is passed an argument of `0`.</span></span> <span data-ttu-id="d4c2c-1681">提供者也可以選擇不會傳回所需要的編碼方式<xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType>方法會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1681">The provider can also choose to not return an encoding by having the <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> method return `null`.</span></span> 
  
<span data-ttu-id="d4c2c-1682">從.NET Framework 4.6 開始，.NET Framework 包含一個編碼提供者， <xref:System.Text.CodePagesEncodingProvider>，如此可用編碼，會出現在完整的.NET Framework，但不適用於通用 Windows 平台。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1682">Starting with the .NET Framework 4.6, the .NET Framework includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in the Universal Windows Platform.</span></span> <span data-ttu-id="d4c2c-1683">根據預設，通用 Windows 平台僅支援 Unicode 編碼方式、 ASCII 和字碼頁 28591。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1683">By default, the Universal Windows Platform only supports the Unicode encodings, ASCII, and code page 28591.</span></span>  
  
 <span data-ttu-id="d4c2c-1684">如果相同的編碼提供者會使用多個呼叫<xref:System.Text.Encoding.RegisterProvider%2A>的第一個方法呼叫的方法，註冊提供者。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1684">If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider.</span></span> <span data-ttu-id="d4c2c-1685">後續呼叫都會被忽略。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1685">Subsequent calls are ignored.</span></span>  
  
 <span data-ttu-id="d4c2c-1686">如果<xref:System.Text.Encoding.RegisterProvider%2A>註冊處理相同的編碼方式的多個提供者會呼叫方法，最後一個已註冊的提供者是用於所有的編碼和解碼作業。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1686">If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</span></span> <span data-ttu-id="d4c2c-1687">任何先前已註冊的提供者會被忽略。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1687">Any previously registered providers are ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d4c2c-1688">
            <paramref name="provider" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1688">
              <paramref name="provider" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1689">以位元組由小到大位元組順序取得 UTF-16 格式的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1689">Gets an encoding for the UTF-16 format using the little endian byte order.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1690">UTF-16 格式的編碼方式，使用位元組由小到大的位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1690">An encoding for the UTF-16 format using the little endian byte order.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1691">支援的.NET，並討論使用編碼的 Unicode 編碼的相關資訊，請參閱[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1691">For information about the encodings supported by the .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="d4c2c-1692"><xref:System.Text.UnicodeEncoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1692">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="d4c2c-1693">它會使用取代後援來取代無法編碼的每個字串和無法解碼的每個位元組以問號 ("？") 字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1693">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="d4c2c-1694">相反地，您可以呼叫<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化由小到大<xref:System.Text.UnicodeEncoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1694">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1695">下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1695">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1696">以位元組由小到大位元組順序取得 UTF-32 格式的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1696">Gets an encoding for the UTF-32 format using the little endian byte order.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1697">UTF-32 格式的編碼物件，使用位元組由小到大的位元組順序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1697">An  encoding object for the UTF-32 format using the little endian byte order.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1698"><xref:System.Text.UTF32Encoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1698">The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="d4c2c-1699">它會使用取代後援，來取代 Unicode REPLACEMENT CHARACTER (U + 7C94:FFFE) 中的每一個無法編碼的字串和無法解碼的每個位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1699">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</span></span> <span data-ttu-id="d4c2c-1700">相反地，您可以呼叫<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化<xref:System.Text.UTF32Encoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1700">Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 <span data-ttu-id="d4c2c-1701">如需少位元組由小到大位元組順序的討論，請參閱<xref:System.Text.Encoding>類別主題。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1701">For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.</span></span>  
  
 <span data-ttu-id="d4c2c-1702">支援的.NET，並討論使用編碼的 Unicode 編碼的相關資訊，請參閱[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1702">For information about the encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1703">下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1703">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1704">取得 UTF-7 格式的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1704">Gets an encoding for the UTF-7 format.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1705">UTF-7 格式的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1705">An encoding for the UTF-7 format.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1706">在過去有已限制為 7 個位元，例如 NNTP 和某些電子郵件應用程式的環境中，主要會使用 utf-7 編碼。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1706">UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</span></span> <span data-ttu-id="d4c2c-1707">強固性和安全性問題，因為您不應該使用 UTF7 8 位元環境中的編碼方式，utf-8 編碼方式可以使用。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1707">Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1708">下列範例會決定編碼的字元陣列所需的位元組數目、 編碼字元，並顯示產生的位元組數。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1708">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1709">取得 UTF-8 格式的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1709">Gets an encoding for the UTF-8 format.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1710">UTF-8 格式的編碼方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1710">An encoding for the UTF-8 format.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1711">這個屬性會傳回<xref:System.Text.UTF8Encoding>物件可將 Unicode （UTF 16 編碼） 的字元編碼為一到四個位元組，每個字元序列，並會解碼為 Unicode （UTF 16 編碼） 個字元的 UTF-8 編碼的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1711">This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</span></span> <span data-ttu-id="d4c2c-1712">支援的.NET，並討論使用編碼的 Unicode 字元編碼的相關資訊，請參閱[.NET 中的字元編碼](~/docs/standard/base-types/character-encoding.md)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1712">For information about the character encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
 <span data-ttu-id="d4c2c-1713"><xref:System.Text.UTF8Encoding>這個屬性所傳回的物件可能沒有適當的行為，您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1713">The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span>  
  
-   <span data-ttu-id="d4c2c-1714">它會傳回<xref:System.Text.UTF8Encoding>提供 Unicode 位元組順序標記 (BOM) 的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1714">It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM).</span></span> <span data-ttu-id="d4c2c-1715">若要具現化並不提供 BOM UTF8 編碼方式，呼叫的任何多載<xref:System.Text.UTF8Encoding.%23ctor%2A>建構函式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1715">To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.</span></span>  
  
-   <span data-ttu-id="d4c2c-1716">它會傳回<xref:System.Text.UTF8Encoding>會使用取代後援，以問號取代無法編碼的每個字串和無法解碼的每個位元組的物件 ("？") 字元。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1716">It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</span></span> <span data-ttu-id="d4c2c-1717">相反地，您可以呼叫<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>建構函式來具現化<xref:System.Text.UTF8Encoding>物件為其後援<xref:System.Text.EncoderFallbackException>或<xref:System.Text.DecoderFallbackException>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1717">Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1718">下列範例會定義陣列，其中包含下列字元：</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1718">The following example defines an array that consists of the following characters:</span></span>  
  
-   <span data-ttu-id="d4c2c-1719">拉丁文小寫字母 Z (U + 007A)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1719">LATIN SMALL LETTER Z (U+007A)</span></span>  
  
-   <span data-ttu-id="d4c2c-1720">拉丁文小型字母 (U + 0061)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1720">LATIN SMALL LETTER A (U+0061)</span></span>  
  
-   <span data-ttu-id="d4c2c-1721">結合音符 (U + 0306)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1721">COMBINING BREVE (U+0306)</span></span>  
  
-   <span data-ttu-id="d4c2c-1722">拉丁文小寫字母 AE 與嚴重 (U + 01FD)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1722">LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</span></span>  
  
-   <span data-ttu-id="d4c2c-1723">希臘文小寫字母 BETA (U + 03B2)</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1723">GREEK SMALL LETTER BETA (U+03B2)</span></span>  
  
-   <span data-ttu-id="d4c2c-1724">Surrogate 字組 (範圍從 U+D800 U + DD54) 形成希臘 ACROPHONIC ATTIC 一個千位 STATERS (U + 10154)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1724">A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</span></span>  
  
 <span data-ttu-id="d4c2c-1725">它會顯示每個字元的 utf-16 程式碼單位，並決定 utf-8 編碼器編碼的字元陣列所需的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1725">It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</span></span> <span data-ttu-id="d4c2c-1726">然後將字元編碼，並顯示結果的 UTF-8 編碼位元組。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1726">It then encodes the characters and displays the resulting UTF-8-encoded bytes.</span></span>  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1727">在衍生類別中覆寫時，若要取得目前的編碼方式，請取得向 Internet Assigned Numbers Authority (IANA) 註冊的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1727">When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1728">目前 <see cref="T:System.Text.Encoding" /> 的 IANA 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1728">The IANA name for the current <see cref="T:System.Text.Encoding" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1729"><xref:System.Text.Encoding.WebName%2A>屬性是相同<xref:System.Text.EncodingInfo.Name%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1729">The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.</span></span>  
  
 <span data-ttu-id="d4c2c-1730">請注意，<xref:System.Text.Encoding.WebName%2A>傳回 IANA 註冊名稱的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1730">Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding.</span></span> <span data-ttu-id="d4c2c-1731">當其值為一項標準的名稱時，編碼方式的實作可能會不符合該標準的完整。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1731">When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</span></span> <span data-ttu-id="d4c2c-1732"><xref:System.Text.Encoding.HeaderName%2A>屬性會定義不同的編碼方式，可能比較適合進行電子郵件標頭。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1732">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for email headers.</span></span> <span data-ttu-id="d4c2c-1733">不過，大部分的應用程式應該使用<xref:System.Text.Encoding.WebName%2A>改。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1733">However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.</span></span>  
  
 <span data-ttu-id="d4c2c-1734">如需有關 IANA 的詳細資訊，請移至[www.iana.org](https://www.iana.org/)。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1734">For more information on the IANA, go to [www.iana.org](https://www.iana.org/).</span></span>  
  
 <span data-ttu-id="d4c2c-1735"><xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType>等同<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>所傳回<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1735">The <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4c2c-1736">部分網站名稱會在重複的項目;請參閱的 < 備註 ><xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1736">Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> for more information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1737">下列範例會加入<xref:System.Text.Encoding.WebName%2A>HTML 標頭中。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1737">The following example includes the <xref:System.Text.Encoding.WebName%2A> in an HTML header.</span></span>  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 <span data-ttu-id="d4c2c-1738">下列範例會擷取每個編碼不同的名稱，並顯示一或多個不同的名稱編碼<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1738">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d4c2c-1739">它會顯示<xref:System.Text.Encoding.EncodingName%2A>但不會對其比較。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1739">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d4c2c-1740">在衍生類別中覆寫時，請取得最能符合目前編碼方式的 Windows 作業系統字碼頁。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1740">When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d4c2c-1741">最能符合目前 <see cref="T:System.Text.Encoding" /> 的 Windows 作業系統字碼頁。</span>
          <span class="sxs-lookup">
            <span data-stu-id="d4c2c-1741">The Windows operating system code page that most closely corresponds to the current <see cref="T:System.Text.Encoding" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d4c2c-1742">提供這個屬性是與 Windows 多語系 (MLang) Api 相容性，例如判斷字型系列。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1742">This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</span></span> <span data-ttu-id="d4c2c-1743">全球化，使用 Unicode 編碼方式的其中一個建議改為。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1743">For globalization, using one of the Unicode encodings is recommended instead.</span></span> <span data-ttu-id="d4c2c-1744">也建議使用<xref:System.Text.Encoding.WebName%2A>而不是<xref:System.Text.Encoding.WindowsCodePage%2A>來識別的字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1744">It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d4c2c-1745">下列範例會決定最能符合每個編碼 Windows 字碼頁。</span><span class="sxs-lookup"><span data-stu-id="d4c2c-1745">The following example determines the Windows code page that most closely corresponds to each encoding.</span></span>  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>