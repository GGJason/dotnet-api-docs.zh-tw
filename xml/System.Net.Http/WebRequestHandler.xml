<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a680639f246d9261064282b95f8cdb49f566df8c" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48744395" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class WebRequestHandler&#xA;Inherits HttpClientHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebRequestHandler : System::Net::Http::HttpClientHandler" />
  <TypeSignature Language="F#" Value="type WebRequestHandler = class&#xA;    inherit HttpClientHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 Windows 市集應用程式或其他環境中所沒有的桌面特定功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別會實作傳輸處理常式使用<xref:System.Net.HttpWebRequest>將 HTTP 要求傳送至伺服器的執行個體。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebRequestHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Http.WebRequestHandler" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPipelining As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPipelining { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowPipelining : bool with get, set" Usage="System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否將要求導送至網際網路資源。</summary>
        <value>傳回 <see cref="T:System.Boolean" />。  
  
 如果要求應該要導送，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式使用<xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A>可指出以管線連接喜好設定的屬性。 當<xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A>是`true`，應用程式會以管線的連接的伺服器上支援它們。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationLevel As AuthenticationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::AuthenticationLevel AuthenticationLevel { System::Net::Security::AuthenticationLevel get(); void set(System::Net::Security::AuthenticationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationLevel : System.Net.Security.AuthenticationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出用於這個要求的驗證和模擬等級。</summary>
        <value>傳回 <see cref="T:System.Net.Security.AuthenticationLevel" />。  
  
<see cref="T:System.Net.Security.AuthenticationLevel" /> 值的位元組合。  預設值是 <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在相互驗證中，用戶端和伺服器都會出示建立其識別的認證。 <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> 和 <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> 與 Kerberos 驗證有關。 Kerberos 驗證可以直接支援，或在使用交涉安全性通訊協定時，用來選取實際的安全性通訊協定。 如需有關驗證通訊協定的詳細資訊，請參閱 <<c0> [ 網際網路驗證](~/docs/framework/network-programming/internet-authentication.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Cache::RequestCachePolicy ^ CachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個要求的快取原則。</summary>
        <value>傳回 <see cref="T:System.Net.Cache.RequestCachePolicy" />。  
  
定義快取原則的 <see cref="T:System.Net.Cache.RequestCachePolicy" /> 物件。 預設值為 <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的快取原則和快取中要求的資源出現與否會決定是否可以從快取中擷取的回應。 使用快取回的應，通常可改善應用程式效能，但會有風險的快取中的回應不符合伺服器上的回應。  
  
 您可以在 Machine.config 組態檔中，或藉由設定，指定預設快取原則<xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A>屬性。  
  
 如果資源的回應資料流擷取和讀取資料流末端，則一份資源只會加入至快取。 因此針對相同資源的另一個要求可以使用快取的複本，根據此要求的快取原則層級。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個要求關聯的安全憑證集合。</summary>
        <value>傳回 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />。  
  
與這個要求相關聯的安全憑證的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : TimeSpan with get, set" Usage="System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定在上傳資料前，應用程式等待來自伺服器的 100-Continue 的時間長度 (以毫秒為單位)。</summary>
        <value>傳回 <see cref="T:System.TimeSpan" />。  
  
在上傳資料前，應用程式等待來自伺服器的 100-Continue 的時間長度 (以毫秒為單位)。 預設值為 350 毫秒。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前要求的模擬等級。</summary>
        <value>傳回 <see cref="T:System.Security.Principal.TokenImpersonationLevel" />。  
  
要求的模擬層級。 預設值為 <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 模擬等級會決定伺服器如何使用用戶端的認證。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定回應標頭的最大允許長度。</summary>
        <value>傳回 <see cref="T:System.Int32" />。  
  
回應標頭的長度，以 KB (1024 位元組) 為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 回應標頭的長度會包含回應狀態行及收到的 HTTP 通訊協定的一部分的任何額外的控制字元。 值為-1 表示沒有限制加諸於回應標頭;值為 0 表示所有的要求會失敗。  
  
 如果<xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A>屬性未明確設定，則預設值為<xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A>屬性。  
  
 如果收到的回應標頭的長度超過的值<xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A>屬性，會擲回例外狀況回應存取時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定寫入要求或從伺服器讀取回應時的逾時 (以毫秒為單位)。</summary>
        <value>傳回 <see cref="T:System.Int32" />。  
  
寫入或讀取逾時前的毫秒數。預設值為 300,000 毫秒 (5 分鐘)。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定驗證伺服器憑證的回呼方法。</summary>
        <value>傳回 <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />。  
  
驗證伺服器憑證的回呼方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A>是`null`，將會使用標準的已知憑證授權單位驗證伺服器憑證。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否允許高速 NTLM 驗證連接共用。</summary>
        <value>傳回 <see cref="T:System.Boolean" />。  
  
 保持已驗證連接於開啟的狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的預設值是`false`，因而導致要求完成之後關閉目前的連接。 您的應用程式必須通過驗證的順序，每一次，就會發出新的要求。如果這個屬性設定為`true`，執行驗證之後，用來擷取回應的連線保持開啟。 在此情況下，其他要求，將此屬性設定為`true`可能使用的連接，而不需重新驗證。 換句話說，如果使用者 A 已驗證的連線，使用者 B 可以重複使用 A 的連線;使用者 B 的要求完成根據使用者 a 的認證  
  
> [!CAUTION]
>  因為它可能會有應用程式使用的連接，而不必經過驗證，您必須要確定沒有任何系統管理的弱點可能會在您的系統時將此屬性設定為`true`。 如果您的應用程式會將要求傳送多個使用者 （會模擬多個使用者帳戶），並需要驗證來保護資源，執行未設定這個屬性為`true`除非您使用連線群組，如下所述。  
  
 您可能要考慮啟用這項機制，如果您有效能問題，並使用整合式 Windows 驗證的 Web 伺服器上執行您的應用程式。  
  
 啟用此設定會使系統的安全性風險。 如果您設定<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>屬性設`true`務必採取下列預防措施：  
  
-   執行您的應用程式中受保護的環境，可協助避免可能的連接入侵。  
  
 如果您控制後端伺服器，或者您可以考慮關閉驗證持續性。 這會增加效能，以較小的程度，但是比較安全。 如需詳細資訊，搜尋 MSDN library 中的 AuthPersistence [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>