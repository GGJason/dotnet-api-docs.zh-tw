<Type Name="HttpClientHandler" FullName="System.Net.Http.HttpClientHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4e4378873f3a5fa6c23c6de9bded7f111e986d3e" /><Meta Name="ms.sourcegitcommit" Value="8c966994f39ffe6e7c21611e9ec1b91247a68500" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="01/26/2019" /><Meta Name="ms.locfileid" Value="55084612" /></Metadata><TypeSignature Language="C#" Value="public class HttpClientHandler : System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HttpClientHandler extends System.Net.Http.HttpMessageHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpClientHandler&#xA;Inherits HttpMessageHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpClientHandler : System::Net::Http::HttpMessageHandler" />
  <TypeSignature Language="F#" Value="type HttpClientHandler = class&#xA;    inherit HttpMessageHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpMessageHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="bcaed-101">.NET Framework 和 .NET Core 2.0 及更舊版本中 <see cref="T:System.Net.Http.HttpClient" /> 使用的預設訊息處理常式。</span><span class="sxs-lookup"><span data-stu-id="bcaed-101">The default message handler used by <see cref="T:System.Net.Http.HttpClient" /> in .NET Framework and .NET Core 2.0 and earlier.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-102">`HttpClientHandler`類別和從它衍生的類別可讓開發人員設定各種不同的範圍從 proxy 到驗證的選項。</span><span class="sxs-lookup"><span data-stu-id="bcaed-102">The `HttpClientHandler` class and classes derived from it enable developers to configure a variety of options ranging from proxies to authentication.</span></span>  
  
### <a name="httpclienthandler-in-net-core"></a><span data-ttu-id="bcaed-103">.NET Core 中的 HttpClientHandler</span><span class="sxs-lookup"><span data-stu-id="bcaed-103">HttpClientHandler in .NET Core</span></span>

<span data-ttu-id="bcaed-104">.NET Core 2.1 中，從開始<xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType>類別而不是`HttpClientHandler`提供較高層級的 HTTP 網路功能 Api 所使用的實作。</span><span class="sxs-lookup"><span data-stu-id="bcaed-104">Starting with .NET Core 2.1, the <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> class instead of `HttpClientHandler` provides the implementation used by higher-level HTTP networking APIs.</span></span> <span data-ttu-id="bcaed-105">您可以設定您的應用程式使用`HttpClientHandler`改為在下列任一方式：</span><span class="sxs-lookup"><span data-stu-id="bcaed-105">You can configure your application to use `HttpClientHandler` instead in any of the following ways:</span></span>

- <span data-ttu-id="bcaed-106">藉由呼叫<xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType>方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="bcaed-106">By calling the <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> method as follows:</span></span>

  ```csharp
  AppContext.SetSwitch("System.Net.Http.useSocketsHttpHandler", false);
  ```
  ```vb
  AppContext.SetSwitch("System.Net.Http.useSocketsHttpHandler", False)
  ``` 
<span data-ttu-id="bcaed-107">藉由定義`System.Net.Http.useSocketsHttpHandler`切換移入 *。 netcore.runtimeconfig.json*組態檔：</span><span class="sxs-lookup"><span data-stu-id="bcaed-107">By defining the `System.Net.Http.useSocketsHttpHandler` switch in the *.netcore.runtimeconfig.json* configuration file:</span></span>

  ```json
  "runtimeOptions": {
    "configProperties": {
        "System.Net.Http.useSocketsHttpHandler": false
    }
  }
  ```
  
- <span data-ttu-id="bcaed-108">定義名為環境變數`DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER`並將它設定為`false`則為 0。</span><span class="sxs-lookup"><span data-stu-id="bcaed-108">By defining an environment variable named `DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER` and setting it to either `false` or 0.</span></span>

## Examples  
 [!code-csharp[System.Net.Http.HttpClientHandler#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.http.httpclienthandler/cs/source.cs#1)]  
  
 <span data-ttu-id="bcaed-109">上述程式碼範例會使用`async Task Main()`進入點。</span><span class="sxs-lookup"><span data-stu-id="bcaed-109">The preceding code example uses an `async Task Main()` entry point.</span></span> <span data-ttu-id="bcaed-110">該功能需要 C# 7.1 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="bcaed-110">That feature requires C# 7.1 or later.</span></span>
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=245696"><span data-ttu-id="bcaed-111">連接到 web 服務</span><span class="sxs-lookup"><span data-stu-id="bcaed-111">Connecting to a web service</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245697"><span data-ttu-id="bcaed-112">快速入門：使用 httpclient 進行連線</span><span class="sxs-lookup"><span data-stu-id="bcaed-112">Quickstart: Connecting using HttpClient</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245699"><span data-ttu-id="bcaed-113">如何使用 HttpClient 處理常式</span><span class="sxs-lookup"><span data-stu-id="bcaed-113">How to use HttpClient handlers</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245698"><span data-ttu-id="bcaed-114">如何保護 HttpClient 連線</span><span class="sxs-lookup"><span data-stu-id="bcaed-114">How to secure HttpClient connections</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=242550"><span data-ttu-id="bcaed-115">HttpClient 範例</span><span class="sxs-lookup"><span data-stu-id="bcaed-115">HttpClient Sample</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpClientHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClientHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpClientHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bcaed-116">建立 <see cref="T:System.Net.Http.HttpClientHandler" /> 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="bcaed-116">Creates an instance of a <see cref="T:System.Net.Http.HttpClientHandler" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.Http.HttpClientHandler.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-117">取得或設定值，這個值指出此處理常式是否應該接在重新導向回應之後。</span><span class="sxs-lookup"><span data-stu-id="bcaed-117">Gets or sets a value that indicates whether the handler should follow redirection responses.</span></span></summary>
        <value><span data-ttu-id="bcaed-118"><see langword="true" /> 如果處理常式應該接在重新導向回應;否則<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-118"><see langword="true" /> if the handler should follow redirection responses; otherwise <see langword="false" />.</span></span> <span data-ttu-id="bcaed-119">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-119">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-120">設定<xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A>至`true`如果您想要自動遵循 HTTP 重新導向標頭之資源的新位置的處理常式。</span><span class="sxs-lookup"><span data-stu-id="bcaed-120">Set <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> to `true` if you want the handler to automatically follow HTTP redirection headers to the new location of the resource.</span></span> <span data-ttu-id="bcaed-121">若要遵循重新導向的最大數目由設定<xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="bcaed-121">The maximum number of redirections to follow is set by the <xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A> property.</span></span>  
  
 <span data-ttu-id="bcaed-122">如果<xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A>設為`false`，所有 HTTP 回應 HTTP 狀態碼從 300 399 會都傳回應用程式。</span><span class="sxs-lookup"><span data-stu-id="bcaed-122">If <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> is set to `false`, all HTTP responses with an HTTP status code from 300 to 399 are  returned to the application.</span></span>  
  
 <span data-ttu-id="bcaed-123">授權標頭都會自動重新導向和處理常式會自動嘗試重新驗證，才能重新導向的位置。</span><span class="sxs-lookup"><span data-stu-id="bcaed-123">The Authorization header is cleared on auto-redirects and the handler automatically tries to re-authenticate to the redirected location.</span></span> <span data-ttu-id="bcaed-124">在實務上，這表示如果它是可能發生重新導向應用程式無法將授權標頭自訂驗證資訊。</span><span class="sxs-lookup"><span data-stu-id="bcaed-124">In practice, this means that an application can't put custom authentication information into the Authorization header if it is possible to encounter redirection.</span></span> <span data-ttu-id="bcaed-125">相反地，應用程式必須實作並註冊自訂驗證模組。</span><span class="sxs-lookup"><span data-stu-id="bcaed-125">Instead, the application must implement and register a custom authentication module.</span></span>  

> [!NOTE]
>  <span data-ttu-id="bcaed-126">具有<xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A>設定為`true`，.NET Framework 會遵循重新導向，即使正在從 HTTPS URI 重新導向至 HTTP URI。</span><span class="sxs-lookup"><span data-stu-id="bcaed-126">With <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> set to `true`, the .NET Framework will follow redirections even when being redirected to an HTTP URI from an HTTPS URI.</span></span>
<span data-ttu-id="bcaed-127">.NET core 1.0、 1.1 和 2.0 版的版本將不會追蹤重新導向從 HTTPS 至 HTTP，即使<xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A>設為`true`。</span><span class="sxs-lookup"><span data-stu-id="bcaed-127">.NET Core versions 1.0, 1.1 and 2.0 will not follow a redirection from HTTPS to HTTP even if <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> is set to `true`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.Http.HttpClientHandler.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-128">取得或設定解壓縮方法的類型，此為 HTTP 內容回應的自動解壓縮處理常式所使用。</span><span class="sxs-lookup"><span data-stu-id="bcaed-128">Gets or sets the type of decompression method used by the handler for automatic decompression of the HTTP content response.</span></span></summary>
        <value><span data-ttu-id="bcaed-129">處理常式所使用的自動解壓縮方法。</span><span class="sxs-lookup"><span data-stu-id="bcaed-129">The automatic decompression method used by the handler.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
<span data-ttu-id="bcaed-130">適用於.NET Framework 4.x`System.Net.Http`二進位檔在全域組件快取 (GAC) 中，預設值是<xref:System.Net.DecompressionMethods.None>。</span><span class="sxs-lookup"><span data-stu-id="bcaed-130">For the .NET Framework 4.x `System.Net.Http` binary in the Global Assembly Cache (GAC), the default value is <xref:System.Net.DecompressionMethods.None>.</span></span>

<span data-ttu-id="bcaed-131">當[ `System.Net.Http` NuGet 套件](https://www.nuget.org/packages/System.Net.Http/)到 v4.3.2 4.1.0 版時，預設值是<xref:System.Net.DecompressionMethods.GZip>和<xref:System.Net.DecompressionMethods.Deflate>。</span><span class="sxs-lookup"><span data-stu-id="bcaed-131">When the [`System.Net.Http` NuGet package](https://www.nuget.org/packages/System.Net.Http/) v4.1.0 to v4.3.2 is used, the default is <xref:System.Net.DecompressionMethods.GZip> and <xref:System.Net.DecompressionMethods.Deflate>.</span></span>

<span data-ttu-id="bcaed-132">在 NuGet 套件 v4.3.2 的預設值之後<xref:System.Net.DecompressionMethods.None>用。</span><span class="sxs-lookup"><span data-stu-id="bcaed-132">After NuGet package v4.3.2, the default value of <xref:System.Net.DecompressionMethods.None> is used.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckCertificateRevocationList">
      <MemberSignature Language="C#" Value="public bool CheckCertificateRevocationList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCertificateRevocationList" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.CheckCertificateRevocationList" />
      <MemberSignature Language="VB.NET" Value="Public Property CheckCertificateRevocationList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CheckCertificateRevocationList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCertificateRevocationList : bool with get, set" Usage="System.Net.Http.HttpClientHandler.CheckCertificateRevocationList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-133">取得或設定值，指出是否根據憑證授權撤銷清單來檢查憑證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-133">Gets or sets a value that indicates whether the certificate is checked against the certificate authority revocation list.</span></span></summary>
        <value><span data-ttu-id="bcaed-134">如果檢查憑證撤銷清單，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-134"><see langword="true" /> if the certificate revocation list is checked; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="bcaed-135">僅限 .NET Framework 4.7.1：這個屬性未實作。</span><span class="sxs-lookup"><span data-stu-id="bcaed-135">.NET Framework 4.7.1 only: This property is not implemented.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificateOptions">
      <MemberSignature Language="C#" Value="public System.Net.Http.ClientCertificateOption ClientCertificateOptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Http.ClientCertificateOption ClientCertificateOptions" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.ClientCertificateOptions" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificateOptions As ClientCertificateOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Http::ClientCertificateOption ClientCertificateOptions { System::Net::Http::ClientCertificateOption get(); void set(System::Net::Http::ClientCertificateOption value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificateOptions : System.Net.Http.ClientCertificateOption with get, set" Usage="System.Net.Http.HttpClientHandler.ClientCertificateOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.ClientCertificateOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-136">取得或設定值，表示憑證是否會從憑證存放區自動選取，或呼叫端是否允許傳入特定用戶端憑證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-136">Gets or sets a value that indicates if the certificate is automatically picked from the certificate store or if the caller is allowed to pass in a specific client certificate.</span></span></summary>
        <value><span data-ttu-id="bcaed-137">與此處理常式相關聯的安全性憑證集合。</span><span class="sxs-lookup"><span data-stu-id="bcaed-137">The collection of security certificates associated with this handler.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.HttpClientHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-138">取得為伺服器相關聯要求的安全憑證集合。</span><span class="sxs-lookup"><span data-stu-id="bcaed-138">Gets the collection of security certificates that are associated requests to the server.</span></span></summary>
        <value><span data-ttu-id="bcaed-139">執行憑證時，會向伺服器 X509CertificateCollection 型用戶端驗證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-139">The X509CertificateCollection that is presented to the server when performing certificate based client authentication.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.Http.HttpClientHandler.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-140">取得或設定處理常式用來儲存伺服器 cookie 的 cookie 容器。</span><span class="sxs-lookup"><span data-stu-id="bcaed-140">Gets or sets the cookie container used to store server cookies by the handler.</span></span></summary>
        <value><span data-ttu-id="bcaed-141">處理常式用來儲存伺服器 cookie 的 cookie 容器。</span><span class="sxs-lookup"><span data-stu-id="bcaed-141">The cookie container used to store server cookies by the handler.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-142"><xref:System.Net.Http.HttpClientHandler.CookieContainer%2A>屬性所提供的執行個體<xref:System.Net.CookieContainer>類別，其中包含這個處理常式相關聯的 cookie。</span><span class="sxs-lookup"><span data-stu-id="bcaed-142">The <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> property provides an instance of the <xref:System.Net.CookieContainer> class that contains the cookies associated with this handler.</span></span>  
  
 <span data-ttu-id="bcaed-143">如果<xref:System.Net.Http.HttpClientHandler.UseCookies%2A>屬性是`true`，則<xref:System.Net.Http.HttpClientHandler.CookieContainer%2A>屬性表示用來儲存伺服器 cookie 的 cookie 容器。</span><span class="sxs-lookup"><span data-stu-id="bcaed-143">If the <xref:System.Net.Http.HttpClientHandler.UseCookies%2A> property is `true`, the <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> property represents the cookie container used to store the server cookies.</span></span> <span data-ttu-id="bcaed-144">使用者可以傳送要求使用此屬性之前，先設定自訂的 cookie。</span><span class="sxs-lookup"><span data-stu-id="bcaed-144">The user can set custom cookies before sending requests using this property.</span></span> <span data-ttu-id="bcaed-145">如果<xref:System.Net.Http.HttpClientHandler.UseCookies%2A>屬性為 false，而且使用者新增至 cookie <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A>，cookie 會被忽略，而且不會傳送到伺服器。</span><span class="sxs-lookup"><span data-stu-id="bcaed-145">If the  <xref:System.Net.Http.HttpClientHandler.UseCookies%2A> property is false and the user adds cookies to <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A>, cookies are ignored and not sent to the server.</span></span> <span data-ttu-id="bcaed-146">設定<xref:System.Net.Http.HttpClientHandler.CookieContainer%2A>至`null`將會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="bcaed-146">Setting the <xref:System.Net.Http.HttpClientHandler.CookieContainer%2A> to `null` will throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.Http.HttpClientHandler.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-147">取得或設定這個處理常式所用的驗證資訊。</span><span class="sxs-lookup"><span data-stu-id="bcaed-147">Gets or sets authentication information used by this handler.</span></span></summary>
        <value><span data-ttu-id="bcaed-148">與處理常式相關聯的驗證認證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-148">The authentication credentials associated with the handler.</span></span> <span data-ttu-id="bcaed-149">預設為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-149">The default is <see langword="null" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousAcceptAnyServerCertificateValidator">
      <MemberSignature Language="C#" Value="public static Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,bool&gt; DangerousAcceptAnyServerCertificateValidator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Func`5&lt;class System.Net.Http.HttpRequestMessage, class System.Security.Cryptography.X509Certificates.X509Certificate2, class System.Security.Cryptography.X509Certificates.X509Chain, valuetype System.Net.Security.SslPolicyErrors, bool&gt; DangerousAcceptAnyServerCertificateValidator" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DangerousAcceptAnyServerCertificateValidator As Func(Of HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ DangerousAcceptAnyServerCertificateValidator { Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DangerousAcceptAnyServerCertificateValidator : Func&lt;System.Net.Http.HttpRequestMessage, System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.X509Certificates.X509Chain, System.Net.Security.SslPolicyErrors, bool&gt;" Usage="System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-150">取得一律傳回 <see langword="true" /> 的快取委派。</span><span class="sxs-lookup"><span data-stu-id="bcaed-150">Gets a cached delegate that always returns <see langword="true" />.</span></span></summary>
        <value><span data-ttu-id="bcaed-151">一律傳回 <see langword="true" /> 的快取委派。</span><span class="sxs-lookup"><span data-stu-id="bcaed-151">A cached delegate that always returns <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-152">特別是在測試案例，常見模式使用<xref:System.Net.Http.HttpClient>連接到伺服器，不應該進行驗證，例如自我簽署憑證的憑證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-152">Particularly in test scenarios, a common pattern use <xref:System.Net.Http.HttpClient> to connect to a server with a certificate that shouldn't be validated, such as a self-signed certificate.</span></span> <span data-ttu-id="bcaed-153">您經常執行此<xref:System.Net.Http.HttpClientHandler>splittunneling<xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A>屬性的委派，一律會傳回`True`; 這表示憑證已通過驗證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-153">You commonly do this with <xref:System.Net.Http.HttpClientHandler> by setting the <xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A> property to a delegate that always returns `True`; this indicates that the certificate has passed validation.</span></span> <span data-ttu-id="bcaed-154">不過，並非所有實作都支援此回呼中，而某些會擲回<xref:System.PlatformNotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="bcaed-154">However, not all implementations support this callback, and some throw <xref:System.PlatformNotSupportedException>.</span></span>  
  
 <span data-ttu-id="bcaed-155"><xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A>屬性解決這項限制。</span><span class="sxs-lookup"><span data-stu-id="bcaed-155">The <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> property addresses this limitation.</span></span> <span data-ttu-id="bcaed-156">所傳回的委派<xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A>屬性可以指派給<xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A>屬性，如下列範例會：</span><span class="sxs-lookup"><span data-stu-id="bcaed-156">The delegate returned by the <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> property can be assigned to the <xref:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback%2A> property, as the following example does:</span></span>  
  
```cs
handler.ServerCertificateCustomValidationCallback = httpClientHandler.DangerousAcceptAnyServerCertificateValidator;
```

 <span data-ttu-id="bcaed-157">這可讓<xref:System.Net.Http.HttpClientHandler>實作已知的物件的參考識別表示開發人員的意圖。</span><span class="sxs-lookup"><span data-stu-id="bcaed-157">This gives <xref:System.Net.Http.HttpClientHandler> implementations a known object reference identity that expresses the developer's intention.</span></span> <span data-ttu-id="bcaed-158">如果物件儲存在<xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A>屬性會參考等於<xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A>，執行階段是能夠完全停用驗證，否則會擲回的平台上<xref:System.PlatformNotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="bcaed-158">If the object stored in the <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A> property is reference equals to <xref:System.Net.Http.HttpClientHandler.DangerousAcceptAnyServerCertificateValidator%2A>, the runtime is able to entirely disable validation on a platform that would otherwise throw a <xref:System.PlatformNotSupportedException>.</span></span>  
  
 <span data-ttu-id="bcaed-159">作為一項好處，開發人員可以使用這個屬性，方便的工具，加上旗標停用憑證驗證，以避免傳送不安全的應用程式的開發人員更容易的危險。</span><span class="sxs-lookup"><span data-stu-id="bcaed-159">As a side benefit, developers can use this property to make it easier for tools to flag the danger of disabling certificate validation, which makes it easier for developers to avoid shipping insecure applications.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultProxyCredentials">
      <MemberSignature Language="C#" Value="public System.Net.ICredentials DefaultProxyCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials DefaultProxyCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.DefaultProxyCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultProxyCredentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ICredentials ^ DefaultProxyCredentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultProxyCredentials : System.Net.ICredentials with get, set" Usage="System.Net.Http.HttpClientHandler.DefaultProxyCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-160">使用預設 (系統) Proxy 時，取得或設定要提交至預設 Proxy 伺服器進行驗證的認證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-160">When the default (system) proxy is being used, gets or sets the credentials to submit to the default proxy server for authentication.</span></span> <span data-ttu-id="bcaed-161">只有當 <see cref="P:System.Net.Http.HttpClientHandler.UseProxy" /> 設定為 <see langword="true" /> 且 <see cref="P:System.Net.Http.HttpClientHandler.Proxy" /> 設定為 <see langword="null" /> 時，才使用預設 Proxy。</span><span class="sxs-lookup"><span data-stu-id="bcaed-161">The default proxy is used only when <see cref="P:System.Net.Http.HttpClientHandler.UseProxy" /> is set to <see langword="true" /> and <see cref="P:System.Net.Http.HttpClientHandler.Proxy" /> is set to <see langword="null" />.</span></span></summary>
        <value><span data-ttu-id="bcaed-162">若要驗證預設的 proxy 伺服器要求所需的認證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-162">The credentials needed to authenticate a request to the default proxy server.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClientHandler.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="httpClientHandler.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="bcaed-163"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源；<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="bcaed-163"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="bcaed-164">釋放 <see cref="T:System.Net.Http.HttpClientHandler" /> 所使用的 Unmanaged 資源，並選擇性處置 Managed 資源。</span><span class="sxs-lookup"><span data-stu-id="bcaed-164">Releases the unmanaged resources used by the <see cref="T:System.Net.Http.HttpClientHandler" /> and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-165">這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bcaed-165">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="bcaed-166">`Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設為`true`。</span><span class="sxs-lookup"><span data-stu-id="bcaed-166">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="bcaed-167"><xref:System.Object.Finalize%2A> 叫用`Dispose`具有`disposing`設定為`false`。</span><span class="sxs-lookup"><span data-stu-id="bcaed-167"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="bcaed-168">`disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.Net.Http.HttpClientHandler> 參考的任何 Managed 物件所掌握的資源。</span><span class="sxs-lookup"><span data-stu-id="bcaed-168">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Http.HttpClientHandler> references.</span></span> <span data-ttu-id="bcaed-169">這個方法會叫用每個參考物件的 `Dispose()` 方法。</span><span class="sxs-lookup"><span data-stu-id="bcaed-169">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaxAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxAutomaticRedirections : int with get, set" Usage="System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-170">取得或設定處理常式追蹤的最大重新導向數目。</span><span class="sxs-lookup"><span data-stu-id="bcaed-170">Gets or sets the maximum number of redirects that the handler follows.</span></span></summary>
        <value><span data-ttu-id="bcaed-171">處理常式追蹤的最大重新導向回應數目。</span><span class="sxs-lookup"><span data-stu-id="bcaed-171">The maximum number of redirection responses that the handler follows.</span></span> <span data-ttu-id="bcaed-172">預設值為 50。</span><span class="sxs-lookup"><span data-stu-id="bcaed-172">The default value is 50.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-173"><xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A>屬性設定為如果遵循要求重新導向的數目上限<xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="bcaed-173">The <xref:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections%2A> property sets the maximum number of redirections for the request to follow if the <xref:System.Net.Http.HttpClientHandler.AllowAutoRedirect%2A> property is `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxConnectionsPerServer">
      <MemberSignature Language="C#" Value="public int MaxConnectionsPerServer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxConnectionsPerServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxConnectionsPerServer" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxConnectionsPerServer As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxConnectionsPerServer { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxConnectionsPerServer : int with get, set" Usage="System.Net.Http.HttpClientHandler.MaxConnectionsPerServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-174">取得或設定使用 <see cref="T:System.Net.Http.HttpClient" /> 物件提出要求時，所允許的同時連線 數目上限 (每個伺服器端點)。</span><span class="sxs-lookup"><span data-stu-id="bcaed-174">Gets or sets the maximum number of concurrent connections (per server endpoint) allowed when making requests using an <see cref="T:System.Net.Http.HttpClient" /> object.</span></span> <span data-ttu-id="bcaed-175">請注意，此限制是按照每個伺服器端點計算，例如值 256 允許 http://www.adatum.com/ 使用 256 個同時連線，而 http://www.adventure-works.com/ 另有 256 個同時連線。</span><span class="sxs-lookup"><span data-stu-id="bcaed-175">Note that the limit is per server endpoint, so for example a value of 256 would permit 256 concurrent connections to http://www.adatum.com/ and another 256 to http://www.adventure-works.com/.</span></span></summary>
        <value><span data-ttu-id="bcaed-176">並行 （每個伺服器端點） 所允許的連線數目上限<see cref="T:System.Net.Http.HttpClient" />物件。</span><span class="sxs-lookup"><span data-stu-id="bcaed-176">The maximum number of concurrent connections (per server endpoint) allowed by an <see cref="T:System.Net.Http.HttpClient" /> object.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxRequestContentBufferSize">
      <MemberSignature Language="C#" Value="public long MaxRequestContentBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxRequestContentBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxRequestContentBufferSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxRequestContentBufferSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxRequestContentBufferSize : int64 with get, set" Usage="System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-177">取得或設定此處理常式所使用最大要求內容的緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="bcaed-177">Gets or sets the maximum request content buffer size used by the handler.</span></span></summary>
        <value><span data-ttu-id="bcaed-178">最大要求內容緩衝區大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="bcaed-178">The maximum request content buffer size in bytes.</span></span> <span data-ttu-id="bcaed-179">預設值為 2 GB。</span><span class="sxs-lookup"><span data-stu-id="bcaed-179">The default value is 2 gigabytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-180">應用程式可以設定<xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A>較低的值，以限制的要求緩衝區大小的屬性。</span><span class="sxs-lookup"><span data-stu-id="bcaed-180">An app can set the <xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A> property to a lower value to limit the size of the request buffer.</span></span> <span data-ttu-id="bcaed-181">要求內容的大小是否大於<xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A> 屬性中擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="bcaed-181">If the size of the request content is greater than the <xref:System.Net.Http.HttpClientHandler.MaxRequestContentBufferSize%2A> property, an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.HttpClientHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-182">取得或設定回應標頭的最大長度，以 KB (1024 位元組) 為單位。</span><span class="sxs-lookup"><span data-stu-id="bcaed-182">Gets or sets the maximum length, in kilobytes (1024 bytes), of the response headers.</span></span> <span data-ttu-id="bcaed-183">比方說，如果值為 64，則最大回應標頭長度允許有 65536 個位元組。</span><span class="sxs-lookup"><span data-stu-id="bcaed-183">For example, if the value is 64, then 65536 bytes are allowed for the maximum response headers' length.</span></span></summary>
        <value><span data-ttu-id="bcaed-184">最大長度，以 kb 為單位 （1024 位元組），回應標頭。</span><span class="sxs-lookup"><span data-stu-id="bcaed-184">The maximum length, in kilobytes (1024 bytes), of the response headers.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.Http.HttpClientHandler.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-185">取得或設定值，這個值指出處理常式是否隨著要求傳送授權標頭。</span><span class="sxs-lookup"><span data-stu-id="bcaed-185">Gets or sets a value that indicates whether the handler sends an Authorization header with the request.</span></span></summary>
        <value><span data-ttu-id="bcaed-186"><see langword="true" /> 表示處理常式在進行驗證後隨同要求傳送 HTTP 授權標頭，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-186"><see langword="true" /> for the handler to send an HTTP Authorization header with requests after authentication has taken place; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="bcaed-187">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-187">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-188">在特定用戶端提出要求後<xref:System.Uri>成功驗證時，如果<xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A>屬性是`true`並提供認證，<xref:System.Net.Http.HttpClientHandler>中提供的認證清單進行比對的相符項目<xref:System.Net.Http.HttpClientHandler.Credentials%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="bcaed-188">After a client request to a specific <xref:System.Uri> is successfully authenticated, if the <xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A> property is `true` and credentials are supplied, <xref:System.Net.Http.HttpClientHandler> matches against the credential list supplied in the  <xref:System.Net.Http.HttpClientHandler.Credentials%2A> property.</span></span> <span data-ttu-id="bcaed-189">授權標頭會隨著每個要求傳送至任何<xref:System.Uri>符合特定<xref:System.Uri>到最後的斜線。</span><span class="sxs-lookup"><span data-stu-id="bcaed-189">The Authorization header is sent with each request to any <xref:System.Uri> that matches the specific <xref:System.Uri> up to the last forward slash.</span></span>  
  
 <span data-ttu-id="bcaed-190">如果用戶端要求在特定<xref:System.Uri>是驗證不成功，要求會使用標準驗證程序。</span><span class="sxs-lookup"><span data-stu-id="bcaed-190">If the client request to a specific <xref:System.Uri> is not successfully authenticated, the request uses standard authentication procedures.</span></span>  
  
 <span data-ttu-id="bcaed-191">第一個要求中，除了<xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A>屬性會指出是否要傳送的後續要求使用的驗證資訊<xref:System.Uri>符合特定<xref:System.Uri>到而不需要等待進行最後的斜線伺服器所面臨的挑戰。</span><span class="sxs-lookup"><span data-stu-id="bcaed-191">With the exception of the first request, the <xref:System.Net.Http.HttpClientHandler.PreAuthenticate%2A> property indicates whether to send authentication information with subsequent requests to a <xref:System.Uri> that matches the specific <xref:System.Uri> up to the last forward slash without waiting to be challenged by the server.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Properties { System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Net.Http.HttpClientHandler.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-192">取得 <see cref="T:System.Net.Http.HttpClient" /> 要求之自訂屬性的可寫入字典 (也就是對應)。</span><span class="sxs-lookup"><span data-stu-id="bcaed-192">Gets a writable dictionary (that is, a map) of custom properties for the <see cref="T:System.Net.Http.HttpClient" /> requests.</span></span> <span data-ttu-id="bcaed-193">字典會初始化為空字典。您可以插入及查詢自訂處理常式和特殊處理的索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="bcaed-193">The dictionary is initialized empty; you can insert and query key-value pairs for your custom handlers and special processing.</span></span></summary>
        <value><span data-ttu-id="bcaed-194">可寫入自訂屬性的字典。</span><span class="sxs-lookup"><span data-stu-id="bcaed-194">a writable dictionary of custom properties.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.Http.HttpClientHandler.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-195">取得或設定處理常式所使用的 Proxy 資訊。</span><span class="sxs-lookup"><span data-stu-id="bcaed-195">Gets or sets proxy information used by the handler.</span></span></summary>
        <value><span data-ttu-id="bcaed-196">處理常式所使用的 Proxy 資訊。</span><span class="sxs-lookup"><span data-stu-id="bcaed-196">The proxy information used by the handler.</span></span> <span data-ttu-id="bcaed-197">預設值為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-197">The default value is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-198"><xref:System.Net.Http.HttpClientHandler.Proxy%2A>屬性會識別<xref:System.Net.WebProxy>物件，用來處理對網際網路資源的要求。</span><span class="sxs-lookup"><span data-stu-id="bcaed-198">The <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property identifies the <xref:System.Net.WebProxy> object to use to process requests to Internet resources.</span></span> <span data-ttu-id="bcaed-199">若要指定任何 proxy，應使用，請設定<xref:System.Net.Http.HttpClientHandler.Proxy%2A>屬性所傳回的 proxy 執行個體<xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="bcaed-199">To specify that no proxy should be used, set the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property to the proxy instance returned by the <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A> method.</span></span>  
  
 <span data-ttu-id="bcaed-200">在本機電腦或應用程式組態檔，可能會指定使用預設 proxy。</span><span class="sxs-lookup"><span data-stu-id="bcaed-200">The local computer or application config file may specify that a default proxy be used.</span></span> <span data-ttu-id="bcaed-201">如果<xref:System.Net.Http.HttpClientHandler.Proxy%2A>指定屬性，然後從的 proxy 設定<xref:System.Net.Http.HttpClientHandler.Proxy%2A>屬性覆寫本機電腦或應用程式組態檔和處理常式會使用指定的 proxy 設定。</span><span class="sxs-lookup"><span data-stu-id="bcaed-201">If the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property is specified, then the proxy settings from the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property override the local computer or application config file and the handler will use the proxy settings specified.</span></span> <span data-ttu-id="bcaed-202">如果在組態檔中未不指定任何 proxy，<xref:System.Net.Http.HttpClientHandler.Proxy%2A>屬性為未指定，則處理常式會使用繼承自 Internet Explorer 中，在本機電腦上的 proxy 設定。</span><span class="sxs-lookup"><span data-stu-id="bcaed-202">If no proxy is specified in a config file and the <xref:System.Net.Http.HttpClientHandler.Proxy%2A> property is unspecified, the handler uses the proxy settings inherited from Internet Explorer on the local computer.</span></span> <span data-ttu-id="bcaed-203">如果沒有在 Internet Explorer proxy 設定，要求會直接傳送到伺服器。</span><span class="sxs-lookup"><span data-stu-id="bcaed-203">If there are no proxy settings in Internet Explorer, the request is sent directly to the server.</span></span>  
  
 <span data-ttu-id="bcaed-204"><xref:System.Net.Http.HttpClientHandler>類別剖析包含萬用字元的 proxy 略過清單繼承自 Internet Explorer 相同略過清單是由 Internet Explorer 直接剖析。</span><span class="sxs-lookup"><span data-stu-id="bcaed-204">The <xref:System.Net.Http.HttpClientHandler> class parses a proxy bypass list with wildcard characters inherited from Internet Explorer the same as the bypass list is parsed directly by Internet Explorer.</span></span> <span data-ttu-id="bcaed-205">例如，<xref:System.Net.Http.HttpClientHandler>類別將會剖析"nt \*"從 Internet Explorer 略過清單做為規則運算式的 「 nt。\*"。</span><span class="sxs-lookup"><span data-stu-id="bcaed-205">For example, the <xref:System.Net.Http.HttpClientHandler> class will parse a bypass list of "nt\*" from Internet Explorer as a regular expression of "nt.\*".</span></span> <span data-ttu-id="bcaed-206">因此的 URL 」 http://nt.com」 會略過 proxy 使用<xref:System.Net.Http.HttpClientHandler>類別和使用 Internet Explorer。</span><span class="sxs-lookup"><span data-stu-id="bcaed-206">So a URL of " http://nt.com" would bypass the proxy using the <xref:System.Net.Http.HttpClientHandler> class and using Internet Explorer.</span></span>  
  
 <span data-ttu-id="bcaed-207"><xref:System.Net.Http.HttpClientHandler>類別支援本機 proxy 略過。</span><span class="sxs-lookup"><span data-stu-id="bcaed-207">The <xref:System.Net.Http.HttpClientHandler> class supports local proxy bypass.</span></span> <span data-ttu-id="bcaed-208">類別會將目的地為本機，如果下列任一條件成立：</span><span class="sxs-lookup"><span data-stu-id="bcaed-208">The class considers a destination to be local if any of the following conditions are met:</span></span>  
  
1.  <span data-ttu-id="bcaed-209">目的地包含一般名稱 （不在 URL 中的點）。</span><span class="sxs-lookup"><span data-stu-id="bcaed-209">The destination contains a flat name (no dots in the URL).</span></span>  
  
2.  <span data-ttu-id="bcaed-210">目的地包含迴路位址 (<xref:System.Net.IPAddress.Loopback>或是<xref:System.Net.IPAddress.IPv6Loopback>) 或目的地包含<xref:System.Net.IPAddress>指派給本機電腦。</span><span class="sxs-lookup"><span data-stu-id="bcaed-210">The destination contains a loopback address (<xref:System.Net.IPAddress.Loopback> or <xref:System.Net.IPAddress.IPv6Loopback>) or the destination contains an <xref:System.Net.IPAddress> assigned to the local computer.</span></span>  
  
3.  <span data-ttu-id="bcaed-211">目的地的網域尾碼符合本機電腦的網域尾碼 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>)。</span><span class="sxs-lookup"><span data-stu-id="bcaed-211">The domain suffix of the destination matches the local computer's domain suffix (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="protected internal override System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClientHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClientHandler.SendAsync (request, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="bcaed-212">HTTP 要求訊息。</span><span class="sxs-lookup"><span data-stu-id="bcaed-212">The HTTP request message.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="bcaed-213">取消作業的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="bcaed-213">A cancellation token to cancel the operation.</span></span></param>
        <summary><span data-ttu-id="bcaed-214">根據 <see cref="T:System.Net.Http.HttpRequestMessage" /> 提供的資訊建立 <see cref="T:System.Net.Http.HttpResponseMessage" /> 的執行個體，做為不封鎖作業。</span><span class="sxs-lookup"><span data-stu-id="bcaed-214">Creates an instance of  <see cref="T:System.Net.Http.HttpResponseMessage" /> based on the information provided in the <see cref="T:System.Net.Http.HttpRequestMessage" /> as an operation that will not block.</span></span></summary>
        <returns><span data-ttu-id="bcaed-215">工作物件，表示非同步作業。</span><span class="sxs-lookup"><span data-stu-id="bcaed-215">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-216">這項作業是不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="bcaed-216">This operation is does not block.</span></span> <span data-ttu-id="bcaed-217">它會傳回的執行個體<xref:System.Threading.Tasks.Task%601>代表非同步作業。</span><span class="sxs-lookup"><span data-stu-id="bcaed-217">It returns an instance of <xref:System.Threading.Tasks.Task%601> to represent the asynchronous operation.</span></span> <span data-ttu-id="bcaed-218">作業完成後，<xref:System.Threading.Tasks.Task%601.Result%2A>包含回應訊息。</span><span class="sxs-lookup"><span data-stu-id="bcaed-218">When the operation completes, <xref:System.Threading.Tasks.Task%601.Result%2A> contains the response message.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bcaed-219"><paramref name="request" /> 以前是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-219">The <paramref name="request" /> was <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateCustomValidationCallback">
      <MemberSignature Language="C#" Value="public Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,bool&gt; ServerCertificateCustomValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`5&lt;class System.Net.Http.HttpRequestMessage, class System.Security.Cryptography.X509Certificates.X509Certificate2, class System.Security.Cryptography.X509Certificates.X509Chain, valuetype System.Net.Security.SslPolicyErrors, bool&gt; ServerCertificateCustomValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateCustomValidationCallback As Func(Of HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ ServerCertificateCustomValidationCallback { Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ get(); void set(Func&lt;System::Net::Http::HttpRequestMessage ^, System::Security::Cryptography::X509Certificates::X509Certificate2 ^, System::Security::Cryptography::X509Certificates::X509Chain ^, System::Net::Security::SslPolicyErrors, bool&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateCustomValidationCallback : Func&lt;System.Net.Http.HttpRequestMessage, System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.X509Certificates.X509Chain, System.Net.Security.SslPolicyErrors, bool&gt; with get, set" Usage="System.Net.Http.HttpClientHandler.ServerCertificateCustomValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Net.Http.HttpRequestMessage,System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-220">取得或設定驗證伺服器憑證的回呼方法。</span><span class="sxs-lookup"><span data-stu-id="bcaed-220">Gets or sets a callback method to validate the server certificate.</span></span></summary>
        <value><span data-ttu-id="bcaed-221">驗證伺服器憑證的回呼方法。</span><span class="sxs-lookup"><span data-stu-id="bcaed-221">A callback method to validate the server certificate.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SslProtocols">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.SslProtocols SslProtocols { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Authentication.SslProtocols SslProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SslProtocols" />
      <MemberSignature Language="VB.NET" Value="Public Property SslProtocols As SslProtocols" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::SslProtocols SslProtocols { System::Security::Authentication::SslProtocols get(); void set(System::Security::Authentication::SslProtocols value); };" />
      <MemberSignature Language="F#" Value="member this.SslProtocols : System.Security.Authentication.SslProtocols with get, set" Usage="System.Net.Http.HttpClientHandler.SslProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.SslProtocols</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-222">取得或設定 TLS/SSL 通訊協定，其是由 HttpClientHandler 物件管理之 <see cref="T:System.Net.Http.HttpClient" /> 物件所使用。</span><span class="sxs-lookup"><span data-stu-id="bcaed-222">Gets or sets the TLS/SSL protocol used by the <see cref="T:System.Net.Http.HttpClient" /> objects managed by the HttpClientHandler object.</span></span></summary>
        <value><span data-ttu-id="bcaed-223"><see cref="T:System.Security.Authentication.SslProtocols" /> 列舉型別中定義的一個值。</span><span class="sxs-lookup"><span data-stu-id="bcaed-223">One of the values defined in the <see cref="T:System.Security.Authentication.SslProtocols" /> enumeration.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="bcaed-224">僅限 .NET Framework 4.7.1：這個屬性未實作。</span><span class="sxs-lookup"><span data-stu-id="bcaed-224">.NET Framework 4.7.1 only: This property is not implemented.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SupportsAutomaticDecompression">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAutomaticDecompression { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SupportsAutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsAutomaticDecompression As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsAutomaticDecompression { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAutomaticDecompression : bool" Usage="System.Net.Http.HttpClientHandler.SupportsAutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-225">取得值，表示處理常式是否支援自動回應內容解壓縮。</span><span class="sxs-lookup"><span data-stu-id="bcaed-225">Gets a value that indicates whether the handler supports automatic response content decompression.</span></span></summary>
        <value><span data-ttu-id="bcaed-226">如果此處理常式支援自動回應內容解壓縮，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-226"><see langword="true" /> if the if the handler supports automatic response content decompression; otherwise <see langword="false" />.</span></span> <span data-ttu-id="bcaed-227">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-227">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsProxy">
      <MemberSignature Language="C#" Value="public virtual bool SupportsProxy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsProxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SupportsProxy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsProxy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsProxy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsProxy : bool" Usage="System.Net.Http.HttpClientHandler.SupportsProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-228">取得值，這個值指出處理常式是否支援 Proxy 設定。</span><span class="sxs-lookup"><span data-stu-id="bcaed-228">Gets a value that indicates whether the handler supports proxy settings.</span></span></summary>
        <value><span data-ttu-id="bcaed-229">如果處理常式支援 Proxy 設定，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-229"><see langword="true" /> if the if the handler supports proxy settings; otherwise <see langword="false" />.</span></span> <span data-ttu-id="bcaed-230">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-230">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsRedirectConfiguration">
      <MemberSignature Language="C#" Value="public virtual bool SupportsRedirectConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsRedirectConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.SupportsRedirectConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsRedirectConfiguration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsRedirectConfiguration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsRedirectConfiguration : bool" Usage="System.Net.Http.HttpClientHandler.SupportsRedirectConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-231">取得值，這個值指出處理常式是否支援 <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> 和 <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> 屬性的組態設定。</span><span class="sxs-lookup"><span data-stu-id="bcaed-231">Gets a value that indicates whether the handler supports configuration settings for the <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> and <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> properties.</span></span></summary>
        <value><span data-ttu-id="bcaed-232">如果處理常式支援 <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> 和 <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> 屬性的組態設定，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-232"><see langword="true" /> if the if the handler supports configuration settings for the <see cref="P:System.Net.Http.HttpClientHandler.AllowAutoRedirect" /> and <see cref="P:System.Net.Http.HttpClientHandler.MaxAutomaticRedirections" /> properties; otherwise <see langword="false" />.</span></span> <span data-ttu-id="bcaed-233">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-233">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCookies">
      <MemberSignature Language="C#" Value="public bool UseCookies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.UseCookies" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCookies As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCookies { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCookies : bool with get, set" Usage="System.Net.Http.HttpClientHandler.UseCookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-234">取得或設定值，表示處理常式是否使用 <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" /> 屬性來儲存伺服器 Cookie 並在傳送要求時使用這些 Cookie。</span><span class="sxs-lookup"><span data-stu-id="bcaed-234">Gets or sets a value that indicates whether the handler uses the  <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" /> property  to store server cookies and uses these cookies when sending requests.</span></span></summary>
        <value><span data-ttu-id="bcaed-235">如果處理常式支援使用 <see langword="true" /> 屬性來儲存伺服器 Cookie 並在傳送要求時使用這些 Cookie，則為 <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-235"><see langword="true" /> if the if the handler supports uses the  <see cref="P:System.Net.Http.HttpClientHandler.CookieContainer" /> property  to store server cookies and uses these cookies when sending requests; otherwise <see langword="false" />.</span></span> <span data-ttu-id="bcaed-236">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-236">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.Http.HttpClientHandler.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-237">取得或設定值，控制是否隨著處理常式的要求傳送預設認證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-237">Gets or sets a value that controls whether default credentials are sent with requests by the handler.</span></span></summary>
        <value><span data-ttu-id="bcaed-238">如果使用預設認證，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-238"><see langword="true" /> if the default credentials are used; otherwise <see langword="false" />.</span></span> <span data-ttu-id="bcaed-239">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-239">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcaed-240">將此屬性設定為`true`所做<xref:System.Net.Http.HttpClientHandler>物件應該如果要求的伺服器上，驗證使用目前登入使用者的認證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-240">Set this property to `true` when requests made by the <xref:System.Net.Http.HttpClientHandler> object should, if requested by the server, be authenticated using the credentials of the currently logged on user.</span></span> <span data-ttu-id="bcaed-241">用戶端應用程式，這是在大部分情況下想要的行為。</span><span class="sxs-lookup"><span data-stu-id="bcaed-241">For client applications, this is the desired behavior in most scenarios.</span></span> <span data-ttu-id="bcaed-242">對於中介層應用程式，例如 ASP.NET 應用程式，而不是使用這個屬性中，您通常設定<xref:System.Net.Http.HttpClientHandler.Credentials%2A>屬性，以代表其提出要求的用戶端的認證。</span><span class="sxs-lookup"><span data-stu-id="bcaed-242">For middle-tier applications, such as ASP.NET applications, instead of using this property, you would typically set the <xref:System.Net.Http.HttpClientHandler.Credentials%2A> property to the credentials of the client on whose behalf the request is made.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseProxy">
      <MemberSignature Language="C#" Value="public bool UseProxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseProxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClientHandler.UseProxy" />
      <MemberSignature Language="VB.NET" Value="Public Property UseProxy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseProxy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseProxy : bool with get, set" Usage="System.Net.Http.HttpClientHandler.UseProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcaed-243">取得或設定值，指出處理常式是否針對要求使用 Proxy。</span><span class="sxs-lookup"><span data-stu-id="bcaed-243">Gets or sets a value that indicates whether the handler uses a proxy for requests.</span></span></summary>
        <value><span data-ttu-id="bcaed-244">如果處理常式應該針對要求使用 Proxy，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-244"><see langword="true" /> if the handler should use a proxy for requests; otherwise <see langword="false" />.</span></span> <span data-ttu-id="bcaed-245">預設值為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="bcaed-245">The default value is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>