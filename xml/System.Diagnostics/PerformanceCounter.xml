<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5b73baa2caa50673fc6647874bc12da2c4ebcc06" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49143363" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type PerformanceCounter = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.PerformanceCounterDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.PerformanceCounterInstaller,System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表 Windows NT 效能計數器元件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter>元件可用來讀取現有的預先定義或自訂的計數器和發佈效能 （寫入） 至自訂計數器的資料。  
  
 有許多預先定義的計數器，列在 「 Windows 效能監視器[新增計數器對話方塊](http://go.microsoft.com/fwlink/p/?LinkId=257854)。 若要深入了解.NET Framework 效能計數器，請參閱[效能計數器](~/docs/framework/debug-trace-profile/performance-counters.md)。  
  
 此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
> [!IMPORTANT]
>  在 1.0 和 1.1 版的.NET framework 版本中，這個類別會要求完全信任立即呼叫端。 從.NET Framework 2.0 版開始，這個類別會要求<xref:System.Diagnostics.PerformanceCounterPermission>特定動作。 強烈建議，<xref:System.Diagnostics.PerformanceCounterPermission>不授與完全信任程式碼。  能夠讀取和寫入效能計數器可讓程式碼來執行動作，例如列舉執行處理序和取得其相關資訊。  
>   
>  此外，傳遞<xref:System.Diagnostics.PerformanceCounter>物件到信任度較低的程式碼可以建立安全性問題。 永遠不會傳遞效能計數器物件，例如<xref:System.Diagnostics.PerformanceCounterCategory>或<xref:System.Diagnostics.PerformanceCounter>、 較不受信任的程式碼。  
  
 若要讀取從效能計數器，建立的執行個體<xref:System.Diagnostics.PerformanceCounter>類別中，將<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，並選擇性地<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>或<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>內容，然後再呼叫<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>才會對效能的方法計數器讀取的內容。  
  
 若要發佈效能計數器資料，建立使用的一或多個自訂的計數器<xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType>方法，建立的執行個體<xref:System.Diagnostics.PerformanceCounter>類別中，將<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A> ，並選擇性地<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>或<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>屬性，然後呼叫<xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>， <xref:System.Diagnostics.PerformanceCounter.Increment%2A>，或<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法或一組<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性來變更您的自訂計數器的值。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用聯鎖更新計數器的值。 這有助於在多執行緒或多重處理序的案例，也會導致對效能帶來負面影響，保留的計數器值正確無誤。 如果您不需要精確度的連鎖作業提供，您可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性直接直到 5 倍的效能改善。  不過，在多執行緒的情況下，某些更新為計數器值可能會忽略，導致不正確的資料。  
  
 此計數器是根據效能會收集資料的機制。 登錄會儲存所有計數器，其中每個相關系統功能的特定區域的名稱。 範例包括處理器的忙碌時間、 記憶體使用量或透過網路連線接收的位元組數目。  
  
 透過其名稱和位置，會唯一識別每個計數器。 檔案路徑包括磁碟機、 目錄、 一或多個子目錄和檔案名稱的相同方式，在計數器資訊包含四個項目： 電腦、 類別、 分類執行個體和計數器名稱。  
  
 分類或效能物件計數器會測量資料，必須包含的計數器資訊。 電腦的類別包括實體元件，例如處理器、 磁碟和記憶體。 也有系統的類別，例如處理序和執行緒。 每個類別目錄與功能性的項目內的電腦，並已指派給它的一組標準的計數器。 這些物件會列在 新增計數器 對話方塊中，在 Windows 2000 系統監視器 中，效能物件下拉式清單中，您必須納入的計數器路徑。 效能資料會依相關的類別是。  
  
 在某些情況下，可以存在相同的類別目錄的幾個複本。 例如，數個處理序和執行緒同時執行，而某些電腦包含多個處理器。 分類的複本稱為類別的執行個體，而每個執行個體具有一組指派給它的標準計數器。 如果類別可以有多個執行個體，則執行個體規格必須包含在計數器資訊。  
  
 若要取得執行所需的計算所需的初始或上一個值的計數器的效能資料，請呼叫<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法兩次，並使用您的應用程式需要傳回的資訊。  
  
> [!NOTE]
>  與安裝的效能計數器分類[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]使用不同的共用的記憶體，且每個效能計數器分類都有它自己的記憶體。 您可以指定不同的共用記憶體的大小，藉由建立 DWORD 登錄機碼 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services 中名為 FileMappingSize\\*\<類別名稱 >* \效能。 FileMappingSize 值設定為類別目錄的共用的記憶體大小。 預設大小為 131072 十進位。 FileMappingSize 值不存在，如果`fileMappingSize`屬性值`performanceCounters`使用 Machine.config 檔案中指定的項目時，造成額外負擔的組態檔處理。 您可以藉由設定登錄中的檔案對應大小，達成應用程式啟動的效能改善。 如需有關檔案對應大小的詳細資訊，請參閱[ &lt;performanceCounters&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Diagnostics.PerformanceCounter>類別來建立和使用<xref:System.Diagnostics.PerformanceCounterType.AverageCount64>計數器型別。 此範例會建立類別、 設定計數器時，會收集資料，從計數器，然後呼叫<xref:System.Diagnostics.CounterSampleCalculator>解譯效能計數器資料的類別。 中繼和最終結果會顯示在主控台視窗中。 如需的其他效能計數器類型的其他範例，請參閱<xref:System.Diagnostics.PerformanceCounterType>列舉型別。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個類別不能由部分信任的程式碼。</permission>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 類別的新的、唯讀的執行個體，而不將執行個體與任何系統或自訂效能計數器相關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載的建構函式集合<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性為空字串 ("")，並設定<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本機電腦中，屬性 ("。")。  
  
 這個建構函式不會初始化效能計數器，因此它不會將執行個體關聯的本機電腦上現有的計數器。 若要指向特定的效能計數器，設定<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，並選擇性地<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>和<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>之前讀取任何其他屬性，或嘗試從計數器讀取的屬性。 若要寫入的效能計數器，請設定<xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>屬性設`false`。  
  
> [!NOTE]
>  <xref:System.Security.Permissions.HostProtectionAttribute>套用至這個成員的屬性具有下列<xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A>屬性值： <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState>。 <xref:System.Security.Permissions.HostProtectionAttribute> 不會影響桌面應用程式 (這些應用程式的啟動方式一般都是按兩下圖示、輸入命令或在瀏覽器輸入 URL)。 如需詳細資訊，請參閱 <<c0> <xref:System.Security.Permissions.HostProtectionAttribute> 類別或[SQL Server 程式設計和主機保護屬性](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立預設執行個體<xref:System.Diagnostics.PerformanceCounter>類別。 建立執行個體之後， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，並<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性值已設定，而且若要呼叫的結果<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法會顯示。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">與這個效能計數器相關的效能計數器分類 (效能物件) 名稱。</param>
        <param name="counterName">效能計數器的名稱。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 類別的新的、唯讀的執行個體，並將其與本機電腦上指定的系統或自訂效能計數器相關聯。 這個建構函式 (Constructor) 要求分類包含單一執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參數的字串不區分大小寫。  
  
 您可以使用這個多載來存取屬於分類包含單一效能計數器分類執行個體的本機電腦上的計數器。 如果您嘗試使用這個建構函式指向這<xref:System.Diagnostics.PerformanceCounter>類別目錄包含多個執行個體，則建構函式會擲回的例外狀況的執行個體。 這個多載可以存取任何唯讀或讀取/寫入計數器，但不會以唯讀模式。 A<xref:System.Diagnostics.PerformanceCounter>使用這個多載所建立的執行個體無法寫入的計數器，即使計數器本身是可讀寫。  
  
 這個多載的建構函式集合<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>和<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>屬性的值您傳入，、 設定<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本機電腦中，屬性"。"，並設定<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性設為空字串 ("")。  
  
 這個建構函式會初始化效能計數器，並將執行個體與本機電腦上的現有計數器 （系統或自訂計數器） 相關聯。 您為傳入的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>和<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>屬性必須指向本機電腦上的現有效能計數器。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> 為空字串 ("")。  
  
-或- 
 <paramref name="counterName" /> 為空字串 ("")。  
  
-或- 
指定的分類不存在。  
  
-或- 
指定的分類會標記為多執行個體，而且需要以執行個體名稱建立效能計數器。  
  
-或- 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已經當地語系化成不同的語言。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> 或 <paramref name="counterName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">與這個效能計數器相關的效能計數器分類 (效能物件) 名稱。</param>
        <param name="counterName">效能計數器的名稱。</param>
        <param name="readOnly">若要以唯讀模式存取計數器 (不過計數器本身可以讀取/寫入)，則為 <see langword="true" />；若要以讀取/寫入模式存取計數器，則為 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 類別的新的、唯讀或讀取/寫入執行個體，並將其與本機電腦上指定的系統或自訂效能計數器相關聯。 這個建構函式要求分類包含單一執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參數的字串不區分大小寫。  
  
 使用此多載，可存取的唯讀或讀取/寫入屬於分類包含單一效能計數器分類執行個體的本機電腦上的計數器。 如果您嘗試使用這個建構函式指向這<xref:System.Diagnostics.PerformanceCounter>類別目錄包含多個執行個體，則建構函式會擲回的例外狀況的執行個體。  
  
 這個多載的建構函式集合<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>屬性的值您傳入，、 設定<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本機電腦中，屬性"。"，並設定<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性設為空字串 ("")。  
  
 這個建構函式會初始化效能計數器，並將執行個體與本機電腦上的現有計數器 （系統或自訂計數器） 相關聯。 您為傳入的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>和<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>屬性必須指向本機電腦上的現有效能計數器。 如果您指向的效能計數器執行個體不是有效的則呼叫建構函式會擲回例外狀況。  
  
> [!NOTE]
>  您可以使用這個多載來連接到系統的計數器，但您無法寫入至系統計數器。 因此，設定`readOnly`至`false`當連接到系統計數器會導致擲回例外狀況的建構函式。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
   
  
## Examples  
 下列程式碼範例建立的執行個體<xref:System.Diagnostics.PerformanceCounter>類別。 此範例會傳入類別目錄名稱、 計數器名稱和旗標值，指出此計數器不唯讀的。 這個程式碼範例是針對較大範例的一部分<xref:System.Diagnostics.PerformanceCounter>類別。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> 為空字串 ("")。  
  
-或- 
<paramref name="counterName" /> 為空字串 ("")。  
  
-或- 
指定的分類不存在。 (如果 <paramref name="readOnly" /> 為 <see langword="true" />)。  
  
-或- 
指定的分類不是 .NET Framework 自訂分類 (如果 <paramref name="readOnly" /> 為 <see langword="false" />)。  
  
-或- 
指定的分類會標記為多執行個體，而且需要以執行個體名稱建立效能計數器。  
  
-或- 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已經當地語系化成不同的語言。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> 或 <paramref name="counterName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">與這個效能計數器相關的效能計數器分類 (效能物件) 名稱。</param>
        <param name="counterName">效能計數器的名稱。</param>
        <param name="instanceName">效能計數器分類執行個體的名稱；如果分類含有單一執行個體，則為空字串 ("")。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 類別的新的、唯讀的執行個體，並將其與本機電腦上指定的系統或自訂效能計數器和分類執行個體相關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參數的字串不區分大小寫。  
  
 這個多載的建構函式集合<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，並<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性的值，並設定<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>屬性到本機電腦中，"。"。  
  
 這個建構函式會初始化效能計數器，並將執行個體與本機電腦上的現有計數器 （系統或自訂計數器） 相關聯。 您為傳入的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性必須指向本機電腦上的現有效能計數器。 如果您指向的效能計數器執行個體不是有效的則呼叫建構函式會擲回例外狀況。  
  
 這個多載可以存取任何唯讀或讀取/寫入計數器，但不會以唯讀模式。 A<xref:System.Diagnostics.PerformanceCounter>使用這個多載所建立的執行個體無法寫入的計數器，即使計數器本身是可讀寫。  
  
 若要建立效能類別執行個體，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>建構函式。 如果所指定的類別執行個體`instanceName`已經存在新的物件會參考現有的類別執行個體。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> 為空字串 ("")。  
  
-或- 
 <paramref name="counterName" /> 為空字串 ("")。  
  
-或- 
指定的分類無效。  
  
-或- 
指定的分類會標記為多執行個體，而且需要以執行個體名稱建立效能計數器。  
  
-或- 
 <paramref name="instanceName" /> 長度超過 127 個字元。  
  
-或- 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已經當地語系化成不同的語言。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> 或 <paramref name="counterName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">與這個效能計數器相關的效能計數器分類 (效能物件) 名稱。</param>
        <param name="counterName">效能計數器的名稱。</param>
        <param name="instanceName">效能計數器分類執行個體的名稱；如果分類含有單一執行個體，則為空字串 ("")。</param>
        <param name="readOnly">若要以唯讀模式存取計數器，則為 <see langword="true" />；若要以讀取/寫入模式存取計數器，則為 <see langword="false" />。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 類別的新的、唯讀或讀取/寫入執行個體，並將其與本機電腦上指定的系統或自訂效能計數器和分類執行個體相關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參數的字串不區分大小寫。  
  
 使用此多載來存取效能計數器在唯讀或讀取/寫入模式。  
  
 這個多載的建構函式集合<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，並<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>傳遞它和集合中屬性的值<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>屬性到本機電腦中，"。"。  
  
 這個建構函式會初始化效能計數器，並將執行個體與本機電腦上的現有計數器 （系統或自訂計數器） 相關聯。 您為傳入的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性必須指向本機電腦上的現有效能計數器。 如果您指向的效能計數器執行個體不是有效的則呼叫建構函式會擲回例外狀況。  
  
> [!NOTE]
>  您可以使用這個多載來連接到系統的計數器，但您無法寫入至系統計數器。 因此，設定`readOnly`至`false`當連接到系統計數器會導致擲回例外狀況的建構函式。  
  
 若要建立效能類別執行個體，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>建構函式。 如果所指定的類別執行個體`instanceName`已經存在新的物件會參考現有的類別執行個體。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> 為空字串 ("")。  
  
-或- 
 <paramref name="counterName" /> 為空字串 ("")。  
  
-或- 
要求的讀取/寫入使用權限設定對這個計數器無效。  
  
-或- 
指定的分類不存在 (如果 <paramref name="readOnly" /> 為 <see langword="true" />)。  
  
-或- 
指定的分類不是 .NET Framework 自訂分類 (如果 <paramref name="readOnly" /> 為 <see langword="false" />)。  
  
-或- 
指定的分類會標記為多執行個體，而且需要以執行個體名稱建立效能計數器。  
  
-或- 
 <paramref name="instanceName" /> 長度超過 127 個字元。  
  
-或- 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已經當地語系化成不同的語言。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> 或 <paramref name="counterName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">與這個效能計數器相關的效能計數器分類 (效能物件) 名稱。</param>
        <param name="counterName">效能計數器的名稱。</param>
        <param name="instanceName">效能計數器分類執行個體的名稱；如果分類含有單一執行個體，則為空字串 ("")。</param>
        <param name="machineName">效能計數器和其相關聯的分類所在的電腦。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.PerformanceCounter" /> 類別的新的、唯讀的執行個體，並將其與指定電腦上指定的系統或自訂效能計數器和分類執行個體相關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 參數的字串不區分大小寫。  
  
 這個多載的建構函式集合<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>， <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>，和<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>屬性為您所傳遞的值。  
  
 這個建構函式會初始化效能計數器，並將執行個體與指定的電腦上的現有計數器 （系統或自訂計數器） 相關聯。 您為傳入的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>和<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>屬性必須指向現有的效能計數器。 如果您指向的效能計數器執行個體不是有效的則呼叫建構函式會擲回例外狀況。 這個多載可以存取任何唯讀或讀取/寫入計數器，但不會以唯讀模式。 A<xref:System.Diagnostics.PerformanceCounter>使用這個多載所建立的執行個體無法寫入的計數器，即使計數器本身是可讀寫。  
  
> [!NOTE]
>  您無法寫入遠端效能計數器。 沒有任何多載，可讓您指定的讀取/寫入執行個體<xref:System.Diagnostics.PerformanceCounter>類別連接到遠端電腦。  
  
 若要建立效能類別執行個體，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>建構函式。 如果所指定的類別執行個體`instanceName`已經存在新的物件會參考現有的類別執行個體。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
> [!NOTE]
>  在 Windows Vista 中，當遠端電腦屬於工作群組中，您可能需要停用 UAC，讓本機使用者帳戶未篩選，而且可以是提高權限為系統管理員帳戶。 基於安全性理由，停用 UAC 應該是最後的手段。 如需有關停用 UAC，請參閱[使用者帳戶控制和 WMI](http://go.microsoft.com/fwlink/?LinkId=91617)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> 為空字串 ("")。  
  
-或- 
 <paramref name="counterName" /> 為空字串 ("")。  
  
-或- 
要求的讀取/寫入使用權限設定對這個計數器無效。  
  
-或- 
計數器不在指定的電腦上。  
  
-或- 
指定的分類會標記為多執行個體，而且需要以執行個體名稱建立效能計數器。  
  
-或- 
 <paramref name="instanceName" /> 長度超過 127 個字元。  
  
-或- 
 <paramref name="categoryName" /> 和 <paramref name="counterName" /> 已經當地語系化成不同的語言。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數無效。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> 或 <paramref name="counterName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="performanceCounter.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始初始化用於表單或為另一元件所使用的 <see cref="T:System.Diagnostics.PerformanceCounter" /> 執行個體。 初始化會於執行階段時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來開始初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.PerformanceCounter.EndInit%2A>方法結束初始化。 使用<xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>和<xref:System.Diagnostics.PerformanceCounter.EndInit%2A>方法可防止元件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個效能計數器的效能計數器分類的名稱。</summary>
        <value>與這個效能計數器相關的效能計數器分類 (效能物件) 名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>會顯示在`Performance Object`欄位的效能計數器管理員 MMC 嵌入式管理單元中的`Add Counter` 對話方塊。  
  
 效能計數器會監視分類或效能物件，在電腦上的行為。 類別包含實體的元件 （例如處理器、 磁碟和記憶體） 和系統物件 （例如處理程序和執行緒）。 系統與相同的效能物件相關的計數器會分組為類別，表示其一般的焦點。 當您建立的執行個體<xref:System.Diagnostics.PerformanceCounter>類別，您先指出與其元件將互動，而且然後從該類別選取計數器的分類。  
  
 比方說，一個 Windows 計數器分類是 [記憶體] 類別。 此類別內的系統計數器會追蹤記憶體的資料，例如可用的位元組數目和快取的位元組數目。 如果您想要使用 在您的應用程式中快取的位元組，您會建立的執行個體<xref:System.Diagnostics.PerformanceCounter>元件，將它連接到 記憶體 類別中，，，然後挑選該類別的適當計數器 （在此案例中，快取的位元組為單位）。  
  
 雖然您的系統提供許多其他的計數器類別，您可能將互動最常使用的類別會快取、 記憶體、 物件、 PhysicalDisk、 程序、 處理器、 伺服器、 系統和執行緒的類別。  
  
   
  
## Examples  
 下列程式碼範例會建立預設執行個體<xref:System.Diagnostics.PerformanceCounter>類別。 建立執行個體之後， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，並<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性值已設定，而且若要呼叫的結果<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法會顯示。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="performanceCounter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉效能計數器，並釋放這個效能計數器執行個體所配置的所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您建立的關聯這<xref:System.Diagnostics.PerformanceCounter>與所在的伺服器，系統的效能計數器的執行個體初始化的執行個體，並將記憶體配置給包含計數器範例的資訊。 <xref:System.Diagnostics.PerformanceCounter.Close%2A>方法會釋放物件所配置的資源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberSignature Language="F#" Value="static member CloseSharedResources : unit -&gt; unit" Usage="System.Diagnostics.PerformanceCounter.CloseSharedResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放由計數器配置的效能計數器程式庫的共用狀態。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用於讀取的效能計數器分類。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterHelp : string" Usage="System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterHelp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個效能計數器的描述。</summary>
        <value>這個效能計數器所測量的項目或數量的描述。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [新增計數器] 對話方塊中，在顯示的效能計數器管理員 MMC 嵌入式管理單元的<xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A>當使用者從 [計數器] 清單中選取計數器，並按一下 [說明] 按鈕的文字。  
  
 當您建立新的計數器時，使用<xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A>文字來描述計數器的監視執行，因此使用者可以判斷是否要將計數器新增至 「 系統監視器的顯示。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.PerformanceCounter" /> 執行個體沒有與效能計數器相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用於讀取的效能計數器分類。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CounterName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定與這個 <see cref="T:System.Diagnostics.PerformanceCounter" /> 執行個體相關的效能計數器的名稱。</summary>
        <value>計數器的名稱，一般用於描述計算所得的數量。 這個名稱會顯示於 [效能計數器管理工具 MMC 嵌入式管理單元] 中 [新增計數器] 對話方塊的計數器清單中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以取得一份可用的預先存在計數器從 Windows 效能管理員[新增計數器對話方塊](http://go.microsoft.com/fwlink/p/?LinkId=257854)。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>屬性設為一般計數器名稱。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterType : System.Diagnostics.PerformanceCounterType" Usage="System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_CounterType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關的效能計數器的計數器型別。</summary>
        <value>
          <see cref="T:System.Diagnostics.PerformanceCounterType" />，描述計數器與監視應用程式的互動方式，以及它所包含的值的性質 (例如，計算過或未計算的)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterType>列舉包含的效能計數器，您可以互動的型別。 有些計數器型別則代表導出的值，例如系統所需的計數器度量的平均值。 其他類型代表未經處理、 或未計算的值。 下表顯示您互動最頻繁的計數器型別。  
  
|計數器的責任|PerformanceCounterType 值|範例|  
|------------------------------|----------------------------------|-------------|  
|維護項目或作業的簡單計數。|`NumberOfItems32`|追蹤收到的 32 位元整數的訂單數目。|  
|維護的較高容量的簡單計數。|`NumberOfItems64`|追蹤具有非常大量的站台的訂單數量、 儲存為 64 位元整數。|  
|追蹤項目或每秒的作業的數目。|`RateOfCountsPerSecond32`|站台上每秒接收的追蹤訂單。|  
|追蹤項目或作業每秒的高容量數字。|`RateOfCountsPerSecond64`|追蹤訂單上每秒接收非常大量的網站。|  
|計算的平均時間，來執行處理程序，或處理項目|`AverageTimer32`|計算訂單處理所花費的平均時間。|  
  
 當您建立的類型需要使用對應的基底計數器的計數器時，您必須宣告計數器和中的基底<xref:System.Diagnostics.CounterCreationDataCollection>您傳入<xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">該執行個體沒有與效能計數器正確的相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用於讀取的效能計數器分類。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberSignature Language="F#" Value="member this.Decrement : unit -&gt; int64" Usage="performanceCounter.Decrement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>經由有效率的不可部分完成的作業 (Atomic Operation)，將相關的效能計數器逐一遞減。</summary>
        <returns>遞減的計數器值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以撰寫至自訂計數器。 所有系統計數器都是唯讀的。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用聯鎖更新計數器的值。 這有助於在多執行緒或多重處理序的案例，也會導致對效能帶來負面影響，保留的計數器值正確無誤。 如果您不需要精確度的連鎖作業提供，您可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性直接直到 5 倍的效能改善。  不過，在多執行緒的情況下，某些更新為計數器值可能會忽略，導致不正確的資料。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">計數器是唯讀的，所以應用程式無法將其遞減。  
  
-或- 
該執行個體沒有與效能計數器正確的相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
        <threadsafe>這個方法是安全執行緒。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultFileMappingSize : int" Usage="System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1">
          <AttributeName>System.Obsolete("This field has been deprecated and is not used.  Use machine.config or an application configuration file to set the size of the PerformanceCounter file mapping.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定效能計數器所共用之全域記憶體的大小 (以位元組計)。 預設大小為 524,288 個位元組。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="performanceCounter.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束初始化用於表單或為另一元件所使用的 <see cref="T:System.Diagnostics.PerformanceCounter" /> 執行個體。 初始化會於執行階段時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來結束初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>方法會啟動初始化。 使用<xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>和<xref:System.Diagnostics.PerformanceCounter.EndInit%2A>方法可防止元件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberSignature Language="F#" Value="member this.Increment : unit -&gt; int64" Usage="performanceCounter.Increment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>經由有效率的不可部分完成的作業，將相關的效能計數器逐一遞增。</summary>
        <returns>遞增的計數器值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以撰寫至自訂計數器。 所有系統計數器都是唯讀的。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用聯鎖更新計數器的值。 這有助於在多執行緒或多重處理序的案例，也會導致對效能帶來負面影響，保留的計數器值正確無誤。 如果您不需要精確度的連鎖作業提供，您可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性直接直到 5 倍的效能改善。  不過，在多執行緒的情況下，某些更新為計數器值可能會忽略，導致不正確的資料。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">計數器是唯讀的，所以應用程式無法將其遞增。  
  
-或- 
該執行個體沒有與效能計數器正確的相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
        <threadsafe>這個方法是安全執行緒。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int64 -&gt; int64" Usage="performanceCounter.IncrementBy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要被遞增的值 (負值會將計數器遞減)。</param>
        <summary>經由有效率的不可部分完成的作業，將相關的效能計數器值按指定的數量遞增或遞減。</summary>
        <returns>新的計數器值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以撰寫至自訂計數器。 所有系統計數器都是唯讀的。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用聯鎖更新計數器的值。 這有助於在多執行緒或多重處理序的案例，也會導致對效能帶來負面影響，保留的計數器值正確無誤。 如果您不需要精確度的連鎖作業提供，您可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性直接直到 5 倍的效能改善。  不過，在多執行緒的情況下，某些更新為計數器值可能會忽略，導致不正確的資料。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>方法加入至計數器遞增。 這個程式碼範例是針對較大範例的一部分<xref:System.Diagnostics.PerformanceCounter>類別。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">計數器是唯讀的，所以應用程式無法將其遞增。  
  
-或- 
該執行個體沒有與效能計數器正確的相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">如果寫入的效能計數器分類<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />屬性是<see langword="false" />。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
        <threadsafe>這個方法是安全執行緒。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceLifetime : System.Diagnostics.PerformanceCounterInstanceLifetime with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定處理序的存留期 (Lifetime)。</summary>
        <value>其中一個 <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> 值。 預設值為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果效能計數器分類以.NET Framework 1.0 或 1.1 版建立的它會使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.CounterType%2A>屬性是<xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>，則<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>值必須是效能計數器<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定值不是 <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> 列舉型別的成員。</exception>
        <exception cref="T:System.InvalidOperationException">在 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 已初始化後設定 <see cref="T:System.Diagnostics.PerformanceCounter" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個效能計數器的執行個體名稱。</summary>
        <value>效能計數器分類執行個體的名稱，如果計數器是單一執行個體計數器，則為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  執行個體名稱必須少於 128 個字元的長度。  
  
 在某些情況下，類別會細分為執行個體，以追蹤多個項目與相關的分類之物件的相關資料。 執行個體套用至整個分類，而不是個別計數器。 在類別內的每個計數器有定義的分類每個執行個體。 例如，處理序類別包含名為閒置和系統的執行個體。 處理序類別內的每個計數器，因此包含每個執行個體，顯示閒置處理序或系統處理序的相關資訊的資料。  
  
 許多類別並不會包含多個執行個體，因此您可以將此屬性保留空白，表示沒有任何執行個體是與分類相關聯。  
  
 如果這個<xref:System.Diagnostics.PerformanceCounter>執行個體指向非自訂類別目錄時，您可以選擇只有現有的類別執行個體。 您可以只在自訂類別，可讓您定義多個計數器和分類執行個體，您需要建立新的類別執行個體。  
  
 若要建立效能類別執行個體，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>建構函式。 如果所指定的類別執行個體`instanceName`已經存在新的物件會參考現有的類別執行個體。  
  
> [!NOTE]
>  請勿使用字元"（"，"）"，"#"、"\\」，或"/"的執行個體名稱。 如果使用下列任何字元，則效能主控台 (請參閱[執行階段分析](~/docs/framework/debug-trace-profile/runtime-profiling.md)) 可能無法正確顯示執行個體值。  
  
 如果執行個體名稱會自動產生，而且可能包含字元"（"，"）"，"#"、"\\」，或"/"，請使用下表中的字元對應。  
  
|字元|對應的字元|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 <xref:System.AppDomain.FriendlyName%2A>的屬性<xref:System.AppDomain>從物件取得<xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType>屬性是可包含無效字元的執行個體名稱的常見來源。  
  
   
  
## Examples  
 下列程式碼範例會建立預設執行個體<xref:System.Diagnostics.PerformanceCounter>類別。 建立執行個體之後， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，並<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>屬性值已設定，而且若要呼叫的結果<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法會顯示。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個效能計數器的電腦名稱。</summary>
        <value>伺服器，效能計數器及其相關的分類所在處。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可寫入才能存在於計數器的值，在本機電腦上。 不過，您可以讀取計數器的值，您可以從任何電腦的企業中擁有存取權限。  
  
 當您設定<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>屬性以指向遠端電腦，<xref:System.Diagnostics.PerformanceCounter>執行個體會嘗試開啟該電腦上的計數器。 如果計數器不存在，則設定這個屬性會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.PerformanceCounter.MachineName" /> 格式無效。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberSignature Language="F#" Value="member this.NextSample : unit -&gt; System.Diagnostics.CounterSample" Usage="performanceCounter.NextSample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得計數器範例，並為其傳回未經處理或未計算的值。</summary>
        <returns>
          <see cref="T:System.Diagnostics.CounterSample" />，表示系統為這個計數器取得的下一個未經處理的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法通常用於包含未計算的值的計數器。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Diagnostics.PerformanceCounter.NextSample%2A>方法，以取得計數器的下一個未計算的值。 這個程式碼範例是針對較大範例的一部分<xref:System.Diagnostics.PerformanceCounter>類別。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">該執行個體沒有與效能計數器正確的相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用於讀取的效能計數器分類。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberSignature Language="F#" Value="member this.NextValue : unit -&gt; single" Usage="performanceCounter.NextValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得計數器樣本，並為其傳回計算過的值。</summary>
        <returns>系統為這個計數器取得的下一個計算過的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果計數器的導出的值取決於兩個計數器讀取，第一次讀取的作業會傳回 0.0。 重設指定不同的計數器的效能計數器屬性就相當於建立新的效能計數器，並使用新的屬性的第一個讀取的作業傳回 0.0。 若要呼叫的建議的延遲時間<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法是一秒，允許執行下一個累加讀取計數器。  
  
> [!NOTE]
>  若要讀取效能計數器，您必須使用系統管理權限。 在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Diagnostics.PerformanceCounterType.ElapsedTime>計數器，並使用<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法來顯示時間週期內的計數器的值。  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">該執行個體沒有與效能計數器正確的相關聯。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用於讀取的效能計數器分類。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.RawValue : int64 with get, set" Usage="System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_RawValue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個計數器的未經處理或未經計算的值。</summary>
        <value>計數器未經處理的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果計數器型別是 32 位元大小，而您嘗試將此屬性設定為太大，無法容納值，屬性就會截斷為 32 位元值。 當讀取本機電腦上的自訂計數器，請使用<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性，而不是導出的值可能會產生效能明顯優於在未經處理的值不足的狀況。  
  
 如果您正在閱讀的計數器是唯讀屬性，取得<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性的屬性稱為次取樣的計數器。 這個動作相當於發出初始呼叫<xref:System.Diagnostics.PerformanceCounter.NextSample%2A>方法。 如果您後續呼叫<xref:System.Diagnostics.PerformanceCounter.NextSample%2A>，您可以在兩個呼叫所傳回的值上執行計算。  
  
 由於系統計數器是唯讀的您可以取得，但未設定其原始值。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用聯鎖更新計數器的值。 這有助於在多執行緒或多重處理序的案例，也會導致對效能帶來負面影響，保留的計數器值正確無誤。 如果您不需要精確度的連鎖作業提供，您可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>屬性直接直到 5 倍的效能改善。  不過，在多執行緒的情況下，某些更新為計數器值可能會忽略，導致不正確的資料。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
> [!NOTE]
>  若要閱讀 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的效能計數器，您必須是 Performance Monitor Users 群組的成員，或具有系統管理權限。  
>   
>  若要避免將權限來存取效能計數器，Windows Vista 中的提高，請將您自己新增至 Performance Monitor Users 群組。  
>   
>  在 Windows Vista 中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Diagnostics.CounterSample>類別，以顯示的值<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>計數器的屬性。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您嘗試設定計數器的未經處理的值，但是處理器是唯讀的。  
  
-或- 
該執行個體沒有與效能計數器正確的相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <exception cref="T:System.UnauthorizedAccessException">以不具有系統管理員權限執行的程式碼嘗試讀取效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用於寫入的效能計數器分類。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PC_ReadOnly")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定數值，表示 <see cref="T:System.Diagnostics.PerformanceCounter" /> 執行個體是否處於唯讀模式。</summary>
        <value>如果 <see cref="T:System.Diagnostics.PerformanceCounter" /> 執行個體是唯讀模式 (即使計數器本身是自訂的 .NET Framework 計數器)，則為 <see langword="true" />；如果它是讀取/寫入模式，則為 <see langword="false" />。 預設值是建構函式設定的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 系統的計數器，如<xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>應一律`true`。 您無法寫入至系統計數器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberSignature Language="F#" Value="member this.RemoveInstance : unit -&gt; unit" Usage="performanceCounter.RemoveInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>刪除由 <see cref="T:System.Diagnostics.PerformanceCounter" /> 物件 <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" /> 屬性所指定的分類執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以移除僅針對自訂計數器執行個體。 所有系統計數器都是唯讀的因此嘗試移除其中一個會擲回例外狀況。  
  
> [!NOTE]
>  若要發行的效能計數器共用記憶體時，請避免可能的競爭情形，建議<xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A>方法呼叫從<xref:System.AppDomain.DomainUnload>事件處理常式。  
  
 若要建立效能類別執行個體，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>建構函式。 如果所指定的類別執行個體`instanceName`已經存在新的物件會參考現有的類別執行個體。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>屬性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>效能計數器分類以.NET Framework 1.0 或 1.1 版中建立和<xref:System.InvalidOperationException>就會擲回。 建立與舊版本的效能計數器分類使用全域共用的記憶體和值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必須是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果類別不使用 1.0 或 1.1 版的.NET Framework 的版本上執行的應用程式中，刪除並重新建立類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個計數器是唯讀的，所以任何與分類相關的執行個體都無法移除。  
  
-或- 
該執行個體沒有與效能計數器正確的相關聯。  
  
-或- 
使用全域共用記憶體時，<see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> 屬性是設定為 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取系統 API 時發生的錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Me)，這兩個平台都不支援效能計數器。</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用於寫入的效能計數器分類。 關聯的列舉型別：<see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
  </Members>
</Type>