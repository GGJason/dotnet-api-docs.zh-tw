<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cbfbcc77256bd34443df230f42cc12dddc55633e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30399672" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示作業系統處理序 (Process) 執行緒。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.ProcessThread>來取得有關目前正在系統執行的執行緒。 這樣做可讓您，例如，若要監視執行緒的效能特性。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 執行緒是執行透過程式的路徑。 它是 Win32 排程執行的最小單位。 其中包含堆疊，以及 CPU 暫存器中，系統排程器之執行清單中的項目狀態。  
  
 程序包含一個或多個執行緒和程式碼、 資料和程式在記憶體中的其他資源。 一般程式資源是開啟的檔案、 信號及動態配置的記憶體。 每個資源的程序可由所有處理序的執行緒共用。  
  
 當系統排程器可讓控制項執行程式的執行緒中的一個時，就會執行程式。 排程器會判斷應該執行哪一個執行緒與時機。 較低優先順序的執行緒可能會強制等待較高優先權執行緒完成其工作。 多處理器的電腦上排程器可以將個別執行緒不同的處理器，以平衡的 CPU 負載。  
  
 每個處理序啟動與單一執行緒，也就是主要執行緒。 任何執行緒可以建立額外的執行緒。 在處理序中的所有執行緒都共用該程序的位址空間。  
  
 主執行緒不一定是位在集合中的第一個索引。  
  
> [!NOTE]
>  從.NET Framework 2.0 版開始，在其他電腦上的參考效能計數器資料的能力會排除許多的.NET Framework 方法和屬性。 這項變更為了改善效能，也讓非系統管理員可以使用<xref:System.Diagnostics.ProcessThread>類別。 如此一來，現在可能會收到未取得例外狀況在舊版的.NET framework 中的某些應用程式<xref:System.NotSupportedException>。 方法和受影響的屬性太多而無法在此，列出但例外狀況資訊已新增至受影響的成員主題。  
  
 個別執行的處理序的執行緒，並不知道彼此，除非您顯示它們彼此。 不過，共用通用資源的執行緒必須協調工作使用號誌或另一個處理序間通訊的方法。  
  
 若要取得所有集合的<xref:System.Diagnostics.ProcessThread>與目前的處理序相關聯的物件都取得<xref:System.Diagnostics.Process.Threads%2A>屬性<xref:System.Diagnostics.Process>執行個體。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得執行緒的基礎優先權 (Base Priority)。</summary>
        <value>執行緒的基礎優先權，由作業系統結合處理序的優先權類別和相關執行緒的優先權層級計算所得。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.BasePriority%2A>起始處理序執行緒的優先順序。 您可以檢視透過系統監視器的優先權基底計數器的基礎優先權的相關資訊。  
  
 作業系統執行緒的優先權層級範圍結合處理序的優先權類別計算執行緒的基本優先順序。 您可以設定的程序<xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType>屬性中值的其中一個<xref:System.Diagnostics.ProcessPriorityClass>列舉型別，也就是<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。 您可以設定執行緒的<xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>框住執行緒的基礎優先權值範圍的屬性。 Win32 七個基本優先順序層級，每個類別會使用四個優先權類別。  
  
 執行緒的目前優先權可能會與基底的優先權不符合。 例如，可以變更作業系統<xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>經過的時間為基礎的屬性或其他等級，當處理序必須會放入預先其他人存取處理器。 此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性，系統將會從處理序離開等候狀態時，暫時提高執行緒優先權。 處理程序會回到等候狀態時，會重設的優先順序。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得執行緒的目前優先權。</summary>
        <value>執行緒目前的優先權，可能與基礎優先權 (根據作業系統如何排程執行緒) 不符合。 針對作用中的執行緒，可能暫時提高優先權。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒的目前優先權可能會與基底的優先權不符合。 例如，可以變更作業系統<xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>屬性根據時間已過，或其他的等級，當處理序必須會放入預先其他人存取處理器。 此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性，系統將會從處理序離開等候狀態時，暫時提高執行緒優先權。 處理程序會回到等候狀態時，會重設的優先順序。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得執行緒的唯一識別項。</summary>
        <value>與特定執行緒相關的唯一識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統會重複使用的執行緒識別數字，用來識別只有在其存留期間的執行緒。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>設定執行這個執行緒的慣用處理器。</summary>
        <value>執行緒的慣用處理器，用於系統排程執行緒時，以判斷執行執行緒所在的處理器。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>值是以零為起始。  換句話說，若要設定的第一個處理器的執行緒親和性，此屬性設定為零。  
  
 系統會排程在盡可能其慣用的處理器上的執行緒。  
  
 處理序執行緒可以移轉處理器，以重新載入處理器快取每個移轉。 指定執行緒的處理器可以改善在繁重的系統負載下的效能降低的次數會重新載入處理器快取。  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>「 記事本 」 的第一個處理器執行個體屬性。  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">系統無法設定在指定的處理器上啟動執行緒。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定數值，表示每當執行緒的處理序之主視窗接收到焦點 (Focus) 時，作業系統是否應該暫時提高相關執行緒的優先權。</summary>
        <value>
          若要在使用者與處理序的介面互動時，提高執行緒的優先權，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A>是`true`，系統暫時提升執行緒的優先權，只要其相關聯的處理序取自等候狀態。 這個動作可防止其他處理程序會中斷目前執行緒的處理。 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A>設定會影響所有現有的執行緒，以及任何後續程序所建立的執行緒。 若要還原正常的行為，請設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性`false`。  
  
 <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 執行緒已在處理序中執行時，才有作用<xref:System.Diagnostics.Process.PriorityClass%2A>設為其中一個列舉值動態優先順序 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)。  
  
> [!NOTE]
>  提高過度提高優先權可以耗盡必要作業系統和網路功能資源。 這可能會造成問題的其他作業系統工作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取優先權提高資訊。  
  
 -或-  
  
 無法設定優先權提高資訊。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定執行緒的優先權層級。</summary>
        <value>其中一個 <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> 值，指定限定執行緒優先權的範圍。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 優先權層級並非單一的值，而不是某個範圍的值。 作業系統計算所使用的程序執行緒的基礎優先權<xref:System.Diagnostics.Process.PriorityClass%2A>選擇的值中指定的範圍從<xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取執行緒優先權層級資訊。  
  
 -或-  
  
 無法設定執行緒優先權層級。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得執行緒在作業系統核心中執行程式碼所耗用的時間量。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，表示執行緒在作業系統核心中執行程式碼所耗用的時間量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 使用數個不同的保護機制，而且根目錄中的所有使用者模式與特殊權限的模式之間的差異。 <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> 對應至應用程式已花在特權模式下，在作業系統核心內執行的時間量。 <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>屬性表示應用程式已花在使用者模式中，系統核心外部執行的程式碼的時間量。  
  
 使用者模式會在兩個重要方面限制應用程式。 首先，應用程式無法直接存取周邊裝置，但必須改為呼叫以取得或設定週邊資料在作業系統核心。 作業系統可以確保應用程式不會終結週邊資料所需的另一個。 其次，應用程式無法讀取或變更作業系統本身會維護的資料。 這項限制可防止不小心或故意損毀的核心應用程式。 如果應用程式需要的作業系統執行的作業，它會呼叫其中一個作業系統的常式。 許多這些轉換為特殊權限模式中，執行作業，並順暢地傳回使用者模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取執行緒時間。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>設定可以執行相關執行緒的處理器。</summary>
        <value>指向一組位元的 <see cref="T:System.IntPtr" />，其中每個位元表示執行緒可以在其上執行的處理器。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒的處理器相似性是一組處理器它有關聯性。 換句話說，這些 it 可以在排程上執行。  
  
 <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> 位元表示每個處理器。 位元 0 代表其中一個處理器，位元 1 代表處理器兩個，依此類推。 下表顯示可能的子集<xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>四個處理器的系統。  
  
|屬性值 （以十六進位方式）|有效的處理器|  
|---------------------------------------|----------------------|  
|0x0001|1|  
|0x0002|2|  
|0x0003|1 或 2|  
|0x0004|3|  
|0x0005|1 或 3|  
|0x0007|1、 2 或 3|  
|0x000F|1、 2、 3 或 4|  
  
 您也可以指定單一的慣用的處理器執行緒藉由設定<xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>屬性。 處理序執行緒可以移轉處理器，以重新載入處理器快取每個移轉。 指定執行緒的處理器可以改善在繁重的系統負載下的效能降低的次數會重新載入處理器快取。  
  
   
  
## Examples  
 下列範例示範如何設定<xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>「 記事本 」 的第一個處理器執行個體屬性。  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">處理序相似性不能被設定。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重設這個執行緒的理想處理器，以指示沒有一個的理想處理器。 換句話說，沒有任何處理器是理想的。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法重設理想處理器。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得作業系統啟動這個執行緒所呼叫之函式的記憶體位址。</summary>
        <value>執行緒的起始位址，指向執行緒執行之應用程式定義的函式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個處理序啟動與單一執行緒，也就是主要執行緒。 任何執行緒可以建立額外的執行緒。  
  
 處理程序具有虛擬位址空間、 可執行程式碼、 資料、 物件控制代碼、 環境變數、 基本優先順序，和最小值和最大工作集大小。 處理程序的所有執行緒都共用其虛擬位址空間和系統資源。 此外，每個執行緒各維護例外狀況處理常式、 排程的優先權和一組結構時執行緒正在等候排程儲存的執行緒內容的系統。 執行緒內容會包含執行緒的處理序的位址空間中的執行緒組機器暫存器、 核心堆疊、 執行緒環境區塊，以及使用者堆疊。  
  
 每個 Windows 執行緒實際上會開始執行的系統提供的函數，而不應用程式提供的函式中。 主執行緒的開始位址進行，因此，相同 （它代表系統提供的函式的位址） 的系統中每個 Windows 處理序。 不過，<xref:System.Diagnostics.ProcessThread.StartAddress%2A>屬性可讓您取得專屬於您的應用程式的起始函式位址。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得作業系統啟動執行緒的時間。</summary>
        <value>
          <see cref="T:System.DateTime" />，表示當作業系統啟動執行緒時的系統時間。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取執行緒時間。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個執行緒目前的狀態。</summary>
        <value>
          <see cref="T:System.Diagnostics.ThreadState" />，表示執行緒的執行，例如，執行中、等候中或終止。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性值是否有效時，才<xref:System.Diagnostics.ProcessThread.ThreadState%2A>值是<xref:System.Diagnostics.ThreadState.Wait>。 因此，請檢查<xref:System.Diagnostics.ProcessThread.ThreadState%2A>值之前<xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個執行緒使用處理器所耗用的總時間量。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，表示執行緒已控制處理器的時間量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A>屬性表示系統已超出等候狀態的執行緒，並且有它的優先權任何處理器上的時間總數。 在多處理器系統上，這個值將包含在每個處理器，花費的時間，如果使用多個處理器的執行緒。  
  
 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A>屬性是總和<xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>和<xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取執行緒時間。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關執行緒在應用程式內部執行程式碼所耗用的時間量。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，表示執行緒在應用程式內部 (相對於在作業系統核心中) 執行程式碼所耗用的時間量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows NT 使用數個不同的保護機制，而且根目錄中的所有使用者模式與特殊權限的模式之間的差異。 <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> 對應至的應用程式已在作業系統核心外部的使用者模式中執行所花費的時間量。 <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>對應至應用程式已花在特權模式下，系統核心內執行的程式碼的時間量。  
  
 使用者模式會在兩個重要方面限制應用程式。 首先，應用程式無法直接存取周邊裝置，但必須改為呼叫以取得或設定週邊資料在作業系統核心。 作業系統可以確保應用程式不會終結週邊資料所需的另一個。 其次，應用程式無法讀取或變更作業系統本身會維護的資料。 這項限制可防止不小心或故意損毀的核心應用程式。 如果應用程式需要的作業系統執行的作業，它會呼叫其中一個作業系統的常式。 許多這些轉換為特殊權限模式中，執行作業，並順暢地傳回使用者模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取執行緒時間。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得執行緒正在等候的原因。</summary>
        <value>
          <see cref="T:System.Diagnostics.ThreadWaitReason" />，表示執行緒在等候狀態的原因。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性時才有效唯一<xref:System.Diagnostics.ProcessThread.ThreadState%2A>是<xref:System.Diagnostics.ThreadState.Wait>。 因此，請檢查<xref:System.Diagnostics.ProcessThread.ThreadState%2A>值之前<xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">執行緒不在等候狀態。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台為 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.NotSupportedException">處理序位於遠端電腦上。</exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>