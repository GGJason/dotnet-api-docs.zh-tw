<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="035bb483e7f4700eea14b2b39e00ff7f6172ea58" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58691859" /></Metadata><TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ProcessThread = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="4bf40-101">表示作業系統處理序 (Process) 執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-101">Represents an operating system process thread.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-102">使用<xref:System.Diagnostics.ProcessThread>來取得目前正在系統執行的執行緒相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-102">Use <xref:System.Diagnostics.ProcessThread> to obtain information about a thread that is currently running on the system.</span></span> <span data-ttu-id="4bf40-103">如此可讓您，比方說，若要監視執行緒的效能特性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-103">Doing so allows you, for example, to monitor the thread's performance characteristics.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4bf40-104">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="4bf40-104">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="4bf40-105">當您完成使用型別時，您應該處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="4bf40-105">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="4bf40-106">若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-106">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="4bf40-107">若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="4bf40-107">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="4bf40-108">如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="4bf40-108">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="4bf40-109">執行緒是執行透過程式的路徑。</span><span class="sxs-lookup"><span data-stu-id="4bf40-109">A thread is a path of execution through a program.</span></span> <span data-ttu-id="4bf40-110">它是 Win32 排程執行的最小單位。</span><span class="sxs-lookup"><span data-stu-id="4bf40-110">It is the smallest unit of execution that Win32 schedules.</span></span> <span data-ttu-id="4bf40-111">它包含堆疊，以及 CPU 暫存器中，系統排程器的 [執行] 清單中的項目狀態。</span><span class="sxs-lookup"><span data-stu-id="4bf40-111">It consists of a stack, the state of the CPU registers, and an entry in the execution list of the system scheduler.</span></span>  
  
 <span data-ttu-id="4bf40-112">處理程序是由一個或多個執行緒和程式碼、 資料和程式在記憶體中的其他資源所組成。</span><span class="sxs-lookup"><span data-stu-id="4bf40-112">A process consists of one or more threads and the code, data, and other resources of a program in memory.</span></span> <span data-ttu-id="4bf40-113">一般程式資源是開啟的檔案、 信號及動態配置的記憶體。</span><span class="sxs-lookup"><span data-stu-id="4bf40-113">Typical program resources are open files, semaphores, and dynamically allocated memory.</span></span> <span data-ttu-id="4bf40-114">每個資源的處理程序是由所有處理程序的執行緒共用。</span><span class="sxs-lookup"><span data-stu-id="4bf40-114">Each resource of a process is shared by all that process's threads.</span></span>  
  
 <span data-ttu-id="4bf40-115">當系統排程器執行控制提供給其中一個程式的執行緒時，就會執行程式。</span><span class="sxs-lookup"><span data-stu-id="4bf40-115">A program executes when the system scheduler gives execution control to one of the program's threads.</span></span> <span data-ttu-id="4bf40-116">排程器可讓您判斷應該執行哪一個執行緒和時間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-116">The scheduler determines which threads should run and when.</span></span> <span data-ttu-id="4bf40-117">低優先順序的執行緒可能會強制較高優先順序的執行緒完成其工作時等候。</span><span class="sxs-lookup"><span data-stu-id="4bf40-117">A lower-priority thread might be forced to wait while higher-priority threads complete their tasks.</span></span> <span data-ttu-id="4bf40-118">多處理器的電腦上排程器可以前往個別的執行緒不同的處理器，以平衡的 CPU 負載。</span><span class="sxs-lookup"><span data-stu-id="4bf40-118">On multiprocessor computers, the scheduler can move individual threads to different processors, thus balancing the CPU load.</span></span>  
  
 <span data-ttu-id="4bf40-119">每個處理序會啟動單一執行緒，也就是主執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-119">Each process starts with a single thread, which is known as the primary thread.</span></span> <span data-ttu-id="4bf40-120">任何執行緒可以建立額外的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-120">Any thread can create additional threads.</span></span> <span data-ttu-id="4bf40-121">在處理序中的所有執行緒都共用該處理序的位址空間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-121">All the threads within a process share the address space of that process.</span></span>  
  
 <span data-ttu-id="4bf40-122">主要執行緒不一定是位在集合中的第一個索引。</span><span class="sxs-lookup"><span data-stu-id="4bf40-122">The primary thread is not necessarily located at the first index in the collection.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4bf40-123">從.NET Framework 2.0 版開始，在其他電腦上的參考效能計數器資料的能力已消除許多的.NET Framework 方法和屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-123">Starting with the .NET Framework version 2.0, the ability to reference performance counter data on other computers has been eliminated for many of the .NET Framework methods and properties.</span></span> <span data-ttu-id="4bf40-124">這項變更為了改善效能，也讓非系統管理員使用<xref:System.Diagnostics.ProcessThread>類別。</span><span class="sxs-lookup"><span data-stu-id="4bf40-124">This change was made to improve performance and to enable non-administrators to use the <xref:System.Diagnostics.ProcessThread> class.</span></span> <span data-ttu-id="4bf40-125">如此一來，未取得例外狀況在舊版.NET Framework 的某些應用程式可能會立即取得<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="4bf40-125">As a result, some applications that did not get exceptions in earlier versions of the .NET Framework may now get a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="4bf40-126">方法和受影響的屬性太多而不一一列舉，但受影響的成員主題已加入的例外狀況資訊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-126">The methods and properties affected are too numerous to list here, but the exception information has been added to the affected member topics.</span></span>  
  
 <span data-ttu-id="4bf40-127">處理序的執行緒會個別執行，並不知道彼此，除非它們讓彼此看到。</span><span class="sxs-lookup"><span data-stu-id="4bf40-127">The threads of a process execute individually and are unaware of each other unless you make them visible to each other.</span></span> <span data-ttu-id="4bf40-128">不過，共用通用資源的執行緒必須協調其工作使用號誌或另一個處理序間通訊的方法。</span><span class="sxs-lookup"><span data-stu-id="4bf40-128">Threads that share common resources, however, must coordinate their work by using semaphores or another method of interprocess communication.</span></span>  
  
 <span data-ttu-id="4bf40-129">若要取得所有集合<xref:System.Diagnostics.ProcessThread>目前的處理序相關聯的物件都取得<xref:System.Diagnostics.Process.Threads%2A>屬性<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="4bf40-129">To get a collection of all the <xref:System.Diagnostics.ProcessThread> objects associated with the current process, get the <xref:System.Diagnostics.Process.Threads%2A> property of the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-130">取得執行緒的基礎優先權 (Base Priority)。</span><span class="sxs-lookup"><span data-stu-id="4bf40-130">Gets the base priority of the thread.</span></span></summary>
        <value><span data-ttu-id="4bf40-131">執行緒的基礎優先權，由作業系統結合處理序的優先權類別和相關執行緒的優先權層級計算所得。</span><span class="sxs-lookup"><span data-stu-id="4bf40-131">The base priority of the thread, which the operating system computes by combining the process priority class with the priority level of the associated thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-132"><xref:System.Diagnostics.ProcessThread.BasePriority%2A>是開始程序的執行緒優先權。</span><span class="sxs-lookup"><span data-stu-id="4bf40-132">The <xref:System.Diagnostics.ProcessThread.BasePriority%2A> is the starting priority for the process thread.</span></span> <span data-ttu-id="4bf40-133">您可以檢視的基底的優先順序，透過 「 系統監視器的優先權基底計數器的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-133">You can view information about the base priority through the System Monitor's Priority Base counter.</span></span>  
  
 <span data-ttu-id="4bf40-134">作業系統結合處理序的優先順序類別中的執行緒的優先權層級範圍計算執行緒的基礎優先權。</span><span class="sxs-lookup"><span data-stu-id="4bf40-134">The operating system computes a thread's base priority by combining the thread's priority level range with the process's priority class.</span></span> <span data-ttu-id="4bf40-135">您可以設定的程序<xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType>屬性中值的其中一個<xref:System.Diagnostics.ProcessPriorityClass>列舉型別，也就是<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。</span><span class="sxs-lookup"><span data-stu-id="4bf40-135">You can set the process's <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> property to one of the values in the <xref:System.Diagnostics.ProcessPriorityClass> enumeration, which are <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>.</span></span> <span data-ttu-id="4bf40-136">您可以設定執行緒的<xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>界限執行緒的基本優先順序之值的範圍的屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-136">You can set the thread's <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> property to a range of values that bounds the thread's base priority.</span></span> <span data-ttu-id="4bf40-137">Win32 與每個類別的七個基底的優先順序層級使用四個優先權類別。</span><span class="sxs-lookup"><span data-stu-id="4bf40-137">Win32 uses four priority classes with seven base priority levels per class.</span></span>  
  
 <span data-ttu-id="4bf40-138">執行緒的目前優先權可能會偏離的基本優先順序。</span><span class="sxs-lookup"><span data-stu-id="4bf40-138">The thread's current priority might deviate from the base priority.</span></span> <span data-ttu-id="4bf40-139">比方說，可以變更作業系統<xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>過屬性隨著時間或其他的提升，當處理序必須領先其他人中放置的存取，處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-139">For example, the operating system can change the <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> property based on the time elapsed or other boosts when a process must be put ahead of others for access to the processor.</span></span> <span data-ttu-id="4bf40-140">此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>會造成系統程序會從等候狀態時，暫時提高執行緒優先權的屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-140">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to cause the system to temporarily boost the priority of a thread whenever the process is taken out of the wait state.</span></span> <span data-ttu-id="4bf40-141">處理程序會回到等候狀態時，會重設的優先順序。</span><span class="sxs-lookup"><span data-stu-id="4bf40-141">The priority is reset when the process returns to the wait state.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPriority : int" Usage="System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadCurrentPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-142">取得執行緒的目前優先權。</span><span class="sxs-lookup"><span data-stu-id="4bf40-142">Gets the current priority of the thread.</span></span></summary>
        <value><span data-ttu-id="4bf40-143">執行緒目前的優先權，可能與基礎優先權 (根據作業系統如何排程執行緒) 不符合。</span><span class="sxs-lookup"><span data-stu-id="4bf40-143">The current priority of the thread, which may deviate from the base priority based on how the operating system is scheduling the thread.</span></span> <span data-ttu-id="4bf40-144">針對作用中的執行緒，可能暫時提高優先權。</span><span class="sxs-lookup"><span data-stu-id="4bf40-144">The priority may be temporarily boosted for an active thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-145">執行緒的目前優先權可能會偏離的基本優先順序。</span><span class="sxs-lookup"><span data-stu-id="4bf40-145">The thread's current priority might deviate from the base priority.</span></span> <span data-ttu-id="4bf40-146">比方說，可以變更作業系統<xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>屬性隨著時間經過，或其他的增加，當處理程序時必須加以領先其他人存取處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-146">For example, the operating system can change the <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> property based on the time elapsed, or other boosts, when a process must be put ahead of others for access to the processor.</span></span> <span data-ttu-id="4bf40-147">此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>會造成系統程序會從等候狀態時，暫時提高執行緒優先權的屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-147">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to cause the system to temporarily boost the priority of a thread whenever the process is taken out of the wait state.</span></span> <span data-ttu-id="4bf40-148">處理程序會回到等候狀態時，會重設的優先順序。</span><span class="sxs-lookup"><span data-stu-id="4bf40-148">The priority is reset when the process returns to the wait state.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-149">取得執行緒的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="4bf40-149">Gets the unique identifier of the thread.</span></span></summary>
        <value><span data-ttu-id="4bf40-150">與特定執行緒相關的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="4bf40-150">The unique identifier associated with a specific thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-151">作業系統會重複使用執行緒識別數字，用來識別只有在其存留時間期間的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-151">The operating system reuses thread identification numbers, which identify threads only during their lifetimes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IdealProcessor : int" Usage="System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-152">設定執行這個執行緒的慣用處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-152">Sets the preferred processor for this thread to run on.</span></span></summary>
        <value><span data-ttu-id="4bf40-153">執行緒的慣用處理器，用於系統排程執行緒時，以判斷執行執行緒所在的處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-153">The preferred processor for the thread, used when the system schedules threads, to determine which processor to run the thread on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-154"><xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>值是以零為起始。</span><span class="sxs-lookup"><span data-stu-id="4bf40-154">The <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> value is zero-based.</span></span>  <span data-ttu-id="4bf40-155">換句話說，若要設定的第一個處理器的執行緒親和性，此屬性設定為零。</span><span class="sxs-lookup"><span data-stu-id="4bf40-155">In other words, to set the thread affinity for the first processor, set the property to zero.</span></span>  
  
 <span data-ttu-id="4bf40-156">系統會排定其盡可能的慣用處理器上的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-156">The system schedules threads on their preferred processors whenever possible.</span></span>  
  
 <span data-ttu-id="4bf40-157">處理序執行緒可以移轉處理器，以重新載入處理器快取每個移轉。</span><span class="sxs-lookup"><span data-stu-id="4bf40-157">A process thread can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="4bf40-158">指定執行緒的處理器可以改善繁重的系統負載下的效能降低的處理器快取會重新載入的次數。</span><span class="sxs-lookup"><span data-stu-id="4bf40-158">Specifying a processor for a thread can improve performance under heavy system loads by reducing the number of times the processor cache is reloaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4bf40-159">下列範例示範如何設定<xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>「 記事本 」 的第一個處理器執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-159">The following example demonstrates how to set the <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> property for an instance of Notepad to the first processor.</span></span>  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-160">系統無法設定在指定的處理器上啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-160">The system could not set the thread to start on the specified processor.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-161">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-161">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-162">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-162">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-163">取得或設定數值，表示每當執行緒的處理序之主視窗接收到焦點 (Focus) 時，作業系統是否應該暫時提高相關執行緒的優先權。</span><span class="sxs-lookup"><span data-stu-id="4bf40-163">Gets or sets a value indicating whether the operating system should temporarily boost the priority of the associated thread whenever the main window of the thread's process receives the focus.</span></span></summary>
        <value><span data-ttu-id="4bf40-164">若要在使用者與處理序的介面互動時，提高執行緒的優先權，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4bf40-164"><see langword="true" /> to boost the thread's priority when the user interacts with the process's interface; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4bf40-165">預設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4bf40-165">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-166">當<xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A>是`true`，系統暫時增加執行緒的優先順序，只要其相關聯的處理序會從等候狀態。</span><span class="sxs-lookup"><span data-stu-id="4bf40-166">When <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> is `true`, the system temporarily boosts the thread's priority whenever its associated process is taken out of the wait state.</span></span> <span data-ttu-id="4bf40-167">這個動作可防止其他處理序中斷目前執行緒的處理。</span><span class="sxs-lookup"><span data-stu-id="4bf40-167">This action prevents other processes from interrupting the processing of the current thread.</span></span> <span data-ttu-id="4bf40-168"><xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A>設定會影響所有現有的執行緒，以及任何後續的程序所建立的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-168">The <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> setting affects all existing threads as well as any threads subsequently created by the process.</span></span> <span data-ttu-id="4bf40-169">若要還原的正常行為，請設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性設`false`。</span><span class="sxs-lookup"><span data-stu-id="4bf40-169">To restore normal behavior, set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="4bf40-170"><xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 只有在執行緒正在執行中有的程序時，才有作用<xref:System.Diagnostics.Process.PriorityClass%2A>設為其中一個動態優先順序列舉值 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)。</span><span class="sxs-lookup"><span data-stu-id="4bf40-170"><xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> has an effect only when the thread is running in a process that has a <xref:System.Diagnostics.Process.PriorityClass%2A> set to one of the dynamic priority enumeration values (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4bf40-171">提升提高優先權可能會耗盡必要作業系統和網路功能資源。</span><span class="sxs-lookup"><span data-stu-id="4bf40-171">Boosting the priority too high can drain resources from essential operating system and network functions.</span></span> <span data-ttu-id="4bf40-172">這可能會造成問題的其他作業系統工作。</span><span class="sxs-lookup"><span data-stu-id="4bf40-172">This could cause problems with other operating system tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-173">無法擷取優先權提高資訊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-173">The priority boost information could not be retrieved.</span></span>  
  
<span data-ttu-id="4bf40-174">-或-</span><span class="sxs-lookup"><span data-stu-id="4bf40-174">-or-</span></span> 
<span data-ttu-id="4bf40-175">無法設定優先權提高資訊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-175">The priority boost information could not be set.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-176">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-176">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-177">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-177">The process is on a remote computer.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityLevel : System.Diagnostics.ThreadPriorityLevel with get, set" Usage="System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityLevel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-178">取得或設定執行緒的優先權層級。</span><span class="sxs-lookup"><span data-stu-id="4bf40-178">Gets or sets the priority level of the thread.</span></span></summary>
        <value><span data-ttu-id="4bf40-179">其中一個 <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> 值，指定限定執行緒優先權的範圍。</span><span class="sxs-lookup"><span data-stu-id="4bf40-179">One of the <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> values, specifying a range that bounds the thread's priority.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-180">優先權層級不是單一值，而不是值的範圍。</span><span class="sxs-lookup"><span data-stu-id="4bf40-180">The priority level is not a single value, but rather a range of values.</span></span> <span data-ttu-id="4bf40-181">作業系統使用的程序計算執行緒的基礎優先權<xref:System.Diagnostics.Process.PriorityClass%2A>選擇值中指定的範圍從<xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-181">The operating system computes the thread's base priority by using the process's <xref:System.Diagnostics.Process.PriorityClass%2A> to choose a value from the range specified in the <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-182">無法擷取執行緒優先權層級資訊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-182">The thread priority level information could not be retrieved.</span></span>  
  
<span data-ttu-id="4bf40-183">-或-</span><span class="sxs-lookup"><span data-stu-id="4bf40-183">-or-</span></span> 
<span data-ttu-id="4bf40-184">無法設定執行緒優先權層級。</span><span class="sxs-lookup"><span data-stu-id="4bf40-184">The thread priority level could not be set.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-185">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-185">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-186">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-186">The process is on a remote computer.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-187">取得執行緒在作業系統核心中執行程式碼所耗用的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-187">Gets the amount of time that the thread has spent running code inside the operating system core.</span></span></summary>
        <value><span data-ttu-id="4bf40-188"><see cref="T:System.TimeSpan" />，表示執行緒在作業系統核心中執行程式碼所耗用的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-188">A <see cref="T:System.TimeSpan" /> indicating the amount of time that the thread has spent running code inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-189">Windows 會使用數個不同的保護機制，而且根目錄中的所有使用者模式和特殊權限的模式之間的差異。</span><span class="sxs-lookup"><span data-stu-id="4bf40-189">Windows uses several different protection mechanisms, and at the root of them all is the distinction between user mode and privileged mode.</span></span> <span data-ttu-id="4bf40-190"><xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> 對應至應用程式已花在特權模式下，在作業系統核心內執行的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-190"><xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> corresponds to the amount of time that the application has spent running in privileged mode, inside the operating system core.</span></span> <span data-ttu-id="4bf40-191"><xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>屬性會指出應用程式花在使用者模式中，系統核心外部執行的程式碼的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-191">The <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> property indicates the amount of time that the application has spent running code in user mode, outside the system core.</span></span>  
  
 <span data-ttu-id="4bf40-192">使用者模式會限制應用程式，在兩個重要的方面。</span><span class="sxs-lookup"><span data-stu-id="4bf40-192">User mode restricts the application in two important ways.</span></span> <span data-ttu-id="4bf40-193">首先，應用程式無法直接存取週邊設備，但必須改為呼叫來取得或設定週邊設備的資料在作業系統核心。</span><span class="sxs-lookup"><span data-stu-id="4bf40-193">First, the application cannot directly access the peripherals, but instead must call the operating system core to get or set peripheral data.</span></span> <span data-ttu-id="4bf40-194">作業系統可以確保應用程式不會終結週邊設備的資料所需的另一個。</span><span class="sxs-lookup"><span data-stu-id="4bf40-194">The operating system can thus ensure that one application does not destroy peripheral data that is needed by another.</span></span> <span data-ttu-id="4bf40-195">第二，應用程式無法讀取或變更作業系統本身會維護的資料。</span><span class="sxs-lookup"><span data-stu-id="4bf40-195">Second, the application cannot read or change data that the operating system itself maintains.</span></span> <span data-ttu-id="4bf40-196">這項限制可防止應用程式不小心或故意損毀的核心。</span><span class="sxs-lookup"><span data-stu-id="4bf40-196">This restriction prevents applications from either inadvertently or intentionally corrupting the core.</span></span> <span data-ttu-id="4bf40-197">如果應用程式需要執行作業的作業系統，它會呼叫其中一個系統的常式。</span><span class="sxs-lookup"><span data-stu-id="4bf40-197">If the application needs the operating system to perform an operation, it calls one of the system's routines.</span></span> <span data-ttu-id="4bf40-198">許多這些轉換為特殊權限模式中，執行作業，並順暢地傳回給使用者模式。</span><span class="sxs-lookup"><span data-stu-id="4bf40-198">Many of these transition into privileged mode, perform the operation, and smoothly return to user mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-199">無法擷取執行緒時間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-199">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-200">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-200">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-201">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-201">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint" Usage="System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-202">設定可以執行相關執行緒的處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-202">Sets the processors on which the associated thread can run.</span></span></summary>
        <value><span data-ttu-id="4bf40-203">指向一組位元的 <see cref="T:System.IntPtr" />，其中每個位元表示執行緒可以在其上執行的處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-203">An <see cref="T:System.IntPtr" /> that points to a set of bits, each of which represents a processor that the thread can run on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-204">執行緒的處理器相似性是一組處理器有關聯性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-204">The processor affinity of a thread is the set of processors it has a relationship to.</span></span> <span data-ttu-id="4bf40-205">換句話說，這些 it 可以排程上執行。</span><span class="sxs-lookup"><span data-stu-id="4bf40-205">In other words, those it can be scheduled to run on.</span></span>  
  
 <span data-ttu-id="4bf40-206"><xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> 位元代表每個處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-206"><xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> represents each processor as a bit.</span></span> <span data-ttu-id="4bf40-207">位元 0 代表其中一個處理器，位元 1 代表處理器兩個，依此類推。</span><span class="sxs-lookup"><span data-stu-id="4bf40-207">Bit 0 represents processor one, bit 1 represents processor two, and so on.</span></span> <span data-ttu-id="4bf40-208">下表顯示可能的子集<xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>四個處理器的系統。</span><span class="sxs-lookup"><span data-stu-id="4bf40-208">The following table shows a subset of the possible <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> for a four-processor system.</span></span>  
  
|<span data-ttu-id="4bf40-209">屬性值 （以十六進位方式）</span><span class="sxs-lookup"><span data-stu-id="4bf40-209">Property value (in hexadecimal)</span></span>|<span data-ttu-id="4bf40-210">有效的處理器</span><span class="sxs-lookup"><span data-stu-id="4bf40-210">Valid processors</span></span>|  
|---------------------------------------|----------------------|  
|<span data-ttu-id="4bf40-211">0x0001</span><span class="sxs-lookup"><span data-stu-id="4bf40-211">0x0001</span></span>|<span data-ttu-id="4bf40-212">1</span><span class="sxs-lookup"><span data-stu-id="4bf40-212">1</span></span>|  
|<span data-ttu-id="4bf40-213">0x0002</span><span class="sxs-lookup"><span data-stu-id="4bf40-213">0x0002</span></span>|<span data-ttu-id="4bf40-214">2</span><span class="sxs-lookup"><span data-stu-id="4bf40-214">2</span></span>|  
|<span data-ttu-id="4bf40-215">0x0003</span><span class="sxs-lookup"><span data-stu-id="4bf40-215">0x0003</span></span>|<span data-ttu-id="4bf40-216">1 或 2</span><span class="sxs-lookup"><span data-stu-id="4bf40-216">1 or 2</span></span>|  
|<span data-ttu-id="4bf40-217">0x0004</span><span class="sxs-lookup"><span data-stu-id="4bf40-217">0x0004</span></span>|<span data-ttu-id="4bf40-218">3</span><span class="sxs-lookup"><span data-stu-id="4bf40-218">3</span></span>|  
|<span data-ttu-id="4bf40-219">0x0005</span><span class="sxs-lookup"><span data-stu-id="4bf40-219">0x0005</span></span>|<span data-ttu-id="4bf40-220">1 或 3</span><span class="sxs-lookup"><span data-stu-id="4bf40-220">1 or 3</span></span>|  
|<span data-ttu-id="4bf40-221">0x0007</span><span class="sxs-lookup"><span data-stu-id="4bf40-221">0x0007</span></span>|<span data-ttu-id="4bf40-222">1、 2 或 3</span><span class="sxs-lookup"><span data-stu-id="4bf40-222">1, 2, or 3</span></span>|  
|<span data-ttu-id="4bf40-223">0x000F</span><span class="sxs-lookup"><span data-stu-id="4bf40-223">0x000F</span></span>|<span data-ttu-id="4bf40-224">1、 2、 3 或 4</span><span class="sxs-lookup"><span data-stu-id="4bf40-224">1, 2, 3, or 4</span></span>|  
  
 <span data-ttu-id="4bf40-225">您也可以藉由設定指定執行緒的單一的慣用處理器<xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-225">You can also specify the single, preferred processor for a thread by setting the <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> property.</span></span> <span data-ttu-id="4bf40-226">處理序執行緒可以移轉處理器，以重新載入處理器快取每個移轉。</span><span class="sxs-lookup"><span data-stu-id="4bf40-226">A process thread can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="4bf40-227">指定執行緒的處理器可以改善繁重的系統負載下的效能降低的處理器快取會重新載入的次數。</span><span class="sxs-lookup"><span data-stu-id="4bf40-227">Specifying a processor for a thread can improve performance under heavy system loads by reducing the number of times the processor cache is reloaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4bf40-228">下列範例示範如何設定<xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>「 記事本 」 的第一個處理器執行個體屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-228">The following example shows how to set the <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> property for an instance of Notepad to the first processor.</span></span>  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-229">處理序相似性不能被設定。</span><span class="sxs-lookup"><span data-stu-id="4bf40-229">The processor affinity could not be set.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-230">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-230">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-231">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-231">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberSignature Language="F#" Value="member this.ResetIdealProcessor : unit -&gt; unit" Usage="processThread.ResetIdealProcessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4bf40-232">重設這個執行緒的理想處理器，以指示沒有一個的理想處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-232">Resets the ideal processor for this thread to indicate that there is no single ideal processor.</span></span> <span data-ttu-id="4bf40-233">換句話說，沒有任何處理器是理想的。</span><span class="sxs-lookup"><span data-stu-id="4bf40-233">In other words, so that any processor is ideal.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-234">無法重設理想處理器。</span><span class="sxs-lookup"><span data-stu-id="4bf40-234">The ideal processor could not be reset.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-235">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-235">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-236">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-236">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.StartAddress : nativeint" Usage="System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-237">取得作業系統啟動這個執行緒所呼叫之函式的記憶體位址。</span><span class="sxs-lookup"><span data-stu-id="4bf40-237">Gets the memory address of the function that the operating system called that started this thread.</span></span></summary>
        <value><span data-ttu-id="4bf40-238">執行緒的起始位址，指向執行緒執行之應用程式定義的函式。</span><span class="sxs-lookup"><span data-stu-id="4bf40-238">The thread's starting address, which points to the application-defined function that the thread executes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-239">每個處理序會啟動單一執行緒，也就是主執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-239">Each process starts with a single thread, which is known as the primary thread.</span></span> <span data-ttu-id="4bf40-240">任何執行緒可以建立額外的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-240">Any thread can create additional threads.</span></span>  
  
 <span data-ttu-id="4bf40-241">處理序有虛擬位址空間、 可執行程式碼、 資料、 物件控制代碼、 環境變數、 基本優先順序，並最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="4bf40-241">A process has a virtual address space, executable code, data, object handles, environment variables, a base priority, and minimum and maximum working set sizes.</span></span> <span data-ttu-id="4bf40-242">處理程序的所有執行緒都共用其虛擬位址空間和系統資源。</span><span class="sxs-lookup"><span data-stu-id="4bf40-242">All the threads of a process share its virtual address space and system resources.</span></span> <span data-ttu-id="4bf40-243">此外，每個執行緒各維護，例外狀況處理常式、 排程優先順序和一組結構時執行緒正在等候排程儲存執行緒內容的系統。</span><span class="sxs-lookup"><span data-stu-id="4bf40-243">In addition, each thread maintains exception handlers, a scheduling priority, and a set of structures in which the system saves the thread context while the thread is waiting to be scheduled.</span></span> <span data-ttu-id="4bf40-244">執行緒內容會包含執行緒的處理序位址空間中的執行緒組機器暫存器、 核心堆疊、 執行緒環境區塊，以及使用者堆疊。</span><span class="sxs-lookup"><span data-stu-id="4bf40-244">The thread context includes the thread's set of machine registers, the kernel stack, a thread environment block, and a user stack in the address space of the thread's process.</span></span>  
  
 <span data-ttu-id="4bf40-245">每個 Windows 執行緒開始執行中的系統提供的函數，而不應用程式提供的函式。</span><span class="sxs-lookup"><span data-stu-id="4bf40-245">Every Windows thread actually begins execution in a system-supplied function, not the application-supplied function.</span></span> <span data-ttu-id="4bf40-246">主執行緒的開始位址是，因此，相同 （它代表系統提供的函式的位址） 系統中的每個 Windows 處理程序。</span><span class="sxs-lookup"><span data-stu-id="4bf40-246">The starting address for the primary thread is, therefore, the same (as it represents the address of the system-supplied function) for every Windows process in the system.</span></span> <span data-ttu-id="4bf40-247">不過，<xref:System.Diagnostics.ProcessThread.StartAddress%2A>屬性可讓您取得的特定應用程式起始函式的位址。</span><span class="sxs-lookup"><span data-stu-id="4bf40-247">However, the <xref:System.Diagnostics.ProcessThread.StartAddress%2A> property allows you to get the starting function address that is specific to your application.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-248">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-248">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-249">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-249">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-250">取得作業系統啟動執行緒的時間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-250">Gets the time that the operating system started the thread.</span></span></summary>
        <value><span data-ttu-id="4bf40-251"><see cref="T:System.DateTime" />，表示當作業系統啟動執行緒時的系統時間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-251">A <see cref="T:System.DateTime" /> representing the time that was on the system when the operating system started the thread.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-252">無法擷取執行緒時間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-252">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-253">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-253">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-254">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-254">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Diagnostics.ThreadState" Usage="System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadThreadState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-255">取得這個執行緒目前的狀態。</span><span class="sxs-lookup"><span data-stu-id="4bf40-255">Gets the current state of this thread.</span></span></summary>
        <value><span data-ttu-id="4bf40-256"><see cref="T:System.Diagnostics.ThreadState" />，表示執行緒的執行，例如，執行中、等候中或終止。</span><span class="sxs-lookup"><span data-stu-id="4bf40-256">A <see cref="T:System.Diagnostics.ThreadState" /> that indicates the thread's execution, for example, running, waiting, or terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-257"><xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性值為有效時，才<xref:System.Diagnostics.ProcessThread.ThreadState%2A>值是<xref:System.Diagnostics.ThreadState.Wait>。</span><span class="sxs-lookup"><span data-stu-id="4bf40-257">The <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property value is valid only when the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> value is <xref:System.Diagnostics.ThreadState.Wait>.</span></span> <span data-ttu-id="4bf40-258">因此，請檢查<xref:System.Diagnostics.ProcessThread.ThreadState%2A>值之後會取得<xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-258">Therefore, check the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> value before you get the <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-259">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-259">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-260">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-260">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-261">取得這個執行緒使用處理器所耗用的總時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-261">Gets the total amount of time that this thread has spent using the processor.</span></span></summary>
        <value><span data-ttu-id="4bf40-262"><see cref="T:System.TimeSpan" />，表示執行緒已控制處理器的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-262">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the thread has had control of the processor.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-263"><xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A>屬性會指出系統已等候狀態中取出執行緒，並指定其優先權任何處理器上的時間總數量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-263">The <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> property indicates the total amount of time that the system has taken the thread out of the wait state and given it priority on any processor.</span></span> <span data-ttu-id="4bf40-264">在多處理器系統上，這個值會包含每個處理器，所花費的時間，如果使用多個處理器的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4bf40-264">On a multiple processor system, this value would include time spent on each processor, if the thread used more than one processor.</span></span>  
  
 <span data-ttu-id="4bf40-265"><xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A>值的總和<xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>和<xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-265">The <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> property is the sum of the <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> and <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> properties.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-266">無法擷取執行緒時間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-266">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-267">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-267">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-268">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-268">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-269">取得相關執行緒在應用程式內部執行程式碼所耗用的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-269">Gets the amount of time that the associated thread has spent running code inside the application.</span></span></summary>
        <value><span data-ttu-id="4bf40-270"><see cref="T:System.TimeSpan" />，表示執行緒在應用程式內部 (相對於在作業系統核心中) 執行程式碼所耗用的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-270">A <see cref="T:System.TimeSpan" /> indicating the amount of time that the thread has spent running code inside the application, as opposed to inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-271">Windows NT 使用數個不同的保護機制，而且根目錄中的所有使用者模式和特殊權限的模式之間的差異。</span><span class="sxs-lookup"><span data-stu-id="4bf40-271">Windows NT uses several different protection mechanisms, and at the root of them all is the distinction between user mode and privileged mode.</span></span> <span data-ttu-id="4bf40-272"><xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> 對應至應用程式已花費在作業系統核心外部的使用者模式中執行的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-272"><xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> corresponds to the amount of time that the application has spent running in user mode, outside the operating system core.</span></span> <span data-ttu-id="4bf40-273"><xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>對應至應用程式花在特權模式下，系統核心內執行的程式碼的時間量。</span><span class="sxs-lookup"><span data-stu-id="4bf40-273">The <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> corresponds to the amount of time that the application has spent running code in privileged mode, inside the system core.</span></span>  
  
 <span data-ttu-id="4bf40-274">使用者模式會限制應用程式，在兩個重要的方面。</span><span class="sxs-lookup"><span data-stu-id="4bf40-274">User mode restricts the application in two important ways.</span></span> <span data-ttu-id="4bf40-275">首先，應用程式無法直接存取週邊設備，但必須改為呼叫來取得或設定週邊設備的資料在作業系統核心。</span><span class="sxs-lookup"><span data-stu-id="4bf40-275">First, the application cannot directly access the peripherals, but instead must call the operating system core to get or set peripheral data.</span></span> <span data-ttu-id="4bf40-276">作業系統可以確保應用程式不會終結週邊設備的資料所需的另一個。</span><span class="sxs-lookup"><span data-stu-id="4bf40-276">The operating system can thus ensure that one application does not destroy peripheral data that is needed by another.</span></span> <span data-ttu-id="4bf40-277">第二，應用程式無法讀取或變更作業系統本身會維護的資料。</span><span class="sxs-lookup"><span data-stu-id="4bf40-277">Second, the application cannot read or change data that the operating system itself maintains.</span></span> <span data-ttu-id="4bf40-278">這項限制可防止應用程式不小心或故意損毀的核心。</span><span class="sxs-lookup"><span data-stu-id="4bf40-278">This restriction prevents applications from either inadvertently or intentionally corrupting the core.</span></span> <span data-ttu-id="4bf40-279">如果應用程式需要執行作業的作業系統，它會呼叫其中一個系統的常式。</span><span class="sxs-lookup"><span data-stu-id="4bf40-279">If the application needs the operating system to perform an operation, it calls one of the system's routines.</span></span> <span data-ttu-id="4bf40-280">許多這些轉換為特殊權限模式中，執行作業，並順暢地傳回給使用者模式。</span><span class="sxs-lookup"><span data-stu-id="4bf40-280">Many of these transition into privileged mode, perform the operation, and smoothly return to user mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="4bf40-281">無法擷取執行緒時間。</span><span class="sxs-lookup"><span data-stu-id="4bf40-281">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-282">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-282">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-283">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-283">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitReason : System.Diagnostics.ThreadWaitReason" Usage="System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadWaitReason")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4bf40-284">取得執行緒正在等候的原因。</span><span class="sxs-lookup"><span data-stu-id="4bf40-284">Gets the reason that the thread is waiting.</span></span></summary>
        <value><span data-ttu-id="4bf40-285"><see cref="T:System.Diagnostics.ThreadWaitReason" />，表示執行緒在等候狀態的原因。</span><span class="sxs-lookup"><span data-stu-id="4bf40-285">A <see cref="T:System.Diagnostics.ThreadWaitReason" /> representing the reason that the thread is in the wait state.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4bf40-286"><xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性是時才有效<xref:System.Diagnostics.ProcessThread.ThreadState%2A>是<xref:System.Diagnostics.ThreadState.Wait>。</span><span class="sxs-lookup"><span data-stu-id="4bf40-286">The <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property is valid only when the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> is <xref:System.Diagnostics.ThreadState.Wait>.</span></span> <span data-ttu-id="4bf40-287">因此，請檢查<xref:System.Diagnostics.ProcessThread.ThreadState%2A>值之後會取得<xref:System.Diagnostics.ProcessThread.WaitReason%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="4bf40-287">Therefore, check the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> value before you get the <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="4bf40-288">執行緒不在等候狀態。</span><span class="sxs-lookup"><span data-stu-id="4bf40-288">The thread is not in the wait state.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="4bf40-289">平台為 Windows 98 或 Windows Millennium Edition。</span><span class="sxs-lookup"><span data-stu-id="4bf40-289">The platform is Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="4bf40-290">處理序位於遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="4bf40-290">The process is on a remote computer.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>