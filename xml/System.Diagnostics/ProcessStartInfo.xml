<Type Name="ProcessStartInfo" FullName="System.Diagnostics.ProcessStartInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5cdee8b0d47963d6cad7b5a0396ec89d4dfc944e" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061270" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ProcessStartInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ProcessStartInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessStartInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ProcessStartInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessStartInfo sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>指定一組啟動處理序時所使用的值。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo> 會搭配<xref:System.Diagnostics.Process>元件。 當您啟動處理程序，使用<xref:System.Diagnostics.Process>類別，您可以存取附加至正在執行的處理序時，處理所提供的資訊。  
  
 您可以使用<xref:System.Diagnostics.ProcessStartInfo>類別，以便更有效控制您所啟動的程序。 您至少必須設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性，以手動方式或使用建構函式。 任何應用程式或文件的檔案名稱。 在此文件會定義任何已開啟的檔案類型或預設與其相關聯的動作。 您可以為您的電腦檢視已登錄之檔案類型和其相關聯的應用程式，使用**資料夾選項**對話方塊中，這可透過作業系統。 **進階**通往對話方塊，顯示是否已註冊的特定檔案類型相關聯的開啟動作的按鈕。  
  
 此外，您可以設定其他屬性，定義要搭配此檔案採取的動作。 您可以指定特定的型別值<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性。 例如，您可以指定 「 列印 」 文件類型。 此外，您可以指定<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>来傳遞至檔案的開啟程序的命令列引數的屬性值。 例如，如果您指定的文字編輯器應用程式中<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性，您可以使用<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>屬性來指定要開啟編輯器 中的文字檔。  
  
 標準輸入通常是鍵盤，而標準輸出和標準錯誤通常的螢幕。 不過，您可以使用<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>， <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>，和<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>屬性，讓從取得輸入，或傳回輸出到檔案或其他裝置的程序。 如果您使用<xref:System.Diagnostics.Process.StandardInput%2A>， <xref:System.Diagnostics.Process.StandardOutput%2A>，或<xref:System.Diagnostics.Process.StandardError%2A>屬性<xref:System.Diagnostics.Process>元件，您必須先設定對應的值上<xref:System.Diagnostics.ProcessStartInfo>屬性。 當您讀取或寫入資料流中，否則系統會擲回例外狀況。  
  
 設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性來指定是否使用作業系統 shell 來啟動處理序。 如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>設`false`、 新的處理序會繼承標準輸入、 輸出標準，和呼叫的標準錯誤資料流處理，除非<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>， <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>，或<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>屬性，分別設定為`true`. 
  
 您可以變更任何值<xref:System.Diagnostics.ProcessStartInfo>屬性在處理序啟動的時間。 啟動程序之後，變更這些值沒有任何作用。  
  
> [!NOTE]
>  這個類別包含在類別層級套用至所有成員的連結要求。 A<xref:System.Security.SecurityException>立即呼叫端沒有完全信任權限時，會擲回。 如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Diagnostics.ProcessStartInfo>類別，以啟動 Internet Explorer 中，提供做為目的地 Url<xref:System.Diagnostics.ProcessStartInfo>引數。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫成員<see cref="T:System.Diagnostics.ProcessStartInfo" />。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;[NIB： 具名使用權限集合](http://msdn.microsoft.com/library/08250d67-c99d-4ab0-8d2b-b0e12019f6e3): <see langword="FullTrust" />。</permission>
    <altmember cref="T:System.Diagnostics.Process" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.ProcessStartInfo" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>不指定用來啟動處理序的檔案名稱，初始化 <see cref="T:System.Diagnostics.ProcessStartInfo" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須設定至少<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>之前啟動處理序的屬性。 任何應用程式或文件的檔案名稱。 在此情況下，文件會定義為任何已開啟的檔案類型或預設與其相關聯的動作。 您可以為您的電腦檢視已登錄之檔案類型和其相關聯的應用程式，使用**資料夾選項**對話方塊中，這可透過作業系統。 **進階**通往對話方塊，顯示是否已註冊的特定檔案類型相關聯的開啟動作的按鈕。  
  
 （選擇性） 您也可以設定其他屬性，然後再開始此程序。 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性提供要採取的動作，例如"print"，在指定的檔案與<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>屬性提供一個方式來將命令列引數傳遞至檔案，系統會開啟它時。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">用來啟動處理序的應用程式或文件。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.ProcessStartInfo" /> 類別的新執行個體，並指定用來啟動處理序的檔案名稱 (例如應用程式或文件)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何應用程式或文件的檔案名稱。 在此情況下，文件會定義為任何已開啟的檔案類型或預設與其相關聯的動作。 您可以為您的電腦檢視已登錄之檔案類型和其相關聯的應用程式，使用**資料夾選項**對話方塊中，這可透過作業系統。 **進階**通往對話方塊，顯示是否已註冊的特定檔案類型相關聯的開啟動作的按鈕。  
  
 您可以變更<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性之後呼叫這個建構函式，在處理序啟動的時間。 啟動程序之後，變更這些值沒有任何作用。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProcessStartInfo (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, arguments As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ProcessStartInfo(System::String ^ fileName, System::String ^ arguments);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">用來啟動處理序的應用程式。</param>
        <param name="arguments">要在處理序啟動時傳遞至應用程式的命令列引數。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.ProcessStartInfo" /> 類別的新執行個體，並指定用來啟動處理序的應用程式檔案名稱，以及指定要傳遞至應用程式的命令列引數集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 任何應用程式或文件的檔案名稱。 在此情況下，文件會定義為任何已開啟的檔案類型或預設與其相關聯的動作。 您可以為您的電腦檢視已登錄之檔案類型和其相關聯的應用程式，使用**資料夾選項**對話方塊中，這可透過作業系統。 **進階**通往對話方塊，顯示是否已註冊的特定檔案類型相關聯的開啟動作的按鈕。  
  
 您可以變更<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>或<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>屬性之後呼叫這個建構函式，在處理序啟動的時間。 啟動程序之後，變更這些值沒有任何作用。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="ArgumentList">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; ArgumentList { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; ArgumentList" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ArgumentList" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArgumentList As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ ArgumentList { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arguments">
      <MemberSignature Language="C#" Value="public string Arguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Arguments" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Arguments" />
      <MemberSignature Language="VB.NET" Value="Public Property Arguments As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Arguments { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Command line arguments that will be passed to the application specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定啟動應用程式時要使用的命令列引數集。</summary>
        <value>單一字串，包含要傳遞至 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性中所指定之目標應用程式的引數。 預設為空字串 ("")。 在 Windows Vista 及較早版本的 Windows 作業系統上，加入處理序之完整路徑長度的引數長度必須小於 2080。 在 Windows 7 及更新版本中，長度必須小於 32699。  
  
 引數會由目標應用程式剖析及解譯，因此必須配合該應用程式的期望。 針對下列範例所示的 .NET 應用程式，空格會解譯為多個引數之間的分隔符號。 您必須以引號括住含有空格的單一引數，但這些引號不會傳送至目標應用程式。 在最後剖析之引數所包含的引號中，三重逸出 (Triple-Escape) 每個標記。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列第一個範例會建立一個小型應用程式 (argsecho.exe) 該 echos 其引數至主控台。 第二個範例會建立會叫用 argsecho.exe 示範不同的變化的引數 屬性的應用程式。  
  
 [!code-cpp[Process.Start_static#3](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#3)]
 [!code-csharp[Process.Start_static#3](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#3)]
 [!code-vb[Process.Start_static#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#3)]  
  
 [!code-cpp[Process.Start_static#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#2)]
 [!code-csharp[Process.Start_static#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#2)]
 [!code-vb[Process.Start_static#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNoWindow">
      <MemberSignature Language="C#" Value="public bool CreateNoWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CreateNoWindow" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.CreateNoWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property CreateNoWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CreateNoWindow { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to start the process without creating a new window to contain it.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示是否要在新視窗中啟動處理序。</summary>
        <value>
          如果應該啟動處理序而不建立要包含處理序的新視窗，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性是`true`或<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A>屬性不是`null`、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>屬性值會被忽略，建立新的視窗。  

 .NET 核心不支援直接在 unix 平台，包括 macOS 和 Linux 上建立的 windows。 在這類平台上，會忽略這個屬性。
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，識別在啟動處理序時要使用的網域。 如果此值為 <see langword="null" />，則必須以 UPN 格式指定 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 屬性。 </summary>
        <value>啟動處理序時要使用的 Active Directory 網域。 如果此值為 <see langword="null" />，則必須以 UPN 格式指定 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 屬性。 </value>
        <remarks>這個屬性主要是使用 Active Directory 的企業環境內的使用者感興趣。</remarks>
      </Docs>
    </Member>
    <Member MemberName="Environment">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; Environment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; Environment" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Environment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Environment As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ Environment { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得套用至這個處理序及其子處理序的環境變數。</summary>
        <value>泛型字典，包含套用至這個處理序及其子處理序的環境變數。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 環境變數包含檔的搜尋路徑、 暫存檔、 應用程式特定選項，以及其他類似的資訊的目錄。 雖然您無法直接設定<xref:System.Diagnostics.ProcessStartInfo.Environment%2A>屬性，您可以修改屬性所傳回之泛型字典。 例如，下列程式碼會加入 TempPath 環境變數： `myProcess.StartInfo.Environment.Add("TempPath", "C:\\Temp")`。  您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性`false`變更之後開始程序<xref:System.Diagnostics.ProcessStartInfo.Environment%2A>屬性。 如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`、<xref:System.InvalidOperationException>時擲回<xref:System.Diagnostics.Process.Start%2A>方法呼叫。  
  
 在.NET Framework 應用程式，使用<xref:System.Diagnostics.ProcessStartInfo.Environment%2A>屬性等同於使用<xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="EnvironmentVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.StringDictionary EnvironmentVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.StringDictionary EnvironmentVariables" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvironmentVariables As StringDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::StringDictionary ^ EnvironmentVariables { System::Collections::Specialized::StringDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StringDictionaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Set of environment variables that apply to this process and child processes.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.StringDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得檔案的搜尋路徑、暫存檔的目錄、應用程式特定選項和其他類似的資訊。</summary>
        <value>字串字典，提供適用於這個處理序和子處理序的環境變數。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然您無法設定<xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A>屬性，您可以修改<xref:System.Collections.Specialized.StringDictionary>屬性所傳回。 例如，下列程式碼會加入 TempPath 環境變數： `myProcess.StartInfo.EnvironmentVariables.Add("TempPath", "C:\\Temp")`。  您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性`false`變更之後開始程序<xref:System.Diagnostics.ProcessStartInfo.EnvironmentVariables%2A>屬性。 如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`、<xref:System.InvalidOperationException>時擲回<xref:System.Diagnostics.Process.Start%2A>方法呼叫。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialog">
      <MemberSignature Language="C#" Value="public bool ErrorDialog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ErrorDialog" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialog" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ErrorDialog { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to show an error dialog to the user if there is an error.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示是否要在無法啟動處理序時向使用者顯示錯誤對話方塊。</summary>
        <value>
          若要在處理序無法啟動時，錯誤對話方塊應該顯示在螢幕上，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 必須是`true`如果您想要設定<xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>至`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorDialogParentHandle">
      <MemberSignature Language="C#" Value="public IntPtr ErrorDialogParentHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ErrorDialogParentHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorDialogParentHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ErrorDialogParentHandle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗控制代碼，以便在無法啟動處理序而顯示錯誤對話方塊時使用。</summary>
        <value>因處理序啟動失敗而產生之錯誤對話方塊的控制代碼指標。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>是`true`、<xref:System.Diagnostics.ProcessStartInfo.ErrorDialogParentHandle%2A>屬性會指定父視窗會顯示對話方塊。 它是適合用來指定保留 [前方的應用程式] 對話方塊中的父系。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileName">
      <MemberSignature Language="C#" Value="public string FileName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.FileName" />
      <MemberSignature Language="VB.NET" Value="Public Property FileName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FileName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.StartFileNameEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the application, document or URL to start.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要啟動的應用程式或文件。</summary>
        <value>要啟動的應用程式名稱，或是與應用程式相關聯且具有可用預設開啟動作之檔案類型的文件名稱。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須設定至少<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>之前啟動處理序的屬性。 任何應用程式或文件的檔案名稱。 文件會定義任何已開啟的檔案類型或預設與其相關聯的動作。 您可以為您的電腦檢視已登錄之檔案類型和其相關聯的應用程式，使用**資料夾選項**對話方塊中，這可透過作業系統。 **進階**通往對話方塊，顯示是否已註冊的特定檔案類型相關聯的開啟動作的按鈕。  
  
 您可以使用的檔案類型的一組部分取決於值<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性。 如果<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`，您可以啟動任何文件，並執行檔案，例如列印、 作業與<xref:System.Diagnostics.Process>元件。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`false`，您就可以開始只可執行檔與<xref:System.Diagnostics.Process>元件。  
  
 您可以啟動 ClickOnce 應用程式設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>從中您原先安裝應用程式的位置 （例如，Web 位址） 的屬性。 無法啟動 ClickOnce 應用程式透過指定已安裝在硬碟上。  
  
   
  
## Examples  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUserProfile">
      <MemberSignature Language="C#" Value="public bool LoadUserProfile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadUserProfile" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.LoadUserProfile" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadUserProfile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadUserProfile { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示是否要從登錄載入 Windows 使用者設定檔。</summary>
        <value>
          如果應該載入 Windows 使用者設定檔，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用使用者名稱、 密碼和網域來啟動處理程序時，會參考這個屬性。  
  
 如果值為`true`，使用者的設定檔中`HKEY_USERS`載入登錄機碼。 載入設定檔可能會很費時。 因此，最好使用此值，您必須存取中的資訊時，才`HKEY_CURRENT_USER`登錄機碼。  
  
 在 Windows Server 2003 和 Windows 2000 中，設定檔之後卸載新處理序已終止，不論處理序已建立子處理程序。  
  
 在 Windows XP 中，設定檔之後的新處理序會卸載，則已建立的所有子處理序已都終止。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Password">
      <MemberSignature Language="C#" Value="public System.Security.SecureString Password { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.SecureString Password" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Password" />
      <MemberSignature Language="VB.NET" Value="Public Property Password As SecureString" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::SecureString ^ Password { System::Security::SecureString ^ get(); void set(System::Security::SecureString ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecureString</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定安全字串，其中包含啟動處理序時要使用的使用者密碼。</summary>
        <value>要在啟動處理序時使用的使用者密碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>必須設定屬性，如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A>所提供。 如果未設定的屬性，預設工作目錄。 %SYSTEMROOT%\system32  
  
> [!NOTE]
>  設定<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>，而<xref:System.Diagnostics.ProcessStartInfo.Password%2A>中的屬性<xref:System.Diagnostics.ProcessStartInfo>物件是以使用者認證啟動處理序的建議的做法。  
  
 A<xref:System.Security.SecureString>物件就像<xref:System.String>物件，因為它具有文字值。 不過，值<xref:System.Security.SecureString>物件會自動加密，直到您的應用程式將它標記為唯讀的而且可以從電腦記憶體中刪除您的應用程式或.NET Framework 記憶體回收行程可以修改它。  
  
 如需安全字串和濆爧髍孮密碼來設定這個屬性的範例的詳細資訊，請參閱<xref:System.Security.SecureString>類別。  
  
> [!NOTE]
>  如果您提供的值<xref:System.Diagnostics.ProcessStartInfo.Password%2A>屬性，<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性必須是`false`，或<xref:System.InvalidOperationException>就會擲回時<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>方法呼叫。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PasswordInClearText">
      <MemberSignature Language="C#" Value="public string PasswordInClearText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PasswordInClearText" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.PasswordInClearText" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordInClearText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PasswordInClearText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定啟動處理程序時使用之純文字格式的使用者密碼。</summary>
        <value>純文字格式的使用者密碼。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardError">
      <MemberSignature Language="C#" Value="public bool RedirectStandardError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardError { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process's error output is written to the Process instance's StandardError member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示應用程式的錯誤輸出是否寫入至 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</summary>
        <value>
          如果錯誤輸出應該寫入至 <see cref="P:System.Diagnostics.Process.StandardError" />，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.Process>將文字寫入至其標準錯誤資料流，通常會在主控台上顯示文字。 藉由重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流，您可以操作或隱藏的錯誤輸出的處理程序。 比方說，您可以篩選文字、 以不同的方式，將其格式化或將輸出寫入主控台和指定的記錄檔。  
  
> [!NOTE]
>  您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>至`false`如果您想要設定<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A>至`true`。 否則，讀取<xref:System.Diagnostics.Process.StandardError%2A>資料流擲回例外狀況。  
  
 重新導向<xref:System.Diagnostics.Process.StandardError%2A>同步或非同步方式，就可以讀取資料流。 這類方法<xref:System.IO.StreamReader.Read%2A>，<xref:System.IO.StreamReader.ReadLine%2A>和<xref:System.IO.StreamReader.ReadToEnd%2A>執行同步處理程序的錯誤輸出資料流上的讀取的作業。 這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。 這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。  
  
> [!NOTE]
>  正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以確保已清除輸出緩衝區。  
  
 同步讀取作業會讀取自呼叫端之間的相依性<xref:System.Diagnostics.Process.StandardError%2A>資料流及子處理序寫入該資料流。 這些相依性可能會導致死結狀況。 當呼叫端會從子處理序的重新導向資料流讀取時，它會相依於子系。 呼叫者會等待讀取作業，直到子寫入資料流，或關閉資料流。 時子處理序寫入資料不足，無法填滿其重新導向資料流，它會相依於父代。 子處理序等候下一個寫入作業之前從完整的資料流讀取的父系，或關閉資料流。 當呼叫端和子處理序等待對方來完成作業，且無法繼續時，就會導致死結狀態。 您可以評估呼叫端和子處理序之間的相依性，以避免死結。  
  
 例如，下列 C# 程式碼會示範如何從重新導向資料流讀取，並等候子處理序結束。  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況呼叫`p.StandardError.ReadToEnd`之前`p.WaitForExit`。 如果父處理呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿重新導向資料流。 父處理序會無限期地等候子處理序結束。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。 例如，下列 C# 程式碼會執行兩個資料流上的讀取的作業。  
  
```csharp  
// Do not perform a synchronous read to the end of both  
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況執行非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 如果父處理序的呼叫就會導致死結狀態`p.StandardOutput.ReadToEnd`後面`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的錯誤資料流。 父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 若要避免這些相依性和其潛在的死結，您可以使用非同步讀取的作業。 或者，您可以藉由建立兩個執行緒，並讀取每個個別執行緒上的資料流的輸出，避免發生死結狀況。  
  
   
  
## Examples  
 下列範例會使用`net use`命令搭配對應的網路資源的使用者提供的引數。 然後會讀取 net 命令標準錯誤資料流，並寫入至主控台。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardInput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardInput { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process command input is read from the Process instance's StandardInput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示應用程式的輸入是否從 <see cref="P:System.Diagnostics.Process.StandardInput" /> 資料流讀取。</summary>
        <value>
          如果應該從 <see cref="P:System.Diagnostics.Process.StandardInput" /> 讀取輸入，則為 <see langword="true" />，否則為<see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>可以讀取其標準輸入資料流，一般是鍵盤輸入的文字。 藉由重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流，您可以透過程式設計方式指定處理程序的輸入。 例如，而不是使用鍵盤輸入，您可以提供指定之檔案的內容中的文字或另一個應用程式的輸出。  
  
> [!NOTE]
>  您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>至`false`如果您想要設定<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A>至`true`。 否則，寫入<xref:System.Diagnostics.Process.StandardInput%2A>資料流擲回例外狀況。  
  
   
  
## Examples  
 下列範例說明如何將重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流的處理程序。 `sort`命令是主控台應用程式讀取及排序文字輸入。  
  
 此範例會啟動`sort`命令與重新導向輸入。 接著會提示使用者輸入的文字，並傳遞要文字`sort`透過重新導向處理序<xref:System.Diagnostics.Process.StandardInput%2A>資料流。 `sort`結果會顯示主控台使用者。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
      </Docs>
    </Member>
    <Member MemberName="RedirectStandardOutput">
      <MemberSignature Language="C#" Value="public bool RedirectStandardOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RedirectStandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectStandardOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RedirectStandardOutput { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process output is written to the Process instance's StandardOutput member.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示應用程式的文字輸出是否寫入至 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</summary>
        <value>
          如果輸出應該寫入至 <see cref="P:System.Diagnostics.Process.StandardOutput" />，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.Process>將文字寫入至其標準的資料流，通常會在主控台上顯示文字。 藉由設定<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>至`true`重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，您可以操作或隱藏程序的輸出。 比方說，您可以篩選文字、 以不同的方式，將其格式化或將輸出寫入主控台和指定的記錄檔。  
  
> [!NOTE]
>  您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>至`false`如果您想要設定<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A>至`true`。 否則，讀取<xref:System.Diagnostics.Process.StandardOutput%2A>資料流擲回例外狀況。  
  
 重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>同步或非同步方式，就可以讀取資料流。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流上的同步讀取的作業。 這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 這個方法會啟用指定的事件處理常式 (請參閱<xref:System.Diagnostics.Process.OutputDataReceived>) 的資料流輸出並立即傳回給呼叫者，它可以執行其他工作時將資料流輸出導向至事件處理常式。  
  
> [!NOTE]
>  正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以確保已清除輸出緩衝區。  
  
 同步讀取作業會讀取自呼叫端之間的相依性<xref:System.Diagnostics.Process.StandardOutput%2A>資料流及子處理序寫入該資料流。 這些相依性可能會導致死結狀況。 當呼叫端會從子處理序的重新導向資料流讀取時，它會相依於子系。 呼叫者會等待讀取作業，直到子寫入資料流，或關閉資料流。 時子處理序寫入資料不足，無法填滿其重新導向資料流，它會相依於父代。 子處理序等候下一個寫入作業之前從完整的資料流讀取的父系，或關閉資料流。 當呼叫端和子處理序等待對方來完成作業，且無法繼續時，就會導致死結狀態。 您可以評估呼叫端和子處理序之間的相依性，以避免死結。  
  
 例如，下列 C# 程式碼會示範如何從重新導向資料流讀取，並等候子處理序結束。  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況呼叫`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。 如果父處理呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子處理序寫入足夠的文字，以填滿重新導向資料流。 父處理序會無限期地等候子處理序結束。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
 當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。 例如，下列 C# 程式碼會執行兩個資料流上的讀取的作業。  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況執行非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 如果父處理序的呼叫就會導致死結狀態`p.StandardOutput.ReadToEnd`後面`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的錯誤資料流。 父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 若要避免這些相依性和其潛在的死結，您可以使用非同步讀取的作業。 或者，您可以藉由建立兩個執行緒，並讀取每個個別執行緒上的資料流的輸出，避免發生死結狀況。  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
      </Docs>
    </Member>
    <Member MemberName="StandardErrorEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardErrorEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardErrorEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardErrorEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardErrorEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定錯誤輸出的慣用編碼。</summary>
        <value>物件，代表錯誤輸出的慣用編碼。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值<xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A>屬性是`null`，處理序會使用預設標準錯誤的錯誤輸出的編碼方式。 <xref:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding%2A>啟動處理程序之前，必須設定屬性。 設定這個屬性並不保證程序將使用指定的編碼。處理程序會使用它支援這些編碼方式。 應該測試應用程式，以決定支援的編碼方式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardInputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardInputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardInputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardInputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardInputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardInputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StandardOutputEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding StandardOutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding StandardOutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property StandardOutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ StandardOutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定標準輸出的慣用編碼。</summary>
        <value>物件，代表標準輸出的慣用編碼。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值<xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A>屬性是`null`，處理程序會使用預設標準輸出的編碼標準的輸出。 <xref:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding%2A>啟動處理程序之前，必須設定屬性。 設定這個屬性並不保證程序將使用指定的編碼方式。 應該測試應用程式，以判斷這個程序支援的編碼。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public string UserName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要在啟動處理序時使用的使用者名稱。 如果您使用 UPN 格式 <paramref name="user" />@<paramref name="DNS_domain_name" />，<see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> 屬性必須為 <see langword="null" />。</summary>
        <value>要在啟動處理序時使用的使用者名稱。 如果您使用 UPN 格式 <paramref name="user" />@<paramref name="DNS_domain_name" />，<see cref="P:System.Diagnostics.ProcessStartInfo.Domain" /> 屬性必須為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>必須設定屬性，如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A>所提供。 如果未設定的屬性，預設工作目錄。 %SYSTEMROOT%\system32  
  
 如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>屬性不是`null`或空字串，<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性必須是`false`，或<xref:System.InvalidOperationException>就會擲回時<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>方法呼叫。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseShellExecute">
      <MemberSignature Language="C#" Value="public bool UseShellExecute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseShellExecute" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" />
      <MemberSignature Language="VB.NET" Value="Public Property UseShellExecute As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseShellExecute { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether to use the operating system shell to start the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示是否要使用作業系統 Shell 來啟動處理序。</summary>
        <value>
          如果在啟動處理序時使用 Shell，則為 <see langword="true" />，如果處理序應直接從可執行檔建立，則為 <see langword="false" />。 預設值是<see langword="true" />上.NET Framework 應用程式和<see langword="false" />.NET Core 應用程式上。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此屬性設定為`false`可讓您重新導向輸入、 輸出和錯誤資料流。  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 必須是`false`如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>屬性不是`null`或空字串，或<xref:System.InvalidOperationException>就會擲回時<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>方法呼叫。  
  
 當您使用作業系統 shell 來啟動處理序時，您可以開始 （即有一個預設開啟動作的可執行檔相關聯的任何已註冊的檔案類型） 的文件，然後在檔案執行作業，列印，例如使用<xref:System.Diagnostics.Process>物件。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`false`，您可以使用來啟動只可執行檔<xref:System.Diagnostics.Process>物件。  
  
> [!NOTE]
>  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 必須是`true`如果您設定<xref:System.Diagnostics.ProcessStartInfo.ErrorDialog%2A>屬性`true`。  
  
 <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>屬性具有不同行為的值而定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>屬性。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`、<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>屬性指定的可執行檔的位置。 如果<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>為空字串，它會假設目前的目錄，包含可執行檔。  
  
 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`false`、<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>屬性不用來尋找可執行檔。 相反地，它僅供處理程序已啟動且具有意義，只在新的處理序的內容。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`false`、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以是完整的路徑的可執行檔或簡單的可執行檔名稱，系統就會嘗試尋找在 PATH 環境變數所指定的資料夾中。  
  
   
  
## Examples  
 [!code-cpp[ProcessOneStream#1](~/samples/snippets/cpp/VS_Snippets_CLR/ProcessOneStream/CPP/stdstr.cpp#1)]
 [!code-csharp[ProcessOneStream#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessOneStream/CS/stdstr.cs#1)]
 [!code-vb[ProcessOneStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessOneStream/VB/stdstr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">嘗試在通用 Windows 平台 (UWP) App 上將值設定為 <see langword="true" />。</exception>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="Verb">
      <MemberSignature Language="C#" Value="public string Verb { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Verb" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verb" />
      <MemberSignature Language="VB.NET" Value="Public Property Verb As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Verb { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.VerbConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The verb to apply to the document specified by the FileName property.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定動詞命令，用於開啟 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性所指定的應用程式或文件時。</summary>
        <value>對處理序所開啟的檔案所要採取的動作。 預設值為空字串 ("")，表示不採取任何動作。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個副檔名有它自己的動詞，可以使用來取得集<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性。 例如，"`print`"動詞命令會列印使用指定的文件<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 可以指定預設的動詞命令使用空字串 ("")。 動詞命令的範例包括 「 編輯 」、 「 開啟 」、 「 OpenAsReadOnly"、"Print"和 「 Printto"。 您應該使用的動詞命令所傳回集合中出現的動詞<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性。  
  
 當您使用<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性，當您設定的值時，必須包含副檔名<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 檔案名稱不需要有副檔名，如果您手動輸入的值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會使用指定的動詞命令和檔案名稱，以啟動新處理序。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性。  
  
 [!code-csharp[ProcessVerbs_Diagnostics#4](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#4)]
 [!code-vb[ProcessVerbs_Diagnostics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      </Docs>
    </Member>
    <Member MemberName="Verbs">
      <MemberSignature Language="C#" Value="public string[] Verbs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Verbs" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.Verbs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Verbs As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Verbs { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動詞命令集，這個動詞命令集與 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性所指定的檔案類型相關聯。</summary>
        <value>動作，系統可以將這個動作套用至 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性所指定的檔案。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性可讓您判斷可與所指定的檔案的動詞<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 您可以設定<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性設為值的集合中的任何指令動詞。 動詞命令的範例包括 「 編輯 」、 「 開啟 」、 「 OpenAsReadOnly"、"Print"和 「 Printto"。  
  
 當您使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性，當您設定的值時，必須包含副檔名<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 檔案名稱副檔名會決定可能的動詞命令集。  
  
   
  
## Examples  
 下列程式碼範例會顯示所選的檔案名稱定義的動詞命令。 如果使用者選取其中一個已定義的指令動詞，此範例會啟動新的處理序，使用選取的指令動詞和輸入的檔案名稱。  
  
 [!code-csharp[ProcessVerbs_Diagnostics#3](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessVerbs_Diagnostics/CS/source.cs#3)]
 [!code-vb[ProcessVerbs_Diagnostics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessVerbs_Diagnostics/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.Verb" />
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessWindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessWindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As ProcessWindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessWindowStyle WindowStyle { System::Diagnostics::ProcessWindowStyle get(); void set(System::Diagnostics::ProcessWindowStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("How the main window should be created when the process starts.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessWindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定視窗狀態，用於啟動處理序時。</summary>
        <value>其中一個列舉值，表示處理序是在最大化視窗、最小化視窗、一般 (不是最大化也不是最小化) 視窗或不可見視窗中啟動。 預設值為 <see langword="Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">視窗樣式不是其中一個 <see cref="T:System.Diagnostics.ProcessWindowStyle" /> 列舉型別 (Enumeration) 成員。</exception>
      </Docs>
    </Member>
    <Member MemberName="WorkingDirectory">
      <MemberSignature Language="C#" Value="public string WorkingDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WorkingDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessStartInfo.WorkingDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkingDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WorkingDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.WorkingDirectoryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The initial working directory for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性為 <see langword="false" /> 時，取得或設定要啟動之處理序的工作目錄。 當 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 為 <see langword="true" /> 時，取得或設定包含要啟動之處理序的目錄。</summary>
        <value>如果 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 為 <see langword="true" />，則為包含要啟動之處理序的目錄完整名稱。 當 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性為 <see langword="false" /> 時，則為要啟動之處理序的工作目錄。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>必須設定屬性，如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A>所提供。 如果未設定的屬性，預設工作目錄。 %SYSTEMROOT%\system32  
  
 如果目錄已經系統 path 變數的一部分，您不必重複此屬性中的目錄位置。  
  
 <xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>屬性具有不同行為時<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`比<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`false`。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`、<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>屬性指定的可執行檔的位置。 如果<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>為空字串，包含可執行檔了解目前的目錄。  
  
> [!NOTE]
>  當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`，工作目錄的應用程式的啟動可執行檔也是可執行檔的工作目錄。  
  
 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`false`、<xref:System.Diagnostics.ProcessStartInfo.WorkingDirectory%2A>屬性不用來尋找可執行檔。 相反地，其值適用於會啟動，才有意義的新處理序內容中的程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>