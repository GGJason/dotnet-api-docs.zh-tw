<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2145a11bbb9faa94763035b22147eede6d4adee" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30400602" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供與 Windows 事件記錄檔的互動。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> 可讓您存取或自訂 Windows 事件記錄檔，它會記錄重要的軟體或硬體事件的相關資訊。 使用<xref:System.Diagnostics.EventLog>，您可以從現有的記錄檔讀取、 寫入記錄檔中的項目，建立或刪除事件來源、 刪除記錄檔，以及回應記錄項目。 建立事件來源時，您也可以建立新的記錄檔。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 除了提供個別的事件記錄檔和其項目，存取<xref:System.Diagnostics.EventLog>類別可讓您存取的所有事件記錄檔集合。 您可以使用`static`成員<xref:System.Diagnostics.EventLog>若要刪除記錄檔，取得記錄清單、 建立或刪除來源，或判斷電腦是否已包含特定的來源。  
  
 有三個預設事件記錄檔： 應用程式、 系統及安全性。 安全性記錄檔為唯讀。 其他應用程式和服務安裝，例如 Active Directory 中，可能會有額外的事件記錄檔。  
  
 使用時，有一些安全性考量<xref:System.Diagnostics.EventLog>類別。 <xref:System.Diagnostics.EventLog> 需要<xref:System.Diagnostics.EventLogPermission>的.NET Framework 2.0 和更新版本中中的特定動作或.NET Framework 1.0 和 1.1 版中的完全信任權限。 我們建議最好讓<xref:System.Diagnostics.EventLogPermission>授與部分信任程式碼。  您應該永遠不會傳遞任何事件記錄檔物件，包括<xref:System.Diagnostics.EventLogEntryCollection>和<xref:System.Diagnostics.EventLogEntry>較不受信任的程式碼的物件。 例如，建立<xref:System.Diagnostics.EventLog>物件、 撰寫一個項目，然後再將傳遞<xref:System.Diagnostics.EventLog>部分信任程式碼的物件可以建立安全性問題，因為能夠讀取和寫入事件記錄檔可讓程式碼來執行動作，例如發行事件記錄檔訊息，另一個應用程式的名稱。  
  
 從 Windows Vista 開始，使用者帳戶控制 (UAC) 會判斷使用者的認證。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的認證從標準使用者提高為系統管理員。 您可以開啟應用程式的捷徑功能表啟動應用程式時 （如果您使用滑鼠，以滑鼠右鍵按一下應用程式圖示），並指出您想要以系統管理員身分執行。  
  
 您可以使用<xref:System.Diagnostics.EventLog>若要建立自訂的事件記錄檔，您可以透過伺服器檢視的 事件檢視器。 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>方法，以顯示事件檢視器中的事件記錄檔的當地語系化的名稱。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法以設定事件記錄檔的行為，當它在達到最大記錄檔大小。  
  
 若要從事件記錄檔讀取，指定記錄檔名稱 (<xref:System.Diagnostics.EventLog.Log%2A>屬性) 和伺服器電腦名稱 (<xref:System.Diagnostics.EventLog.MachineName%2A>事件記錄檔的屬性。 如果您未指定伺服器的電腦名稱，在本機電腦 」。 」，會假設。 不需要指定事件來源 (<xref:System.Diagnostics.EventLog.Source%2A>屬性)，因為來源是只有需要寫入記錄檔。 <xref:System.Diagnostics.EventLog.Entries%2A>屬性會自動填入的項目事件記錄檔的清單。  
  
 若要寫入事件記錄檔，指定或建立事件來源 (<xref:System.Diagnostics.EventLog.Source%2A>屬性)。 您必須建立新的事件來源電腦上具有系統管理認證。 事件來源使用，註冊您的應用程式事件記錄檔項目的有效來源。 您可以使用事件來源寫入一次只能有一個記錄。 <xref:System.Diagnostics.EventLog.Source%2A>屬性可以是隨機的任何字串，但必須是相異的電腦上的其他來源的名稱。 事件來源通常是應用程式或另一個的識別字串的名稱。 嘗試建立重複<xref:System.Diagnostics.EventLog.Source%2A>值擲回例外狀況。 不過，單一的事件記錄檔可以與多個來源產生關聯。  
  
 如果與相關聯的事件記錄檔的事件來源<xref:System.Diagnostics.EventLog>執行個體不存在，則建立新的事件來源。 若要建立事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理認證。  
  
 這是因為必須搜尋所有的事件記錄檔，包括安全性記錄檔，以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。  
  
> [!IMPORTANT]
>  使用具名的 mutex，建立或刪除事件來源時，需要同步處理的基礎程式碼。 如果高特殊權限的應用程式鎖定具名的 mutex，嘗試建立或刪除事件來源會導致應用程式停止回應，直到釋放鎖定為止。 若要避免這個問題，永遠不會授與<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>不受信任的程式碼的權限。 此外，<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>權限可能會允許略過其他使用權限，以及應該只授與高度信任的程式碼。  
  
 應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。 如果您沒有明確設定<xref:System.Diagnostics.EventLog.Log%2A>屬性、 事件記錄檔預設值為應用程式記錄檔。  
  
> [!NOTE]
>  沒有要保護應用程式做為任何已註冊的來源寫入項目。  如果應用程式授與<xref:System.Diagnostics.EventLogPermissionAccess.Write>權限，它可以寫入事件的任何有效的來源電腦上註冊。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法將事件寫入事件記錄檔。 您必須指定事件來源寫入事件。您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統沒有重新整理其事件來源的清單，而且您嘗試要寫入的事件，該新的來源寫入作業將會失敗。 您可以使用設定新的來源<xref:System.Diagnostics.EventLogInstaller>物件或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理認證。  
  
 只有一個事件記錄檔可以寫入每個來源一次。不過，您的應用程式可以使用多個來源來寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔案。 若要變更現有來源的設定詳細資料，您必須刪除來源，並再建立使用新的設定。 如果其他應用程式或元件使用現有的來源，建立新的來源與更新的組態，而不是刪除現有的來源。  
  
 您可以向事件來源的當地語系化資源的事件類別目錄和訊息字串。 您的應用程式可以使用資源識別項，而不是指定實際的字串值寫入事件記錄檔項目。 請參閱<xref:System.Diagnostics.EventLogInstaller>和<xref:System.Diagnostics.EventSourceCreationData>設定您的來源的資源檔的相關資訊的類別。  
  
 如果您的應用程式會將字串值，直接寫入事件記錄檔，您不必設定資源的來源檔案內容。 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 當寫入事件時，至少必須指定訊息字串或訊息字串的資源識別項。 其他屬性是選擇性的。 選擇性的事件設定的範例包括下列各項：  
  
-   您可以設定<xref:System.Diagnostics.EventLogEntryType>指定 事件檢視器顯示之項目的圖示。  
  
-   如果您的應用程式使用類別來進行篩選的事件，您可以指定事件的類別識別項。  
  
-   如果您想要將其他資訊與給定的事件產生關聯，您可以將二進位資料附加至您的事件項目中。  
  
> [!IMPORTANT]
>  事件記錄會耗用磁碟空間、 處理器時間，以及其他系統資源。 請務必記錄重要的資訊。 我們建議您將事件記錄檔呼叫放在錯誤路徑，而不是主要的程式碼的路徑中，因此它們不效能產生負面影響。  
  
 如需執行個體的初始屬性值的清單<xref:System.Diagnostics.EventLog>，請參閱<xref:System.Diagnostics.EventLog.%23ctor%2A>建構函式。  
  
   
  
## Examples  
 下列範例會建立事件來源`MySource`它不存在，並將項目寫入事件記錄檔`MyNewLog`。  
  
> [!NOTE]
>  從 Windows Vista 開始，您必須以系統管理員身分執行此應用程式。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 不讓執行個體和任何記錄檔產生關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>執行個體。 如果您只讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔，您也可以指定只有<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|在本機電腦 ("。")。|  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果它不存在，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">本機電腦上的記錄檔名稱。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 讓執行個體與本機電腦上的記錄檔產生關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載設定<xref:System.Diagnostics.EventLog.Log%2A>屬性`logName`參數。 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>執行個體。 如果您只讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔，您也可以指定只有<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。 這個建構函式的多載指定<xref:System.Diagnostics.EventLog.Log%2A>屬性，但是您可以變更此值之前讀取<xref:System.Diagnostics.EventLog.Entries%2A>屬性。  
  
 如果您指定在來源<xref:System.Diagnostics.EventLog.Source%2A>屬性是唯一的其他來源的電腦上，後續呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>不存在時，具有指定名稱，建立記錄檔。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 參數。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|在本機電腦 ("。")。|  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔 」 myNewLog 」，在本機電腦上的項目。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">記錄檔名稱為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">記錄檔名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定電腦上的記錄檔名稱。</param>
        <param name="machineName">記錄檔所在處的電腦。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 讓執行個體與指定電腦上的記錄檔產生關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載設定<xref:System.Diagnostics.EventLog.Log%2A>屬性`logName`參數和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性`machineName`參數。 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>。 如果您只讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔，您也可以指定只有<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。  
  
> [!NOTE]
>  這個建構函式的多載指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，但您可以變更之前讀取<xref:System.Diagnostics.EventLog.Entries%2A>屬性。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 參數。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 參數。|  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔 」 myNewLog"，"myServer"的電腦上的項目。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">記錄檔名稱為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">記錄檔名稱無效。  
  
 -或-  
  
 電腦名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定電腦上的記錄檔名稱</param>
        <param name="machineName">記錄檔所在處的電腦。</param>
        <param name="source">事件記錄檔項目的來源。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 讓執行個體和指定電腦上的記錄檔產生關聯，並建立或指派指定的來源給 <see cref="T:System.Diagnostics.EventLog" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式設定<xref:System.Diagnostics.EventLog.Log%2A>屬性`logName`參數，<xref:System.Diagnostics.EventLog.MachineName%2A>屬性`machineName`參數，而<xref:System.Diagnostics.EventLog.Source%2A>屬性`source`參數。 <xref:System.Diagnostics.EventLog.Source%2A>時寫入事件記錄檔是必要屬性。 不過，如果您只讀取事件記錄檔，只<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>（只要伺服器事件記錄檔包含已與它相關聯的來源），都需要屬性。 如果您只讀取事件記錄檔，另一個多載建構函式可能會就夠了。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` 參數。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 參數。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 參數。|  
  
   
  
## Examples  
 下列範例會的項目寫入事件記錄檔時，「 MyNewLog"的本機電腦上，使用"MySource"的來源。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">記錄檔名稱為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">記錄檔名稱無效。  
  
 -或-  
  
 電腦名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始初始化表單或為另一個元件所使用的 <see cref="T:System.Diagnostics.EventLog" />。 初始化會於執行階段時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來開始初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.EventLog.EndInit%2A>方法結束初始化。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法會防止控制項完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> 已經初始化。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除事件記錄檔的所有項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件記錄檔會以判斷它們可以包含的項目數量的大小上限設定。 事件記錄檔已滿時，它會停止記錄新事件的資訊，或開始覆寫先前項目。 如果事件錄製隨即停止，您可以使用這個方法來清除現有的項目記錄，讓它再次啟動錄製事件。 您必須擁有清除事件記錄檔項目記錄檔所在電腦的系統管理員權限。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> 關閉事件記錄檔，釋出事件控制代碼，擷取新的讀取和寫入控制代碼，並重新開啟事件記錄檔。 在方法呼叫之後收到的事件不會清除和現有的事件。  
  
   
  
## Examples  
 下列範例會清除事件記錄檔。  
  
> [!CAUTION]
>  由於應用程式、 系統、 安全性和其他非自訂的記錄檔可能包含重要的資訊;請務必指定自訂的記錄檔，然後再執行這個程式碼範例。 這個範例會刪除自訂記錄檔`myNewLog`。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔未成功清除。  
  
 -或-  
  
 無法開啟記錄檔。 無法使用 Windows 錯誤碼。</exception>
        <exception cref="T:System.ArgumentException">沒有指定 <see cref="P:System.Diagnostics.EventLog.Log" /> 屬性的值。 確定記錄檔名稱不是空字串。</exception>
        <exception cref="T:System.InvalidOperationException">檔案不存在。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉事件記錄檔，並釋放讀取和寫入控制代碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A>方法呼叫由受保護<xref:System.ComponentModel.Component.Dispose%2A>方法。 您不需要叫用<xref:System.Diagnostics.EventLog.Close%2A>之前先呼叫<xref:System.ComponentModel.Component.Dispose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔的讀取控制代碼或寫入控制代碼未成功釋放。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立能夠將事件資訊寫入系統上的特定記錄檔的應用程式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">事件來源及其目標事件記錄檔的組態屬性。</param>
        <summary>使用事件來源及對應的事件記錄檔指定的組態屬性，建立有效的事件來源，以撰寫當地語系化的事件訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要設定新的來源項目寫入事件記錄檔，在本機電腦或遠端電腦上使用此多載。 您不需要使用這個方法來讀取事件記錄檔。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法會使用輸入`sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>，<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>和<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>屬性來建立新的來源和其相關聯的事件記錄檔的目標電腦上的登錄值。 新的來源名稱不符合現有的來源名稱或在目標電腦上的現有事件記錄檔名稱。 如果<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>屬性未設定、 應用程式事件記錄檔登錄來源。 如果<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>未設定來源登錄在本機電腦上。  
  
> [!NOTE]
>  若要建立事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是，必須搜尋所有的事件記錄檔，包括安全性、 以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  從 Windows Vista 開始，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定事件來源寫入事件。您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但寫入第一個項目之前，不會建立記錄檔。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由所附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>副檔名".evt"檔案名稱的屬性。  
  
 每個來源只有一個事件記錄檔只能寫入一次。不過，您的應用程式可以使用多個來源來寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔案。  
  
 您可以向事件來源當地語系化的資源檔的事件類別目錄和訊息字串。 您的應用程式可以寫入事件記錄項目使用的資源識別項，而非指定實際的字串。 事件檢視器會尋找並顯示目前的語言設定為基礎的當地語系化的資源檔中的對應字串使用的資源識別碼。 您可以登錄事件類別目錄、 訊息和參數插入字串中，個別的檔案，或您可以註冊相同的資源檔，所有的三種類型的字串。 使用<xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>， <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>， <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>，和<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>內容來設定要當地語系化的項目寫入事件記錄檔的來源。 如果您的應用程式會將字串值，直接寫入事件記錄檔，您不需要設定這些屬性。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有來源的設定詳細資料，您必須刪除來源，並再建立使用新的設定。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不會刪除現有的來源建立新的來源。  
  
> [!NOTE]
>  如果來源有設定事件記錄檔，並重新設定為另一個事件記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會判斷事件來源是否命名`SampleApplicationSource`註冊本機電腦上。 如果事件來源不存在，此範例會設定為來源的訊息資源檔，並建立新的事件來源。 最後，範例會設定事件記錄檔，使用中的資源識別碼值的當地語系化的顯示名稱`DisplayNameMsgId`和中的資源檔案路徑`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 此範例會使用下列的訊息文字檔案，內建資源程式庫 EventLogMsgs.dll。 訊息文字檔案是建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。 具體而言，資源識別碼 5001 定義事件記錄檔的當地語系化名稱。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在 <paramref name="sourceData" /> 中指定的電腦名稱無效。  
  
 \-或-  
  
 <paramref name="sourceData" /> 中所指定的來源名稱為 <see langword="null" />。  
  
 \-或-  
  
 在 <paramref name="sourceData" /> 中指定的記錄檔名稱無效。 事件記錄檔名稱必須由可列印字元組成，不得包括字元 '*'、'?' 或 '\\'。  
  
 \-或-  
  
 在 <paramref name="sourceData" /> 中指定的記錄檔名稱無效，無法建立使用者記錄檔。 事件記錄檔名稱 AppEvent、SysEvent 和 SecEvent 會保留供系統使用。  
  
 \-或-  
  
 此記錄檔名稱符合現有的事件來源名稱。  
  
 \-或-  
  
 指定 <paramref name="sourceData" /> 來源名稱產生的登錄機碼路徑長度超過 254 個字元。  
  
 \-或-  
  
 在 <paramref name="sourceData" /> 中指定的記錄檔名稱的前 8 個字元不是唯一的。  
  
 \-或-  
  
 已經登錄 <paramref name="sourceData" /> 中指定的來源名稱。  
  
 \-或-  
  
 在 <paramref name="sourceData" /> 中指定的來源名稱符合現有的事件記錄檔名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">應用程式登錄在本機電腦上的來源名稱。</param>
        <param name="logName">寫入來源項目的記錄檔名稱。 可能的值包括應用程式、系統或自訂事件記錄檔。</param>
        <summary>建立指定的來源名稱做為有效的事件來源，以便將項目寫入本機電腦上的記錄檔。 這個方法也可以在本機電腦上建立新的自訂記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載來建立自訂的記錄檔，或是建立並註冊<xref:System.Diagnostics.EventLog.Source%2A>至本機電腦上現有的記錄檔。  
  
 如果`logName`是`null`或空字串 ("") 當您呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，記錄檔預設為應用程式記錄檔。 如果記錄檔不存在本機電腦上，系統會建立自訂的記錄檔，並註冊您的應用程式做為<xref:System.Diagnostics.EventLog.Source%2A>為該記錄檔。  
  
> [!NOTE]
>  若要建立事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是，必須搜尋所有的事件記錄檔，包括安全性、 以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  在 Windows Vista (含) 以後版本中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 您只需要建立事件來源，如果您要寫入事件記錄檔。 之前將項目寫入事件記錄檔，您必須與事件記錄檔登錄事件來源為有效的事件來源。 當您撰寫的記錄項目時，系統會使用<xref:System.Diagnostics.EventLog.Source%2A>來尋找適當的記錄檔中要放置您的項目。 如果您正在閱讀事件記錄檔，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到本機電腦上的記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>當從記錄檔讀取本機電腦 ("。") 會假設。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定事件來源寫入事件。您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但寫入第一個項目之前，不會建立記錄檔。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由所附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>副檔名".evt"檔案名稱的屬性。  
  
 來源必須為本機電腦上唯一新的來源名稱不符合現有的來源名稱或現有的事件記錄檔名稱。 只有一個事件記錄檔可以寫入每個來源一次。不過，您的應用程式可以使用多個來源來寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔案。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有來源的設定詳細資料，您必須刪除來源，並再建立使用新的設定。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不會刪除現有的來源建立新的來源。  
  
> [!NOTE]
>  如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果它不存在，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 為空字串 ("") 或 <see langword="null" />  
  
 \-或-  
  
 <paramref name="logName" /> 不是有效的名稱。 事件記錄檔名稱必須由可列印字元組成，不得包括字元 '*'、'?' 或 '\\'。  
  
 \-或-  
  
 <paramref name="logName" /> 不適用於建立使用者記錄。 事件記錄檔名稱 AppEvent、SysEvent 和 SecEvent 會保留供系統使用。  
  
 \-或-  
  
 此記錄檔名稱符合現有的事件來源名稱。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。  
  
 \-或-  
  
 <paramref name="logName" /> 的前 8 個字元符合現有事件記錄檔名稱的前 8 個字元。  
  
 \-或-  
  
 來源因為已經存在於本機電腦上而無法登錄。  
  
 \-或-  
  
 來源名稱符合現有的事件記錄檔名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="logName">寫入來源項目的記錄檔名稱。 可能的值包括應用程式、系統或自訂事件記錄檔。 如果您未指定值，<c>logName</c> 會預設為應用程式。</param>
        <param name="machineName">要註冊這個事件來源的電腦名稱，或者表示本機電腦的 "."。</param>
        <summary>建立指定的來源名稱做為有效的事件來源，以便將項目寫入指定之電腦上的記錄檔。 這個方法也可以用來在指定的電腦上建立新的自訂記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載來建立自訂的記錄檔，或是建立並註冊<xref:System.Diagnostics.EventLog.Source%2A>至指定的電腦上現有的記錄檔。  
  
 如果`logName`是`null`或空字串 ("") 當您呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，記錄檔預設為應用程式記錄檔。 如果記錄檔不存在指定的電腦上，系統會建立自訂的記錄檔，並註冊您的應用程式做為<xref:System.Diagnostics.EventLog.Source%2A>為該記錄檔。  
  
 您只需要建立事件來源，如果您要寫入事件記錄檔。 之前將項目寫入事件記錄檔，您必須與事件記錄檔登錄事件來源為有效的事件來源。 當您撰寫的記錄項目時，系統會使用<xref:System.Diagnostics.EventLog.Source%2A>來尋找適當的記錄檔中要放置您的項目。 如果您正在閱讀事件記錄檔，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  若要建立事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是，必須搜尋所有的事件記錄檔，包括安全性、 以判斷事件來源是否為唯一。 在 Windows Vista 和更新版本，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  在 Windows Vista (含) 以後版本中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定事件來源寫入事件。您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但寫入第一個項目之前，不會建立記錄檔。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由所附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>副檔名".evt"檔案名稱的屬性。  
  
 來源必須為本機電腦上唯一新的來源名稱不符合現有的來源名稱或現有的事件記錄檔名稱。 只有一個事件記錄檔可以寫入每個來源一次。不過，您的應用程式可以使用多個來源來寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔案。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有來源的設定詳細資料，您必須刪除來源，並再建立使用新的設定。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不會刪除現有的來源建立新的來源。  
  
> [!NOTE]
>  如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`在電腦上`MyServer`，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 不是有效的電腦名稱。  
  
 \-或-  
  
 <paramref name="source" /> 為空字串 ("") 或 <see langword="null" />  
  
 \-或-  
  
 <paramref name="logName" /> 不是有效的名稱。 事件記錄檔名稱必須由可列印字元組成，不得包括字元 '*'、'?' 或 '\\'。  
  
 \-或-  
  
 <paramref name="logName" /> 不適用於建立使用者記錄。 事件記錄檔名稱 AppEvent、SysEvent 和 SecEvent 會保留供系統使用。  
  
 \-或-  
  
 此記錄檔名稱符合現有的事件來源名稱。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。  
  
 \-或-  
  
 <paramref name="logName" /> 的前 8 個字元符合指定電腦上現有事件記錄檔名稱的前 8 個字元。  
  
 \-或-  
  
 來源因為已經存在於指定的電腦上而無法登錄。  
  
 \-或-  
  
 來源名稱符合現有的事件來源名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移除記錄檔資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要刪除的記錄檔名稱。 可能的值包括：應用程式、安全性、系統和電腦上的任何自訂事件記錄檔。</param>
        <summary>將事件記錄檔從本機電腦移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在本機電腦上您想要刪除的記錄檔時，請使用這個方法。 您可以刪除任何記錄檔的電腦上，提供您有適當的登錄權限。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 移除所指定的記錄檔`logName`從本機電腦。 如果您想要刪除來源只登錄到記錄檔，請呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，因此您可以使用在本身的類別呼叫。 不需要建立的新執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>方法會先刪除保留的記錄檔內容的檔案。 接著會存取登錄，並移除已註冊為該記錄檔的所有事件來源。 如果您重新建立在稍後針對某個點的記錄，您應該註冊的事件來源同樣地，如果它們是可重複使用。 如果您不會登錄事件來源，而且其他使用者撰寫，事件來源，而不指定記錄檔名稱，將應用程式事件記錄檔中建立事件來源。 因此，應用程式，先前能夠寫入您刪除並重新建立記錄檔中的項目會寫入應用程式記錄檔相反地，因為它現在包含事件來源。  
  
> [!NOTE]
>  重新建立事件記錄檔可能很困難。 避免刪除任何系統建立的事件記錄檔，例如應用程式記錄檔。  
  
 刪除記錄檔，透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔登錄來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
   
  
## Examples  
 下列範例會刪除從本機電腦的記錄檔。 此範例會判斷由其來源的記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 然後再刪除自訂的記錄檔，請確定沒有其他來源寫入該記錄檔。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> 為空字串 ("") 或 <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。  
  
 \-或-  
  
 計數器不在指定的電腦上。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔未成功清除。  
  
 -或-  
  
 無法開啟記錄檔。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要刪除的記錄檔名稱。 可能的值包括：應用程式、安全性、系統和指定的電腦上的任何自訂事件記錄檔。</param>
        <param name="machineName">要刪除記錄檔的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>將事件記錄檔從指定的電腦移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在遠端電腦上您想要刪除的記錄檔時，請使用這個方法。 您可以刪除任何記錄檔的電腦上，提供您有適當的登錄權限。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 移除所指定的記錄檔`logName`所指定的電腦從`machineName`。 如果您想要刪除來源只登錄到記錄檔，請呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，因此您可以使用在本身的類別呼叫。 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 這個方法會先刪除保留的記錄檔內容的檔案。 接著會存取登錄，並移除已註冊為該記錄檔的所有事件來源。 如果您重新建立在稍後針對某個點的記錄，您應該註冊的事件來源同樣地，如果它們是可重複使用。 如果您不會登錄事件來源，而且其他使用者撰寫，事件來源，而不指定記錄檔名稱，將應用程式事件記錄檔中建立事件來源。 因此，應用程式，先前能夠寫入您刪除並重新建立記錄檔中的項目會寫入應用程式記錄檔相反地，因為它現在包含事件來源。  
  
> [!NOTE]
>  重新建立事件記錄檔可能很困難。 避免刪除任何系統建立的事件記錄檔，例如應用程式記錄檔。  
  
 刪除記錄檔，透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔登錄來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
   
  
## Examples  
 下列範例會刪除記錄檔，從指定的電腦。 此範例會判斷由其來源的記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 然後再刪除自訂的記錄檔，請確定沒有其他來源寫入該記錄檔。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> 為空字串 ("") 或 <see langword="null" />  
  
 \-或-  
  
 <paramref name="machineName" /> 不是有效的電腦名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。  
  
 \-或-  
  
 計數器不在指定的電腦上。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔未成功清除。  
  
 -或-  
  
 無法開啟記錄檔。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將應用程式的事件來源登錄從事件記錄檔移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">應用程式在事件記錄檔系統中登錄的名稱。</param>
        <summary>將事件來源登錄從本機電腦的事件記錄檔移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來移除註冊<xref:System.Diagnostics.EventLog.Source%2A>從本機電腦。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 存取本機電腦上的登錄，並移除您的應用程式做為有效的事件來源註冊。  
  
 如果您不再需要寫入該記錄檔項目，您可以為有效的事件來源移除您的元件。 例如，您可能會執行這如果您需要變更您的元件和一個記錄檔。 一次只有一個記錄檔登錄來源，因為變更記錄檔需要您移除目前的登錄。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 移除只登錄到記錄檔的來源。 如果您想要移除記錄檔本身，呼叫<xref:System.Diagnostics.EventLog.Delete%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，因此您可以使用在本身的類別呼叫。 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 刪除記錄檔，透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔登錄來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
> [!NOTE]
>  如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會從本機電腦刪除的來源。 此範例會決定其來源的記錄檔，然後再刪除記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 然後再刪除自訂的記錄檔，請確定沒有其他來源寫入該記錄檔。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">本機電腦的登錄中沒有 <paramref name="source" /> 參數。  
  
 \-或-  
  
 您沒有事件記錄檔登錄機碼的寫入權限。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">應用程式在事件記錄檔系統中登錄的名稱。</param>
        <param name="machineName">要移除登錄的電腦名稱，或者表示本機電腦的 "."。</param>
        <summary>將應用程式的事件來源登錄從指定的電腦移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要移除註冊使用此多載<xref:System.Diagnostics.EventLog.Source%2A>從遠端電腦。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 存取所指定的電腦上的登錄`machineName`，並移除您的應用程式做為有效的事件來源註冊。  
  
 如果您不再需要寫入該記錄檔項目，您可以為有效的事件來源移除您的元件。 例如，您可能會執行這如果您需要變更您的元件和一個記錄檔。 一次只有一個記錄檔登錄來源，因為變更記錄檔需要您移除目前的登錄。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 移除只登錄到記錄檔的來源。 如果您想要移除記錄檔本身，呼叫<xref:System.Diagnostics.EventLog.Delete%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，因此您可以使用在本身的類別呼叫。 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 刪除記錄檔，透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔登錄來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
> [!NOTE]
>  如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會從指定的電腦刪除的來源。 此範例會決定其來源的記錄檔，然後再刪除記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 然後再刪除自訂的記錄檔，請確定沒有其他來源寫入該記錄檔。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數是無效的。  
  
 \-或-  
  
 指定電腦的登錄中沒有 <paramref name="source" /> 參數。  
  
 \-或-  
  
 您沒有事件記錄檔登錄機碼的寫入權限。</exception>
        <exception cref="T:System.InvalidOperationException">
          無法刪除 <paramref name="source" />，因為在登錄中，<paramref name="source" /> 的父登錄機碼並未包含具有相同名稱的子機碼 (Subkey)。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Diagnostics.EventLog" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A> 叫用`Dispose`與`disposing`設`false`。  
  
 當`disposing`參數為 true，這個方法的任何 managed 物件所持有的資源全部釋出這個<xref:System.Diagnostics.EventLog>參考。 這個方法會叫用每個參考物件的 `Dispose()` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以被其他物件呼叫多次。 在覆寫<see langword="Dispose(Boolean)" />小心不要參考物件已處置過的早期呼叫中<see langword="Dispose" />。 如需有關如何實作<see langword="Dispose(Boolean)" />，請參閱[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 如需有關<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示 <see cref="T:System.Diagnostics.EventLog" /> 是否接收 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件通知。</summary>
        <value>
          如果 <see cref="T:System.Diagnostics.EventLog" /> 在項目寫入到記錄檔時接收通知，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>屬性會決定是否<xref:System.Diagnostics.EventLog>項目寫入記錄檔時引發事件。 若屬性是`true`，接收的元件<xref:System.Diagnostics.EventLog.EntryWritten>事件將會收到通知隨時將項目會寫入記錄檔中指定<xref:System.Diagnostics.EventLog.Log%2A>屬性。 如果<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>是`false`，不會引發事件。  
  
> [!NOTE]
>  只有當項目寫入本機電腦上，您可以接收事件通知。 您無法接收通知的遠端電腦上寫入的項目。  
  
   
  
## Examples  
 下列範例會處理<xref:System.Diagnostics.EventLog.EntryWritten>事件。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">事件記錄位於遠端電腦上。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束對表單或為另一個元件所使用之 <see cref="T:System.Diagnostics.EventLog" /> 的初始化。 初始化會於執行階段時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來結束初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.EventLog.BeginInit%2A>方法初始化開始。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法可防止控制項完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔的內容。</summary>
        <value>將項目保存在事件記錄檔中的 <see cref="T:System.Diagnostics.EventLogEntryCollection" />。 每個項目與 <see cref="T:System.Diagnostics.EventLogEntry" /> 類別的執行個體相關聯。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.Entries%2A>時讀取事件記錄檔的成員。  
  
 因為屬性是唯讀，則您無法修改項目，或寫入記錄檔使用<xref:System.Diagnostics.EventLog.Entries%2A>。 請改為指定<xref:System.Diagnostics.EventLog.Source%2A>呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>寫入新的記錄檔項目。 您可以使用<xref:System.Diagnostics.EventLog.Entries%2A>計數的事件記錄檔中的項目，並檢視每個<xref:System.Diagnostics.EventLogEntry>集合中。 使用索引<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>成員，才能擷取資訊的特定項目，例如<xref:System.Diagnostics.EventLogEntry.Message%2A>， <xref:System.Diagnostics.EventLogEntry.Category%2A>， <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>，或<xref:System.Diagnostics.EventLogEntry.EntryType%2A>。  
  
 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>只讀取記錄時。 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和<xref:System.Diagnostics.EventLog.MachineName%2A>（伺服器電腦名稱） 的屬性<xref:System.Diagnostics.EventLog>執行個體。 在任一情況下，<xref:System.Diagnostics.EventLog.Entries%2A>成員會自動填入的項目事件記錄檔的清單。 您可以讀取個別項目這份清單中選取適當的項目索引。  
  
 讀取和寫入記錄項目之間的一個重大差異是不需要明確地呼叫讀取的方法。 之後<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>都有指定，<xref:System.Diagnostics.EventLog.Entries%2A>自動填入屬性。 如果您變更的值<xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，<xref:System.Diagnostics.EventLog.Entries%2A>屬性重新讀取它的下一次擴展之後。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦中，"。"，會假設。  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔中，「 MyNewLog 」，在本機電腦上的項目。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於項目寫入至本機電腦上的事件記錄檔時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得事件通知，您必須設定<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>至`true`。 項目寫入本機電腦上時，您只可以接收事件通知。 您無法接收通知的遠端電腦上寫入的項目。  
  
 當您建立 <xref:System.Diagnostics.EventLog.EntryWritten> 委派 (Delegate) 時，就可以識別即將處理此事件的方法。 若要使事件與您的事件處理常式產生關聯，請將委派的執行個體 (Instance) 加入至事件。 每當事件發生時，直到您移除委派，會呼叫事件處理常式。 如需處理事件的委派的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 系統會回應至<xref:System.Diagnostics.EventLog.WriteEntry%2A>才發生至少六秒之前的最後一個寫入事件。 這表示您只會收到一個<xref:System.Diagnostics.EventLog.EntryWritten>六秒的間隔內的事件通知，即使多個事件記錄的變更發生。 如果您插入夠長的睡眠狀態 （約 10 秒） 之間間隔呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，您不太可能會遺失事件。 不過，如果寫入事件經常發生，您可能不會收到事件通知，直到下一個間隔。 一般而言，遺失的事件通知不會遺失，但延遲。  
  
   
  
## Examples  
 下列範例會處理項目寫入事件。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷指定的記錄檔是否存在。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜尋的記錄檔的名稱。 可能值包括：應用程式、安全性、系統、其他應用程式特定的記錄檔 (例如，與 Active Directory 關聯的記錄檔)，或者電腦上的任何自訂記錄檔。</param>
        <summary>判斷記錄檔是否存在於本機電腦上。</summary>
        <returns>
          如果記錄檔存在於本機電腦上，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要判斷本機電腦上是否有記錄檔中使用這個方法。 如果您想要判斷來源是否存在的本機電腦上，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 這個方法會存取登錄，因此您必須為本機電腦上擁有適當的登錄權限否則，查詢會傳回`false`。  
  
 因為您無法在相同電腦上讓新的記錄檔的現有記錄檔名稱，建立新的記錄檔之前先使用此方法來判斷是否指定`logName`已存在於本機電腦上。 `logName`參數不區分大小寫。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，所以它可以呼叫此類別本身。 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName 是 <see langword="null" /> 或者是空值。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜尋的記錄檔。 可能值包括：應用程式、安全性、系統、其他應用程式特定的記錄檔 (例如，與 Active Directory 關聯的記錄檔)，或者電腦上的任何自訂記錄檔。</param>
        <param name="machineName">要在其上搜尋記錄檔的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>判斷記錄檔是否存在於指定的電腦上。</summary>
        <returns>
          如果記錄檔存在於指定的電腦上，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要判斷遠端電腦上是否有記錄檔中使用這個方法。 如果您想要判斷來源是否存在的遠端電腦上，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 這個方法會存取登錄，因此您必須為指定電腦上擁有適當的登錄權限否則，查詢會傳回`false`。  
  
 因為您無法在相同電腦上讓新的記錄檔的現有記錄檔名稱，建立新的記錄檔之前使用這個方法來判斷是否有一個具有指定`logName`已存在於所指定的伺服器上`machineName`參數。 `logName`和`machineName`參數不區分大小寫。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，所以它可以呼叫此類別本身。 不需要建立的新執行個體<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數是無效的格式。 確認要搜尋的電腦採用的適合的語法。  
  
 -或-  
  
 <paramref name="logName" /> 是 <see langword="null" /> 或者是空值。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立事件記錄檔的陣列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>搜尋本機電腦上的所有事件記錄檔，並建立含有清單的 <see cref="T:System.Diagnostics.EventLog" /> 物件陣列。</summary>
        <returns>表示本機電腦上記錄檔的類型 <see cref="T:System.Diagnostics.EventLog" /> 的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列<xref:System.Diagnostics.EventLog>物件是在本機電腦上的所有事件記錄檔的快照集時呼叫<xref:System.Diagnostics.EventLog.GetEventLogs%2A>進行。 這不是動態的集合，所以不會反映的刪除或建立的即時記錄檔。 您應該確認陣列中的記錄存在才能讀取或寫入其中。 陣列通常包括至少三個記錄檔： 應用程式、 系統及安全性。 如果您在本機電腦上建立的自訂記錄檔，它們會出現在陣列中。  
  
 若要擷取的事件記錄檔清單，您必須使用適當的登錄權限。 這些權限是相同的呼叫所需<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下列範例會列舉本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">您沒有讀取登錄的權限。  
  
 -或-  
  
 電腦上沒有事件記錄檔服務。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">要在其上搜尋事件記錄檔的電腦。</param>
        <summary>搜尋指定電腦上的所有事件記錄檔，並建立含有清單的 <see cref="T:System.Diagnostics.EventLog" /> 物件陣列。</summary>
        <returns>表示指定電腦上記錄檔的類型 <see cref="T:System.Diagnostics.EventLog" /> 的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列<xref:System.Diagnostics.EventLog>物件是所指定的電腦上的所有事件記錄檔的快照集`machineName`參數時呼叫<xref:System.Diagnostics.EventLog.GetEventLogs%2A>進行。 這不是動態的集合，所以不會反映的刪除或建立的即時記錄檔。 您應該確認陣列中的記錄存在才能讀取或寫入其中。 陣列通常包括至少三個記錄檔： 應用程式、 系統及安全性。 如果您指定的電腦上建立的自訂記錄檔，它們會出現在陣列中。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> 是`static`方法，所以它可以呼叫<xref:System.Diagnostics.EventLog>類別本身。 不需要建立的執行個體<xref:System.Diagnostics.EventLog>物件，讓方法的呼叫。  
  
 若要擷取的事件記錄檔清單，您必須使用適當的登錄權限。 這些權限是相同的呼叫所需<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下列範例會取得在電腦"myServer"上的記錄檔的清單。 然後，它會輸出每個記錄檔的名稱。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數是無效的電腦名稱。</exception>
        <exception cref="T:System.InvalidOperationException">您沒有讀取登錄的權限。  
  
 -或-  
  
 電腦上沒有事件記錄檔服務。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要讀取或寫入的事件記錄檔的名稱。</summary>
        <value>記錄檔的名稱。 可以是應用程式、系統、安全性或者自訂的記錄檔名稱。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，在伺服器上的三個記錄檔存在： 應用程式、 系統及安全性。 應用程式和服務使用的應用程式記錄檔。 裝置驅動程式會使用系統記錄檔。 開啟稽核時，系統會產生成功和失敗稽核事件安全性記錄檔中。 如果您有其他安裝，例如 Windows 伺服器上的 Active Directory 的應用程式可能會有其他預設的記錄檔。 此外，您可以建立自訂記錄檔的本機或遠端電腦上。 自訂記錄檔可協助組織更詳細的方式與您的元件會將事件寫入預設應用程式記錄檔中的項目。  
  
> [!NOTE]
>  記錄檔名稱會限制為 8 個字元。 根據系統 MyLogSample1 和 MyLogSample2 是相同的記錄。  
  
 如果您寫入事件記錄檔時，它是不夠的指定<xref:System.Diagnostics.EventLog.Log%2A>屬性。 您必須使<xref:System.Diagnostics.EventLog.Source%2A>以將它連接到特定的記錄檔事件記錄檔資源的屬性。 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>只讀取記錄檔，但事件來源時必須與伺服器的登錄中的事件記錄檔資源相關聯。 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和<xref:System.Diagnostics.EventLog.MachineName%2A>從中讀取的 （伺服器電腦名稱）。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 如果<xref:System.Diagnostics.EventLog.Source%2A>未指定屬性，呼叫<xref:System.Diagnostics.EventLog.Log%2A>傳回空字串，如果<xref:System.Diagnostics.EventLog.Log%2A>尚未明確設定 (藉由設定<xref:System.Diagnostics.EventLog.Log%2A>屬性，或透過建構函式)。 如果<xref:System.Diagnostics.EventLog.Source%2A>已指定，<xref:System.Diagnostics.EventLog.Log%2A>傳回該來源註冊所在的記錄檔的名稱。  
  
 一次只有一個記錄檔登錄來源。 如果<xref:System.Diagnostics.EventLog.Source%2A>的執行個體已設定屬性<xref:System.Diagnostics.EventLog>，您無法變更<xref:System.Diagnostics.EventLog.Log%2A>該屬性<xref:System.Diagnostics.EventLog>而不需要變更的值<xref:System.Diagnostics.EventLog.Source%2A>或呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一次。 如果您變更<xref:System.Diagnostics.EventLog.Log%2A>屬性之後<xref:System.Diagnostics.EventLog.Source%2A>屬性已設定，寫入記錄項目就會擲回例外狀況。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由所附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>副檔名".evt"檔案名稱的屬性。  
  
 您無法建立新的記錄檔使用<xref:System.Diagnostics.EventLog.Log%2A>屬性 （而未指定記錄檔的來源）。 您可以呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>、 傳入新的記錄檔名稱做為參數，然後再呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 不過，其目的通常是要建立 （和寫入項目） 新應用程式特定的記錄檔，或從現有的記錄檔讀取。  
  
 如果<xref:System.Diagnostics.EventLog.Log%2A>值變更，關閉事件記錄檔，且會釋放所有的事件控制代碼。  
  
> [!CAUTION]
>  如果您設定<xref:System.Diagnostics.EventLog.Log%2A>屬性不存在的記錄檔的名稱，系統會將附加<xref:System.Diagnostics.EventLog>應用程式記錄檔中，但不會警告您它正在使用您所指定的記錄。  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔中，「 NewEventLog 」，在本機電腦上的項目。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔的易記名稱。</summary>
        <value>名稱，表示系統的事件檢視器中的事件記錄檔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 Windows Vista 和更新版本，使用者沒有存取安全性記錄檔的權限。 如果您正在執行 Windows Vista 或更新版本做為使用者，您會收到<xref:System.Security.SecurityException>當您嘗試存取安全性記錄檔中事件的顯示名稱。  
>   
>  在 Windows Vista (含) 以後版本中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
   
  
## Examples  
 下列範例會列舉本機電腦上定義的事件記錄檔，並顯示<xref:System.Diagnostics.EventLog.LogDisplayName%2A>每個事件記錄檔。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="P:System.Diagnostics.EventLog.Log" /> 不存在這部電腦的登錄中。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">讀取指定的登錄機碼的功能。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">能夠存取指定的登錄鍵，如果它是遠端的索引鍵。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件來源的名稱。</param>
        <param name="machineName">要在其上搜尋記錄檔的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>取得登錄指定來源的記錄檔的名稱。</summary>
        <returns>與登錄中指定的來源關聯的記錄檔名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件來源會指出項目會記錄事件。 它通常是應用程式的名稱或名稱的子元件的應用程式，如果應用程式很大。 應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。  
  
 當您建立新的來源，可以只撰寫一個記錄檔一次，則系統會登錄事件記錄檔與您的應用程式項目的有效來源。 <xref:System.Diagnostics.EventLog.Source%2A>屬性可以是任何字串，但無法使用其他電腦上的來源名稱。 嘗試建立重複的<xref:System.Diagnostics.EventLog.Source%2A>值擲回例外狀況。 不過，單一的事件記錄檔可以有許多不同的來源寫入。  
  
   
  
## Examples  
 下列範例會從本機電腦刪除的來源。 此範例會決定其來源的記錄檔，然後再刪除記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 然後再刪除自訂的記錄檔，請確定沒有其他來源寫入該記錄檔。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要在其上讀取或寫入事件的電腦的名稱。</summary>
        <value>事件記錄檔所在處的伺服器名稱。 預設值是本機電腦 (".")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您寫入事件記錄檔，您必須使<xref:System.Diagnostics.EventLog.Source%2A>與您的事件記錄檔物件，將它連接到特定的記錄檔。 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>屬性只會讀取記錄時。 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和<xref:System.Diagnostics.EventLog.MachineName%2A>（伺服器電腦名稱）。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 一次只有一個記錄檔登錄來源。 如果<xref:System.Diagnostics.EventLog.Source%2A>的執行個體已設定屬性<xref:System.Diagnostics.EventLog>，您無法變更<xref:System.Diagnostics.EventLog.MachineName%2A>該屬性<xref:System.Diagnostics.EventLog>而不需要變更的值<xref:System.Diagnostics.EventLog.Source%2A>或呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一次。 如果您變更<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，<xref:System.Diagnostics.EventLog>關閉所有控制代碼，並附加記錄檔和新的電腦上的來源。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A>值不可為空字串。 若未明確設定，則預設為本機電腦 ("。")。  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔中，「 NewEventLog"，指定電腦上的項目。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">電腦名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定最大事件記錄檔大小 (以 KB 為單位)。</summary>
        <value>最大事件記錄檔大小 (以 KB 為單位)。 預設值為 512，表示最大記錄檔大小為 512 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>屬性表示事件記錄檔的大小限制。 當事件記錄檔到達大小限制，設定的<xref:System.Diagnostics.EventLog.OverflowAction%2A>值決定是否會捨棄新的項目，或新的項目是否覆寫較舊的項目。  
  
> [!NOTE]
>  這個屬性表示這個執行個體所代表的事件記錄檔的組態設定。 當事件記錄檔到達大小上限時，此屬性會指定作業系統如何處理新的項目寫入事件記錄檔已註冊的所有事件來源。  
  
   
  
## Examples  
 下列範例會列舉本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值小於 64 或大於 4194240，或者不是 64 的偶數倍數。</exception>
        <exception cref="T:System.InvalidOperationException">這個 <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的記錄檔名稱。  
  
 \-或-  
  
 無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔項目的保留天數。</summary>
        <value>保留事件記錄檔項目的天數。 預設值為 7。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>屬性可檢查事件記錄檔的目前設定。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>變更最小數目的事件記錄檔中的每個項目必須保留的天數。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值取決於設定的溢位行為的事件記錄檔。 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>，然後在<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值為 0。 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>，然後在<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值為-1。 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，然後在<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值小於或等於零，並代表的事件記錄檔項目的事件記錄檔已滿時保留的天數。  
  
 事件記錄檔達到大小限制時，才會發生溢位行為。 當<xref:System.Diagnostics.EventLog>具有其<xref:System.Diagnostics.EventLog.OverflowAction%2A>設<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，和事件記錄檔達到大小上限，則新的項目寫入只可以取代項目，其時間超過<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>期間。 保留的最小週期的事件項目時，適當的事件記錄檔會定期封存。 否則，就可能會遺失事件記錄檔達到限制時的新項目。 若要避免遺失新的事件資訊，請設定根據特定的事件記錄檔的封存排程事件的最小保留天數。  
  
   
  
## Examples  
 下列範例會列舉本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">將新的項目寫入事件記錄檔的溢位行為。</param>
        <param name="retentionDays">每一個事件記錄檔項目會保留的最小天數。 只有當 <c>action</c> 設定為 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> 時，才會使用這個參數。</param>
        <summary>當事件記錄檔到達最大檔案大小時，變更寫入新項目的已設定行為。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件記錄檔的溢位行為會指定要寫入的記錄檔已達到其最大檔案大小，新的項目時，會發生什麼事。  
  
> [!NOTE]
>  溢位行為在事件記錄檔達到檔案大小上限時，才會生效。 溢位行為不會影響新的項目寫入記錄檔可容納額外的事件記錄項目。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法會設定事件記錄檔的溢位行為。 <xref:System.Diagnostics.EventLog> 執行個體。 呼叫這個方法所指定的事件記錄檔後<xref:System.Diagnostics.EventLog.Log%2A>屬性，<xref:System.Diagnostics.EventLog.OverflowAction%2A>和<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>屬性值會反映新設定的溢位行為。  
  
> [!NOTE]
>  這個屬性表示這個執行個體所代表的事件記錄檔的組態設定。 當事件記錄檔到達大小上限時，此屬性會指定作業系統如何處理新的項目寫入事件記錄檔已註冊的所有事件來源。  
  
 設定`action`參數<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>表示新項目會覆寫舊的項目時<xref:System.Diagnostics.EventLog>達到最大值。 如果`action`參數設定為<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>、`retentionDays`參數值會被忽略。  
  
 設定`action`參數<xref:System.Diagnostics.OverflowAction.OverwriteOlder>來表示，每個新的項目會覆寫舊的項目時<xref:System.Diagnostics.EventLog>達到最大值。 指定在記錄檔中使用的事件必須保留的天數`retentionDays`參數。 新的項目不會覆寫的保留範圍內寫入的事件。  
  
 設定`action`參數<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>捨棄新的事件，當達到最大記錄檔大小。 如果`action`參數設定為<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>、`retentionDays`參數值會被忽略。  
  
> [!CAUTION]
>  將溢位原則設定為<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>指定事件記錄檔已滿時，就會捨棄新的項目。 如果您使用此設定，請確定事件記錄檔定期封存和清除，以避免達到其大小上限。  
  
   
  
## Examples  
 下列範例顯示針對指定的事件記錄檔中，設定的溢位原則，並允許使用者選取新的溢位原則設定事件記錄檔。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 不是有效的 <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> 小於 1 或大於 365。</exception>
        <exception cref="T:System.InvalidOperationException">這個 <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的記錄檔名稱。  
  
 \-或-  
  
 無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當事件記錄檔到達最大記錄檔大小時，取得儲存新項目的已設定行為。</summary>
        <value>
          <see cref="T:System.Diagnostics.OverflowAction" /> 值，指定當事件記錄檔到達最大記錄檔大小時，儲存新項目的已設定行為。 預設值為 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在新的事件會寫入事件記錄檔大小變大。 每個事件記錄檔已設定的最大大小的限制;<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>屬性會定義事件記錄檔大小所允許的 kb 數目上限。  
  
 使用<xref:System.Diagnostics.EventLog.OverflowAction%2A>來檢查事件記錄檔，在其大小上限設定溢位行為的屬性值。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法，以變更事件記錄檔的溢位行為。  
  
> [!NOTE]
>  溢位行為在事件記錄檔達到檔案大小上限時，才會生效。 溢位行為不會影響新的項目寫入記錄檔可容納額外的事件記錄項目。  
  
   
  
## Examples  
 下列範例會列舉本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">當地語系化資源檔的完整指定路徑。</param>
        <param name="resourceId">資源識別項，可為資源檔內的當地語系化字串編排索引。</param>
        <summary>指定事件記錄檔的當地語系化名稱，這會顯示在伺服器的 [事件檢視器] 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>登錄和自訂事件記錄檔的事件檢視器中顯示的當地語系化的名稱。  
  
 指定的資源識別碼必須對應到資源檔中定義的當地語系化字串。 事件檢視器會顯示使用當地語系化的字串和目前的文化特性設定的自訂事件記錄檔名稱。 例如，您可以定義多個資源檔中的不同文化特性的當地語系化的事件記錄檔名稱。 事件檢視器會顯示對應到目前使用者的文化特性設定當地語系化的字串。  
  
 如果事件檢視器無法從資源檔，載入當地語系化的字串，或如果沒有顯示名稱已註冊的事件記錄檔，事件檢視器顯示中定義的事件記錄檔名稱<xref:System.Diagnostics.EventLog.Log%2A>。  
  
> [!NOTE]
>  您不需要註冊預先定義的事件記錄檔的顯示名稱。 作業系統會註冊應用程式、 系統及安全性事件記錄檔的當地語系化的顯示名稱。  
  
   
  
## Examples  
 下列範例會判斷事件來源是否命名`SampleApplicationSource`註冊本機電腦上。 如果事件來源不存在，此範例會設定為來源的訊息資源檔，並建立新的事件來源。 最後，範例會設定事件記錄檔，使用中的資源識別碼值的當地語系化的顯示名稱`DisplayNameMsgId`和中的資源檔案路徑`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 此範例會使用下列的訊息文字檔案，內建資源程式庫 EventLogMsgs.dll。 訊息文字檔案是建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。 具體而言，資源識別碼 5001 定義事件記錄檔的當地語系化名稱。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個 <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的記錄檔名稱。  
  
 \-或-  
  
 無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">管理電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定寫入至事件記錄檔時登錄和使用的來源名稱。</summary>
        <value>這個名稱 (具有事件記錄檔)，被登錄為項目的來源。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件來源會指出項目會記錄事件。 它通常是應用程式的名稱或名稱的子元件的應用程式，如果應用程式很大。 應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。  
  
 您只需要指定事件來源，如果您要撰寫事件記錄檔。 之前將項目寫入事件記錄檔，您必須與事件記錄檔登錄事件來源為有效的事件來源。 當您撰寫的記錄項目時，系統會使用<xref:System.Diagnostics.EventLog.Source%2A>来尋找適當的記錄檔，在其中放置項目的屬性。 如果您正在閱讀事件記錄檔，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到本機電腦上的記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定事件來源寫入事件。您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但寫入第一個項目之前，不會建立記錄檔。  
  
 來源必須為本機電腦上唯一新的來源名稱不符合現有的來源名稱或現有的事件記錄檔名稱。 只有一個事件記錄檔可以寫入每個來源一次。不過，您的應用程式可以使用多個來源來寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔案。  
  
 如果您變更<xref:System.Diagnostics.EventLog.Source%2A>值<xref:System.Diagnostics.EventLog>來登錄它已關閉，且會釋放所有的事件控制代碼。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有來源的設定詳細資料，您必須刪除來源，並再建立使用新的設定。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不會刪除現有的來源建立新的來源。  
  
> [!NOTE]
>  如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果它不存在，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜尋指定事件來源的電腦的登錄。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件來源的名稱。</param>
        <summary>判斷事件來源是否登錄於本機電腦上。</summary>
        <returns>
          如果事件來源登錄於本機電腦上，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要判斷事件來源是否存在於本機電腦上使用這個方法。 如果您想要判斷記錄檔是否存在的本機電腦上，使用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 這個方法會存取登錄，因此您必須為本機電腦上擁有適當的登錄權限否則，<xref:System.Security.SecurityException>就會擲回。  
  
> [!NOTE]
>  若要搜尋的事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是，必須搜尋所有的事件記錄檔，包括安全性、 以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  從 Windows Vista 開始，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼會存取效能計數器，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
> [!NOTE]
>  服務正在執行下<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帳戶沒有執行這個方法所需的權限。 解決方法是檢查 事件來源是否存在於<xref:System.ServiceProcess.ServiceInstaller>，而且如果它不存在，安裝程式中建立的來源。  
  
 因為您無法讓新的來源的同一部電腦上現有的來源名稱，然後再嘗試使用這個方法來呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，確保來源所指定的名稱與`source`不存在本機電腦上。 `source`參數不區分大小寫。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果它不存在，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          找不到 <paramref name="source" />，但無法搜尋部分或全部的事件記錄檔。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件來源的名稱。</param>
        <param name="machineName">要在其上進行尋找的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>判斷事件來源是否登錄於指定的電腦上。</summary>
        <returns>
          如果事件來源註冊於指定的電腦上，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來判斷所指定的電腦上是否有事件來源`machineName`參數。 如果您想要判斷記錄檔是否存在於指定的電腦，使用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 這個方法會存取登錄，因為您必須指定伺服器上擁有適當的登錄權限否則，<xref:System.Security.SecurityException>就會擲回。  
  
> [!NOTE]
>  若要搜尋的事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是，必須搜尋所有的事件記錄檔，包括安全性、 以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  從 Windows Vista 開始，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼會存取效能計數器，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
> [!NOTE]
>  服務正在執行下<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帳戶沒有執行這個方法所需的權限。 解決方法是檢查 事件來源是否存在於<xref:System.ServiceProcess.ServiceInstaller>，而且如果它不存在，安裝程式中建立的來源。  
  
 因為您無法讓新的來源的同一部電腦上現有的來源名稱，然後再嘗試使用這個方法來呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，確保來源所指定的名稱與`source`不存在電腦上。 `source`和`machineName`參數不區分大小寫。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> 是`static`方法，所以它可以呼叫此類別本身。 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`在電腦上`MyServer`，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 為無效的電腦名稱。</exception>
        <exception cref="T:System.Security.SecurityException">
          找不到 <paramref name="source" />，但無法搜尋部分或全部的事件記錄檔。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定物件，其用於封送處理 (Marshal) 因為 <see cref="T:System.Diagnostics.EventLog" /> 項目寫入事件而發出的事件處理常式呼叫。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用來封送處理因為事件記錄檔上的 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件而發出的事件處理常式呼叫。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，方法處理<xref:System.Diagnostics.EventLog.EntryWritten>系統執行緒集區的執行緒上呼叫事件。 如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。  
  
 當<xref:System.Diagnostics.EventLog.EntryWritten>事件由 visual 的 Windows Form 的元件，例如按鈕，存取元件，透過系統執行緒集區可能無法運作，或可能會導致例外狀況處理。 避免這種設定<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>給 Windows Form 元件時，會導致處理方法<xref:System.Diagnostics.EventLog.EntryWritten>元件建立所在的相同執行緒上呼叫的事件。  
  
 如果<xref:System.Diagnostics.EventLog>內使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>會自動設定為包含的控制項<xref:System.Diagnostics.EventLog>。 例如，如果您將放置<xref:System.Diagnostics.EventLog>form1 設計工具上 (繼承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>屬性<xref:System.Diagnostics.EventLog>設為 Form1 的執行個體。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將項目寫入事件記錄檔中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <summary>將具有指定訊息文字的資訊類型項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來寫入事件記錄檔與此相關聯的資訊項目<xref:System.Diagnostics.EventLog>執行個體。 如果您想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，使用不同的多載的<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性您<xref:System.Diagnostics.EventLog>元件之前的項目寫入記錄檔。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統需要註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>屬性尚未設定在您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  所註冊的程序期間引發的錯誤時會產生許多上面所列的例外狀況<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果它不存在，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
 -或-  
  
 該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
 \-或-  
  
 來源已經登錄用於不同的事件記錄檔。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <summary>將具有指定訊息文字的錯誤、警告、資訊、成功稽核或失敗稽核項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來寫入指定的項目<xref:System.Diagnostics.EventLogEntryType>事件記錄檔。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性您<xref:System.Diagnostics.EventLog>元件之前的項目寫入記錄檔。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統需要註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>屬性尚未設定在您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況的註冊程序期間引發的錯誤所產生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
  
   
  
## Examples  
 下列範例會警告項目寫入事件記錄檔時，「 MyNewLog 」，在本機電腦上。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
 -或-  
  
 該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
 \-或-  
  
 來源已經登錄用於不同的事件記錄檔。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <summary>使用指定的登錄事件來源，將具有指定訊息文字的資訊類型項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法，將資訊項目寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 如果您想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，使用不同的多載的<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
>   
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果它不存在，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空白字串 ("")。  
  
 \-或-  
  
 <paramref name="source" /> 值為 <see langword="null" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <summary>將有指定訊息文字和應用程式定義的事件識別項的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`eventID`事件記錄檔。 `eventID`來源一起唯一識別的事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
 您可以指定事件的識別項，除了<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性您<xref:System.Diagnostics.EventLog>元件之前的項目寫入記錄檔。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統需要註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>屬性尚未設定在您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況的註冊程序期間引發的錯誤所產生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
 -或-  
  
 該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
 \-或-  
  
 來源已經登錄用於不同的事件記錄檔。  
  
 \-或-  
  
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <summary>用指定的登錄事件來源，將有指定訊息文字的錯誤、警告、資訊、成功稽核或失敗稽核項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來寫入指定的項目<xref:System.Diagnostics.EventLogEntryType>事件記錄檔中，已使用來源登錄為適當的記錄檔事件來源。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
  
   
  
## Examples  
 下列範例會警告項目寫入事件記錄檔時，「 MyNewLog 」，在本機電腦上。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空白字串 ("")。  
  
 \-或-  
  
 <paramref name="source" /> 值為 <see langword="null" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <summary>將具有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`category`事件記錄檔。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會顯示為 65526，-1 為 65535。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
 若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及在資源檔中，類別目錄字串數目使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 除了類別目錄中，您可以指定要寫入事件記錄檔事件的事件識別項。 事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性您<xref:System.Diagnostics.EventLog>元件之前的項目寫入記錄檔。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統需要註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>屬性尚未設定在您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況的註冊程序期間引發的錯誤所產生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
 -或-  
  
 該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
 \-或-  
  
 來源已經登錄用於不同的事件記錄檔。  
  
 \-或-  
  
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <summary>使用指定的登錄事件來源，將有指定訊息文字和應用程式定義的事件識別項的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`eventID`事件記錄檔中，已使用來源登錄為適當的記錄檔事件來源。 `eventID`，以及來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
 這個多載的事件識別項，除了的<xref:System.Diagnostics.EventLog.WriteEntry%2A>可讓您指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空白字串 ("")。  
  
 \-或-  
  
 <paramref name="source" /> 值為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <param name="rawData">保存與項目相關的二進位資料的位元組陣列。</param>
        <summary>將有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔，並將二進位資料附加到訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載將應用程式定義的事件特定資料寫入事件記錄檔。 事件檢視器不會解譯這項資料。它只能在組合的十六進位和文字格式顯示未經處理資料。 使用事件的特定資料謹慎使用，包括它只有在確定會很有用給偵錯問題。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描記錄檔，並建立報告，其中包含從特定的事件資料的資訊。  
  
 除了二進位資料，您可以指定應用程式定義的類別目錄和應用程式定義的事件識別項。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
> [!NOTE]
>  `category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會顯示為 65526，-1 為 65535。  
  
 若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及在資源檔中，類別目錄字串數目使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性您<xref:System.Diagnostics.EventLog>元件之前的項目寫入記錄檔。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統需要註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>屬性尚未設定在您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況的註冊程序期間引發的錯誤所產生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
 -或-  
  
 該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
 \-或-  
  
 來源已經登錄用於不同的事件記錄檔。  
  
 \-或-  
  
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <summary>使用指定的登錄事件來源，將有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔。 <paramref name="category" /> 可以讓事件檢視器用來篩選記錄檔中的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`category`事件記錄檔中，使用 已登錄為適當的記錄檔事件來源的來源。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會顯示為 65526，-1 為 65535。  
  
 若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及在資源檔中，類別目錄字串數目使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 除了類別目錄中，您可以指定要寫入事件記錄檔事件的事件識別項。 事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
>   
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空白字串 ("")。  
  
 \-或-  
  
 <paramref name="source" /> 值為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <param name="rawData">保存與項目相關的二進位資料的位元組陣列。</param>
        <summary>將有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔 (使用指定的登錄事件來源)，並將二進位資料附加到訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，將應用程式定義的事件特定資料寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 事件檢視器不會解譯這項資料。它只能在組合的十六進位和文字格式顯示未經處理資料。 謹慎使用; 使用特定的事件資料包含只有在確定會很有用。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描記錄檔，並建立報告，其中包含從特定的事件資料的資訊。  
  
 除了二進位資料，您可以指定應用程式定義的類別目錄和應用程式定義的事件識別項。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會出現為 65526，-1 為 65535。  
  
 若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及在資源檔中，類別目錄字串數目使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。  
>   
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空白字串 ("")。  
  
 \-或-  
  
 <paramref name="source" /> 值為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將當地語系化的事件項目寫入事件記錄檔。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>將當地語系化的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將當地語系化的項目寫入事件記錄檔中使用這個方法。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼來顯示的當地語系化的資源檔中的對應字串<xref:System.Diagnostics.EventLog.Source%2A>。 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。  
  
 輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性您<xref:System.Diagnostics.EventLog>元件之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，值`message`字串可能不是您預期如果遠端電腦未執行.NET Framework。 此外，`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
   
  
## Examples  
 下列範例會將兩個稽核事件記錄檔的項目`myNewLog`。 此範例會建立新的事件來源和新的事件記錄檔，如果它們尚不存在本機電腦上。 事件訊息文字會指定資源檔中使用的資源識別項。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 此範例會使用下列的訊息文字檔案，內建資源程式庫 EventLogMsgs.dll。 訊息文字檔案是建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
 -或-  
  
 該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
 \-或-  
  
 來源已經登錄用於不同的事件記錄檔。  
  
 \-或-  
  
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 <paramref name="values" /> 擁有超過 256 個項目。  
  
 \-或-  
  
 其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="data">保存與項目相關的二進位資料的位元組陣列。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>以指定的事件資料、訊息取代字串和相關聯的二進位資料來寫入事件記錄檔項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將當地語系化的項目與其他事件的特定資料寫入事件記錄檔中使用這個方法。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼來顯示的當地語系化的資源檔中的對應字串<xref:System.Diagnostics.EventLog.Source%2A>。 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。  
  
 輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。  
  
 指定二進位資料時必須提供其他詳細資料事件的事件。 例如，使用`data`參數來包含特定錯誤的資訊。 事件檢視器不會解譯相關聯的事件資料。它會顯示資料組合的十六進位和文字格式。 謹慎使用; 使用特定的事件資料包含只有在確定會很有用。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描事件記錄檔，並建立報告，其中包含從特定的事件資料的資訊。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性您<xref:System.Diagnostics.EventLog>元件之前使用的元件之前<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.WriteEvent%2A>，本機電腦 ("。") 會假設。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，值`message`字串可能不是您預期如果遠端電腦未執行.NET Framework。 此外，`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。  
  
   
  
## Examples  
 下列範例會將兩個稽核事件記錄檔的項目`myNewLog`。 此範例會建立新的事件來源和新的事件記錄檔，如果它們尚不存在本機電腦上。 事件訊息文字會指定資源檔中使用的資源識別項。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 此範例會使用下列的訊息文字檔案，內建資源程式庫 EventLogMsgs.dll。 訊息文字檔案是建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
 -或-  
  
 該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
 \-或-  
  
 來源已經登錄用於不同的事件記錄檔。  
  
 \-或-  
  
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 <paramref name="values" /> 擁有超過 256 個項目。  
  
 \-或-  
  
 其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">為指定電腦上的應用程式註冊的事件來源名稱。</param>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>以指定的事件資料、訊息取代字串，以及使用指定的已登錄事件來源，寫入事件記錄檔項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法將當地語系化的項目寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼，來顯示來源的當地語系化的資源檔中的對應字串。 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。  
  
 輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。  
  
 指定的來源必須先登錄事件記錄檔之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
   
  
## Examples  
 下列範例會參考事件項目和警告事件項目寫入現有的事件記錄檔。 事件訊息文字會指定資源檔中使用的資源識別項。 此範例假設對應的資源檔已經註冊來源。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 此範例會使用下列的訊息文字檔案，內建資源程式庫 EventLogMsgs.dll。 訊息文字檔案是建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空白字串 ("")。  
  
 \-或-  
  
 <paramref name="source" /> 值為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 <paramref name="values" /> 擁有超過 256 個項目。  
  
 \-或-  
  
 其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">為指定電腦上的應用程式註冊的事件來源名稱。</param>
        <param name="instance">
          <see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="data">保存與項目相關的二進位資料的位元組陣列。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>以指定的事件資料、訊息取代字串和相關聯的二進位資料，以及使用指定的已登錄事件來源，寫入事件記錄檔項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法將當地語系化的項目與其他事件的特定資料寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼，來顯示來源的當地語系化的資源檔中的對應字串。 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。  
  
 輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。  
  
 指定二進位資料時必須提供其他詳細資料事件的事件。 例如，使用`data`參數來包含特定錯誤的資訊。 事件檢視器不會解譯相關聯的事件資料。它會顯示資料組合的十六進位和文字格式。 謹慎使用; 使用特定的事件資料包含只有在確定會很有用。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描事件記錄檔，並建立報告，其中包含從特定的事件資料的資訊。  
  
 指定的來源必須先登錄事件記錄檔之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
   
  
## Examples  
 下列範例會參考事件項目和警告事件項目寫入現有的事件記錄檔。 事件訊息文字會指定資源檔中使用的資源識別項。 此範例假設對應的資源檔已經註冊來源。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 此範例會使用下列的訊息文字檔案，內建資源程式庫 EventLogMsgs.dll。 訊息文字檔案是建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空白字串 ("")。  
  
 \-或-  
  
 <paramref name="source" /> 值為 <see langword="null" />。  
  
 \-或-  
  
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
 \-或-  
  
 <paramref name="values" /> 擁有超過 256 個項目。  
  
 \-或-  
  
 其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
 \-或-  
  
 來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>