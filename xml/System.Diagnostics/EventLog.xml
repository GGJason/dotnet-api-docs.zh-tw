<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="417bf7d809505603f672181ab2b03cc736ef1c33" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395925" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供與 Windows 事件記錄檔的互動。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> 可讓您存取或自訂 Windows 事件記錄檔記錄重要的軟體或硬體事件的相關資訊。 使用<xref:System.Diagnostics.EventLog>，您可以從現有的記錄檔讀取、 寫入記錄檔中的項目、 建立或刪除事件來源、 刪除記錄檔，並回應記錄項目。 建立事件來源時，您也可以建立新的記錄檔。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 除了存取個別的事件記錄檔和其項目，<xref:System.Diagnostics.EventLog>類別可讓您存取所有事件記錄檔的集合。 您可以使用`static`的成員<xref:System.Diagnostics.EventLog>來刪除記錄，請取得記錄清單、 建立或刪除來源，或判斷電腦是否已包含特定的來源。  
  
 有三個預設事件記錄檔：應用程式、 系統及安全性。 安全性記錄檔是唯讀的。 其他應用程式和服務安裝，例如 Active Directory 中，可能會有額外的事件記錄檔。  
  
 使用時，有一些安全性考量<xref:System.Diagnostics.EventLog>類別。 <xref:System.Diagnostics.EventLog> 需要<xref:System.Diagnostics.EventLogPermission>特定的動作，在.NET Framework 2.0 和更新版本中或在.NET Framework 1.0 和 1.1 版中的完全信任權限。 我們建議<xref:System.Diagnostics.EventLogPermission>不授與部分信任程式碼。  您應該永遠不會傳遞任何事件記錄檔物件，包括<xref:System.Diagnostics.EventLogEntryCollection>和<xref:System.Diagnostics.EventLogEntry>較不受信任的程式碼的物件。 例如，建立<xref:System.Diagnostics.EventLog>物件，寫入項目，然後再將傳遞<xref:System.Diagnostics.EventLog>物件到部分受信任的程式碼可以建立安全性問題，因為能夠讀取和寫入事件記錄檔可執行動作，例如發出的程式碼事件記錄檔訊息，另一個應用程式的名稱。  
  
 從 Windows Vista 開始，使用者帳戶控制 (UAC) 會決定使用者的認證。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的認證從標準使用者提高為系統管理員。 您可以藉由開啟應用程式的捷徑功能表來啟動應用程式時 （如果您使用滑鼠，以滑鼠右鍵按一下應用程式圖示），並指出您想要以系統管理員身分執行。  
  
 您可以使用<xref:System.Diagnostics.EventLog>若要建立自訂的事件記錄檔，您可以透過伺服器檢視的 事件檢視器。 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>方法，以在事件檢視器中顯示您的事件記錄檔的當地語系化的名稱。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>來設定事件記錄檔的行為，當它達到最大記錄檔大小的方法。  
  
 若要讀取事件記錄檔，請指定 記錄檔名稱 (<xref:System.Diagnostics.EventLog.Log%2A>屬性) 和伺服器電腦名稱 (<xref:System.Diagnostics.EventLog.MachineName%2A>事件記錄檔的屬性。 如果您未指定伺服器的電腦名稱，本機電腦中，"。"，會假設。 您不需要指定事件來源 (<xref:System.Diagnostics.EventLog.Source%2A>屬性)，因為來源是只有需要寫入記錄檔。 <xref:System.Diagnostics.EventLog.Entries%2A>屬性會自動填入的項目事件記錄檔的清單。  
  
 若要寫入事件記錄檔，指定或建立事件來源 (<xref:System.Diagnostics.EventLog.Source%2A>屬性)。 您必須具有系統管理認證，以建立新的事件來源電腦上。 事件來源會註冊您的應用程式事件記錄檔做為有效的來源項目。 您可以使用事件來源寫入一次只能有一個記錄檔。 <xref:System.Diagnostics.EventLog.Source%2A>屬性可以是任何隨機字串，但必須是相異的電腦上的其他來源的名稱。 事件來源通常是應用程式或另一個的識別字串的名稱。 嘗試建立重複<xref:System.Diagnostics.EventLog.Source%2A>值就會擲回例外狀況。 不過，單一的事件記錄檔可以與多個來源相關聯。  
  
 如果與相關聯的事件記錄檔的事件來源<xref:System.Diagnostics.EventLog>執行個體不存在，會建立新的事件來源。 若要建立事件來源，在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理認證。  
  
 這項需求是因為所有的事件記錄檔，包括安全性記錄檔，必須搜尋以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限以存取安全性記錄檔中;因此，<xref:System.Security.SecurityException>就會擲回。  
  
> [!IMPORTANT]
>  使用具名的 mutex 建立或刪除事件來源時，需要同步處理的基礎程式碼。 如果高特殊權限的應用程式鎖定具名的 mutex，嘗試建立或刪除事件來源產生應用程式停止回應，直到鎖定解除為止。 若要避免此問題，永遠不會授與<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>不受信任的程式碼的權限。 颾魤 ㄛ<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>權限可能會允許略過其他權限，以及只應該授與高度信任程式碼。  
  
 應用程式和服務應該將寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。 如果您沒有明確設定<xref:System.Diagnostics.EventLog.Log%2A>屬性預設為應用程式記錄檔的事件記錄檔。  
  
> [!NOTE]
>  沒有要保護的應用程式，從撰寫為任何已註冊的來源。  如果應用程式授與<xref:System.Diagnostics.EventLogPermissionAccess.Write>權限，它可以寫入之事件的任何有效的來源電腦上登錄。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔的方法。 您必須指定要寫入事件，事件來源您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統尚未重新整理其事件來源的清單，而且您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以使用，以設定新的來源<xref:System.Diagnostics.EventLogInstaller>物件或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須具有系統管理認證，以建立新的事件來源電腦上。  
  
 每個來源一次; 可以寫入只有一個事件記錄檔不過，您的應用程式也可以使用多個來源，以寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔。 若要變更現有的來源的設定詳細資料，您必須刪除來源，並再建立新的組態。 如果其他應用程式或元件使用現有的來源，建立新的來源與更新的組態，而不是刪除現有的來源。  
  
 您可以在您的事件類別目錄和訊息字串的當地語系化資源註冊事件來源。 您的應用程式可以使用資源識別碼，而不是指定實際的字串值寫入事件記錄檔項目。 請參閱<xref:System.Diagnostics.EventLogInstaller>和<xref:System.Diagnostics.EventSourceCreationData>類別，如需有關設定您的來源資源檔。  
  
 如果您的應用程式會將字串值，直接寫入事件記錄檔，您不必設定資源的來源檔案內容。 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 當寫入事件時，您至少必須指定的訊息字串或將訊息字串的資源識別項。 其他事件屬性是選擇性的。 選擇性的事件設定的範例包括下列各項：  
  
-   您可以設定<xref:System.Diagnostics.EventLogEntryType>來指定 事件檢視器顯示之項目的圖示。  
  
-   如果您的應用程式會使用分類來篩選事件，您可以指定事件的類別識別項。  
  
-   如果您想要指定的事件相關聯的其他資訊，您可以將二進位資料附加至您的事件項目中。  
  
> [!IMPORTANT]
>  事件記錄會消耗磁碟空間、 處理器時間，以及其他系統資源。 請務必記錄必要的資訊。 我們建議您將事件記錄檔呼叫放在錯誤路徑，而不是在主要程式碼路徑中，因此它們不效能產生負面影響。  
  
 如需執行個體的初始屬性值的清單<xref:System.Diagnostics.EventLog>，請參閱<xref:System.Diagnostics.EventLog.%23ctor%2A>建構函式。  
  
   
  
## Examples  
 下列範例會建立事件來源`MySource`如果尚未存在，它的項目寫入事件記錄檔`MyNewLog`。  
  
> [!NOTE]
>  從 Windows Vista 開始，您必須以系統管理員身分執行此應用程式。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 不讓執行個體和任何記錄檔產生關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>執行個體。 如果您僅讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔中，您也可以指定僅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|在本機電腦 ("。")。|  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果不存在，它的項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">本機電腦上的記錄檔名稱。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 讓執行個體與本機電腦上的記錄檔產生關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個多載<xref:System.Diagnostics.EventLog.Log%2A>屬性設`logName`參數。 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>執行個體。 如果您僅讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔中，您也可以指定僅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。 這個多載的建構函式指定<xref:System.Diagnostics.EventLog.Log%2A>屬性，但您可以變更此讀取前<xref:System.Diagnostics.EventLog.Entries%2A>屬性。  
  
 如果您在指定的來源<xref:System.Diagnostics.EventLog.Source%2A>屬性是唯一的電腦，後續呼叫上的其他來源<xref:System.Diagnostics.EventLog.WriteEntry%2A>建立記錄，其指定的名稱，如果不存在。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 參數。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|在本機電腦 ("。")。|  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔，而"myNewLog 」，在本機電腦中的項目。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">記錄檔名稱為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">記錄檔名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定電腦上的記錄檔名稱。</param>
        <param name="machineName">記錄檔所在處的電腦。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 讓執行個體與指定電腦上的記錄檔產生關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個多載<xref:System.Diagnostics.EventLog.Log%2A>屬性，以`logName`參數和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性設`machineName`參數。 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>。 如果您僅讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔中，您也可以指定僅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。  
  
> [!NOTE]
>  這個多載的建構函式指定<xref:System.Diagnostics.EventLog.Log%2A>並<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，但是您可以變更之前讀取<xref:System.Diagnostics.EventLog.Entries%2A>屬性。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 參數。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 參數。|  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔，而 「 myNewLog"，"myServer"的電腦上的項目。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">記錄檔名稱為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">記錄檔名稱無效。  
  
-或- 
電腦名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定電腦上的記錄檔名稱</param>
        <param name="machineName">記錄檔所在處的電腦。</param>
        <param name="source">事件記錄檔項目的來源。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 類別的新執行個體。 讓執行個體和指定電腦上的記錄檔產生關聯，並建立或指派指定的來源給 <see cref="T:System.Diagnostics.EventLog" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式設定<xref:System.Diagnostics.EventLog.Log%2A>屬性，以`logName`參數，<xref:System.Diagnostics.EventLog.MachineName%2A>屬性設`machineName`參數，而<xref:System.Diagnostics.EventLog.Source%2A>屬性設`source`參數。 <xref:System.Diagnostics.EventLog.Source%2A>寫入事件記錄檔時，就需要屬性。 不過，如果您僅讀取事件記錄檔，只有<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>（只要事件記錄檔，在伺服器上都有一個已經與它關聯的來源），都需要屬性。 如果您僅讀取事件記錄檔，另一個多載的建構函式可能已足夠。  
  
 下表顯示的執行個體的初始屬性值<xref:System.Diagnostics.EventLog>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` 參數。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 參數。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 參數。|  
  
   
  
## Examples  
 下列範例會的項目寫入事件記錄檔時，「 MyNewLog"，本機電腦上，使用"MySource"的來源。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">記錄檔名稱為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">記錄檔名稱無效。  
  
-或- 
電腦名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始初始化表單或為另一個元件所使用的 <see cref="T:System.Diagnostics.EventLog" />。 初始化會於執行階段時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來開始初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.EventLog.EndInit%2A>方法結束初始化。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法可防止控制項完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> 已經初始化。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除事件記錄檔的所有項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件記錄檔的設定，判斷它們可以包含的項目數量的大小上限。 事件記錄檔已滿時，它會停止記錄新事件的資訊，或開始覆寫先前項目。 如果停止事件記錄，您可以使用這個方法來清除現有的項目記錄，並允許它重新啟動記錄事件。 您必須清除事件記錄檔項目記錄檔所在電腦的系統管理員權限。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> 關閉事件記錄檔，釋出事件控制代碼，新的擷取讀取和寫入控制代碼，並重新開啟事件記錄檔。 方法的呼叫之後收到的事件不會清除現有的事件。  
  
   
  
## Examples  
 下列範例會清除事件記錄檔。  
  
> [!CAUTION]
>  由於應用程式、 系統、 安全性和其他非自訂記錄檔可能包含重要的資訊;請務必指定自訂的記錄檔，然後再執行此程式碼範例。 此範例會刪除自訂記錄檔`myNewLog`。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔未成功清除。  
  
-或- 
無法開啟記錄檔。 無法使用 Windows 錯誤碼。</exception>
        <exception cref="T:System.ArgumentException">沒有指定 <see cref="P:System.Diagnostics.EventLog.Log" /> 屬性的值。 確定記錄檔名稱不是空字串。</exception>
        <exception cref="T:System.InvalidOperationException">檔案不存在。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉事件記錄檔，並釋放讀取和寫入控制代碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A>方法會呼叫受保護的<xref:System.ComponentModel.Component.Dispose%2A>方法。 您不需要叫用<xref:System.Diagnostics.EventLog.Close%2A>再呼叫<xref:System.ComponentModel.Component.Dispose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔的讀取控制代碼或寫入控制代碼未成功釋放。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立能夠將事件資訊寫入系統上的特定記錄檔的應用程式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">事件來源及其目標事件記錄檔的組態屬性。</param>
        <summary>使用事件來源及對應的事件記錄檔指定的組態屬性，建立有效的事件來源，以撰寫當地語系化的事件訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要設定新的來源項目寫入事件記錄檔，在本機電腦或遠端電腦上使用此多載。 您不需要使用這個方法來讀取事件記錄檔。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法會使用輸入`sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>，<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>和<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>屬性，以建立新的來源和其相關聯的事件記錄檔的目標電腦上的登錄值。 新的來源名稱不符合現有的來源名稱或在目標電腦上現有的事件記錄檔名稱。 如果<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>屬性未設定時，來源會註冊為應用程式事件記錄檔。 如果<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>未設定，來源登錄在本機電腦上。  
  
> [!NOTE]
>  若要建立事件來源，在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是所有的事件記錄檔，包括安全性、 必須要搜尋以判斷事件來源是否唯一。 從 Windows Vista 開始，使用者沒有權限以存取安全性記錄檔中;因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  從 Windows Vista 開始，使用者帳戶控制 (UAC) 會決定使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定要寫入事件，事件來源您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔的事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但直到第一個項目寫入至其中，才會建立記錄檔。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案會儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>".evt"副檔名的屬性。  
  
 每個來源只有一個事件記錄檔只能寫入一次;不過，您的應用程式也可以使用多個來源，以寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔。  
  
 您可以在事件類別目錄和訊息字串的當地語系化的資源檔與註冊事件來源。 您的應用程式可以寫入事件記錄項目使用資源識別碼，而不是指定實際的字串。 事件檢視器會尋找並顯示目前語言設定為基礎的當地語系化的資源檔中的對應字串使用的資源識別碼。 您可以註冊個別的檔案，事件類別目錄、 訊息和參數插入字串，或您可以註冊相同的資源檔，所有的三種類型的字串。 使用<xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>， <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>， <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>，和<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>屬性來設定要當地語系化的項目寫入事件記錄檔的來源。 如果您的應用程式會將字串值，直接寫入事件記錄檔，您不需要設定這些屬性。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有的來源的設定詳細資料，您必須刪除來源，並再建立新的組態。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不是刪除現有來源建立新的來源。  
  
> [!NOTE]
>  如果來源設定為事件記錄檔，且重新設定為另一個事件記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會判斷是否事件來源名為`SampleApplicationSource`登錄在本機電腦上。 如果事件來源不存在，此範例會設定為來源的訊息資源檔，並建立新的事件來源。 最後，範例會設定事件記錄檔，使用中的資源識別碼值的當地語系化的顯示名稱`DisplayNameMsgId`中的資源檔路徑和`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 此範例會使用下列的訊息文字檔案，內建資源庫 EventLogMsgs.dll。 訊息文字檔案是從其中建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。 具體而言，資源識別元 5001 定義事件記錄檔的當地語系化名稱。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在 <paramref name="sourceData" /> 中指定的電腦名稱無效。  
  
-或- 
<paramref name="sourceData" /> 中所指定的來源名稱為 <see langword="null" />。  
  
-或- 
在 <paramref name="sourceData" /> 中指定的記錄檔名稱無效。 事件記錄檔名稱必須由可列印字元組成，不得包括字元 '*'、'?' 或 '\\'。  
  
-或- 
在 <paramref name="sourceData" /> 中指定的記錄檔名稱無效，無法建立使用者記錄檔。 事件記錄檔名稱 AppEvent、SysEvent 和 SecEvent 會保留供系統使用。  
  
-或- 
此記錄檔名稱符合現有的事件來源名稱。  
  
-或- 
指定 <paramref name="sourceData" /> 來源名稱產生的登錄機碼路徑長度超過 254 個字元。  
  
-或- 
在 <paramref name="sourceData" /> 中指定的記錄檔名稱的前 8 個字元不是唯一的。  
  
-或- 
已經登錄 <paramref name="sourceData" /> 中指定的來源名稱。  
  
-或- 
在 <paramref name="sourceData" /> 中指定的來源名稱符合現有的事件記錄檔名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">應用程式登錄在本機電腦上的來源名稱。</param>
        <param name="logName">寫入來源項目的記錄檔名稱。 可能的值包括應用程式、系統或自訂事件記錄檔。</param>
        <summary>建立指定的來源名稱做為有效的事件來源，以便將項目寫入本機電腦上的記錄檔。 這個方法也可以在本機電腦上建立新的自訂記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來建立自訂的記錄檔，或建立並註冊<xref:System.Diagnostics.EventLog.Source%2A>到本機電腦上現有的記錄檔。  
  
 如果`logName`已`null`或空字串 ("") 當您呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，記錄檔預設為應用程式記錄檔。 如果記錄檔不存在本機電腦上，系統會建立自訂記錄檔，並註冊您的應用程式<xref:System.Diagnostics.EventLog.Source%2A>該記錄檔。  
  
> [!NOTE]
>  若要建立事件來源，在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是所有的事件記錄檔，包括安全性、 必須要搜尋以判斷事件來源是否唯一。 從 Windows Vista 開始，使用者沒有權限以存取安全性記錄檔中;因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  在 Windows Vista (含) 以後版本中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 您只需要建立事件來源，如果您要寫入事件記錄檔。 前一個項目寫入事件記錄檔中，您必須向事件來源事件記錄檔為有效的事件來源。 當您撰寫的記錄項目時，系統會使用<xref:System.Diagnostics.EventLog.Source%2A>尋找適當的記錄檔，在其中放置您的項目。 如果您正在讀取事件記錄檔，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或有<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到本機電腦上的記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>讀取時從記錄檔，在本機電腦 ("。") 會假設。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定要寫入事件，事件來源您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔的事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但直到第一個項目寫入至其中，才會建立記錄檔。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案會儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>".evt"副檔名的屬性。  
  
 來源必須是唯一的本機電腦上，新的來源名稱不符合現有的來源名稱或現有的事件記錄檔名稱。 每個來源一次; 可以寫入只有一個事件記錄檔不過，您的應用程式也可以使用多個來源，以寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有的來源的設定詳細資料，您必須刪除來源，並再建立新的組態。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不是刪除現有來源建立新的來源。  
  
> [!NOTE]
>  如果來源已對應至記錄重新對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果不存在，它的項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 為空字串 ("") 或 <see langword="null" />  
  
-或- 
 <paramref name="logName" /> 不是有效的名稱。 事件記錄檔名稱必須由可列印字元組成，不得包括字元 '*'、'?' 或 '\\'。  
  
-或- 
 <paramref name="logName" /> 不適用於建立使用者記錄。 事件記錄檔名稱 AppEvent、SysEvent 和 SecEvent 會保留供系統使用。  
  
-或- 
此記錄檔名稱符合現有的事件來源名稱。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。  
  
-或- 
<paramref name="logName" /> 的前 8 個字元符合現有事件記錄檔名稱的前 8 個字元。  
  
-或- 
來源因為已經存在於本機電腦上而無法登錄。  
  
-或- 
來源名稱符合現有的事件記錄檔名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="logName">寫入來源項目的記錄檔名稱。 可能的值包括應用程式、系統或自訂事件記錄檔。 如果您未指定值，<paramref name="logName" /> 會預設為應用程式。</param>
        <param name="machineName">要註冊這個事件來源的電腦名稱，或者表示本機電腦的 "."。</param>
        <summary>建立指定的來源名稱做為有效的事件來源，以便將項目寫入指定之電腦上的記錄檔。 這個方法也可以用來在指定的電腦上建立新的自訂記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來建立自訂的記錄檔，或建立並註冊<xref:System.Diagnostics.EventLog.Source%2A>至指定的電腦上現有的記錄檔。  
  
 如果`logName`已`null`或空字串 ("") 當您呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，記錄檔預設為應用程式記錄檔。 如果記錄檔不存在指定的電腦上，系統會建立自訂記錄檔，並註冊您的應用程式<xref:System.Diagnostics.EventLog.Source%2A>該記錄檔。  
  
 您只需要建立事件來源，如果您要寫入事件記錄檔。 前一個項目寫入事件記錄檔中，您必須向事件來源事件記錄檔為有效的事件來源。 當您撰寫的記錄項目時，系統會使用<xref:System.Diagnostics.EventLog.Source%2A>尋找適當的記錄檔，在其中放置您的項目。 如果您正在讀取事件記錄檔，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或有<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  若要建立事件來源，在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是所有的事件記錄檔，包括安全性、 必須要搜尋以判斷事件來源是否唯一。 在 Windows Vista 和更新版本，使用者沒有權限以存取安全性記錄檔中;因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  在 Windows Vista (含) 以後版本中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定要寫入事件，事件來源您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔的事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但直到第一個項目寫入至其中，才會建立記錄檔。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案會儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>".evt"副檔名的屬性。  
  
 來源必須是唯一的本機電腦上，新的來源名稱不符合現有的來源名稱或現有的事件記錄檔名稱。 每個來源一次; 可以寫入只有一個事件記錄檔不過，您的應用程式也可以使用多個來源，以寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有的來源的設定詳細資料，您必須刪除來源，並再建立新的組態。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不是刪除現有來源建立新的來源。  
  
> [!NOTE]
>  如果來源已對應至記錄重新對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`電腦上`MyServer`，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 不是有效的電腦名稱。  
  
-或- 
 <paramref name="source" /> 為空字串 ("") 或 <see langword="null" />  
  
-或- 
 <paramref name="logName" /> 不是有效的名稱。 事件記錄檔名稱必須由可列印字元組成，不得包括字元 '*'、'?' 或 '\\'。  
  
-或- 
 <paramref name="logName" /> 不適用於建立使用者記錄。 事件記錄檔名稱 AppEvent、SysEvent 和 SecEvent 會保留供系統使用。  
  
-或- 
此記錄檔名稱符合現有的事件來源名稱。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。  
  
-或- 
<paramref name="logName" /> 的前 8 個字元符合指定電腦上現有事件記錄檔名稱的前 8 個字元。  
  
-或- 
來源因為已經存在於指定的電腦上而無法登錄。  
  
-或- 
來源名稱符合現有的事件來源名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移除記錄檔資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要刪除的記錄檔名稱。 可能的值包括：應用程式、安全性、系統和電腦上的任何自訂事件記錄檔。</param>
        <summary>將事件記錄檔從本機電腦移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在本機電腦上您想要刪除的記錄檔時，請使用這個方法。 提供您有適當的登錄權限，您可以刪除電腦上的任何記錄檔。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 移除所指定的記錄檔`logName`從本機電腦。 如果您想要刪除原始檔登錄到記錄檔，請呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 並<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，讓它們可以呼叫類別本身。 您不需要建立的新執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>方法會先刪除保留的記錄檔的內容檔案。 然後，它會存取登錄並移除該記錄檔註冊的所有事件來源。 如果您重新建立在稍後的時間點的記錄，您應該註冊事件來源同樣地，若要重複使用。 如果您不會註冊事件來源，而且其他使用者不需要指定記錄檔名稱寫入的事件來源，將應用程式事件記錄檔中建立事件來源。 因此，應用程式，先前能夠寫入您刪除並重新建立記錄檔中的項目會寫入應用程式記錄檔相反的因為它現在包含事件來源。  
  
> [!NOTE]
>  重新建立事件記錄檔可以是相當困難的工作。 避免刪除任何系統建立的事件記錄檔，例如應用程式記錄檔。  
  
 正在刪除記錄，以透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔註冊的來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
   
  
## Examples  
 下列範例會刪除記錄檔從本機電腦。 此範例會判斷其來源的記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 之前刪除自訂記錄檔，請確定沒有其他寫入該記錄檔的來源。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> 為空字串 ("") 或 <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。  
  
-或- 
計數器不在指定的電腦上。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔未成功清除。  
  
-或- 
無法開啟記錄檔。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要刪除的記錄檔名稱。 可能的值包括：應用程式、安全性、系統和所指定電腦上的任何自訂事件記錄檔。</param>
        <param name="machineName">要刪除記錄檔的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>將事件記錄檔從指定的電腦移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在遠端電腦上您想要刪除的記錄檔時，請使用這個方法。 提供您有適當的登錄權限，您可以刪除電腦上的任何記錄檔。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 移除所指定的記錄檔`logName`所指定的電腦從`machineName`。 如果您想要刪除原始檔登錄到記錄檔，請呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 並<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，讓它們可以呼叫類別本身。 您不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 這個方法會先刪除保留的記錄檔的內容檔案。 然後，它會存取登錄並移除該記錄檔註冊的所有事件來源。 如果您重新建立在稍後的時間點的記錄，您應該註冊事件來源同樣地，若要重複使用。 如果您不會註冊事件來源，而且其他使用者不需要指定記錄檔名稱寫入的事件來源，將應用程式事件記錄檔中建立事件來源。 因此，應用程式，先前能夠寫入您刪除並重新建立記錄檔中的項目會寫入應用程式記錄檔相反的因為它現在包含事件來源。  
  
> [!NOTE]
>  重新建立事件記錄檔可以是相當困難的工作。 避免刪除任何系統建立的事件記錄檔，例如應用程式記錄檔。  
  
 正在刪除記錄，以透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔註冊的來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
   
  
## Examples  
 下列範例會刪除記錄檔，從指定的電腦。 此範例會判斷其來源的記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 之前刪除自訂記錄檔，請確定沒有其他寫入該記錄檔的來源。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> 為空字串 ("") 或 <see langword="null" />  
  
-或- 
 <paramref name="machineName" /> 不是有效的電腦名稱。</exception>
        <exception cref="T:System.InvalidOperationException">無法在目標電腦上開啟事件記錄檔的登錄機碼。  
  
-或- 
計數器不在指定的電腦上。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">事件記錄檔未成功清除。  
  
-或- 
無法開啟記錄檔。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將應用程式的事件來源登錄從事件記錄檔移除。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">應用程式在事件記錄檔系統中登錄的名稱。</param>
        <summary>將事件來源登錄從本機電腦的事件記錄檔移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來移除註冊<xref:System.Diagnostics.EventLog.Source%2A>從本機電腦。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 存取本機電腦上的登錄，並移除應用程式有效的事件來源的註冊。  
  
 如果您不再需要它寫入該記錄檔中的項目，您可以為有效的事件來源移除您的元件。 例如，您可能會執行這項操作如果您需要變更您的元件和一個記錄檔。 因為來源一次只能註冊一個記錄檔，變更記錄檔需要您移除目前的註冊。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 移除只登錄到記錄檔的來源。 如果您想要移除記錄檔本身，呼叫<xref:System.Diagnostics.EventLog.Delete%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 並<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，讓它們可以呼叫類別本身。 您不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 正在刪除記錄，以透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔註冊的來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
> [!NOTE]
>  如果來源已對應至記錄重新對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會從本機電腦刪除的來源。 此範例會判斷其來源的記錄檔，，然後刪除記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 之前刪除自訂記錄檔，請確定沒有其他寫入該記錄檔的來源。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">本機電腦的登錄中沒有 <paramref name="source" /> 參數。  
  
-或- 
您沒有事件記錄檔登錄機碼的寫入權限。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">應用程式在事件記錄檔系統中登錄的名稱。</param>
        <param name="machineName">要移除登錄的電腦名稱，或者表示本機電腦的 "."。</param>
        <summary>將應用程式的事件來源登錄從指定的電腦移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要移除註冊使用此多載<xref:System.Diagnostics.EventLog.Source%2A>從遠端電腦。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 存取所指定的電腦上的登錄`machineName`，並移除您的應用程式，為有效的事件來源的註冊。  
  
 如果您不再需要它寫入該記錄檔中的項目，您可以為有效的事件來源移除您的元件。 例如，您可能會執行這項操作如果您需要變更您的元件和一個記錄檔。 因為來源一次只能註冊一個記錄檔，變更記錄檔需要您移除目前的註冊。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 移除只登錄到記錄檔的來源。 如果您想要移除記錄檔本身，呼叫<xref:System.Diagnostics.EventLog.Delete%2A>。 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 並<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，讓它們可以呼叫類別本身。 您不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。  
  
 正在刪除記錄，以透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔註冊的來源。 這可讓其他應用程式使用該記錄檔無法作業。  
  
> [!NOTE]
>  如果來源已對應至記錄重新對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會從指定的電腦刪除的來源。 此範例會判斷其來源的記錄檔，，然後刪除記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 之前刪除自訂記錄檔，請確定沒有其他寫入該記錄檔的來源。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 參數無效。  
  
-或- 
指定電腦的登錄中沒有 <paramref name="source" /> 參數。  
  
-或- 
您沒有事件記錄檔登錄機碼的寫入權限。</exception>
        <exception cref="T:System.InvalidOperationException">無法刪除 <paramref name="source" />，因為在登錄中，<paramref name="source" /> 的父登錄機碼並未包含具有相同名稱的子機碼 (Subkey)。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Diagnostics.EventLog" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設為`true`。 <xref:System.Object.Finalize%2A> 叫用`Dispose`具有`disposing`設定為`false`。  
  
 當`disposing`參數為 true 時，這個方法由任何 managed 物件持有的資源全部釋出這個<xref:System.Diagnostics.EventLog>參考。 這個方法會叫用每個參考物件的 `Dispose()` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> 可以被其他物件呼叫多次。 當覆寫<see langword="Dispose(Boolean)" />小心不要參考先前處置好的呼叫中的物件<see langword="Dispose" />。 如需有關如何實作<see langword="Dispose(Boolean)" />，請參閱 &lt;&lt;c2&gt; [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
如需詳細資訊<see langword="Dispose" />並<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示 <see cref="T:System.Diagnostics.EventLog" /> 是否接收 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件通知。</summary>
        <value>如果 <see cref="T:System.Diagnostics.EventLog" /> 在項目寫入到記錄檔時接收通知，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>屬性會決定是否<xref:System.Diagnostics.EventLog>引發事件時寫入記錄檔項目。 將屬性何時`true`，會收到的元件<xref:System.Diagnostics.EventLog.EntryWritten>事件將會收到通知任何時間項目會寫入至記錄檔中指定<xref:System.Diagnostics.EventLog.Log%2A>屬性。 如果<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>是`false`，不會引發事件。  
  
> [!NOTE]
>  只有當項目會寫入本機電腦上，您可以接收事件通知。 您無法接收通知的遠端電腦上寫入的項目。  
  
   
  
## Examples  
 下列範例會處理<xref:System.Diagnostics.EventLog.EntryWritten>事件。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">事件記錄位於遠端電腦上。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束對表單或為另一個元件所使用之 <see cref="T:System.Diagnostics.EventLog" /> 的初始化。 初始化會於執行階段時執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來結束初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.EventLog.BeginInit%2A>方法會啟動初始化。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法，防止控制項被完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔的內容。</summary>
        <value>將項目保存在事件記錄檔中的 <see cref="T:System.Diagnostics.EventLogEntryCollection" />。 每個項目與 <see cref="T:System.Diagnostics.EventLogEntry" /> 類別的執行個體相關聯。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.Entries%2A>時讀取事件記錄檔的成員。  
  
 因為屬性是唯讀，則您無法修改項目，或寫入記錄檔使用<xref:System.Diagnostics.EventLog.Entries%2A>。 相反地，指定<xref:System.Diagnostics.EventLog.Source%2A>並呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>撰寫新的記錄項目。 您可以使用<xref:System.Diagnostics.EventLog.Entries%2A>來計算事件記錄檔中的項目數，並檢視每個<xref:System.Diagnostics.EventLogEntry>集合中。 使用索引<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>成員，才能擷取資訊的特定項目，例如<xref:System.Diagnostics.EventLogEntry.Message%2A>， <xref:System.Diagnostics.EventLogEntry.Category%2A>， <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>，或<xref:System.Diagnostics.EventLogEntry.EntryType%2A>。  
  
 您不需要指定<xref:System.Diagnostics.EventLog.Source%2A>時只能讀取記錄檔。 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和<xref:System.Diagnostics.EventLog.MachineName%2A>（伺服器電腦名稱） 屬性<xref:System.Diagnostics.EventLog>執行個體。 在任一情況下，<xref:System.Diagnostics.EventLog.Entries%2A>成員會自動填入的項目事件記錄檔的清單。 您可以讀取個別項目這份清單中選取適當的項目索引。  
  
 讀取和寫入記錄項目之間的重要區別是不需要明確地呼叫讀取的方法。 之後<xref:System.Diagnostics.EventLog.Log%2A>並<xref:System.Diagnostics.EventLog.MachineName%2A>都有指定，<xref:System.Diagnostics.EventLog.Entries%2A>屬性會自動填入。 如果您變更的值<xref:System.Diagnostics.EventLog.Log%2A>或是<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，<xref:System.Diagnostics.EventLog.Entries%2A>屬性會填入您閱讀下一次。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦中，"。"，會假設。  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔中，「 MyNewLog 」，在本機電腦上的項目。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於項目寫入至本機電腦上的事件記錄檔時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得事件通知，您必須設定<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>至`true`。 項目寫入本機電腦上時，您只可以接收事件通知。 您無法接收通知的遠端電腦上寫入的項目。  
  
 當您建立 <xref:System.Diagnostics.EventLog.EntryWritten> 委派 (Delegate) 時，就可以識別即將處理此事件的方法。 若要使事件與您的事件處理常式產生關聯，請將委派的執行個體 (Instance) 加入至事件。 每當事件發生時，直到您移除委派，會呼叫事件處理常式。 如需有關如何使用委派處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 系統會回應<xref:System.Diagnostics.EventLog.WriteEntry%2A>只有當最後一個寫入事件發生至少六秒之前。 這表示您只會收到一個<xref:System.Diagnostics.EventLog.EntryWritten>六秒的間隔內的事件通知，即使多個事件記錄的變更時發生。 如果您插入夠長的睡眠間隔 （大約 10 秒） 之間的呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，您不太可能遺漏事件。 不過，如果寫入事件的發生頻率，您可能會收到事件通知，直到下一個間隔。 一般而言，遺失的事件通知不會遺失，但延遲。  
  
   
  
## Examples  
 下列範例會處理項目寫入事件。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷指定的記錄檔是否存在。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜尋的記錄檔的名稱。 可能的值包括：應用程式、安全性、系統、其他應用程式特定的記錄檔 (例如，與 Active Directory 關聯的記錄檔)，或者電腦上的任何自訂記錄檔。</param>
        <summary>判斷記錄檔是否存在於本機電腦上。</summary>
        <returns>如果記錄檔存在於本機電腦上，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來判斷是否記錄檔存在於本機電腦上。 如果您想要判斷來源是否存在於本機電腦，也就是使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 由於這個方法會存取登錄，您還必須擁有適當的登錄權限，本機電腦上，否則，查詢會傳回`false`。  
  
 是因為您無法在相同電腦上讓新的記錄檔的現有記錄檔名稱，然後再建立新的記錄檔使用此方法來判斷是否指定`logName`已存在於本機電腦上。 `logName`參數不區分大小寫。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，所以它可以呼叫類別本身。 您不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName 是 <see langword="null" /> 或者是空值。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜尋的記錄檔。 可能的值包括：應用程式、安全性、系統、其他應用程式特定的記錄檔 (例如，與 Active Directory 關聯的記錄檔)，或者電腦上的任何自訂記錄檔。</param>
        <param name="machineName">要在其上搜尋記錄檔的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>判斷記錄檔是否存在於指定的電腦上。</summary>
        <returns>如果記錄檔存在於指定的電腦上，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來判斷遠端電腦上是否有記錄檔。 如果您想要判斷來源是否存在的遠端電腦上，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 由於這個方法會存取登錄，您必須擁有適當的登錄權限指定電腦上，否則，查詢會傳回`false`。  
  
 是因為您無法在相同電腦上讓新的記錄檔的現有記錄檔名稱，然後再建立新的記錄檔使用此方法以判斷是一個具有指定之`logName`已存在於所指定的伺服器上`machineName`參數。 `logName`和`machineName`參數不區分大小寫。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，所以它可以呼叫類別本身。 您不需要建立的新執行個體<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 參數是無效的格式。 確認要搜尋的電腦採用的適合的語法。  
  
-或- 
<paramref name="logName" /> 是 <see langword="null" /> 或者是空值。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立事件記錄檔的陣列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>搜尋本機電腦上的所有事件記錄檔，並建立含有清單的 <see cref="T:System.Diagnostics.EventLog" /> 物件陣列。</summary>
        <returns>表示本機電腦上記錄檔的類型 <see cref="T:System.Diagnostics.EventLog" /> 的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列<xref:System.Diagnostics.EventLog>物件是在本機電腦上的所有事件記錄檔的快照集時呼叫<xref:System.Diagnostics.EventLog.GetEventLogs%2A>為止。 這不是動態集合，因此不會反映刪除或建立即時的記錄檔。 您應該確認陣列中的記錄檔存在，才能讀取或寫入其中。 陣列通常會包含至少三個記錄檔：應用程式、 系統及安全性。 如果您在本機電腦上建立自訂記錄檔，它們會出現在陣列以及。  
  
 若要擷取的事件記錄檔清單，您必須使用適當的登錄權限。 這些權限完全相同的呼叫所需<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下列範例會列舉在本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">您沒有讀取登錄的權限。  
  
-或- 
電腦上沒有事件記錄檔服務。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">要在其上搜尋事件記錄檔的電腦。</param>
        <summary>搜尋指定電腦上的所有事件記錄檔，並建立含有清單的 <see cref="T:System.Diagnostics.EventLog" /> 物件陣列。</summary>
        <returns>表示指定電腦上記錄檔的類型 <see cref="T:System.Diagnostics.EventLog" /> 的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 陣列<xref:System.Diagnostics.EventLog>物件是所指定的電腦上的所有事件記錄檔的快照集`machineName`參數時呼叫<xref:System.Diagnostics.EventLog.GetEventLogs%2A>為止。 這不是動態集合，因此不會反映刪除或建立即時的記錄檔。 您應該確認陣列中的記錄檔存在，才能讀取或寫入其中。 陣列通常會包含至少三個記錄檔：應用程式、 系統及安全性。 如果您指定的電腦上建立自訂記錄檔，它們會出現在陣列以及。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> 已`static`方法，所以它可呼叫<xref:System.Diagnostics.EventLog>類別本身。 您不需要建立的執行個體<xref:System.Diagnostics.EventLog>撥打電話給方法的物件。  
  
 若要擷取的事件記錄檔清單，您必須使用適當的登錄權限。 這些權限完全相同的呼叫所需<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下列範例會取得電腦"位於 myServer"上的記錄檔清單。 然後，它會輸出每個記錄檔的名稱。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 參數是無效的電腦名稱。</exception>
        <exception cref="T:System.InvalidOperationException">您沒有讀取登錄的權限。  
  
-或- 
電腦上沒有事件記錄檔服務。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要讀取或寫入的事件記錄檔的名稱。</summary>
        <value>記錄檔的名稱。 可以是應用程式、系統、安全性或者自訂的記錄檔名稱。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設會在伺服器上，有三個記錄檔：應用程式、 系統及安全性。 應用程式和服務使用的應用程式記錄檔。 裝置驅動程式會使用系統記錄檔。 開啟稽核時，系統會產生成功和失敗稽核事件安全性記錄檔中。 如果您有其他應用程式安裝，例如在 Windows 伺服器上的 Active Directory 可能有其他的預設記錄檔。 此外，您可以建立自訂記錄檔，在本機或遠端電腦上。 自訂的記錄檔可協助組織以更詳細的方式比您的元件會將事件寫入預設應用程式記錄檔時所允許的項目。  
  
> [!NOTE]
>  記錄檔名稱僅限於 8 個字元。 根據系統，MyLogSample1 MyLogSample2 等相同的記錄檔。  
  
 如果您寫入事件記錄檔，並不夠指定<xref:System.Diagnostics.EventLog.Log%2A>屬性。 您必須使<xref:System.Diagnostics.EventLog.Source%2A>與將它連接到特定的記錄檔事件記錄檔資源的屬性。 您不需要指定<xref:System.Diagnostics.EventLog.Source%2A>僅讀取記錄檔，但事件來源時必須與伺服器的登錄中的事件記錄檔資源相關聯。 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和<xref:System.Diagnostics.EventLog.MachineName%2A>從中讀取的 （伺服器電腦名稱）。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 如果<xref:System.Diagnostics.EventLog.Source%2A>未指定屬性，呼叫<xref:System.Diagnostics.EventLog.Log%2A>會傳回空字串，如果<xref:System.Diagnostics.EventLog.Log%2A>尚未明確設定 (藉由設定<xref:System.Diagnostics.EventLog.Log%2A>屬性，或透過建構函式)。 如果<xref:System.Diagnostics.EventLog.Source%2A>已指定，<xref:System.Diagnostics.EventLog.Log%2A>傳回註冊該來源所在的記錄檔的名稱。  
  
 來源一次只能註冊一個記錄檔。 如果<xref:System.Diagnostics.EventLog.Source%2A>的執行個體已設定屬性<xref:System.Diagnostics.EventLog>，您無法變更<xref:System.Diagnostics.EventLog.Log%2A>屬性，該<xref:System.Diagnostics.EventLog>而不需要變更的值<xref:System.Diagnostics.EventLog.Source%2A>或呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一次。 如果您變更<xref:System.Diagnostics.EventLog.Log%2A>屬性之後<xref:System.Diagnostics.EventLog.Source%2A>屬性已設定，寫入記錄項目就會擲回例外狀況。  
  
 作業系統會將事件記錄檔儲存為檔案。 當您使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要建立新的事件記錄檔，相關聯的檔案會儲存在指定的電腦上的 %SystemRoot%\System32\Config 目錄。 檔案名稱由附加的前 8 個字元設定<xref:System.Diagnostics.EventLog.Log%2A>".evt"副檔名的屬性。  
  
 您無法建立新的記錄檔使用<xref:System.Diagnostics.EventLog.Log%2A>單獨 （不含指定記錄檔的來源） 的屬性。 您可以呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，傳遞做為參數，新的記錄檔名稱，然後呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 不過，其目的通常是要建立 （和項目寫入） 新的應用程式特定記錄檔，或從現有的記錄檔讀取。  
  
 如果<xref:System.Diagnostics.EventLog.Log%2A>值變更時，事件記錄檔就會關閉，並釋放所有的事件控制代碼。  
  
> [!CAUTION]
>  如果您設定<xref:System.Diagnostics.EventLog.Log%2A>屬性不存在的記錄檔的名稱，系統會將附加<xref:System.Diagnostics.EventLog>應用程式記錄檔，但不會警告您它正在使用不是您所指定的記錄檔。  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔中，「 NewEventLog 」，在本機電腦上的項目。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔的易記名稱。</summary>
        <value>名稱，表示系統的事件檢視器中的事件記錄檔。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 Windows Vista 和更新版本，使用者沒有存取安全性記錄檔的權限。 如果您正在執行 Windows Vista 或更新版本，身為使用者，您會收到<xref:System.Security.SecurityException>當您嘗試存取安全性記錄檔中事件的顯示名稱。  
>   
>  在 Windows Vista (含) 以後版本中，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
   
  
## Examples  
 下列範例會列舉在本機電腦上所定義的事件記錄檔，並顯示<xref:System.Diagnostics.EventLog.LogDisplayName%2A>每個事件記錄檔。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <see cref="P:System.Diagnostics.EventLog.Log" /> 不存在這部電腦的登錄中。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">提供讀取指定的登錄機碼的能力。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">能夠存取指定的登錄鍵，如果它是遠端的索引鍵。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件來源的名稱。</param>
        <param name="machineName">要在其上搜尋記錄檔的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>取得登錄指定來源的記錄檔的名稱。</summary>
        <returns>與登錄中指定的來源關聯的記錄檔名稱。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件來源會指出項目會記錄事件。 它通常是應用程式的名稱或名稱的子元件的應用程式，如果應用程式很大。 應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。  
  
 當您建立新的來源，可以只撰寫一個記錄檔一次，則系統會登錄事件記錄檔與您的應用程式做為有效的來源項目。 <xref:System.Diagnostics.EventLog.Source%2A>屬性可以是任何字串，但名稱不能由其他電腦上的來源。 嘗試建立重複<xref:System.Diagnostics.EventLog.Source%2A>值就會擲回例外狀況。 不過，單一的事件記錄檔可以有許多不同的來源寫入它。  
  
   
  
## Examples  
 下列範例會從本機電腦刪除的來源。 此範例會判斷其來源的記錄檔，，然後刪除記錄檔。  
  
> [!NOTE]
>  多個來源可能會寫入事件記錄檔。 之前刪除自訂記錄檔，請確定沒有其他寫入該記錄檔的來源。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要在其上讀取或寫入事件的電腦的名稱。</summary>
        <value>事件記錄檔所在處的伺服器名稱。 預設值是本機電腦 (".")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您寫入事件記錄檔時，就必須將<xref:System.Diagnostics.EventLog.Source%2A>與您的事件記錄檔物件，將它連接到特定的記錄檔。 您不需要指定<xref:System.Diagnostics.EventLog.Source%2A>只讀取記錄時的屬性。 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和<xref:System.Diagnostics.EventLog.MachineName%2A>（伺服器電腦名稱）。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 來源一次只能註冊一個記錄檔。 如果<xref:System.Diagnostics.EventLog.Source%2A>的執行個體已設定屬性<xref:System.Diagnostics.EventLog>，您無法變更<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，該<xref:System.Diagnostics.EventLog>而不需要變更的值<xref:System.Diagnostics.EventLog.Source%2A>或呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一次。 如果您變更<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，<xref:System.Diagnostics.EventLog>關閉所有控制代碼，並重新附加至記錄檔和新的電腦上的來源。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A>值不可為空字串。 如果它沒有明確設定，則預設為本機電腦 ("。")。  
  
   
  
## Examples  
 下列範例會讀取事件記錄檔中，「 NewEventLog"，指定電腦上的項目。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">電腦名稱無效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定最大事件記錄檔大小 (以 KB 為單位)。</summary>
        <value>最大事件記錄檔大小 (以 KB 為單位)。 預設值為 512，表示最大記錄檔大小為 512 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>屬性代表的事件記錄檔的大小限制。 當事件記錄檔到達大小上限，已設定的<xref:System.Diagnostics.EventLog.OverflowAction%2A>值會決定是否會捨棄新的項目，或新的項目是否覆寫較舊的項目。  
  
> [!NOTE]
>  這個屬性表示此執行個體所代表的事件記錄檔的組態設定。 當事件記錄檔達到大小上限時，此屬性會指定作業系統如何處理新的項目寫入事件記錄檔註冊的所有事件來源。  
  
   
  
## Examples  
 下列範例會列舉在本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值小於 64 或大於 4194240，或者不是 64 的偶數倍數。</exception>
        <exception cref="T:System.InvalidOperationException">這個 <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的記錄檔名稱。  
  
-或- 
無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得事件記錄檔項目的保留天數。</summary>
        <value>保留事件記錄檔項目的天數。 預設值為 7。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>檢查事件記錄檔的目前設定的屬性。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>變更最小的數字的事件記錄檔中的每個項目必須保留的天數。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值取決於事件記錄檔設定的溢位行為。 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>，然後在<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值為 0。 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>，然後在<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值為-1。 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，然後在<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值是小於或等於零，且代表事件記錄檔已滿時，事件記錄檔項目的保留的天數。  
  
 當事件記錄檔達到大小限制時，才會發生溢位行為。 當<xref:System.Diagnostics.EventLog>有其<xref:System.Diagnostics.EventLog.OverflowAction%2A>設為<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，和事件記錄檔達到大小上限，則會將新的項目寫入只可以取代項目，其存留期超過<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>期間。 保留的最小週期的事件項目時，適當的事件記錄檔會定期封存。 否則，可能會遺失事件記錄檔已達到限制時的新項目。 若要避免遺失新的事件資訊，設定最小的保留天數，根據您特定的事件記錄檔的封存排程的事件。  
  
   
  
## Examples  
 下列範例會列舉在本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">將新的項目寫入事件記錄檔的溢位行為。</param>
        <param name="retentionDays">每一個事件記錄檔項目會保留的最小天數。 只有當 <paramref name="action" /> 設定為 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> 時，才會使用這個參數。</param>
        <summary>當事件記錄檔到達最大檔案大小時，變更寫入新項目的已設定行為。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件記錄檔的溢位行為會指定要寫入的記錄檔已達到其最大檔案大小，新的項目時，會發生什麼事。  
  
> [!NOTE]
>  溢位行為在事件記錄檔達到檔案大小上限時，才會生效。 溢位行為不會影響新的項目寫入記錄檔可容納額外的事件記錄項目。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法則會設定事件記錄檔的溢位行為。 <xref:System.Diagnostics.EventLog> 執行個體。 呼叫這個方法所指定的事件記錄檔之後<xref:System.Diagnostics.EventLog.Log%2A>屬性，<xref:System.Diagnostics.EventLog.OverflowAction%2A>和<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>屬性的值反映的新設定的溢位行為。  
  
> [!NOTE]
>  這個屬性表示此執行個體所代表的事件記錄檔的組態設定。 當事件記錄檔達到大小上限時，此屬性會指定作業系統如何處理新的項目寫入事件記錄檔註冊的所有事件來源。  
  
 設定`action`參數來<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>表示，新的項目會覆寫舊的項目時<xref:System.Diagnostics.EventLog>達到最大值。 如果`action`參數設定為<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>，則`retentionDays`參數值會被忽略。  
  
 設定`action`參數來<xref:System.Diagnostics.OverflowAction.OverwriteOlder>表示，每個新的項目會覆寫較舊的項目時<xref:System.Diagnostics.EventLog>達到最大值。 指定在記錄檔中使用的事件必須保留的天數`retentionDays`參數。 寫入的保留範圍內的事件不會覆寫新的項目。  
  
 設定`action`參數來<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>捨棄新的事件，當達到最大記錄大小。 如果`action`參數設定為<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>，則`retentionDays`參數值會被忽略。  
  
> [!CAUTION]
>  將溢位的原則設定為<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>指定事件記錄檔已滿時，就會捨棄新的項目。 如果您使用此設定，請確定事件記錄檔定期封存和清除，以避免達到其大小上限。  
  
   
  
## Examples  
 下列範例顯示針對指定的事件記錄檔中，已設定的溢位原則，並允許使用者選取新的溢位原則設定事件記錄檔。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 不是有效的 <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retentionDays" /> 小於 1 或大於 365。</exception>
        <exception cref="T:System.InvalidOperationException">這個 <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的記錄檔名稱。  
  
-或- 
無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當事件記錄檔到達最大記錄檔大小時，取得儲存新項目的已設定行為。</summary>
        <value><see cref="T:System.Diagnostics.OverflowAction" /> 值，指定當事件記錄檔到達最大記錄檔大小時，儲存新項目的已設定行為。 預設值為 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在新的事件會寫入事件記錄檔大小變大。 每個事件記錄檔已設定的最大大小的限制;<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>屬性會定義事件記錄檔大小所允許的 kb 數目上限。  
  
 使用<xref:System.Diagnostics.EventLog.OverflowAction%2A>檢查事件記錄檔的最大大小的已設定的溢位行為的屬性值。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法，以變更事件記錄檔的溢位行為。  
  
> [!NOTE]
>  溢位行為在事件記錄檔達到檔案大小上限時，才會生效。 溢位行為不會影響新的項目寫入記錄檔可容納額外的事件記錄項目。  
  
   
  
## Examples  
 下列範例會列舉在本機電腦上定義的事件記錄檔，並顯示每個事件記錄檔的組態詳細資料。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">當地語系化資源檔的完整指定路徑。</param>
        <param name="resourceId">資源識別項，可為資源檔內的當地語系化字串編排索引。</param>
        <summary>指定事件記錄檔的當地語系化名稱，這會顯示在伺服器的 [事件檢視器] 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>註冊，並顯示自訂事件記錄檔的事件檢視器的當地語系化的名稱。  
  
 指定的資源識別碼必須對應到資源檔中定義的當地語系化字串。 事件檢視器會顯示使用當地語系化的字串和目前的文化特性設定的自訂事件記錄檔名稱。 例如，您可以定義多個資源檔中的不同文化特性的當地語系化的事件記錄檔名稱。 事件檢視器會顯示對應到目前使用者的文化特性設定當地語系化的字串。  
  
 如果事件檢視器無法載入當地語系化的字串，從資源檔，或如果沒有顯示名稱已登錄事件記錄檔，事件檢視器顯示中定義的事件記錄檔名稱<xref:System.Diagnostics.EventLog.Log%2A>。  
  
> [!NOTE]
>  您不需要註冊預先定義的事件記錄檔的顯示名稱。 作業系統會註冊應用程式、 系統及安全性事件記錄檔的當地語系化的顯示名稱。  
  
   
  
## Examples  
 下列範例會判斷是否事件來源名為`SampleApplicationSource`登錄在本機電腦上。 如果事件來源不存在，此範例會設定為來源的訊息資源檔，並建立新的事件來源。 最後，範例會設定事件記錄檔，使用中的資源識別碼值的當地語系化的顯示名稱`DisplayNameMsgId`中的資源檔路徑和`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 此範例會使用下列的訊息文字檔案，內建資源庫 EventLogMsgs.dll。 訊息文字檔案是從其中建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。 具體而言，資源識別元 5001 定義事件記錄檔的當地語系化名稱。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個 <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的記錄檔名稱。  
  
-或- 
無法在目標電腦上開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於管理的電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定寫入至事件記錄檔時登錄和使用的來源名稱。</summary>
        <value>這個名稱 (具有事件記錄檔)，被登錄為項目的來源。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件來源會指出項目會記錄事件。 它通常是應用程式的名稱或名稱的子元件的應用程式，如果應用程式很大。 應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。  
  
 您只需要指定事件來源，如果您要寫入事件記錄檔。 前一個項目寫入事件記錄檔中，您必須向事件來源事件記錄檔為有效的事件來源。 當您撰寫的記錄項目時，系統會使用<xref:System.Diagnostics.EventLog.Source%2A>屬性，以尋找適當的記錄檔，在其中放置您的項目。 如果您正在讀取事件記錄檔，您可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或有<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接到本機電腦上的記錄檔。 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 ("。") 會假設。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>將事件寫入事件記錄檔。 您必須指定要寫入事件，事件來源您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 您可以建立現有的事件記錄檔或新的事件記錄檔的事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但直到第一個項目寫入至其中，才會建立記錄檔。  
  
 來源必須是唯一的本機電腦上，新的來源名稱不符合現有的來源名稱或現有的事件記錄檔名稱。 每個來源一次; 可以寫入只有一個事件記錄檔不過，您的應用程式也可以使用多個來源，以寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔。  
  
 如果您變更<xref:System.Diagnostics.EventLog.Source%2A>值，<xref:System.Diagnostics.EventLog>來登錄它已關閉，且會釋放所有的事件控制代碼。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
 若要變更現有的來源的設定詳細資料，您必須刪除來源，並再建立新的組態。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不是刪除現有來源建立新的來源。  
  
> [!NOTE]
>  如果來源已對應至記錄重新對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果不存在，它的項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜尋指定事件來源的電腦的登錄。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件來源的名稱。</param>
        <summary>判斷事件來源是否登錄於本機電腦上。</summary>
        <returns>如果事件來源登錄於本機電腦上，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，以判斷事件來源是否存在於本機電腦上。 如果您想要判斷記錄檔是否存在於本機電腦，也就是使用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 由於這個方法會存取登錄，您還必須擁有適當的登錄權限，本機電腦上，否則，<xref:System.Security.SecurityException>就會擲回。  
  
> [!NOTE]
>  若要搜尋的事件來源，在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是所有的事件記錄檔，包括安全性、 必須要搜尋以判斷事件來源是否唯一。 從 Windows Vista 開始，使用者沒有權限以存取安全性記錄檔中;因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  從 Windows Vista 開始，使用者帳戶控制 (UAC) 會決定使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
> [!NOTE]
>  執行下一個服務<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帳戶沒有執行這個方法所需的權限。 解決方法是檢查 事件來源是否存在於<xref:System.ServiceProcess.ServiceInstaller>，而且如果它不存在，安裝程式中建立的來源。  
  
 因為您無法提供新的來源的同一部電腦上現有的來源名稱，然後再嘗試使用這個方法來呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以確保來源所指定的名稱與`source`不存在本機電腦上。 `source`參數不區分大小寫。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果不存在，它的項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">找不到 <paramref name="source" />，但無法搜尋部分或全部的事件記錄檔。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件來源的名稱。</param>
        <param name="machineName">要在其上進行尋找的電腦的名稱，或者表示本機電腦的 "."。</param>
        <summary>判斷事件來源是否登錄於指定的電腦上。</summary>
        <returns>如果事件來源註冊於指定的電腦上，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來判斷所指定的電腦上是否存在的事件來源`machineName`參數。 如果您想要判斷記錄檔是否存在於指定的電腦，使用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 由於這個方法會存取登錄，您必須擁有適當的登錄權限指定伺服器上否則，<xref:System.Security.SecurityException>就會擲回。  
  
> [!NOTE]
>  若要搜尋的事件來源，在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。  
>   
>  這項需求的原因是所有的事件記錄檔，包括安全性、 必須要搜尋以判斷事件來源是否唯一。 從 Windows Vista 開始，使用者沒有權限以存取安全性記錄檔中;因此，<xref:System.Security.SecurityException>就會擲回。  
>   
>  從 Windows Vista 開始，使用者帳戶控制 (UAC) 會決定使用者的權限。 如果您是內建 Administrators 群組的成員，系統會將兩個執行階段存取語彙基元 (Token) 指派給您：標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行存取效能計數器的程式碼，您必須先將您的權限從標準使用者提高為系統管理員。 您可以在啟動應用程式時，以滑鼠右鍵按一下應用程式圖示，並指出您想要以系統管理員身分執行，藉此提高為系統管理員權限。  
  
> [!NOTE]
>  執行下一個服務<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帳戶沒有執行這個方法所需的權限。 解決方法是檢查 事件來源是否存在於<xref:System.ServiceProcess.ServiceInstaller>，而且如果它不存在，安裝程式中建立的來源。  
  
 因為您無法提供新的來源的同一部電腦上現有的來源名稱，然後再嘗試使用這個方法來呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以確保來源所指定的名稱與`source`不存在的電腦上。 `source`和`machineName`參數不區分大小寫。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> 是`static`方法，所以它可以呼叫類別本身。 您不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`電腦上`MyServer`，並將項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 為無效的電腦名稱。</exception>
        <exception cref="T:System.Security.SecurityException">找不到 <paramref name="source" />，但無法搜尋部分或全部的事件記錄檔。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定物件，其用於封送處理 (Marshal) 因為 <see cref="T:System.Diagnostics.EventLog" /> 項目寫入事件而發出的事件處理常式呼叫。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用來封送處理因為事件記錄檔上的 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件而發出的事件處理常式呼叫。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>已`null`，方法處理<xref:System.Diagnostics.EventLog.EntryWritten>系統執行緒集區的執行緒上呼叫事件。 如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。  
  
 當<xref:System.Diagnostics.EventLog.EntryWritten>事件由 visual 的 Windows Form 元件，例如按鈕，存取透過系統執行緒集區的元件可能無法運作，或可能會導致例外狀況處理。 藉由設定避免這<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>至 Windows Form 元件，因而導致處理方法<xref:System.Diagnostics.EventLog.EntryWritten>元件建立所在的相同執行緒上呼叫的事件。  
  
 如果<xref:System.Diagnostics.EventLog>使用於內部[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>會自動設為控制包含<xref:System.Diagnostics.EventLog>。 比方說，如果您放置<xref:System.Diagnostics.EventLog>Form1 設計工具上 (繼承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>屬性<xref:System.Diagnostics.EventLog>設為 Form1 的執行個體。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將項目寫入事件記錄檔中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <summary>將具有指定訊息文字的資訊類型項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法將資訊項目寫入事件記錄檔與此相關聯<xref:System.Diagnostics.EventLog>執行個體。 如果您想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，請使用不同的多載的<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性上的您<xref:System.Diagnostics.EventLog>元件之前，您可以寫入記錄檔中的項目。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定的來源<xref:System.Diagnostics.EventLog.Source%2A>屬性的<xref:System.Diagnostics.EventLog>執行個體已不會寫入您的元件，在電腦上註冊<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>為您<xref:System.Diagnostics.EventLog>執行個體，然後再呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統必須註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>並<xref:System.Diagnostics.EventLog.Log%2A>未在設定屬性您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  許多上面所列的例外狀況所產生的註冊程序期間引發的錯誤<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果不存在，它的項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
-或- 
該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
-或- 
來源已經登錄用於不同的事件記錄檔。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <summary>將具有指定訊息文字的錯誤、警告、資訊、成功稽核或失敗稽核項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來寫入指定的項目<xref:System.Diagnostics.EventLogEntryType>事件記錄檔。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性上的您<xref:System.Diagnostics.EventLog>元件之前，您可以寫入記錄檔中的項目。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定的來源<xref:System.Diagnostics.EventLog.Source%2A>屬性的<xref:System.Diagnostics.EventLog>執行個體已不會寫入您的元件，在電腦上註冊<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>為您<xref:System.Diagnostics.EventLog>執行個體，然後再呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統必須註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>並<xref:System.Diagnostics.EventLog.Log%2A>未在設定屬性您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況所產生的註冊程序期間引發的錯誤<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
  
   
  
## Examples  
 下列範例會警告項目寫入事件記錄檔時，「 MyNewLog 」，在本機電腦上。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
-或- 
該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
-或- 
來源已經登錄用於不同的事件記錄檔。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <summary>使用指定的登錄事件來源，將具有指定訊息文字的資訊類型項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個方法，將資訊項目寫入事件記錄檔，使用已註冊為適當的記錄檔的事件來源的來源。 如果您想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，請使用不同的多載的<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
>   
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
   
  
## Examples  
 下列範例會建立來源`MySource`如果不存在，它的項目寫入事件記錄檔`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空白字串 ("")。  
  
-或- 
<paramref name="source" /> 值為 <see langword="null" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <summary>將有指定訊息文字和應用程式定義的事件識別項的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`eventID`事件記錄檔。 `eventID`來源以及唯一識別事件。 每個應用程式可以定義自己已編號的事件，而且它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者了解發生的錯誤，並建議要採取的動作。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
 除了事件識別碼，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性上的您<xref:System.Diagnostics.EventLog>元件之前，您可以寫入記錄檔中的項目。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定的來源<xref:System.Diagnostics.EventLog.Source%2A>屬性的<xref:System.Diagnostics.EventLog>執行個體已不會寫入您的元件，在電腦上註冊<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>為您<xref:System.Diagnostics.EventLog>執行個體，然後再呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統必須註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>並<xref:System.Diagnostics.EventLog.Log%2A>未在設定屬性您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況所產生的註冊程序期間引發的錯誤<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
-或- 
該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
-或- 
來源已經登錄用於不同的事件記錄檔。  
  
-或- 
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <summary>用指定的登錄事件來源，將有指定訊息文字的錯誤、警告、資訊、成功稽核或失敗稽核項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來寫入指定的項目<xref:System.Diagnostics.EventLogEntryType>事件記錄檔中，使用來源已經註冊為適當的記錄檔的事件來源。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
  
   
  
## Examples  
 下列範例會警告項目寫入事件記錄檔時，「 MyNewLog 」，在本機電腦上。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空白字串 ("")。  
  
-或- 
<paramref name="source" /> 值為 <see langword="null" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <summary>將具有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`category`事件記錄檔。 事件檢視器會使用要寫入的事件來源篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以做為資源識別項使用的類別，來顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `category`參數應該是正數值。 負類別目錄值會顯示為互補的正數值在事件檢視器。 例如，-10 會顯示為 65526，-1 為 65535。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
 若要顯示在事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔，以設定和設定`category`分類資源檔中的資源識別碼。 如果事件來源並沒有設定的分類資源檔，或指定`category`不會編製索引的字串，在類別資源檔案中，則 事件檢視器會顯示該項目的數值分類值。 設定的分類資源檔，以及類別目錄中的字串數目資源檔案中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 除了在類別中，您可以指定正在寫入事件記錄檔事件的事件識別項。 事件識別碼，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己已編號的事件，而且它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者了解發生的錯誤，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性上的您<xref:System.Diagnostics.EventLog>元件之前，您可以寫入記錄檔中的項目。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定的來源<xref:System.Diagnostics.EventLog.Source%2A>屬性的<xref:System.Diagnostics.EventLog>執行個體已不會寫入您的元件，在電腦上註冊<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>為您<xref:System.Diagnostics.EventLog>執行個體，然後再呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統必須註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>並<xref:System.Diagnostics.EventLog.Log%2A>未在設定屬性您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況所產生的註冊程序期間引發的錯誤<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
-或- 
該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
-或- 
來源已經登錄用於不同的事件記錄檔。  
  
-或- 
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <summary>使用指定的登錄事件來源，將有指定訊息文字和應用程式定義的事件識別項的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`eventID`事件記錄檔中，使用來源已經註冊為適當的記錄檔的事件來源。 `eventID`，以及原始程式碼，可唯一識別事件。 每個應用程式可以定義自己已編號的事件，而且它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者了解發生的錯誤，並建議要採取的動作。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
 除了事件識別碼，這個多載<xref:System.Diagnostics.EventLog.WriteEntry%2A>可讓您指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空白字串 ("")。  
  
-或- 
<paramref name="source" /> 值為 <see langword="null" />。  
  
-或- 
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <param name="rawData">保存與項目相關的二進位資料的位元組陣列。</param>
        <summary>將有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔，並將二進位資料附加到訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此多載，寫入事件記錄檔中的應用程式定義的事件特定資料。 事件檢視器不會解譯這項資料;它只能在組合的十六進位和文字格式顯示未經處理資料。 使用事件特定資料盡量節制，包括它只有在確定會很有用交給偵錯問題。 您也可以使用事件特定資料，來儲存應用程式可以處理獨立於事件檢視器的資訊。 比方說，您可以特別為您的事件，撰寫一個檢視器，或編寫一個程式，會掃描記錄檔，並建立報告，其中包含從事件特定資料的資訊。  
  
 除了二進位資料，您可以指定應用程式定義的類別目錄和應用程式定義的事件識別項。 事件檢視器會使用要寫入的事件來源篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以做為資源識別項使用的類別，來顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
> [!NOTE]
>  `category`參數應該是正數值。 負類別目錄值會顯示為互補的正數值在事件檢視器。 例如，-10 會顯示為 65526，-1 為 65535。  
  
 若要顯示在事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔，以設定和設定`category`分類資源檔中的資源識別碼。 如果事件來源並沒有設定的分類資源檔，或指定`category`不會編製索引的字串，在類別資源檔案中，則 事件檢視器會顯示該項目的數值分類值。 設定的分類資源檔，以及類別目錄中的字串數目資源檔案中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 事件識別碼，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己已編號的事件，而且它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者了解發生的錯誤，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性上的您<xref:System.Diagnostics.EventLog>元件之前，您可以寫入記錄檔中的項目。 您必須建立並設定事件來源寫入來源的第一個項目之前。  
  
 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 如果在指定的來源<xref:System.Diagnostics.EventLog.Source%2A>屬性的<xref:System.Diagnostics.EventLog>執行個體已不會寫入您的元件，在電腦上註冊<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>為您<xref:System.Diagnostics.EventLog>執行個體，然後再呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 ("。") 會假設。  
  
 如果系統必須註冊<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>並<xref:System.Diagnostics.EventLog.Log%2A>未在設定屬性您<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔。  
  
> [!NOTE]
>  以上所列的許多例外狀況所產生的註冊程序期間引發的錯誤<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端電腦時，訊息 （文字字串） 的值可能無法預期如果遠端電腦未執行.NET Framework。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
-或- 
該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
-或- 
來源已經登錄用於不同的事件記錄檔。  
  
-或- 
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <summary>使用指定的登錄事件來源，將有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔。 <paramref name="category" /> 可以讓事件檢視器用來篩選記錄檔中的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來撰寫應用程式定義的項目`category`事件記錄檔中，使用 已註冊為適當的記錄檔的事件來源的來源。 事件檢視器會使用要寫入的事件來源篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以做為資源識別項使用的類別，來顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `category`參數應該是正數值。 負類別目錄值會顯示為互補的正數值在事件檢視器。 例如，-10 會顯示為 65526，-1 為 65535。  
  
 若要顯示在事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔，以設定和設定`category`分類資源檔中的資源識別碼。 如果事件來源並沒有設定的分類資源檔，或指定`category`不會編製索引的字串，在類別資源檔案中，則 事件檢視器會顯示該項目的數值分類值。 設定的分類資源檔，以及類別目錄中的字串數目資源檔案中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 除了在類別中，您可以指定正在寫入事件記錄檔事件的事件識別項。 事件識別碼，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己已編號的事件，而且它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者了解發生的錯誤，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
>   
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空白字串 ("")。  
  
-或- 
<paramref name="source" /> 值為 <see langword="null" />。  
  
-或- 
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">將應用程式註冊在指定電腦上的來源。</param>
        <param name="message">要寫入事件記錄檔的字串。</param>
        <param name="type">其中一個 <see cref="T:System.Diagnostics.EventLogEntryType" /> 值。</param>
        <param name="eventID">事件的應用程式特定識別項。</param>
        <param name="category">與訊息相關的應用程式特定的子分類。</param>
        <param name="rawData">保存與項目相關的二進位資料的位元組陣列。</param>
        <summary>將有指定訊息文字、應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔 (使用指定的登錄事件來源)，並將二進位資料附加到訊息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法，將應用程式定義的事件特定資料寫入事件記錄檔，使用已註冊為適當的記錄檔的事件來源的來源。 事件檢視器不會解譯這項資料;它只能在組合的十六進位和文字格式顯示未經處理資料。 謹慎使用; 使用事件特定的資料確定會很有用時，才將它包含。 您也可以使用事件特定資料，來儲存應用程式可以處理獨立於事件檢視器的資訊。 比方說，您可以特別為您的事件，撰寫一個檢視器，或編寫一個程式，會掃描記錄檔，並建立報告，其中包含從事件特定資料的資訊。  
  
 除了二進位資料，您可以指定應用程式定義的類別目錄和應用程式定義的事件識別項。 事件檢視器會使用要寫入的事件來源篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以做為資源識別項使用的類別，來顯示的當地語系化類別目錄字串。  
  
> [!NOTE]
>  `category`參數應該是正數值。 負類別目錄值會顯示為互補的正數值在事件檢視器。 例如，-10，會顯示為 65526，-1 為 65535。  
  
 若要顯示在事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔，以設定和設定`category`分類資源檔中的資源識別碼。 如果事件來源並沒有設定的分類資源檔，或指定`category`不會編製索引的字串，在類別資源檔案中，則 事件檢視器會顯示該項目的數值分類值。 設定的分類資源檔，以及類別目錄中的字串數目資源檔案中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別。  
  
 事件識別碼，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己已編號的事件，而且它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者了解發生的錯誤，並建議要採取的動作。  
  
 最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。 `type`由圖示，然後在 事件檢視器記錄檔中的 類型 欄中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>寫入使用當地語系化的訊息資源檔之事件的方法。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果`message`參數包含 NUL 字元，而事件記錄檔中的訊息會在 NUL 字元終止。  
>   
>  `message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空白字串 ("")。  
  
-或- 
<paramref name="source" /> 值為 <see langword="null" />。  
  
-或- 
 <paramref name="eventID" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
訊息字串的長度超過 31,839 個位元組 (在 Windows Vista 之前的 Windows 作業系統中為 32,766 位元組)。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將當地語系化的事件項目寫入事件記錄檔。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>將當地語系化的項目寫入事件記錄檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要當地語系化的項目寫入事件記錄檔中使用這個方法。 您可以指定事件屬性使用的資源識別項，而不是字串值。 事件檢視器使用的資源識別元來顯示的當地語系化的資源檔中的對應字串<xref:System.Diagnostics.EventLog.Source%2A>。 在您撰寫使用資源識別碼的事件之前，您必須註冊來源與對應的資源檔。  
  
 輸入`instance`執行個體指定的事件訊息和屬性。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源的訊息資源檔中定義的訊息。 您可以選擇性地設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>並<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`以定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息不包含取代字串的格式預留位置。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性，在您<xref:System.Diagnostics.EventLog>元件之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須具有定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，值`message`字串可能不是您預期如果遠端電腦未執行.NET Framework。 此外，`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
   
  
## Examples  
 下列範例會寫入兩個稽核事件記錄檔的項目`myNewLog`。 此範例會建立新的事件來源和新的事件記錄檔，如果不存在本機電腦上。 事件訊息文字被指定資源檔中使用的資源識別碼。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 此範例會使用下列的訊息文字檔案，內建資源庫 EventLogMsgs.dll。 訊息文字檔案是從其中建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
-或- 
該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
-或- 
來源已經登錄用於不同的事件記錄檔。  
  
-或- 
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
 <paramref name="values" /> 擁有超過 256 個項目。  
  
-或- 
其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="data">保存與項目相關的二進位資料的位元組陣列。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>以指定的事件資料、訊息取代字串和相關聯的二進位資料來寫入事件記錄檔項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法來寫入事件記錄檔的當地語系化的項目，與其他事件特定的資料。 您可以指定事件屬性使用的資源識別項，而不是字串值。 事件檢視器使用的資源識別元來顯示的當地語系化的資源檔中的對應字串<xref:System.Diagnostics.EventLog.Source%2A>。 在您撰寫使用資源識別碼的事件之前，您必須註冊來源與對應的資源檔。  
  
 輸入`instance`執行個體指定的事件訊息和屬性。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源的訊息資源檔中定義的訊息。 您可以選擇性地設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>並<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`以定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息不包含取代字串的格式預留位置。  
  
 指定的二進位資料與事件時就必須提供事件的其他詳細資料。 例如，使用`data`納入有關特定錯誤的參數。 事件檢視器不會解譯相關聯的事件資料它會顯示資料組合的十六進位和文字格式。 謹慎使用; 使用事件特定的資料確定會很有用時，才將它包含。 您也可以使用事件特定資料，來儲存應用程式可以處理獨立於事件檢視器的資訊。 比方說，您無法專為您的事件，撰寫一個檢視器，或編寫程式，以掃描事件記錄檔，並建立報告，其中包含從事件特定資料的資訊。  
  
 您必須設定<xref:System.Diagnostics.EventLog.Source%2A>屬性，在您<xref:System.Diagnostics.EventLog>元件之前使用的元件之前<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須具有定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
> [!NOTE]
>  如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>為您<xref:System.Diagnostics.EventLog>執行個體，然後再呼叫<xref:System.Diagnostics.EventLog.WriteEvent%2A>，本機電腦 ("。") 會假設。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
> [!NOTE]
>  如果您將項目寫入遠端的電腦時，值`message`字串可能不是您預期如果遠端電腦未執行.NET Framework。 此外，`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址可以包含這個字元順序，因為無法記錄事件訊息包含 IPv6 位址。  
  
   
  
## Examples  
 下列範例會寫入兩個稽核事件記錄檔的項目`myNewLog`。 此範例會建立新的事件來源和新的事件記錄檔，如果不存在本機電腦上。 事件訊息文字被指定資源檔中使用的資源識別碼。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 此範例會使用下列的訊息文字檔案，內建資源庫 EventLogMsgs.dll。 訊息文字檔案是從其中建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">還沒有設定 <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 屬性。  
  
-或- 
該方法已嘗試登錄新的事件來源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的電腦名稱無效。  
  
-或- 
來源已經登錄用於不同的事件記錄檔。  
  
-或- 
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
 <paramref name="values" /> 擁有超過 256 個項目。  
  
-或- 
其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">為指定電腦上的應用程式註冊的事件來源名稱。</param>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>以指定的事件資料、訊息取代字串，以及使用指定的已登錄事件來源，寫入事件記錄檔項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法將當地語系化的項目寫入事件記錄檔，使用已註冊為適當的記錄檔的事件來源的來源。 您可以指定事件屬性使用的資源識別項，而不是字串值。 事件檢視器會顯示對應的字串來源的當地語系化的資源檔使用的資源識別元。 在您撰寫使用資源識別碼的事件之前，您必須註冊來源與對應的資源檔。  
  
 輸入`instance`執行個體指定的事件訊息和屬性。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源的訊息資源檔中定義的訊息。 您可以選擇性地設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>並<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`以定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息不包含取代字串的格式預留位置。  
  
 您必須針對事件記錄檔註冊指定的來源，才能使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須具有定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
   
  
## Examples  
 下列範例會參考事件項目和警告事件項目寫入現有的事件記錄檔。 事件訊息文字被指定資源檔中使用的資源識別碼。 此範例假設來源已經註冊對應的資源檔。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 此範例會使用下列的訊息文字檔案，內建資源庫 EventLogMsgs.dll。 訊息文字檔案是從其中建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空白字串 ("")。  
  
-或- 
<paramref name="source" /> 值為 <see langword="null" />。  
  
-或- 
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
 <paramref name="values" /> 擁有超過 256 個項目。  
  
-或- 
其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">為指定電腦上的應用程式註冊的事件來源名稱。</param>
        <param name="instance"><see cref="T:System.Diagnostics.EventInstance" /> 執行個體，表示當地語系化的事件記錄項目。</param>
        <param name="data">保存與項目相關的二進位資料的位元組陣列。</param>
        <param name="values">要合併到事件記錄項目訊息文字的字串陣列。</param>
        <summary>以指定的事件資料、訊息取代字串和相關聯的二進位資料，以及使用指定的已登錄事件來源，寫入事件記錄檔項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法將當地語系化的項目，與其他事件特定的資料寫入事件記錄檔，使用已註冊為適當的記錄檔的事件來源的來源。 您可以指定事件屬性使用的資源識別項，而不是字串值。 事件檢視器會顯示對應的字串來源的當地語系化的資源檔使用的資源識別元。 在您撰寫使用資源識別碼的事件之前，您必須註冊來源與對應的資源檔。  
  
 輸入`instance`執行個體指定的事件訊息和屬性。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源的訊息資源檔中定義的訊息。 您可以選擇性地設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>並<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`以定義您的事件項目分類和事件類型的輸入。 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息不包含取代字串的格式預留位置。  
  
 指定的二進位資料與事件時就必須提供事件的其他詳細資料。 例如，使用`data`納入有關特定錯誤的參數。 事件檢視器不會解譯相關聯的事件資料它會顯示資料組合的十六進位和文字格式。 謹慎使用; 使用事件特定的資料確定會很有用時，才將它包含。 您也可以使用事件特定資料，來儲存應用程式可以處理獨立於事件檢視器的資訊。 比方說，您無法專為您的事件，撰寫一個檢視器，或編寫程式，以掃描事件記錄檔，並建立報告，其中包含從事件特定資料的資訊。  
  
 您必須針對事件記錄檔註冊指定的來源，才能使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須具有定義的訊息資源檔。  
  
 您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而您嘗試寫入新的來源的事件寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 您必須建立新的事件來源電腦上具有系統管理權限。  
  
 寫入當地語系化的項目或寫入的直接存取的字串，則必須設定的來源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式事件記錄檔中直接寫入字串值。  
  
 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 比方說，使用資源檔，設定一個來源，然後使用該來源中的<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法寫入事件記錄檔的資源識別項的項目。 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。  
  
   
  
## Examples  
 下列範例會參考事件項目和警告事件項目寫入現有的事件記錄檔。 事件訊息文字被指定資源檔中使用的資源識別碼。 此範例假設來源已經註冊對應的資源檔。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 此範例會使用下列的訊息文字檔案，內建資源庫 EventLogMsgs.dll。 訊息文字檔案是從其中建立訊息資源檔的來源。 訊息文字檔案定義的資源識別碼和類別目錄、 事件訊息和參數插入字串的文字。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空白字串 ("")。  
  
-或- 
<paramref name="source" /> 值為 <see langword="null" />。  
  
-或- 
 <paramref name="instance.InstanceId" /> 小於零或大於 <see cref="F:System.UInt16.MaxValue" />。  
  
-或- 
 <paramref name="values" /> 擁有超過 256 個項目。  
  
-或- 
其中一個 <paramref name="values" /> 項目的長度超過 32766 個位元組。  
  
-或- 
來源名稱產生的登錄機碼路徑長度超過 254 個字元。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">無法開啟事件記錄檔的登錄機碼。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">作業系統在將事件項目寫入事件記錄檔時回報錯誤。 無法使用 Windows 錯誤碼。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用於寫入在電腦上的事件記錄檔資訊。 相關聯的列舉型別： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>