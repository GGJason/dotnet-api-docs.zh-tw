<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f3b937515accae8f91569e4cac09306f70365d0" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061725" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供對本機和遠端處理序的存取，並讓您能夠啟動和停止本機系統處理序。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>元件所提供的存取權執行的電腦的處理序。 處理程序，最簡單的說，是執行中應用程式。 執行緒是作業系統會配置處理器時間的基本單位。 執行緒可以執行此程序，包括由另一個執行緒目前正在執行的組件的程式任何的碼部分。  
  
 <xref:System.Diagnostics.Process>元件是有用的工具，啟動、 停止、 控制和監視應用程式。 您可以使用<xref:System.Diagnostics.Process>元件，以取得所執行的處理程序的清單，或者您可以啟動新的處理序。 A<xref:System.Diagnostics.Process>元件用來存取系統處理序。 之後<xref:System.Diagnostics.Process>元件已經初始化，它可以用來取得執行中處理序的相關資訊。 這類資訊包括的執行緒，已載入的模組 （.dll 和.exe 檔案） 集，且使用效能資訊，例如處理程序的記憶體數量。  
  
 此類型會實作<xref:System.IDisposable>介面。 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
> [!NOTE]
>  32 位元處理序無法存取 64 位元處理序的模組。 如果您嘗試從 32 位元處理序取得 64 位元處理序的相關資訊，您會收到<xref:System.ComponentModel.Win32Exception>例外狀況。 相反地，64 位元處理程序，可以存取 32 位元處理序的模組。  
  
 處理序元件會取得全部的屬性群組的相關資訊。 之後<xref:System.Diagnostics.Process>元件已取得的任何群組的一個成員的相關資訊，它將會快取該群組中的其他屬性的值，並不取得新資訊的其他群組成員，直到您呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。 因此，如果屬性值不保證能夠比上次呼叫任何新<xref:System.Diagnostics.Process.Refresh%2A>方法。 群組細項是作業系統相依。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。 否則，系統將不到路徑。 例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。  
  
 系統處理序是以唯一識別系統上處理序識別碼。 如同許多 Windows 資源，也是由其控制代碼，可能不是唯一的電腦上識別處理程序。 控點是泛型的詞彙，資源的識別項。 作業系統持續發生的處理序控制代碼，可從存取<xref:System.Diagnostics.Process.Handle%2A>屬性<xref:System.Diagnostics.Process>元件，即使在處理序已經結束。 因此，您可以取得處理序的系統管理資訊，例如<xref:System.Diagnostics.Process.ExitCode%2A>（通常是零的成功或為非零的錯誤程式碼） 和<xref:System.Diagnostics.Process.ExitTime%2A>。 控制代碼是非常重要的資源，所以遺漏控制更 virulent 比流失記憶體。  
  
> [!NOTE]
>  這個類別包含的連結要求和繼承要求套用到所有成員的類別層級。 A<xref:System.Security.SecurityException>立即呼叫者或衍生的類別並沒有完全信任權限時，會擲回。 如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)。  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] 附註  
 在.NET Framework 中，<xref:System.Diagnostics.Process>類別預設會使用<xref:System.Console>編碼方式，通常是程式碼頁編碼方式，輸入、 輸出和錯誤資料流。 如需範例程式碼，在系統上的文化特性是英文 （美國），字碼頁 437 則是預設編碼方式<xref:System.Console>類別。 不過，[!INCLUDE[net_core](~/includes/net-core-md.md)]可能提供只這些編碼方式的有限的子集。 如果這種情況，它會使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>做為預設編碼。  
  
 如果<xref:System.Diagnostics.Process>物件相依於特定字碼頁編碼方式，您仍然可以它們可執行下列步驟*之前*呼叫任何<xref:System.Diagnostics.Process>方法：  
  
1.  System.Text.Encoding.CodePages.dll 組件的參考加入至您的專案。  
  
2.  擷取<xref:System.Text.EncodingProvider>物件從<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>屬性。  
  
3.  傳遞<xref:System.Text.EncodingProvider>物件<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>進行額外的編碼方式編碼的提供者支援的方法。  
  
 <xref:System.Diagnostics.Process>類別然後將自動使用預設系統而不 UTF8 編碼方式，提供您已註冊編碼提供者，然後再呼叫任何<xref:System.Diagnostics.Process>方法。  
  
   
  
## Examples  
 下列範例會使用的執行個體<xref:System.Diagnostics.Process>啟動處理序的類別。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 下列範例會使用<xref:System.Diagnostics.Process>類別本身和靜態<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理序。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 下列的 F # 範例會定義`runProc`啟動的處理序的函式會擷取所有輸出和錯誤的資訊，並記錄的程序執行的毫秒數。  `runProc`函式具有三個參數： 若要啟動，引數提供給應用程式，並起始目錄的應用程式的名稱。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 程式碼`runProc`函式由寫入[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)和適用於[Microsoft Public License](https://opensource.org/licenses/ms-pl)。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個類別無法供部分信任程式碼。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">針對繼承者完全信任。 這個類別無法被繼承，部分信任程式碼。</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.Process" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未指定<xref:System.Diagnostics.Process.MachineName%2A>屬性，預設值為本機電腦 ("。")。  
  
 您有兩種方式來建立新的關聯<xref:System.Diagnostics.Process>元件之電腦上的處理序。 第一個選項是使用建構函式來建立<xref:System.Diagnostics.Process>元件設定的適當成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性並呼叫<xref:System.Diagnostics.Process.Start%2A>關聯<xref:System.Diagnostics.Process>與新的系統處理序。 第二個選項會使<xref:System.Diagnostics.Process>具有執行系統處理序使用<xref:System.Diagnostics.Process.GetProcessById%2A>或其中一個<xref:System.Diagnostics.Process.GetProcesses%2A>傳回值。  
  
 如果您使用`static`多載<xref:System.Diagnostics.Process.Start%2A>方法來啟動新的系統處理序，該方法會建立新<xref:System.Diagnostics.Process>元件並將它與處理序相關聯。  
  
 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>屬性設為預設值， `true`，您可以使用類似的方式啟動應用程式和文件`Run`對話方塊中的 Windows `Start`功能表。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>是`false`，您就可以開始只可執行檔。  
  
 您可以從命令列呼叫任何可執行檔可以啟動兩種方式之一： 藉由設定的適當成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>方法使用任何參數，或藉由傳遞至適當的參數`static` <xref:System.Diagnostics.Process.Start%2A>成員。  
  
 您可以建立<xref:System.Diagnostics.Process>元件使用建構函式，其中一個靜態<xref:System.Diagnostics.Process.Start%2A>多載，或任何<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcesses%2A>，或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 這麼做之後，您必須讓您檢視相關聯的處理序。 這不會自動更新本身，當處理序屬性已變更在記憶體中的動態檢視。 相反地，您必須呼叫<xref:System.Diagnostics.Process.Refresh%2A>更新元件<xref:System.Diagnostics.Process>應用程式中的屬性資訊。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的基礎優先權 (Base Priority)。</summary>
        <value>基礎優先權，它是從相關聯處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 計算出來的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A>程序會建立相關聯的處理序中執行緒的起始優先順序。 您可以檢視透過系統監視器的優先權基底計數器的基礎優先權的相關資訊。  
  
 根據 24 小時制或其他優先權的提高，作業系統可以變更的基底的優先順序，當處理程序應該放在其他人的前面的時間。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視指派給處理程序的起始優先權。 不過，因為它是唯讀，您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>設定程序的優先順序。 若要變更優先順序，請使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性。 <xref:System.Diagnostics.Process.BasePriority%2A>就可以檢視，使用系統監視器 」，而<xref:System.Diagnostics.Process.PriorityClass%2A>不是。 同時<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>可以透過程式設計方式檢視。 下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>值和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">處理序已經結束。  
  
 -或-  
  
 處理序尚未啟動，因此沒有處理序 ID。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上開始非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A>同步或非同步方式，就可以讀取資料流。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行同步處理程序的錯誤輸出資料流上的讀取的作業。 這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。 這個方法可讓資料流輸出指定之的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。  
  
 請遵循下列步驟來執行非同步的讀取的作業上<xref:System.Diagnostics.Process.StandardError%2A>如<xref:System.Diagnostics.Process>:  
  
1.  請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。  
  
2.  請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 為 `true`。  
  
3.  加入事件處理常式<xref:System.Diagnostics.Process.ErrorDataReceived>事件。 事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。  
  
4.  啟動<xref:System.Diagnostics.Process>。  
  
5.  呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>如<xref:System.Diagnostics.Process>。 此呼叫在開始非同步讀取的作業<xref:System.Diagnostics.Process.StandardError%2A>。  
  
 當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>將某行的文字寫入其<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 您可以藉由呼叫取消非同步讀取的作業<xref:System.Diagnostics.Process.CancelErrorRead%2A>。 讀取的作業可以取消由呼叫端事件處理常式。 之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 以繼續執行非同步的讀取的作業。  
  
> [!NOTE]
>  您不能混用重新導向資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
   
  
## Examples  
 下列範例會使用`net view`命令，列出在遠端電腦上的可用的網路資源。 使用者提供的目標電腦名稱做為命令列引數。 使用者也可以提供錯誤輸出的檔案名稱。 此範例會收集的 net 命令、 等候處理程序完成，然後再寫入至主控台的輸出結果的輸出。 如果使用者提供選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性為 <see langword="false" />。  
  
 \-或-  
  
 非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上進行。  
  
 \-或-  
  
 同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上開始非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A>同步或非同步方式，就可以讀取資料流。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流上的同步讀取的作業。 這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。  
  
 請遵循下列步驟來執行非同步的讀取的作業上<xref:System.Diagnostics.Process.StandardOutput%2A>如<xref:System.Diagnostics.Process>:  
  
1.  請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。  
  
2.  請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 為 `true`。  
  
3.  加入事件處理常式<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。  
  
4.  啟動<xref:System.Diagnostics.Process>。  
  
5.  呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>如<xref:System.Diagnostics.Process>。 此呼叫在開始非同步讀取的作業<xref:System.Diagnostics.Process.StandardOutput%2A>。  
  
 當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>將某行的文字寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
 您可以藉由呼叫取消非同步讀取的作業<xref:System.Diagnostics.Process.CancelOutputRead%2A>。 讀取的作業可以取消由呼叫端事件處理常式。 之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 以繼續執行非同步的讀取的作業。  
  
> [!NOTE]
>  您不能混用重新導向資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
   
  
## Examples  
 下列範例說明如何執行非同步的讀取的作業上的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流`sort`命令。 `sort`命令是主控台應用程式讀取及排序文字輸入。  
  
 此範例會建立為事件委派`SortOutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。 此事件處理常式收到來自的重新導向的文字行<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將文字寫入至螢幕。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 屬性為 <see langword="false" />。  
  
 \-或-  
  
 非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上進行。  
  
 \-或-  
  
 同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上取消非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardError%2A>資料流。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 結束非同步讀取作業。  
  
 之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>一次。  
  
 當您呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>，則所有進行中讀取作業<xref:System.Diagnostics.Process.StandardError%2A>完成，則會停用此事件處理常式。 所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardError%2A>儲存在緩衝區。 如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、 儲存的輸出會傳送至事件處理常式和非同步讀取的作業繼續執行。 如果您想要變更的事件處理常式，繼續進行非同步讀取的作業之前，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  您不能混用非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。 如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>，必須從資料流讀取一次，您必須使用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>繼續非同步讀取的作業。 請勿遵循<xref:System.Diagnostics.Process.CancelErrorRead%2A>讀取並具有呼叫同步方法<xref:System.Diagnostics.Process.StandardError%2A>例如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下列範例會啟動`nmake`命令與使用者提供的引數。 錯誤和輸出資料流讀取以非同步的方式;收集的文字行所顯示到主控台，以及寫入記錄檔。 如果命令輸出超過指定的行數，則會取消非同步讀取的作業。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上取消非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 結束非同步讀取作業。  
  
 之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>一次。  
  
 當您呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>，則所有進行中讀取作業<xref:System.Diagnostics.Process.StandardOutput%2A>完成，則會停用此事件處理常式。 所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardOutput%2A>儲存在緩衝區。 如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、 儲存的輸出會傳送至事件處理常式和非同步讀取的作業繼續執行。 如果您想要變更的事件處理常式，繼續進行非同步讀取的作業之前，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  您不能混用非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。 如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>，必須從資料流讀取一次，您必須使用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>繼續非同步讀取的作業。 請勿遵循<xref:System.Diagnostics.Process.CancelOutputRead%2A>讀取並具有呼叫同步方法<xref:System.Diagnostics.Process.StandardOutput%2A>例如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下列範例會啟動`nmake`命令與使用者提供的引數。 錯誤和輸出資料流讀取以非同步的方式;收集的文字行所顯示到主控台，以及寫入記錄檔。 如果命令輸出超過指定的行數，則會取消非同步讀取的作業。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放與這個元件相關的所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A>方法會導致處理程序停止等候結束等候它，如果關閉處理序控制代碼，並清除處理序專屬的屬性。 <xref:System.Diagnostics.Process.Close%2A> 不會關閉的標準輸出、 輸入和錯誤的讀取器和寫入器，如果它們要從外部參考。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> 方法呼叫 <xref:System.Diagnostics.Process.Close%2A>。 放置<xref:System.Diagnostics.Process>物件存放至`using`區塊處置的資源，而不需要呼叫<xref:System.Diagnostics.Process.Close%2A>。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 秒間隔的最大值為 10 秒。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，此範例會關閉處理序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉有使用者介面的處理序，方法是傳送關閉訊息至其主視窗。</summary>
        <returns>
          如果已成功傳送關閉訊息，則為 <see langword="true" />；如果相關聯處理序沒有主視窗或主視窗已停用 (例如，如果正在顯示強制回應對話方塊)，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當執行程序時，其訊息迴圈會處於等候狀態。 每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。 呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>接近主要視窗中，且格式正確的應用程式中，在關閉子視窗，並撤銷應用程式的所有執行訊息迴圈傳送的要求。 藉由呼叫結束程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。 應用程式可以要求使用者驗證，才能結束，或它可以拒絕結束。 若要強制執行應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗使用 [系統] 功能表的使用者。 因此，要求關閉主視窗結束處理程序不會強制立即結束應用程式。  
  
 編輯程序的資料或配置給處理序的資源可能會遺失如果您呼叫<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 導致處理程序異常終止，並在必要時才應該使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此最好有一個介面的應用程式。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。 <xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。  
  
 您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。 若要結束遠端電腦上，您無法讓處理程序。 您只能檢視遠端電腦上執行的處理序的資訊。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 的第二個時間間隔，最多為 10 秒。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，此範例會關閉處理序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">處理程序已經結束。  
  
 -或-  
  
 沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放這個處理序使用的所有資源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定是否應該在處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <value>
          如果應該在相關聯處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件 (經由結束或呼叫 <see cref="M:System.Diagnostics.Process.Kill" />)，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。 請注意，<see cref="E:System.Diagnostics.Process.Exited" />引發即使值<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />是<see langword="false" />於期間的處理序結束時，或使用者執行<see cref="P:System.Diagnostics.Process.HasExited" />檢查。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性建議當作業系統已關閉處理序時，是否應該通知元件。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性來處理非同步通知的處理序已結束您的應用程式。 若要強制同步等候結束事件 （會中斷應用程式的處理，直到結束事件發生） 的應用程式，請使用<xref:System.Diagnostics.Process.WaitForExit%2A>方法。

> [!NOTE]
> 如果您使用 Visual Studio，並按兩下<xref:System.Diagnostics.Process>元件在專案中，<xref:System.Diagnostics.Process.Exited>事件委派和事件處理常式會自動產生。 其他的程式碼集<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性`false`。 您必須變更此屬性為`true`相關聯的處理序結束時，要執行事件處理常式。

如果元件的<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>值是`true`，或當<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`false`和<xref:System.Diagnostics.Process.HasExited%2A>核取叫用元件，元件可以存取的相關聯的處理序會保留的系統管理資訊儲存作業系統。 這類資訊包括<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.ExitCode%2A>。

相關聯的處理序結束之後，<xref:System.Diagnostics.Process.Handle%2A>的元件不會再指向現有的處理序資源。 相反地，它可以只可用來存取作業系統的處理序資源相關的資訊。 作業系統是感知會結束處理程序尚未釋放的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保存<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>記憶體中的資訊。

沒有相關聯的處理序結束監看的成本。 如果<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`true`、<xref:System.Diagnostics.Process.Exited>相關聯的處理序終止時，就會引發事件。 您的程序<xref:System.Diagnostics.Process.Exited>事件在那時候執行。

有時候，您的應用程式啟動的處理序，但是不需要關閉的通知。 例如，您的應用程式可以啟動 [記事本] 來允許使用者執行文字編輯，但沒有進一步地使用 「 記事本 」 應用程式。 您可以選擇避免處理序結束，因為它不是適用於您的應用程式繼續作業的通知。 設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>至`false`可以節省系統資源。

## Examples  
下列程式碼範例會建立會列印檔案的處理序。 它會設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性，讓處理程序引發<xref:System.Diagnostics.Process.Exited>在結束時的事件。 <xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟用目前執行緒上的原生屬性 <see langword="SeDebugPrivilege" />，將 <see cref="T:System.Diagnostics.Process" /> 元件置於某種狀態，以便與使用特殊模式執行的作業系統處理序互動。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些作業系統處理程序執行中使用特殊模式。 嘗試讀取的屬性，或附加至這些處理序不能除非您已經呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。 呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取特殊模式執行這些程序。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於應用程式寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived>事件表示相關聯的處理序已寫入至其重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 事件只發生在非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>。 若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式來<xref:System.Diagnostics.Process.ErrorDataReceived>事件和呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 此後，<xref:System.Diagnostics.Process.ErrorDataReceived>事件訊號處理程序將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardError%2A>串流處理，直到處理程序會結束或呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>。  
  
> [!NOTE]
>  正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit>方法，以確保已清除輸出緩衝區。 請注意，使用該指定逾時<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>多載沒有*不*確保已清除輸出緩衝區。
  
   
  
## Examples  
 下列範例會使用`net view`命令，列出在遠端電腦上的可用的網路資源。 使用者提供的目標電腦名稱做為命令列引數。 使用者也可以提供錯誤輸出的檔案名稱。 此範例會收集的 net 命令、 等候處理程序完成，然後再寫入至主控台的輸出結果的輸出。 如果使用者提供選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序終止時指定的值。</summary>
        <value>相關處理序終止時指定的程式碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.ExitCode%2A>來取得系統處理序傳回其結束時的狀態。 您可以使用結束程式碼更像整數傳回的值從`main()`程序。  
  
 <xref:System.Diagnostics.Process.ExitCode%2A>處理程序會反映該處理程序的應用程式開發人員所實作的特定慣例的值。 如果您決定您的程式碼中使用的結束代碼值，請確定您知道應用程式處理序所使用的結束代碼慣例。  
  
 開發人員通常會表示成功的結束<xref:System.Diagnostics.Process.ExitCode%2A>值零，而指定的錯誤則為非零值呼叫的方法可以用來識別處理程序異常終止的原因。 不需要遵循下列指導方針，但它們是慣例。  
  
 如果您嘗試取得<xref:System.Diagnostics.Process.ExitCode%2A>處理序已經結束之前，嘗試就會擲回例外狀況。 檢查<xref:System.Diagnostics.Process.HasExited%2A>屬性第一次，確認是否已終止相關的處理序。  
  
> [!NOTE]
>  當非同步事件處理常式已經重新導向標準輸出時，您就可以確認輸出處理尚未完成時<xref:System.Diagnostics.Process.HasExited%2A>傳回`true`。 若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前會採用任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。  
  
 您可以使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>方法，讓相關聯的處理序結束。  
  
 有兩種方式的相關聯的處理序結束時通知： 同步和非同步方式。 同步通知依賴呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以暫停您的應用程式的處理，直到結束相關聯的元件。 非同步通知依賴<xref:System.Diagnostics.Process.Exited>事件。 當使用非同步通知，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`如<xref:System.Diagnostics.Process>元件來接收通知的處理序已結束。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">遠端處理序尚未結束。  
  
 -或-  
  
 處理序 <see cref="P:System.Diagnostics.Process.Handle" /> 無法使用。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於處理序結束時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited>事件表示相關聯的處理序已結束。 此項目表示處理程序結束 （中止） 或成功關閉。 只有當，可能會發生此事件的值<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性是`true`。  
  
 有兩種方式的相關聯的處理序結束時通知： 同步和非同步方式。 同步通知表示呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來封鎖目前的執行緒，直到結束處理程序。 使用非同步通知<xref:System.Diagnostics.Process.Exited>事件，可讓呼叫執行緒能夠繼續在同時執行。 在後者的情況下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`呼叫的應用程式接收訊號事件。  
  
 當作業系統關機程序時，它會通知所有已註冊的 Exited 事件處理常式的其他處理序。 在這個階段中，只要結束處理序控制代碼可用來存取某些屬性，例如<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.HasExited%2A>作業系統會維護，直到它完全解除該控制代碼。  
  
> [!NOTE]
>  即使您擁有已結束的處理序控制代碼時，您不能呼叫<xref:System.Diagnostics.Process.Start%2A>，重新連線至相同的處理序。 呼叫<xref:System.Diagnostics.Process.Start%2A>自動釋出相關的處理序，並連接到處理程序相同的檔案，但全新<xref:System.Diagnostics.Process.Handle%2A>。  
  
 如需有關使用<xref:System.Diagnostics.Process.Exited>事件在 Windows Forms 應用程式，請參閱<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會建立會列印檔案的處理序。 它會引發<xref:System.Diagnostics.Process.Exited>事件的處理序結束，因為<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>建立處理程序時，已設定屬性。 <xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關的處理序結束的時間。</summary>
        <value>
          <see cref="T:System.DateTime" />，表示相關聯處理序何時終止。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果還沒有終止處理程序，嘗試擷取<xref:System.Diagnostics.Process.ExitTime%2A>屬性會擲回的例外狀況。 使用<xref:System.Diagnostics.Process.HasExited%2A>再取得<xref:System.Diagnostics.Process.ExitTime%2A>屬性來判斷是否已終止相關的處理序。  
  
   
  
## Examples  
 下列程式碼範例會建立會列印檔案的處理序。 處理序引發<xref:System.Diagnostics.Process.Exited>時結束為止，事件和事件處理常式顯示<xref:System.Diagnostics.Process.ExitTime%2A>屬性和其他處理資訊。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與目前現用處理序相關聯。</summary>
        <returns>新的 <see cref="T:System.Diagnostics.Process" /> 元件，與正在執行呼叫應用程式的處理序資源相關聯。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新<xref:System.Diagnostics.Process>執行個體，並將它與本機電腦上的處理序資源關聯。  
  
 例如，類似<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcessesByName%2A>，和<xref:System.Diagnostics.Process.GetProcesses%2A>方法<xref:System.Diagnostics.Process.GetCurrentProcess%2A>將現有的資源與新<xref:System.Diagnostics.Process>元件。  
  
   
  
## Examples  
 下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。 然後，它會擷取相同的程序的遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與您指定的現有處理序資源相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">處理序資源的系統唯一識別項。</param>
        <summary>傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定本機電腦上的處理序識別項。</summary>
        <returns>
          <see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的本機處理序資源相關聯。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新<xref:System.Diagnostics.Process>元件並將它與本機電腦上的處理序資源關聯。 處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>並不會建立系統資源，但而不是關聯應用程式所產生的資源<xref:System.Diagnostics.Process>元件。 處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理序。 在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>擲回例外狀況，如果您傳遞給它過期的識別項。  
  
 在任何特定電腦上的處理程序的識別項是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多會傳回其中一個處理序。 如果您想要取得執行特定應用程式使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果執行指定的應用程式的電腦上存在多個處理序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，其中包含所有相關聯的處理序。 您可以查詢每個這些處理序的識別碼。 可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員。 `PID`資料行會顯示指派給處理程序的處理序識別碼。  
  
   
  
## Examples  
 下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。 然後，它會擷取相同的程序的遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 參數指定的處理序未執行。 識別碼可能過期。</exception>
        <exception cref="T:System.InvalidOperationException">這個物件未啟動處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">處理序資源的系統唯一識別項。</param>
        <param name="machineName">網路上的電腦名稱。</param>
        <summary>傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定網路上電腦的處理序識別項和名稱。</summary>
        <returns>
          <see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的遠端處理序資源相關聯。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新<xref:System.Diagnostics.Process>元件並將它與網路上的遠端電腦上的處理序資源關聯。 處理序資源必須已經存在於指定的電腦，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>並不會建立系統資源，但而不是關聯應用程式所產生的資源<xref:System.Diagnostics.Process>元件。 處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理序。 在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>擲回例外狀況，如果您傳遞給它過期的識別項。  
  
 在任何特定電腦上的處理程序的識別項是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多會傳回其中一個處理序。 如果您想要取得執行特定應用程式使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果執行指定的應用程式的電腦上存在多個處理序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，其中包含所有相關聯的處理序。 您可以查詢每個這些處理序的識別碼。 可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員。 `PID`資料行會顯示指派給處理程序的處理序識別碼。  
  
 如果您未指定`machineName`，會使用本機電腦。 或者，您可以指定本機電腦，藉由設定`machineName`值 」。 「 或為空字串 ("")。  
  
   
  
## Examples  
 下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。 然後，它會擷取相同的程序的遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 參數指定的處理序未執行。 識別項可能過期。  
  
 -或-  
  
 <paramref name="machineName" /> 參數的語法無效。 其長度有可能為零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">這個物件未啟動處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與現有的處理序資源相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為本機電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</summary>
        <returns>
          <see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在本機電腦上執行的所有處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與本機電腦上的所有處理序資源建立關聯。 處理序資源必須已經存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>並不會建立系統資源，但而是將資源與應用程式產生相關聯<xref:System.Diagnostics.Process>元件。 因為作業系統本身已執行背景處理程序，這個陣列絕不會是空的。  
  
 如果不想擷取所有的電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>與傳遞至方法的處理序識別碼所識別的系統上的處理序相關聯的元件。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立的陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。  
  
> [!NOTE]
>  可以載入多個 Windows 服務，服務主機處理序 (svchost.exe) 相同的執行個體內。 GetProcesses 不會識別這些個別的服務。因此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。 然後，它會擷取相同的程序的遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">要讀取處理序清單的電腦。</param>
        <summary>為指定電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</summary>
        <returns>
          <see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在指定的電腦上執行的所有處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與指定的 （通常是遠端） 電腦上的所有處理序資源建立關聯。 處理序資源必須已經存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>並不會建立系統資源，但而是將資源與應用程式產生相關聯<xref:System.Diagnostics.Process>元件。 因為作業系統本身已執行背景處理程序，這個陣列絕不會是空的。  
  
 如果不想擷取所有的電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>與傳遞至方法的處理序識別碼所識別的系統上的處理序相關聯的元件。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立的陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。  
  
 這個多載<xref:System.Diagnostics.Process.GetProcesses%2A>方法通常用來擷取在網路上，在遠端電腦上執行的處理序資源的清單，但是您可以指定本機電腦，藉由傳遞 」。 」。  
  
> [!NOTE]
>  可以載入多個 Windows 服務，服務主機處理序 (svchost.exe) 相同的執行個體內。 GetProcesses 不會識別這些個別的服務。因此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。 然後，它會擷取相同的程序的遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數的語法無效。 其長度有可能為零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">作業系統平台不支援遠端電腦上的這項作業。</exception>
        <exception cref="T:System.InvalidOperationException">存取 API 用來取得處理序資訊的效能計數器時發生問題。 此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取基礎系統 API 時發生問題。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與所有共用指定處理序名稱的現有處理序資源相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">處理序的易記名稱。</param>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與本機電腦上共用指定處理序名稱的所有處理序資源相關聯。</summary>
        <returns>
          <see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與相同的可執行檔在本機電腦上執行的所有處理序資源建立關聯。 處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>並不會建立系統資源，但而是將其與應用程式產生聯<xref:System.Diagnostics.Process>元件。 A`processName`可以指定可執行檔不目前正在執行的本機電腦上，讓該方法會傳回的陣列可以是空的。  
  
 處理序名稱是此程序，例如 Outlook、 不包含副檔名為.exe 或路徑的好記名稱。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。 例如，您可以傳遞做為可執行檔名稱`processName`參數，以便關閉該可執行檔的所有執行的執行個體。  
  
 雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，其中包含所有相關聯的處理序。 如果您需要管理處理序使用標準的應用程式開發介面呼叫，您可以查詢每個這些處理序的識別碼。 您無法存取處理序資源，透過單獨處理序名稱，但是，一旦您已擷取的陣列<xref:System.Diagnostics.Process>相關聯的元件與處理序資源，開始、 結束及操作的系統資源。  
  
   
  
## Examples  
 下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。 然後，它會擷取相同的程序的遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">存取 API 用來取得處理序資訊的效能計數器時發生問題。 此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">處理序的易記名稱。</param>
        <param name="machineName">網路上的電腦名稱。</param>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與遠端電腦上共用指定處理序名稱的所有處理序資源相關聯。</summary>
        <returns>
          <see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與相同的可執行檔指定的電腦上執行的所有處理序資源建立關聯。 處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>並不會建立系統資源，但而是將其與應用程式產生聯<xref:System.Diagnostics.Process>元件。 A`processName`可以指定可執行檔不目前正在執行的本機電腦上，讓該方法會傳回的陣列可以是空的。  
  
 處理序名稱是此程序，例如 Outlook、 不包含副檔名為.exe 或路徑的好記名稱。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。 例如，您可以傳遞做為可執行檔名稱`processName`參數，以便關閉該可執行檔的所有執行的執行個體。  
  
 雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，其中包含所有相關聯的處理序。 如果您需要管理處理序使用標準的應用程式開發介面呼叫，您可以查詢每個這些處理序的識別碼。 您無法存取處理序資源，透過單獨處理序名稱，但是，一旦您已擷取的陣列<xref:System.Diagnostics.Process>相關聯的元件與處理序資源，開始、 結束及操作的系統資源。  
  
 取得處理程序，在本機電腦上以及遠端電腦上，您可以使用這個多載。 使用 」。 「 若要指定本機電腦。 另一個多載存在預設使用本機電腦。  
  
 您可以存取遠端電腦上只檢視處理序的相關資訊，例如統計資料、 處理序。 您無法關閉，終止 (使用<xref:System.Diagnostics.Process.Kill%2A>)，或在遠端電腦上啟動處理程序。  
  
   
  
## Examples  
 下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。 然後，它會擷取相同的程序的遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 參數的語法無效。 其長度有可能為零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">作業系統平台不支援遠端電腦上的這項作業。</exception>
        <exception cref="T:System.InvalidOperationException">存取 API 用來取得處理序資訊的效能計數器時發生問題。 此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取基礎系統 API 時發生問題。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的原生控制代碼。</summary>
        <value>處理序啟動時，作業系統指派給相關處理序的控制代碼。 系統會用這個控制代碼追蹤處理序屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以取得可用來做為許多的處理程序資訊及控制函數參數的程序的控制代碼。 您可以使用此控制代碼初始化<xref:System.Threading.WaitHandle>或呼叫與平台的原生方法叫用。  
  
 此處理序控制代碼是私用應用程式--也就是說，不能共用控制代碼的程序。 處理程序也有程序<xref:System.Diagnostics.Process.Id%2A>其不同的是<xref:System.Diagnostics.Process.Handle%2A>，是唯一的因此，在整個系統有效。  
  
 只有處理序啟動透過呼叫<xref:System.Diagnostics.Process.Start%2A>設定<xref:System.Diagnostics.Process.Handle%2A>對應<xref:System.Diagnostics.Process>執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序尚未啟動或已結束。 無法讀取 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性，因為沒有與此 <see cref="T:System.Diagnostics.Process" /> 執行個體相關聯的處理序。  
  
 -或-  
  
 <see cref="T:System.Diagnostics.Process" /> 執行個體已附加至執行中的處理序，但沒有取得具有完整存取權限之控制代碼的必要權限。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序開啟的控制代碼數目。</summary>
        <value>處理序已開啟的作業系統控制代碼數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制代碼為提供的方式來參考物件的處理序。 處理程序可以取得檔案、 資源、 訊息佇列和許多其他作業系統物件的控制代碼。 作業系統會回收控制代碼計數為零時，才與處理序相關聯的記憶體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出相關的處理序是否已經終止。</summary>
        <value>
          如果 <see cref="T:System.Diagnostics.Process" /> 元件所參考的作業系統處理序已終止，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值為`true`如<xref:System.Diagnostics.Process.HasExited%2A>指出相關聯的處理序已結束，正常或不正常。 您可以要求或強制結束藉由呼叫相關聯的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 如果已開啟處理序的控制代碼，作業系統會釋放處理程序記憶體時的處理序已結束，但會保留系統管理處理程序控制代碼，結束代碼和結束時間等相關資訊。 若要取得這項資訊，您可以使用<xref:System.Diagnostics.Process.ExitCode%2A>和<xref:System.Diagnostics.Process.ExitTime%2A>屬性。 這些屬性會自動填入這個元件已啟動的處理程序。 系統管理資訊發行時所有<xref:System.Diagnostics.Process>與系統處理序相關聯的元件會終結並保存至已結束的處理序沒有更多的控制代碼。  
  
 處理程序可以與您的程式碼分開來終止。 如果您啟動使用這個元件的處理序時，系統會更新的值<xref:System.Diagnostics.Process.HasExited%2A>自動，即使在相關聯的處理序結束獨立。  
  
> [!NOTE]
>  當非同步事件處理常式已經重新導向標準輸出時，您就可以確認輸出處理尚未完成時，這個屬性會傳回`true`。 若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前會採用任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 的第二個時間間隔，最多為 10 秒。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，此範例會關閉處理序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有與這個物件關聯的處理序。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取處理序的結束代碼。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的唯一識別項。</summary>
        <value>這個 <see cref="T:System.Diagnostics.Process" /> 執行個體所參考的處理序之系統產生的唯一識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理程序<xref:System.Diagnostics.Process.Id%2A>不正確，如果相關聯的處理序並未執行。 因此，您應該確定處理序正在執行，然後嘗試擷取<xref:System.Diagnostics.Process.Id%2A>屬性。 除非在處理序終止時，處理序識別碼可唯一識別整個系統的程序。  
  
 您可以連接至新的本機或遠端電腦執行的處理序<xref:System.Diagnostics.Process>藉由傳遞至處理序識別碼的執行個體<xref:System.Diagnostics.Process.GetProcessById%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 是`static`會建立新元件的方法，並設定<xref:System.Diagnostics.Process.Id%2A>新屬性<xref:System.Diagnostics.Process>自動執行個體。  
  
 系統可以重複使用處理序識別碼。 <xref:System.Diagnostics.Process.Id%2A>屬性值是唯一的只有當相關聯的處理序正在執行時。 系統處理序已終止之後，可以重複使用<xref:System.Diagnostics.Process.Id%2A>不相關的處理序的屬性值。  
  
 因為此識別碼是唯一的系統上，您可以傳遞給它其他執行緒以傳遞替代<xref:System.Diagnostics.Process>執行個體。 這個動作可節省系統資源，又保證正確地識別出程序。  
  
   
  
## Examples  
 下列範例示範如何取得<xref:System.Diagnostics.Process.Id%2A>所有執行中的應用程式的執行個體。 程式碼建立 「 記事本 」 的新執行個體列出的 「 記事本 」 中的所有執行個體，然後可讓使用者輸入<xref:System.Diagnostics.Process.Id%2A>移除特定的執行個體的數目。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序的 <see cref="P:System.Diagnostics.Process.Id" /> 屬性未設定。  
  
 -或-  
  
 沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>立即停止相關的處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> 強制終止程序，而<xref:System.Diagnostics.Process.CloseMainWindow%2A>只會要求終止。 當執行圖形化介面的處理序時，其訊息迴圈會處於等候狀態。 每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。 呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>接近主要視窗中，且格式正確的應用程式中，在關閉子視窗，並撤銷應用程式的所有執行訊息迴圈傳送的要求。 藉由呼叫結束程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。 應用程式可以要求使用者驗證，才能結束，或它可以拒絕結束。 若要強制執行應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗使用 [系統] 功能表的使用者。 因此，要求關閉主視窗結束處理程序不會強制立即結束應用程式。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A>方法以非同步方式執行。 在呼叫<xref:System.Diagnostics.Process.Kill%2A>方法，請呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來等候處理序結束，或者檢查<xref:System.Diagnostics.Process.HasExited%2A>屬性來判斷是否已經結束處理程序。  
  
 編輯程序的資料或配置給處理序的資源可能會遺失如果您呼叫<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 導致處理程序異常終止，並在必要時才應該使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此最好有一個介面的應用程式。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。 <xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。  
  
 您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。 若要結束遠端電腦上，您無法讓處理程序。 您只能檢視遠端電腦上執行的處理序的資訊。  
  
> [!NOTE]
>  如果呼叫<xref:System.Diagnostics.Process.Kill%2A>方法由目前正在終止處理程序，而<xref:System.ComponentModel.Win32Exception>就會擲回的拒絕存取。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">相關的處理序無法終止。  
  
 -或-  
  
 正在結束處理序。  
  
 -或-  
  
 相關聯的處理序是 Win16 可執行檔。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.Kill" />。 這個方法僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理程序已經結束。  
  
 -或-  
  
 沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件離開可與使用特殊模式執行的作業系統處理序互動的狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些作業系統處理程序執行中使用特殊模式。 嘗試讀取的屬性，或附加至這些處理序不能除非您已經呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。 呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取特殊模式執行這些程序。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序正在執行的所在電腦的名稱。</summary>
        <value>相關處理序正在執行的所在電腦的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以檢視統計資料，且無法呼叫程序，但您的遠端電腦上執行的處理程序資訊<xref:System.Diagnostics.Process.Start%2A>， <xref:System.Diagnostics.Process.CloseMainWindow%2A>，或<xref:System.Diagnostics.Process.Kill%2A>遠端電腦上。  
  
> [!NOTE]
>  當相關聯的處理序在本機電腦上執行時，這個屬性會傳回句號 ("。") 的機器名稱。 您應該使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性來取得正確的電腦名稱。  
  
   
  
## Examples  
 若要使用下列的範例，您必須先執行會在遠端電腦上啟動 「 記事本 」 的至少一個執行個體。 此範例要求的遠端電腦的 [記事本] 正在執行，而且接著會顯示個別名稱<xref:System.Diagnostics.Process.ProcessName%2A>， <xref:System.Diagnostics.Process.Id%2A>，和<xref:System.Diagnostics.Process.MachineName%2A>每個執行個體的屬性。  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的主要模組。</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessModule" />，用來啟動處理序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理序模組代表特定程序中載入.dll 或.exe 檔。 <xref:System.Diagnostics.Process.MainModule%2A>屬性可讓您檢視用來啟動處理程序，包括模組名稱、 檔案名稱和模組的記憶體詳細資訊的可執行檔的相關資訊。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainModule" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 位元處理序正嘗試存取 64 位元處理序的模組。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
 -或-  
  
 處理序已經結束。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序主視窗的視窗控制代碼。</summary>
        <value>由系統產生之相關處理序主視窗的視窗控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主視窗是由目前具有焦點的處理序開啟的視窗 (<xref:System.Windows.Forms.Form.TopLevel%2A>形式)。 您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>來取得目前的主視窗控制代碼，如果已變更的物件。 一般而言，因為快取的視窗控制代碼，則使用<xref:System.Diagnostics.Process.Refresh%2A>事前保證您將會擷取目前的控制代碼。  
  
 您可以取得<xref:System.Diagnostics.Process.MainWindowHandle%2A>屬性只能供本機電腦執行的處理序。 <xref:System.Diagnostics.Process.MainWindowHandle%2A>屬性是可唯一識別與處理序相關聯的視窗的值。  
  
 在程序沒有處理序具有圖形化介面時，才與它相關聯的主視窗。 如果相關聯的處理序沒有主視窗、<xref:System.Diagnostics.Process.MainWindowHandle%2A>值為零。 值也是零的處理序已經隱藏起來，也就是處理不會顯示在工作列中的。 這可以是顯示為圖示在通知區域中，在工作列最右邊的處理程序的情況。  
  
 如果您剛啟動處理程序，並想要使用其主視窗控制代碼，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，以確保已經建立的主視窗控制代碼。 否則便會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 沒有定義，因為處理序已經結束。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序的主視窗標題。</summary>
        <value>處理序的主視窗標題。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在程序沒有處理序具有圖形化介面時，才與它相關聯的主視窗。 如果相關聯的處理序沒有主視窗 (以便<xref:System.Diagnostics.Process.MainWindowHandle%2A>為零)，<xref:System.Diagnostics.Process.MainWindowTitle%2A>為空字串 ("")。 如果您剛啟動處理程序，並想要使用其主視窗標題，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，以確保已經建立的主視窗控制代碼。 否則，系統會擲回例外狀況 (Exception)。  
  
> [!NOTE]
>  主視窗是目前擁有焦點，視窗請注意，這可能不是處理序主視窗。 您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>來取得目前的主視窗控制代碼，如果已變更的物件。  
  
   
  
## Examples  
 下列範例會啟動 [記事本] 的執行個體，並擷取程序的主視窗的標題。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性沒有定義，因為處理序已經結束。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定關聯的處理序所允許的工作集大小上限，以位元組為單位。</summary>
        <value>處理序所需記憶體中工作集大小的最大值，以位元組 (Byte) 為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。 這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用資料。 共用的資料包含頁面包含所有執行您的應用程式，包括.dll 檔案和 system.dll 檔案中頁面的指示。 隨著工作集大小會增加，會增加記憶體需求。  
  
 處理序有最小和最大工作集大小。 每次處理序資源建立時，系統會保留等於工作集大小的處理程序的最小記憶體數量。 虛擬記憶體管理員會保留最少的最小記憶體數量常駐時處理程序為作用中，但不是會保持超過最大大小。  
  
 系統會設定預設的工作集大小。 您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。 不過，設定這些值不保證記憶體會被保留或駐留。  
  
> [!NOTE]
>  當您增加處理程序的工作集大小時，您可以採取遠離系統的其餘部分的實體記憶體。 請確定您沒有要求的是太大，因為這樣做可能會降低系統效能的最小值或最大工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">工作集大小上限無效。 必須大於或等於工作集大小下限。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">無法從關聯的處理序資源擷取工作集資訊。  
  
 -或-  
  
 處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
 -或-  
  
 處理序已經結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定關聯的處理序所允許的工作集大小下限，以位元組為單位。</summary>
        <value>處理序所需記憶體中工作集大小的最小值，以位元組 (Byte) 為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。 這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用資料。 共用的資料包含頁面包含所有執行您的應用程式，包括.dll 檔案和 system.dll 檔案中頁面的指示。 隨著工作集大小會增加，會增加記憶體需求。  
  
 處理序有最小和最大工作集大小。 每次處理序資源建立時，系統會保留等於工作集大小的處理程序的最小記憶體數量。 虛擬記憶體管理員會保留最少的最小記憶體數量常駐時處理程序為作用中，但不是會保持超過最大大小。  
  
 系統會設定預設的工作集大小。 您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。 不過，設定這些值不保證記憶體會被保留或駐留。  
  
> [!NOTE]
>  當您增加處理程序的工作集大小時，您可以採取遠離系統的其餘部分的實體記憶體。 請確定您沒有要求的是太大，因為這樣做可能會降低系統效能的最小值或最大工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">工作集大小下限無效。 必須小於或等於工作集大小上限。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">無法從關聯的處理序資源擷取工作集資訊。  
  
 -或-  
  
 處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
 -或-  
  
 處理序已經結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關的處理序所載入的模組。</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessModule" /> 類型的陣列，代表相關聯處理序所載入的模組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理序模組代表特定程序中載入.dll 或.exe 檔。 A<xref:System.Diagnostics.ProcessModule>執行個體，可讓您檢視模組，包括模組名稱、 檔案名稱和模組的記憶體詳細資料的相關資訊。  
  
 處理程序可以將多個模組載入記憶體。 例如，載入額外的.dll 檔案的.exe 檔案有多個模組。  
  
 之後啟動處理序，這個集合是空的直到系統載入程序。 如果處理序主視窗，您可以呼叫<xref:System.Diagnostics.Process.WaitForInputIdle%2A>之前擷取這個屬性，以確保該集合不是空的時，您取得的清單。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">您嘗試存取系統處理序或閒置處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。 這些程序並沒有模組。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>記憶體量 (以位元組為單位)，指系統已配置給不能寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>配置給關聯處理序的系統記憶體量 (以位元組為單位)，不能寫入虛擬記憶體分頁檔案。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表目前的處理序，以位元組為單位所使用的未分頁的系統記憶體大小。 系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。 非分頁的記憶體配置保留在系統記憶體和並未輸出分頁虛擬記憶體分頁檔案。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**Pool Nonpaged Bytes**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 引發的應用程式開發介面方法<xref:System.Diagnostics.Process.Exited>事件。 呼叫<xref:System.Diagnostics.Process.OnExited%2A>導致<xref:System.Diagnostics.Process.Exited>事件發生和是唯一的方法來引發事件使用<xref:System.Diagnostics.Process>元件。 <xref:System.Diagnostics.Process.OnExited%2A> 主要用元件從衍生類別時。  
  
 做為替代<xref:System.Diagnostics.Process.OnExited%2A>，您可以撰寫您自己的事件處理常式。 您可以建立您自己的事件處理常式委派和事件處理方法。  
  
> [!NOTE]
>  如果您使用 Visual Studio 環境時，事件處理常式委派 (AddOnExited) 和事件處理方法 (Process1_Exited) 會為您建立拖曳<xref:System.Diagnostics.Process>元件拖曳至表單，然後按兩下圖示。 建立時要執行的程式碼<xref:System.Diagnostics.Process.Exited>進入 Process1_Exited 程序發生的事件。 您不需要建立<xref:System.Diagnostics.Process.OnExited%2A>成員，因為它會為您實作。  
  
 引發事件會透過委派叫用此事件處理常式。 如需概觀，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Diagnostics.Process.OnExited%2A>方法在衍生類別中的。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於應用程式將某行寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived>事件表示相關聯<xref:System.Diagnostics.Process>已寫入線條，以新行字元至其重新導向終止<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
 非同步讀取作業期間啟用事件上<xref:System.Diagnostics.Process.StandardOutput%2A>。 若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式來<xref:System.Diagnostics.Process.OutputDataReceived>事件和呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 此後，<xref:System.Diagnostics.Process.OutputDataReceived>事件訊號處理程序將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，直到處理程序會結束或呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>。  
  
> [!NOTE]
>  正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以確保已清除輸出緩衝區。  
  
   
  
## Examples  
 下列範例說明如何執行非同步的讀取的作業上的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流`ipconfig`命令。  
  
 此範例會建立為事件委派`OutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。 此事件處理常式收到來自的重新導向的文字行<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將它儲存在更新版本中所顯示的範例主控台視窗輸出字串中。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</summary>
        <value>記憶體量 (以位元組為單位)，指由關聯的處理序所配置，且可以寫入虛擬記憶體分頁檔案的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</summary>
        <value>虛擬記憶體分頁檔案中，配置給關聯處理序的記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表目前的處理序，以位元組為單位所使用之虛擬記憶體分頁檔中的記憶體大小。 作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用來管理每個處理序虛擬位址空間。 可分頁記憶體不在使用中時，它可以傳輸至磁碟上的虛擬記憶體分頁檔案。 若要取得使用由作業系統處理序的記憶體大小，請使用<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>屬性。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**分頁檔位元組**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例啟動 「 記事本 」 應用程式的執行個體，然後擷取並顯示相關聯的處理序的各種屬性。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>記憶體量 (以位元組為單位)，指系統已配置給可以寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>配置給關聯處理序的系統記憶體量 (以位元組為單位)，可以寫入虛擬記憶體分頁檔案。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性值所傳回的值表示目前的處理序，以位元組為單位所使用的可分頁系統記憶體大小。 系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。 可分頁記憶體不在使用中時，它可以傳輸至磁碟上的虛擬記憶體分頁檔案。 取得處理序所使用的應用程式記憶體的大小，請使用<xref:System.Diagnostics.Process.PagedMemorySize64%2A>屬性。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**Pool Paged Bytes**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量，以位元組為單位。</summary>
        <value>最大記憶體量 (以位元組為單位)，指由關聯的處理序配置給可以寫入虛擬記憶體分頁檔案的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量，以位元組為單位。</summary>
        <value>虛擬記憶體分頁檔案中，從啟動以來配置給關聯處理序的最大記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性值所傳回的值代表自啟動，以位元組為單位，處理序所使用之虛擬記憶體分頁檔中的記憶體大小上限。 作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用來管理每個處理序虛擬位址空間。 可分頁記憶體不在使用中時，它可以傳輸至磁碟上的虛擬記憶體分頁檔案。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**分頁檔位元組尖峰**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</summary>
        <value>最大虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</summary>
        <value>從啟動以來配置給關聯處理序的最大虛擬記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表自啟動，以位元組為單位的處理序使用的虛擬記憶體的大小上限。 作業系統會對應至載入實體記憶體中，或網頁儲存在磁碟上的虛擬記憶體分頁檔案中每個處理序的虛擬位址空間。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**虛擬位元組尖峰**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序工作集大小的最大值 (位元組)。</summary>
        <value>最大實體記憶體數量，為相關的處理序一次所需的量 (位元組)，</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。 這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用資料。 共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用最大實體記憶體量 (以位元組為單位)。</summary>
        <value>從啟動以來配置給關聯處理序的最大實體記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表的工作集記憶體使用處理程序，因為它啟動，以位元組為單位的大小上限。 處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。 這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用資料。 共用的資料包含頁面包含所有處理序執行，包括指示從處理序模組和系統程式庫的指示。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**工作集尖峰**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出作業系統是否應該在主視窗有焦點 (Focus) 時，暫時提高相關的處理序優先權。</summary>
        <value>
          當處理序離開等候狀態時，如果應動態提高處理序優先權，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當執行緒的優先權類別有一個動態優先順序列舉值的處理序中執行時 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)，系統暫時提升執行緒的優先順序，當它被帶離等候狀態。 這個動作可防止其他處理程序會中斷目前執行緒的處理。 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定會影響所有現有的執行緒和任何後續程序所建立的執行緒。 若要還原正常的行為，請設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性`false`。  
  
> [!NOTE]
>  提高過度提高優先權可以耗盡必要作業系統和網路功能，導致問題的其他作業系統工作的資源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法從關聯的處理序資源擷取優先權提升資訊。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。  
  
 -或-  
  
 處理序識別碼或處理序控制代碼為零。 (尚未啟動處理序)。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定相關處理序的整體優先權分類。</summary>
        <value>相關聯處理序的優先權分類，處理序的 <see cref="P:System.Diagnostics.Process.BasePriority" /> 由此計算出來。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理序優先權類別包含執行緒的優先順序層級的範圍。 具有不同優先順序執行相對於此程序的優先權等級的程序中執行的執行緒。 Win32 七個基本優先順序層級，每個類別會使用四個優先權類別。 這些程序的優先順序類別所擷取的<xref:System.Diagnostics.ProcessPriorityClass>列舉型別，可讓您將處理序優先權設定為<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。 根據 24 小時制或其他優先權的提高，基礎優先權層級可以變更作業系統，當處理程序必須晚於其他人存取置於處理器的時間。 此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>暫時提高已超出等候狀態的執行緒的優先權層級。 處理程序會回到等候狀態時，會重設的優先順序。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視指派給處理程序的起始優先權。 不過，因為它是唯讀，您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>屬性來設定處理序的優先順序。 若要變更優先順序，請使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性，取得或設定處理程序的整體優先權分類。  
  
 無法使用 「 系統監視器檢視的優先權等級。 下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法設定處理序優先順序的資訊，或從相關聯的處理序資源擷取。  
  
 -或-  
  
 處理序識別碼或處理序控制代碼為零。 (尚未啟動處理序)。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">使用 Windows 98 或 Windows Millennium Edition (Windows Me) 時，<see cref="P:System.Diagnostics.Process.PriorityClass" /> 已設定為 <see langword="AboveNormal" /> 或 <see langword="BelowNormal" />。 這些平台不支援優先權類別的這些值。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">無法設定優先權類別，因為它不使用如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列舉類型中所定義的有效值。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</summary>
        <value>相關的處理序配置的位元組數目，不能與其他處理序共用。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</summary>
        <value>配置給關聯處理序的記憶體量 (以位元組為單位)，不能與其他處理序共用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表目前的處理序，以位元組為單位，不能與其他處理序共用所使用的記憶體大小。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**私用位元組**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序使用處理器的授權時間。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，表示處理序在作業系統核心內執行程式碼所花費的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序的名稱。</summary>
        <value>名稱，系統用來向使用者識別處理序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A>屬性會保留的可執行檔名稱，例如 Outlook、 不包含副檔名為.exe 或路徑。 它可協助取得和管理相同的可執行檔相關聯的所有處理序。  
  
> [!NOTE]
>  在[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]作業系統<xref:System.Diagnostics.Process.ProcessName%2A>屬性可能會被截斷為 15 個字元，如果無法取得處理序模組資訊。  
  
 您可以呼叫<xref:System.Diagnostics.Process.GetProcessesByName%2A>，它將可執行檔名稱，擷取陣列，其中包含指定的電腦上每個執行的執行個體。 您可以使用此陣列，例如，若要關閉的可執行檔的所有執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序沒有識別項，或沒有處理序與 <see cref="T:System.Diagnostics.Process" /> 相關聯。  
  
 -或-  
  
 關聯處理序已結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">處理序不在這部電腦上。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定處理器，這個處理序中的執行緒可以在其上排程執行。</summary>
        <value>位元遮罩，表示相關的處理序中的執行緒可以在其上執行的處理器。 預設值取決於電腦上的處理器數目。 預設值為 2 <sup>n</sup> -1，其中 n 是處理器數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 2000 和更新版本中，處理程序中的執行緒可以移轉處理器，以重新載入處理器快取每個移轉。 在繁重的系統負載下指定哪一個處理器應該執行特定的執行緒可以改善效能降低的次數會重新載入處理器快取。 處理器和執行緒之間的關聯則稱為處理器相似性。  
  
 每個處理器是位元表示。 位元 0 是第一個處理器，位元 1 是處理器兩個，依此類推。 如果您的位元設定為 1 的值，對應的處理器會選取進行執行緒指派。 當您將<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值為零，作業系統的排程演算法設定執行緒的相似性。 當<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值設定為任何非零值時，值會解譯為指定適合選取處理器的位元遮罩。  
  
 下表顯示選取的<xref:System.Diagnostics.Process.ProcessorAffinity%2A>八個處理器的系統值。  
  
|位元遮罩|二進位值|可供選取的處理器|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 和 2|  
|0x0007|00000000 00000111|1、 2 和 3|  
|0x0009|00000000 00001001|1 到 4|  
|0x007F|00000000 01111111|1、 2、 3、 4、 5、 6 和 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 資訊無法設定或從相關聯的處理序資源擷取。  
  
 -或-  
  
 處理序識別碼或處理序控制代碼為零。 (尚未啟動處理序)。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
 -或-  
  
 處理序已經結束。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>捨棄快取於處理序元件內之相關處理序的任何資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之後<xref:System.Diagnostics.Process.Refresh%2A>呼叫時，第一個要求的每個屬性的相關資訊會造成處理序元件從相關聯的處理序取得新的值。  
  
 當<xref:System.Diagnostics.Process>元件是相關聯處理序資源，屬性值的<xref:System.Diagnostics.Process>立即填入依據相關聯的處理序的狀態。 如果後續變更之相關處理序的資訊，這些變更不會反映在<xref:System.Diagnostics.Process>元件的快取的值。 <xref:System.Diagnostics.Process>元件是的快照集處理序資源在其相關聯的時間。 若要檢視關聯的處理序的目前值，呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 的第二個時間間隔，最多為 10 秒。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，此範例會關閉處理序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出處理序的使用者介面是否正在回應。</summary>
        <value>
          如果相關處理序的使用者介面正在回應系統，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果處理程序具有使用者介面，<xref:System.Diagnostics.Process.Responding%2A>屬性聯繫來判斷處理序是否正在回應使用者輸入的使用者介面。 如果介面不會立即回應<xref:System.Diagnostics.Process.Responding%2A>屬性會傳回`false`。 使用這個屬性來判斷是否相關聯的處理序的介面已停止回應。  
  
 如果處理程序並沒有<xref:System.Diagnostics.Process.MainWindowHandle%2A>，這個屬性會傳回`true`。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Responding" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序的原生控制代碼。</summary>
        <value>這個處理序的原生控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制代碼才可使用呼叫元件啟動處理序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的終端機服務工作階段識別項。</summary>
        <value>相關處理序的終端機服務工作階段識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A>屬性可識別目前執行中應用程式的工作階段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">沒有與此處理序相關聯的工作階段。</exception>
        <exception cref="T:System.InvalidOperationException">沒有與這個工作階段識別項相關聯的處理序。  
  
 -或-  
  
 相關的處理序不在此機器上。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 不支援 <see cref="P:System.Diagnostics.Process.SessionId" /> 屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來讀取應用程式錯誤輸出的資料流。</summary>
        <value>
          <see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準錯誤資料流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.Process>將文字寫入至其標準錯誤資料流，通常會在主控台上顯示文字。 藉由重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流，您可以操作或隱藏的錯誤輸出的處理程序。 比方說，您可以篩選文字、 以不同的方式，將其格式化或將輸出寫入主控台和指定的記錄檔。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardError%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>至`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>至`true`。 否則，讀取<xref:System.Diagnostics.Process.StandardError%2A>資料流擲回例外狀況。  
  
 重新導向<xref:System.Diagnostics.Process.StandardError%2A>同步或非同步方式，就可以讀取資料流。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行同步處理程序的錯誤輸出資料流上的讀取的作業。 這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。 這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。  
  
 同步讀取作業會讀取自呼叫端之間的相依性<xref:System.Diagnostics.Process.StandardError%2A>資料流及子處理序寫入該資料流。 這些相依性可能會導致死結狀況。 當呼叫端會從子處理序的重新導向資料流讀取時，它會相依於子系。 呼叫端會在讀取作業，等到子寫入資料流，或關閉資料流。 時子處理序寫入資料不足，無法填滿其重新導向資料流，它會相依於父代。 子處理序會等候下一個寫入作業，直到父讀取完整的資料流，或關閉資料流。 當呼叫端和子處理序互相等候完成作業，且無法繼續時，就會導致死結狀態。 您可以評估呼叫端和子處理序之間的相依性，以避免死結。  
  
 例如，下列 C# 程式碼會示範如何從重新導向資料流讀取，並等候子處理序結束。  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況呼叫`p.StandardError.ReadToEnd`之前`p.WaitForExit`。 如果父處理呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿重新導向資料流。 父處理序會無限期地等候子處理序結束。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。 下列 C# 程式碼，例如，執行兩個資料流上的讀取的作業。  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況執行非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 如果父處理序的呼叫就會導致死結狀態`p.StandardOutput.ReadToEnd`後面`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的錯誤資料流。 父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 若要避免這些相依性和其潛在的死結，您可以使用非同步讀取的作業。 或者，您可以藉由建立兩個執行緒，並讀取每個個別執行緒上的資料流的輸出，避免發生死結狀況。  
  
> [!NOTE]
>  您不能混用重新導向資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
   
  
## Examples  
 下列範例會使用`net use`命令搭配使用者提供的引數對應網路資源。 然後會讀取 net 命令標準錯誤資料流，並寫入至主控台。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。  
  
 \-或-  
  
 已開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 的非同步讀取作業。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來寫入應用程式輸入的資料流。</summary>
        <value>
          <see cref="T:System.IO.StreamWriter" />，可用來寫入應用程式的標準輸入資料流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>可以讀取其標準輸入資料流，一般是鍵盤輸入的文字。 藉由重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流，您可以透過程式設計方式指定輸入。 例如，而不是使用鍵盤輸入，您可以提供指定之檔案的內容中的文字或另一個應用程式的輸出。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardInput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>至`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>至`true`。 否則，寫入<xref:System.Diagnostics.Process.StandardInput%2A>資料流擲回例外狀況。  
  
   
  
## Examples  
 下列範例說明如何將重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流的處理程序。 此範例會啟動`sort`命令與重新導向輸入。 接著會提示使用者輸入的文字，並將其傳遞至`sort`透過重新導向處理序<xref:System.Diagnostics.Process.StandardInput%2A>資料流。 `sort`結果會顯示主控台使用者。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未定義 <see cref="P:System.Diagnostics.Process.StandardInput" /> 資料流，因為 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 已設定為 <see langword="false" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來讀取應用程式文字輸出的資料流。</summary>
        <value>
          <see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準輸出資料流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.Process>將文字寫入至其標準的資料流，通常會在主控台上顯示文字。 藉由重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，您可以操作或隱藏程序的輸出。 比方說，您可以篩選文字、 以不同的方式，將其格式化或將輸出寫入主控台和指定的記錄檔。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardOutput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>至`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>至`true`。 否則，讀取<xref:System.Diagnostics.Process.StandardOutput%2A>資料流擲回例外狀況。  
  
 重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>同步或非同步方式，就可以讀取資料流。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流上的同步讀取的作業。 這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。  
  
 同步讀取作業會讀取自呼叫端之間的相依性<xref:System.Diagnostics.Process.StandardOutput%2A>資料流及子處理序寫入該資料流。 這些相依性可能會導致死結狀況。 當呼叫端會從子處理序的重新導向資料流讀取時，它會相依於子系。 呼叫端會在讀取作業，等到子寫入資料流，或關閉資料流。 時子處理序寫入資料不足，無法填滿其重新導向資料流，它會相依於父代。 子處理序會等候下一個寫入作業，直到父讀取完整的資料流，或關閉資料流。 當呼叫端和子處理序互相等候完成作業，且無法繼續時，就會導致死結狀態。 您可以評估呼叫端和子處理序之間的相依性，以避免死結。  
  
 例如，下列 C# 程式碼會示範如何從重新導向資料流讀取，並等候子處理序結束。  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況呼叫`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。 如果父處理呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子處理序寫入足夠的文字，以填滿重新導向資料流。 父處理序會無限期地等候子處理序結束。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
 當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。 下列 C# 程式碼，例如，執行兩個資料流上的讀取的作業。  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 程式碼範例可避免發生死結狀況執行非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 如果父處理序的呼叫就會導致死結狀態`p.StandardOutput.ReadToEnd`後面`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的錯誤資料流。 父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 若要避免這些相依性和其潛在的死結，您可以使用非同步讀取的作業。 或者，您可以藉由建立兩個執行緒，並讀取每個個別執行緒上的資料流的輸出，避免發生死結狀況。  
  
> [!NOTE]
>  您不能混用重新導向資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
   
  
## Examples  
 下列範例會執行 ipconfig.exe 命令，並將其標準輸出重新導向至主控台視窗中的範例。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。  
  
 \-或-  
  
 已開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 的非同步讀取作業。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>啟動處理序資源，並將其與 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動 (或重複使用) 這個 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性指定的處理序資源，並將其與元件相關聯。</summary>
        <returns>
          如果啟動處理序資源，則為 <see langword="true" />；如果沒有啟動任何新的處理序資源 (例如，如果重複使用現有的處理序)，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載，啟動處理序資源，並將它與目前關聯<xref:System.Diagnostics.Process>元件。 傳回值`true`指出已啟動新的處理序資源。 如果所指定的處理序資源<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性已在電腦上執行，啟動任何其他處理序資源。 相反地，執行的處理序資源會重複使用和`false`傳回。  
  
 您可以藉由指定在原本安裝應用程式的位置 （例如，網址） 啟動 ClickOnce 應用程式。 無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。  
  
> [!NOTE]
>  如果您使用 Visual Studio 中的這個多載<xref:System.Diagnostics.Process.Start%2A>方法是拖曳後插入程式碼的一個<xref:System.Diagnostics.Process>元件拖曳至設計工具。 使用`Properties`視窗中，展開`StartInfo`類別寫入至適當的值和`FileName`屬性。 您的變更會出現在表單的`InitializeComponent`程序。  
  
 這個多載<xref:System.Diagnostics.Process.Start%2A>不`static`方法。 您必須呼叫它的執行個體從<xref:System.Diagnostics.Process>類別。 然後再呼叫<xref:System.Diagnostics.Process.Start%2A>，您必須先指定<xref:System.Diagnostics.Process.StartInfo%2A>這個屬性資訊<xref:System.Diagnostics.Process>執行個體，因為該資訊用來判斷啟動的處理序資源。  
  
 其他多載的<xref:System.Diagnostics.Process.Start%2A>方法`static`成員。 您不需要建立的執行個體<xref:System.Diagnostics.Process>元件，才能呼叫這些方法多載。 相反地，您可以呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>類別本身，以及新<xref:System.Diagnostics.Process>如果處理序已啟動，則會建立元件。 或者，`null`會傳回處理程序已重複使用。 處理序資源會自動關聯於新<xref:System.Diagnostics.Process>元件所傳回<xref:System.Diagnostics.Process.Start%2A>方法。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A>成員可以用來複製功能的`Run`對話方塊中的 Windows `Start`功能表。 任何可以輸入命令列的項目可以藉由設定適當的值啟動<xref:System.Diagnostics.Process.StartInfo%2A>屬性。 唯一<xref:System.Diagnostics.Process.StartInfo%2A>屬性必須設為<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性沒有可執行檔。 它可以是任何的副檔名已經安裝在系統的應用程式相關聯的檔案類型。 例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以具有副檔名為.txt，如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有副檔名為.doc。  
  
 在命令列中，您可以指定特定的檔案類型的動作。 例如，您可以列印文件，或編輯文字檔。 指定使用這些動作<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性。 對於其他類型的檔案，您可以指定命令列引數時開始從檔案`Run` 對話方塊。 例如，您可以將 URL 當做引數如果您指定做為您的瀏覽器<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 這些引數可以指定在<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成員。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。 否則，系統將不到路徑。 例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。 處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。  
  
 這裡的附註中 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。 否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 部分方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。 不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例會使用的執行個體<xref:System.Diagnostics.Process>啟動處理序的類別。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定檔案名稱。
 或者，<see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 成員是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 是 <see langword="true" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯檔案時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用來啟動處理序的資訊，包括檔名和任何命令列引數。</param>
        <summary>啟動含有處理序啟動資訊 (例如，要啟動之處理序的檔名) 的參數所指定的處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來啟動處理序資源，藉由指定<xref:System.Diagnostics.ProcessStartInfo>執行個體。 多載會將資源與新<xref:System.Diagnostics.Process>物件。  
  
> [!NOTE]
>  若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。  
  
 這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。 使用此多載<xref:System.Diagnostics.ProcessStartInfo>參數是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定其<xref:System.Diagnostics.Process.StartInfo%2A>屬性，以及呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。  
  
 使用<xref:System.Diagnostics.ProcessStartInfo>執行個體，以參數可讓您呼叫<xref:System.Diagnostics.Process.Start%2A>最控制傳入啟動程序呼叫。 如果您需要將只能在檔案名稱或檔案名稱和引數傳遞，則不需要建立新<xref:System.Diagnostics.ProcessStartInfo>執行個體，雖然這是一個選項。 唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>屬性必須設為<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。 它可以是任何的副檔名已經安裝在系統的應用程式相關聯的檔案類型。 例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以具有副檔名為.txt，如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有副檔名為.doc。  
  
 您可以藉由指定在原本安裝應用程式的位置 （例如，網址） 啟動 ClickOnce 應用程式。 無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。  
  
 如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>屬性<xref:System.Diagnostics.Process.StartInfo%2A>執行個體已設定，未受`CreateProcessWithLogonW`呼叫函式，以便啟動處理程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>。 如果<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>屬性是`null`、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>屬性必須是 UPN 格式*使用者*@*DNS_domain_name*。   
  
 不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。 當您已經建立的多載的使用<xref:System.Diagnostics.Process>執行個體，指定的啟動資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。 使用其中一種`static`多載，當您想要建立新<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的處理序。 這個多載並沒有參數的多載可讓您使用指定的處理序資源的啟動資訊<xref:System.Diagnostics.ProcessStartInfo>執行個體。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。 否則，系統將不到路徑。 例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。 處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。  
  
 這裡的附註中 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上`startInfo`參數，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。 否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 部分方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。 不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例首先會繁衍 Internet Explorer 的執行個體，並在瀏覽器會顯示 [我的最愛] 資料夾的內容。 然後會啟動 Internet Explorer 的其他執行個體，並顯示一些特定網頁或網站。 最後它會啟動 Internet Explorer 與正在瀏覽至特定網站時的最小化視窗。  
  
 如需這個方法的其他用途的其他範例，請參閱個別屬性<xref:System.Diagnostics.ProcessStartInfo>類別。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性沒有指定任何檔案名稱。  
  
 -或-  
  
 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性也是 <see langword="true" />。  
  
 -或-  
  
 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 屬性不是 <see langword="null" /> 或空白，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 屬性不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startInfo" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性中所指定的檔案。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯檔案時發生錯誤。  
  
 -或-  
  
 引數長度和處理序完整路徑長度的總和超過 2080。 與這個例外狀況相關聯的錯誤訊息可以是下列其中之一：「傳到系統呼叫的資料區域太小。」 或「拒絕存取」。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之文件或應用程式檔案的名稱。</param>
        <summary>藉由指定文件或應用程式檔案的名稱啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載，指定其檔案名稱啟動處理序資源。 多載會將資源與新<xref:System.Diagnostics.Process>物件。  
  
> [!NOTE]
>  若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。  
  
 這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。  
  
 您可以啟動 ClickOnce 應用程式設定`fileName`從中您原先安裝應用程式的位置 （例如，Web 位址） 的參數。 無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。  
  
 藉由指定其檔案名稱啟動處理程序是類似於輸入中的資訊`Run`對話方塊中的 Windows `Start`功能表。 因此，檔案名稱不需要代表可執行檔。 它可以是任何檔案類型，其副檔名已經相關聯的系統上安裝的應用程式。 例如如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有.doc 的檔案名稱可以有副檔名為.txt。 同樣地，在相同的方式來`Run`對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。  
  
 這個多載不允許處理序的命令列引數。 如果您需要指定一或多個處理程序的命令列引數，使用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>或<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>多載。  
  
 不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。 當您已經建立的多載的使用<xref:System.Diagnostics.Process>執行個體，指定的啟動資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。 使用其中一種`static`多載，當您想要建立新<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的處理序。 這個多載並沒有參數的多載可讓您指定要啟動的處理序資源的檔案名稱。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。 否則，系統將不到路徑。 例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。 處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。  
  
 這裡的附註中 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。 否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 部分方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。 不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例首先會繁衍 Internet Explorer 的執行個體，並在瀏覽器會顯示 [我的最愛] 資料夾的內容。 然後會啟動 Internet Explorer 的其他執行個體，並顯示一些特定網頁或網站。 最後它會啟動 Internet Explorer 與正在瀏覽至特定網站時的最小化視窗。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯的檔案時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境變數具有含引號的字串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之應用程式檔案的名稱。</param>
        <param name="arguments">啟動處理程序時要傳遞的命令列引數。</param>
        <summary>藉由指定應用程式的名稱和一組命令列引數來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載來啟動處理序資源藉由指定其檔案名稱和命令列引數。 多載會將資源與新<xref:System.Diagnostics.Process>物件。  
  
> [!NOTE]
>  若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。  
  
 這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。  
  
 啟動處理序藉由指定其檔案名稱和引數是類似於輸入檔案名稱及命令列引數中的`Run`對話方塊中的 Windows `Start`功能表。 因此，檔案名稱不需要代表可執行檔。 它可以是任何檔案類型，其副檔名已經相關聯的系統上安裝的應用程式。 例如如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有.doc 的檔案名稱可以有副檔名為.txt。 同樣地，在相同的方式來`Run`對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。 如果`fileName`參數所代表的可執行檔，`arguments`參數可能代表可以操作，例如文字檔的檔案`Notepad.exe myfile.txt`。 如果`fileName`參數所代表的命令 (.cmd) 檔，`arguments`參數必須包含"`/c`「 或 」`/k`"引數來指定命令視窗是否會結束或完成之後會維持。  
  
 不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。 當您已經建立的多載的使用<xref:System.Diagnostics.Process>執行個體，指定的啟動資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。 使用其中一種`static`多載，當您想要建立新<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的處理序。 這個多載並沒有參數的多載可讓您指定要傳遞的命令列引數與啟動的處理序資源的檔案名稱。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。 否則，系統將不到路徑。 例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。 處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...  
  
 這裡的附註中 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。 否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 部分方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。 不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例首先會繁衍 Internet Explorer 的執行個體，並在瀏覽器會顯示 [我的最愛] 資料夾的內容。 然後會啟動 Internet Explorer 的其他執行個體，並顯示一些特定網頁或網站。 最後它會啟動 Internet Explorer 與正在瀏覽至特定網站時的最小化視窗。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="fileName" /> 或 <paramref name="arguments" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯的檔案時發生錯誤。  
  
 -或-  
  
 引數長度和處理序完整路徑長度的總和超過 2080。 與這個例外狀況相關聯的錯誤訊息可以是下列其中之一：「傳到系統呼叫的資料區域太小。」 或「拒絕存取」。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境變數具有含引號的字串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之應用程式檔案的名稱。</param>
        <param name="userName">要在啟動處理序時使用的使用者名稱。</param>
        <param name="password">
          <see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</param>
        <param name="domain">要在啟動處理序時使用的網域。</param>
        <summary>藉由指定應用程式的名稱、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載，指定其檔案名稱、 使用者名稱、 密碼和網域來建立新的程序，而且其主執行緒。 新的處理序會指定可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。  
  
> [!NOTE]
>  當可執行檔位於遠端的磁碟機上時，您必須使用統一資源識別元 (URI)，未連結的磁碟機代號來識別網路共用。  
  
> [!NOTE]
>  若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。  
  
 這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>執行個體。  
  
 同樣地，在相同的方式來**執行**對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。 如果`fileName`參數所代表的可執行檔，`arguments`參數可能代表可以操作，例如文字檔的檔案`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  檔案名稱必須代表在可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...  
  
   
  
## Examples  
 下列程式碼範例將示範如何使用這個多載來啟動可執行檔，同時也會示範擲回的<xref:System.ComponentModel.Win32Exception>當嘗試啟動不可執行的檔案與相關聯的應用程式。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定檔案名稱。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯檔案時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之應用程式檔案的名稱。</param>
        <param name="arguments">啟動處理程序時要傳遞的命令列引數。</param>
        <param name="userName">要在啟動處理序時使用的使用者名稱。</param>
        <param name="password">
          <see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</param>
        <param name="domain">要在啟動處理序時使用的網域。</param>
        <summary>藉由指定應用程式的名稱、一組命令列引數、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個多載，指定其檔案名稱、 命令列引數、 使用者名稱、 密碼和網域來建立新的程序，而且其主執行緒。 新的處理序會指定可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。  
  
> [!NOTE]
>  當可執行檔位於遠端的磁碟機上時，您必須使用統一資源識別元 (URI)，未連結的磁碟機代號來識別網路共用。  
  
> [!NOTE]
>  若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。  
  
 這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。  
  
 同樣地，在相同的方式來**執行**對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。 如果`fileName`參數所代表的可執行檔，`arguments`參數可能代表可以操作，例如文字檔的檔案`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  檔案名稱必須代表在可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定檔案名稱。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯的檔案時發生錯誤。  
  
 -或-  
  
 引數長度和關聯檔案完整路徑長度的總和超過 2080。 與這個例外狀況關聯的錯誤訊息可以是下列其中之一：「傳遞到系統呼叫的資料區太小」， 或「拒絕存取」。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要傳遞給 <see cref="T:System.Diagnostics.Process" /> 之 <see cref="M:System.Diagnostics.Process.Start" /> 方法的屬性。</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessStartInfo" />，代表用來啟動處理序的資料。 這些引數包括用來啟動處理序的可執行檔或文件的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 表示要用來啟動處理程序的參數集。 當<xref:System.Diagnostics.Process.Start%2A>呼叫時，<xref:System.Diagnostics.Process.StartInfo%2A>用來指定要啟動處理序。 只需要<xref:System.Diagnostics.Process.StartInfo%2A>成員設定為<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 藉由指定啟動處理序<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性是類似於輸入中的資訊**執行**對話方塊中的 Windows **啟動**功能表。 因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。 它可以是任何檔案類型，其副檔名已經相關聯的系統上安裝的應用程式。 例如<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>可以有副檔名為.txt，如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有.doc。 同樣地，在相同的方式來**執行**對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。 例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"Notepad.exe 」 或 「 記事本 」 的屬性。  
  
 您可以啟動 ClickOnce 應用程式設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>從中您原先安裝應用程式的位置 （例如，Web 位址） 的屬性。 無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。  
  
 如果檔案名稱包含非執行檔，例如.doc 檔案，您可以包含指定要在檔案上採取的動作動詞命令。 例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>"Print"結尾.doc 副檔名的檔案。 在指定的檔案名稱<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要有副檔名，如果您手動輸入的值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性。 不過，如果您使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性來判斷哪些指令動詞可供使用，您必須包含副檔名。  
  
 您可以變更指定的參數<xref:System.Diagnostics.Process.StartInfo%2A>屬性最多的時間，讓您呼叫<xref:System.Diagnostics.Process.Start%2A>方法的程序。 啟動程序之後，變更<xref:System.Diagnostics.Process.StartInfo%2A>值不影響或重新啟動相關的處理序。 如果您呼叫<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>方法<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>屬性設定，未受`CreateProcessWithLogonW`呼叫函式，以便啟動處理程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden>。  
  
 如果您未使用<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理程序，<xref:System.Diagnostics.Process.StartInfo%2A>屬性並不會反映用來啟動處理序的參數。 例如，如果您使用<xref:System.Diagnostics.Process.GetProcesses%2A>取得陣列的電腦上，執行的處理序<xref:System.Diagnostics.Process.StartInfo%2A>每個屬性<xref:System.Diagnostics.Process>不包含原始的檔案名稱或用來啟動處理序引數。  
  
 檔案名稱處理程序啟動時，會填入 （唯讀） 的檔案<xref:System.Diagnostics.Process.MainModule%2A>屬性。 如果您想要擷取可執行檔所關聯之處理序啟動處理程序之後，請使用<xref:System.Diagnostics.Process.MainModule%2A>屬性。 如果您想要設定的可執行檔<xref:System.Diagnostics.Process>其相關聯的處理序尚未啟動執行個體，請使用<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。 因為成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性是引數傳遞至<xref:System.Diagnostics.Process.Start%2A>方法的程序中，然後再變更<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性相關聯的處理序啟動後不會重設<xref:System.Diagnostics.Process.MainModule%2A>屬性。 這些屬性只能用於初始化相關聯的處理序。  
  
   
  
## Examples  
 下列範例會填入<xref:System.Diagnostics.Process.StartInfo%2A>来執行的檔案，與它執行動作，以及是否應該顯示使用者介面。 如需其他範例，請參閱屬性的參考頁面<xref:System.Diagnostics.ProcessStartInfo>類別。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值是 <see langword="null" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關的處理序啟動的時間。</summary>
        <value>物件，指出處理序何時啟動。 如果處理序並未執行，則會擲回例外狀況。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.StartTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序已經結束。  
  
 -或-  
  
 尚未啟動處理序。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">呼叫 Windows 函式時發生錯誤。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定物件，用以封送處理因處理序結束事件而發出的事件處理常式呼叫。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用以封送處理因處理序上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而發出的事件處理常式呼叫。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，處理方法<xref:System.Diagnostics.Process.Exited>系統執行緒集區的執行緒上呼叫事件。 如需系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。  
  
 當<xref:System.Diagnostics.Process.Exited>事件由 visual 的 Windows Form 元件，例如<xref:System.Windows.Forms.Button>，透過系統執行緒集區存取元件可能無法運作，或可能會導致例外狀況。 避免這種設定<xref:System.Diagnostics.Process.SynchronizingObject%2A>給 Windows Form 元件時，會導致處理方法<xref:System.Diagnostics.Process.Exited>元件建立所在的相同執行緒上呼叫的事件。  
  
 如果<xref:System.Diagnostics.Process>內使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.Diagnostics.Process.SynchronizingObject%2A>會自動設定為包含的控制項<xref:System.Diagnostics.Process>。 例如，如果您將<xref:System.Diagnostics.Process>的設計工具上`Form1`(繼承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性<xref:System.Diagnostics.Process>設為執行個體`Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 一般而言，這個屬性設定時元件會放置在控制項或表單，因為這些元件會繫結至特定執行緒。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得正在相關的處理序中執行的執行緒集。</summary>
        <value>
          <see cref="T:System.Diagnostics.ProcessThread" /> 類型的陣列，代表目前正在相關聯處理序中執行的作業系統執行緒。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒處理序中執行程式碼。 每個處理序會啟動與單一執行緒，其主要執行緒。 任何執行緒可以建立額外的執行緒。 執行緒處理序內共用處理序的位址空間。  
  
 使用<xref:System.Diagnostics.ProcessThread>，取得與目前的處理序相關聯的所有執行緒。 主執行緒不一定是索引位置為零的陣列中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">處理序沒有 <see cref="P:System.Diagnostics.Process.Id" />，或沒有與 <see cref="T:System.Diagnostics.Process" /> 執行個體關聯的處理序。  
  
 -或-  
  
 關聯處理序已結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將處理序的名稱格式化為字串，如果適用，將它和父代 (Parent) 元件類型結合。</summary>
        <returns>
          <see cref="P:System.Diagnostics.Process.ProcessName" />，與基底元件的 <see cref="M:System.Object.ToString" /> 傳回值搭配相結合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          Windows 98 不支援 <see cref="M:System.Diagnostics.Process.ToString" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序的總處理器時間。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，表示相關聯處理序花在使用 CPU 的時間。 這個值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的總和。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序的使用者處理器時間。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，表示相關聯處理序花在處理序的應用程式部分內 (而不是在作業系統核心內) 執行程式碼的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示處理序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序的虛擬記憶體的大小 (以位元組為單位)。</summary>
        <value>虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的虛擬記憶體量，以位元組為單位。</summary>
        <value>配置給關聯處理序的虛擬記憶體量，以位元組為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表目前的程序，以位元組為單位使用的虛擬記憶體大小。 作業系統會對應至載入實體記憶體中，或網頁儲存在磁碟上的虛擬記憶體分頁檔案中每個處理序的虛擬位址空間。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**虛擬位元組**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定要等待相關的處理序結束的時間，並且阻止目前的執行緒執行，直到等候時間耗盡或者處理序已經結束為止。 為避免封鎖目前的執行緒，請使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。  
  
 對於程式碼範例，請參閱 <see cref="P:System.Diagnostics.Process.StandardError" /> 與 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性參考頁面。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序結束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 可讓目前的執行緒等候，直到相關聯的處理序終止為止。  所有其他方法會呼叫的程序之後，應該要進行呼叫。 為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 這個方法會指示<xref:System.Diagnostics.Process>等待時間結束的處理程序和事件處理常式無限數量的元件。 這會造成應用程式停止回應。 例如，如果您呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>程序中具有使用者介面，作業系統終止相關的處理序的要求可能不會處理程序寫入永遠不會進入其訊息迴圈。  
  
> [!NOTE]
>  在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]及更新版本、<xref:System.Diagnostics.Process.WaitForExit>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），非無限期。 此外，舊版未等待事件處理常式，如果結束完整<xref:System.Int32.MaxValue>已達時間。  
  
 這個多載可確保，所有處理都完成後，包括重新導向標準輸出的非同步事件處理。 您應該使用這個多載呼叫後<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>標準輸出已重新導向至非同步事件處理常式時，多載。  
  
 系統時相關聯的處理序結束時 （亦即，它會關閉程式透過標準或不正常終止的作業系統），儲存系統管理程序的詳細資訊，並傳回給已經呼叫元件<xref:System.Diagnostics.Process.WaitForExit>。 <xref:System.Diagnostics.Process>元件可以存取資訊，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>已結束的處理序。  
  
 相關聯的處理序已結束，因為<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。 相反地，控制代碼可用來存取作業系統的處理序資源相關的資訊。 系統會考慮到已結束處理程序未釋放的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保存<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>資訊在記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。 基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體，請呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序已終止，您不再需要任何系統管理相關資訊。 <xref:System.Diagnostics.Process.Close%2A> 釋出配置給已結束處理程序的記憶體。  
  
   
  
## Examples  
 請參閱 < 備註 > 一節的<xref:System.Diagnostics.Process.StandardError%2A>屬性參考頁面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法存取等候設定。</exception>
        <exception cref="T:System.SystemException">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。  
  
 -或-  
  
 沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。  
  
 -或-  
  
 您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.WaitForExit" />。 這個方法僅適用於在本機電腦執行的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">等候相關的處理序結束的時間量，以毫秒計算。 最大值是 32 位元整數的最大可能值，對作業系統來說，這表示無限。</param>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序結束的指定毫秒數。</summary>
        <returns>
          如果相關聯處理序已結束，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 可讓目前的執行緒等候，直到相關聯的處理序終止為止。 所有其他方法會呼叫的程序之後，應該要進行呼叫。 為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 這個方法會指示<xref:System.Diagnostics.Process>等候處理序結束的時間有限數量的元件。 如果相關聯的處理序未結束的間隔端點所終止要求遭到拒絕，因為`false`會傳回到呼叫的程序。 您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>如`milliseconds`，和<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>行為相同<xref:System.Diagnostics.Process.WaitForExit>多載。 如果您將 0 （零） 傳遞至方法，它會傳回`true`只有當處理序已經結束; 否則會立即傳回`false`。  
  
> [!NOTE]
>  在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和舊版中，如果`milliseconds`是-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），非無限期。  
  
 當已將標準輸出重新導向至非同步事件處理常式時，它有可能，輸出處理尚未完成此方法傳回時。 若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>在收到後會採用任何參數的多載`true`從這個多載。 為協助確保<xref:System.Diagnostics.Process.Exited>Windows Forms 應用程式中正確地處理事件，請將設定<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。  
  
 相關聯的處理序結束時 （已關閉作業系統，透過標準或不正常終止），系統會儲存系統管理程序的詳細資訊，並傳回給已呼叫的元件<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>。 <xref:System.Diagnostics.Process>元件可以存取資訊，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>已結束的處理序。  
  
 相關聯的處理序已結束，因為<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。 相反地，控制代碼可用來存取作業系統的處理序資源相關的資訊。 系統會考慮到已結束處理程序未釋放的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保存<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>資訊在記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。 基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體，請呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序已終止，您不再需要任何系統管理相關資訊。 <xref:System.Diagnostics.Process.Close%2A> 釋出配置給已結束處理程序的記憶體。  
  
   
  
## Examples  
 請參閱程式碼範例，取得<xref:System.Diagnostics.Process.ExitCode%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法存取等候設定。</exception>
        <exception cref="T:System.SystemException">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。  
  
 -或-  
  
 沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。  
  
 -或-  
  
 您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />。 這個方法僅適用於在本機電腦執行的處理序。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序進入閒置狀態。 這個多載只適用於具有使用者介面和訊息迴圈的處理序。</summary>
        <returns>
          如果關聯的處理序已經達到閒置狀態，則為 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle>強制應用程式等候，直到訊息迴圈已返回閒置狀態的處理。 當執行使用者介面的處理序時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。 在處理序再傳回至訊息迴圈。 處理程序即處於閒置狀態時它正在等待訊息迴圈內的訊息。 此狀態會很有用，比方說，當您的應用程式需要等候完成建立其主視窗之前在應用程式傳送與該視窗啟動的處理序。  
  
 如果處理程序並沒有訊息迴圈，<xref:System.Diagnostics.Process.WaitForInputIdle>會擲回<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle>多載會指示<xref:System.Diagnostics.Process>無限期地等待處理序變成閒置訊息迴圈中的元件。 此指示可能會導致應用程式停止回應。 例如，如果處理程序撰寫為永遠其訊息迴圈會立即結束，如程式碼片段所示`while(true)`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序沒有圖形化介面。  
  
 -或-  
  
 發生未知的錯誤。 處理序無法進入閒置狀態。  
  
 -或-  
  
 處理程序已經結束。  
  
 -或-  
  
 沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">1 到 <see cref="F:System.Int32.MaxValue" /> 的值，指定等候相關聯處理序變成閒置的時間 (毫秒)。 值為 0 時，指定立即傳回，而值為 -1 時則指定無限期等候。</param>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態的指定毫秒數。 這個多載只適用於具有使用者介面和訊息迴圈的處理序。</summary>
        <returns>
          如果相關的處理序已經達到閒置狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>強制應用程式等候，直到訊息迴圈已返回閒置狀態的處理。 當執行使用者介面的處理序時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。 在處理序再傳回至訊息迴圈。 處理程序即處於閒置狀態時它正在等待訊息迴圈內的訊息。 此狀態會很有用，比方說，當您的應用程式需要等候完成建立其主視窗之前在應用程式傳送與該視窗啟動的處理序。  
  
 如果處理程序並沒有訊息迴圈，<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>會擲回<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>多載會指示<xref:System.Diagnostics.Process>元件等候在有限的一段時間閒置訊息迴圈中處理程序。 相關聯的處理序已不變成閒置狀態時的時間間隔結束迴圈仍在處理訊息，因為`false`會傳回到呼叫的程序。  
  
 如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序沒有圖形化介面。  
  
 -或-  
  
 發生未知的錯誤。 處理序無法進入閒置狀態。  
  
 -或-  
  
 處理程序已經結束。  
  
 -或-  
  
 沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的實體記憶體使用量 (以位元組為單位)。</summary>
        <value>相關的處理序正在使用的實體記憶體的總量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表目前的工作集記憶體使用此程序，以位元組為單位的大小。 處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。 這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用資料。 共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示指定的處理序結束代碼。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的實體記憶體量，以位元組為單位。</summary>
        <value>配置給關聯處理序的實體記憶體量，以位元組為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表目前的工作集記憶體使用此程序，以位元組為單位的大小。 處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。 這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用資料。 共用的資料包含頁面包含所有處理序執行，包括指示處理序模組和系統程式庫中的指示。  
  
 這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**工作組**處理序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示各種內容相關聯的處理序。 該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>