<Type Name="Process" FullName="System.Diagnostics.Process">
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="7d50d-101">提供對本機和遠端處理序的存取，並讓您能夠啟動和停止本機系統處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-101">Provides access to local and remote processes and enables you to start and stop local system processes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-102">A<xref:System.Diagnostics.Process>元件所提供的存取權執行的電腦的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-102">A <xref:System.Diagnostics.Process> component provides access to a process that is running on a computer.</span></span> <span data-ttu-id="7d50d-103">處理程序，最簡單的說，是執行中應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-103">A process, in the simplest terms, is a running app.</span></span> <span data-ttu-id="7d50d-104">執行緒是作業系統會配置處理器時間的基本單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-104">A thread is the basic unit to which the operating system allocates processor time.</span></span> <span data-ttu-id="7d50d-105">執行緒可以執行此程序，包括由另一個執行緒目前正在執行的組件的程式任何的碼部分。</span><span class="sxs-lookup"><span data-stu-id="7d50d-105">A thread can execute any part of the code of the process, including parts currently being executed by another thread.</span></span>  
  
 <span data-ttu-id="7d50d-106"><xref:System.Diagnostics.Process>元件是有用的工具，啟動、 停止、 控制和監視應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-106">The <xref:System.Diagnostics.Process> component is a useful tool for starting, stopping, controlling, and monitoring apps.</span></span> <span data-ttu-id="7d50d-107">您可以使用<xref:System.Diagnostics.Process>元件，以取得所執行的處理程序的清單，或者您可以啟動新的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-107">You can use the <xref:System.Diagnostics.Process> component, to obtain a list of the processes that are running, or you can start a new process.</span></span> <span data-ttu-id="7d50d-108">A<xref:System.Diagnostics.Process>元件用來存取系統處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-108">A <xref:System.Diagnostics.Process> component is used to access system processes.</span></span> <span data-ttu-id="7d50d-109">之後<xref:System.Diagnostics.Process>元件已經初始化，它可以用來取得執行中處理序的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-109">After a <xref:System.Diagnostics.Process> component has been initialized, it can be used to obtain information about the running process.</span></span> <span data-ttu-id="7d50d-110">這類資訊包括的執行緒，已載入的模組 （.dll 和.exe 檔案） 集，且使用效能資訊，例如處理程序的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-110">Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.</span></span>  
  
 <span data-ttu-id="7d50d-111">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-111">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="7d50d-112">當您完成使用類型時，您應該會處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="7d50d-112">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="7d50d-113">若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-113">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="7d50d-114">若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-114">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="7d50d-115">如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-115">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-116">32 位元處理序無法存取 64 位元處理序的模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-116">32-bit processes cannot access the modules of a 64-bit process.</span></span> <span data-ttu-id="7d50d-117">如果您嘗試從 32 位元處理序取得 64 位元處理序的相關資訊，您會收到<xref:System.ComponentModel.Win32Exception>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-117">If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception.</span></span> <span data-ttu-id="7d50d-118">相反地，64 位元處理程序，可以存取 32 位元處理序的模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-118">A 64-bit process, on the other hand, can access the modules of a 32-bit process.</span></span>  
  
 <span data-ttu-id="7d50d-119">處理序元件會取得全部的屬性群組的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-119">The process component obtains information about a group of properties all at once.</span></span> <span data-ttu-id="7d50d-120">之後<xref:System.Diagnostics.Process>元件已取得的任何群組的一個成員的相關資訊，它將會快取該群組中的其他屬性的值，並不取得新資訊的其他群組成員，直到您呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-120">After the <xref:System.Diagnostics.Process> component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="7d50d-121">因此，如果屬性值不保證能夠比上次呼叫任何新<xref:System.Diagnostics.Process.Refresh%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-121">Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="7d50d-122">群組細項是作業系統相依。</span><span class="sxs-lookup"><span data-stu-id="7d50d-122">The group breakdowns are operating-system dependent.</span></span>  
  
 <span data-ttu-id="7d50d-123">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-123">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="7d50d-124">否則，系統將不到路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-124">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="7d50d-125">例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="7d50d-125">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
 <span data-ttu-id="7d50d-126">系統處理序是以唯一識別系統上處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-126">A system process is uniquely identified on the system by its process identifier.</span></span> <span data-ttu-id="7d50d-127">如同許多 Windows 資源，也是由其控制代碼，可能不是唯一的電腦上識別處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-127">Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer.</span></span> <span data-ttu-id="7d50d-128">控點是泛型的詞彙，資源的識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-128">A handle is the generic term for an identifier of a resource.</span></span> <span data-ttu-id="7d50d-129">作業系統持續發生的處理序控制代碼，可從存取<xref:System.Diagnostics.Process.Handle%2A>屬性<xref:System.Diagnostics.Process>元件，即使在處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-129">The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the <xref:System.Diagnostics.Process> component, even when the process has exited.</span></span> <span data-ttu-id="7d50d-130">因此，您可以取得處理序的系統管理資訊，例如<xref:System.Diagnostics.Process.ExitCode%2A>（通常是零的成功或為非零的錯誤程式碼） 和<xref:System.Diagnostics.Process.ExitTime%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-130">Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>.</span></span> <span data-ttu-id="7d50d-131">控制代碼是非常重要的資源，所以遺漏控制更 virulent 比流失記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-131">Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-132">這個類別包含的連結要求和繼承要求套用到所有成員的類別層級。</span><span class="sxs-lookup"><span data-stu-id="7d50d-132">This class contains a link demand and an inheritance demand at the class level that applies to all members.</span></span> <span data-ttu-id="7d50d-133">A<xref:System.Security.SecurityException>立即呼叫者或衍生的類別並沒有完全信任權限時，會擲回。</span><span class="sxs-lookup"><span data-stu-id="7d50d-133">A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission.</span></span> <span data-ttu-id="7d50d-134">如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-134">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md).</span></span>  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)]<span data-ttu-id="7d50d-135"> 附註</span><span class="sxs-lookup"><span data-stu-id="7d50d-135"> Notes</span></span>  
 <span data-ttu-id="7d50d-136">在.NET Framework 中，<xref:System.Diagnostics.Process>類別預設會使用<xref:System.Console>編碼方式，通常是程式碼頁編碼方式，輸入、 輸出和錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-136">In the .NET Framework, the <xref:System.Diagnostics.Process> class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams.</span></span> <span data-ttu-id="7d50d-137">如需範例程式碼，在系統上的文化特性是英文 （美國），字碼頁 437 則是預設編碼方式<xref:System.Console>類別。</span><span class="sxs-lookup"><span data-stu-id="7d50d-137">For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class.</span></span> <span data-ttu-id="7d50d-138">不過，[!INCLUDE[net_core](~/includes/net-core-md.md)]可能提供只這些編碼方式的有限的子集。</span><span class="sxs-lookup"><span data-stu-id="7d50d-138">However, [!INCLUDE[net_core](~/includes/net-core-md.md)] may make only a limited subset of these encodings available.</span></span> <span data-ttu-id="7d50d-139">如果這種情況，它會使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>做為預設編碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-139">If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> as the default encoding.</span></span>  
  
 <span data-ttu-id="7d50d-140">如果<xref:System.Diagnostics.Process>物件相依於特定字碼頁編碼方式，您仍然可以它們可執行下列步驟*之前*呼叫任何<xref:System.Diagnostics.Process>方法：</span><span class="sxs-lookup"><span data-stu-id="7d50d-140">If a <xref:System.Diagnostics.Process> object depends on specific code page encodings, you can still make them available by doing the following *before* you call any <xref:System.Diagnostics.Process> methods:</span></span>  
  
1.  <span data-ttu-id="7d50d-141">System.Text.Encoding.CodePages.dll 組件的參考加入至您的專案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-141">Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.</span></span>  
  
2.  <span data-ttu-id="7d50d-142">擷取<xref:System.Text.EncodingProvider>物件從<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-142">Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> property.</span></span>  
  
3.  <span data-ttu-id="7d50d-143">傳遞<xref:System.Text.EncodingProvider>物件<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>進行額外的編碼方式編碼的提供者支援的方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-143">Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> method to make the additional encodings supported by the encoding provider available.</span></span>  
  
 <span data-ttu-id="7d50d-144"><xref:System.Diagnostics.Process>類別然後將自動使用預設系統而不 UTF8 編碼方式，提供您已註冊編碼提供者，然後再呼叫任何<xref:System.Diagnostics.Process>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-144">The <xref:System.Diagnostics.Process> class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any <xref:System.Diagnostics.Process> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-145">下列範例會使用的執行個體<xref:System.Diagnostics.Process>啟動處理序的類別。</span><span class="sxs-lookup"><span data-stu-id="7d50d-145">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 <span data-ttu-id="7d50d-146">下列範例會使用<xref:System.Diagnostics.Process>類別本身和靜態<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-146">The following example uses the <xref:System.Diagnostics.Process> class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 <span data-ttu-id="7d50d-147">下列的 F # 範例會定義`runProc`啟動的處理序的函式會擷取所有輸出和錯誤的資訊，並記錄的程序執行的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-147">The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.</span></span>  <span data-ttu-id="7d50d-148">`runProc`函式具有三個參數： 若要啟動，引數提供給應用程式，並起始目錄的應用程式的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-148">The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.</span></span>  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 <span data-ttu-id="7d50d-149">程式碼`runProc`函式由寫入[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)和適用於[Microsoft Public License](https://opensource.org/licenses/ms-pl)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-149">The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](https://opensource.org/licenses/ms-pl).</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-150">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-150">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-151">這個類別無法供部分信任程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-151">This class cannot be used by partially trusted code.</span></span></permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="7d50d-152">針對繼承者完全信任。</span><span class="sxs-lookup"><span data-stu-id="7d50d-152">for full trust for inheritors.</span></span> <span data-ttu-id="7d50d-153">這個類別無法被繼承，部分信任程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-153">This class cannot be inherited by partially trusted code.</span></span></permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-154">初始化 <see cref="T:System.Diagnostics.Process" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-154">Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-155">如果您未指定<xref:System.Diagnostics.Process.MachineName%2A>屬性，預設值為本機電腦 ("。")。</span><span class="sxs-lookup"><span data-stu-id="7d50d-155">If you do not specify the <xref:System.Diagnostics.Process.MachineName%2A> property, the default is the local computer, (".").</span></span>  
  
 <span data-ttu-id="7d50d-156">您有兩種方式來建立新的關聯<xref:System.Diagnostics.Process>元件之電腦上的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-156">You have two options for associating a new <xref:System.Diagnostics.Process> component with a process on the computer.</span></span> <span data-ttu-id="7d50d-157">第一個選項是使用建構函式來建立<xref:System.Diagnostics.Process>元件設定的適當成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性並呼叫<xref:System.Diagnostics.Process.Start%2A>關聯<xref:System.Diagnostics.Process>與新的系統處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-157">The first option is to use the constructor to create the <xref:System.Diagnostics.Process> component, set the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and call <xref:System.Diagnostics.Process.Start%2A> to associate the <xref:System.Diagnostics.Process> with a new system process.</span></span> <span data-ttu-id="7d50d-158">第二個選項會使<xref:System.Diagnostics.Process>具有執行系統處理序使用<xref:System.Diagnostics.Process.GetProcessById%2A>或其中一個<xref:System.Diagnostics.Process.GetProcesses%2A>傳回值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-158">The second option is to associate the <xref:System.Diagnostics.Process> with a running system process by using <xref:System.Diagnostics.Process.GetProcessById%2A> or one of the <xref:System.Diagnostics.Process.GetProcesses%2A> return values.</span></span>  
  
 <span data-ttu-id="7d50d-159">如果您使用`static`多載<xref:System.Diagnostics.Process.Start%2A>方法來啟動新的系統處理序，該方法會建立新<xref:System.Diagnostics.Process>元件並將它與處理序相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-159">If you use a `static` overload of the <xref:System.Diagnostics.Process.Start%2A> method to start a new system process, the method creates a new <xref:System.Diagnostics.Process> component and associates it with the process.</span></span>  
  
 <span data-ttu-id="7d50d-160">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>屬性設為預設值， `true`，您可以使用類似的方式啟動應用程式和文件`Run`對話方塊中的 Windows `Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="7d50d-160">When the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> property is set to its default value, `true`, you can start applications and documents in a way that is similar to using the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="7d50d-161">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>是`false`，您就可以開始只可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-161">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> is `false`, you can start only executables.</span></span>  
  
 <span data-ttu-id="7d50d-162">您可以從命令列呼叫任何可執行檔可以啟動兩種方式之一： 藉由設定的適當成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>方法使用任何參數，或藉由傳遞至適當的參數`static` <xref:System.Diagnostics.Process.Start%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-162">Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and calling the <xref:System.Diagnostics.Process.Start%2A> method with no parameters, or by passing the appropriate parameter to the `static`<xref:System.Diagnostics.Process.Start%2A> member.</span></span>  
  
 <span data-ttu-id="7d50d-163">您可以建立<xref:System.Diagnostics.Process>元件使用建構函式，其中一個靜態<xref:System.Diagnostics.Process.Start%2A>多載，或任何<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcesses%2A>，或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-163">You can create a <xref:System.Diagnostics.Process> component by using the constructor, one of the static <xref:System.Diagnostics.Process.Start%2A> overloads, or any of the <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, or <xref:System.Diagnostics.Process.GetProcessesByName%2A> methods.</span></span> <span data-ttu-id="7d50d-164">這麼做之後，您必須讓您檢視相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-164">After you have done so, you have a view into the associated process.</span></span> <span data-ttu-id="7d50d-165">這不會自動更新本身，當處理序屬性已變更在記憶體中的動態檢視。</span><span class="sxs-lookup"><span data-stu-id="7d50d-165">This is not a dynamic view that updates itself automatically when the process properties have changed in memory.</span></span> <span data-ttu-id="7d50d-166">相反地，您必須呼叫<xref:System.Diagnostics.Process.Refresh%2A>更新元件<xref:System.Diagnostics.Process>應用程式中的屬性資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-166">Instead, you must call <xref:System.Diagnostics.Process.Refresh%2A> for the component to update the <xref:System.Diagnostics.Process> property information in your application.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-167">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-167">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-168">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-168">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-169">取得相關處理序的基礎優先權 (Base Priority)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-169">Gets the base priority of the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-170">基礎優先權，它是從相關聯處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 計算出來的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-170">The base priority, which is computed from the <see cref="P:System.Diagnostics.Process.PriorityClass" /> of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-171"><xref:System.Diagnostics.Process.BasePriority%2A>程序會建立相關聯的處理序中執行緒的起始優先順序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-171">The <xref:System.Diagnostics.Process.BasePriority%2A> of the process is the starting priority for threads created within the associated process.</span></span> <span data-ttu-id="7d50d-172">您可以檢視透過系統監視器的優先權基底計數器的基礎優先權的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-172">You can view information about the base priority through the System Monitor's Priority Base counter.</span></span>  
  
 <span data-ttu-id="7d50d-173">根據 24 小時制或其他優先權的提高，作業系統可以變更的基底的優先順序，當處理程序應該放在其他人的前面的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-173">Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</span></span>  
  
 <span data-ttu-id="7d50d-174"><xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視指派給處理程序的起始優先權。</span><span class="sxs-lookup"><span data-stu-id="7d50d-174">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority assigned to a process.</span></span> <span data-ttu-id="7d50d-175">不過，因為它是唯讀，您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>設定程序的優先順序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-175">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> to set the priority of the process.</span></span> <span data-ttu-id="7d50d-176">若要變更優先順序，請使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-176">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property.</span></span> <span data-ttu-id="7d50d-177"><xref:System.Diagnostics.Process.BasePriority%2A>就可以檢視，使用系統監視器 」，而<xref:System.Diagnostics.Process.PriorityClass%2A>不是。</span><span class="sxs-lookup"><span data-stu-id="7d50d-177">The <xref:System.Diagnostics.Process.BasePriority%2A> is viewable using the System Monitor, while the <xref:System.Diagnostics.Process.PriorityClass%2A> is not.</span></span> <span data-ttu-id="7d50d-178">同時<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>可以透過程式設計方式檢視。</span><span class="sxs-lookup"><span data-stu-id="7d50d-178">Both the <xref:System.Diagnostics.Process.BasePriority%2A> and the <xref:System.Diagnostics.Process.PriorityClass%2A> can be viewed programmatically.</span></span> <span data-ttu-id="7d50d-179">下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>值和<xref:System.Diagnostics.Process.PriorityClass%2A>值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-179">The following table shows the relationship between <xref:System.Diagnostics.Process.BasePriority%2A> values and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="7d50d-180">BasePriority</span><span class="sxs-lookup"><span data-stu-id="7d50d-180">BasePriority</span></span>|<span data-ttu-id="7d50d-181">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="7d50d-181">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="7d50d-182">4</span><span class="sxs-lookup"><span data-stu-id="7d50d-182">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="7d50d-183">8</span><span class="sxs-lookup"><span data-stu-id="7d50d-183">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="7d50d-184">13</span><span class="sxs-lookup"><span data-stu-id="7d50d-184">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="7d50d-185">24</span><span class="sxs-lookup"><span data-stu-id="7d50d-185">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-186">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-186">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-187">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-187">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-188">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-188">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-189">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-189">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-190">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-190">The process has exited.</span></span>  
  
 <span data-ttu-id="7d50d-191">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-191">-or-</span></span>  
  
 <span data-ttu-id="7d50d-192">處理序尚未啟動，因此沒有處理序 ID。</span><span class="sxs-lookup"><span data-stu-id="7d50d-192">The process has not started, so there is no process ID.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-193">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-193">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-194">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-194">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-195">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上開始非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-195">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-196"><xref:System.Diagnostics.Process.StandardError%2A>同步或非同步方式，就可以讀取資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-196">The <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="7d50d-197">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行同步處理程序的錯誤輸出資料流上的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-197">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="7d50d-198">這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-198">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="7d50d-199">相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-199">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="7d50d-200">這個方法可讓資料流輸出指定之的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-200">This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="7d50d-201">請遵循下列步驟來執行非同步的讀取的作業上<xref:System.Diagnostics.Process.StandardError%2A>如<xref:System.Diagnostics.Process>:</span><span class="sxs-lookup"><span data-stu-id="7d50d-201">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="7d50d-202">請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-202">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="7d50d-203">請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-203">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="7d50d-204">加入事件處理常式<xref:System.Diagnostics.Process.ErrorDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-204">Add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event.</span></span> <span data-ttu-id="7d50d-205">事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。</span><span class="sxs-lookup"><span data-stu-id="7d50d-205">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="7d50d-206">啟動<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-206">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="7d50d-207">呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>如<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-207">Call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="7d50d-208">此呼叫在開始非同步讀取的作業<xref:System.Diagnostics.Process.StandardError%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-208">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span>  
  
 <span data-ttu-id="7d50d-209">當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>將某行的文字寫入其<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-209">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-210">您可以藉由呼叫取消非同步讀取的作業<xref:System.Diagnostics.Process.CancelErrorRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-210">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span> <span data-ttu-id="7d50d-211">讀取的作業可以取消由呼叫端事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-211">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="7d50d-212">之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 以繼續執行非同步的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-212">After canceling, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-213">您不能混用重新導向資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-213">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="7d50d-214">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-214">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="7d50d-215">例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="7d50d-215">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="7d50d-216">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-216">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="7d50d-217">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-217">For example, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-218">下列範例會使用`net view`命令，列出在遠端電腦上的可用的網路資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-218">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="7d50d-219">使用者提供的目標電腦名稱做為命令列引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-219">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="7d50d-220">使用者也可以提供錯誤輸出的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-220">The user can also supply a file name for error output.</span></span> <span data-ttu-id="7d50d-221">此範例會收集的 net 命令、 等候處理程序完成，然後再寫入至主控台的輸出結果的輸出。</span><span class="sxs-lookup"><span data-stu-id="7d50d-221">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="7d50d-222">如果使用者提供選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-222">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-223"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-223">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.</span></span>  
  
 <span data-ttu-id="7d50d-224">\-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-224">\- or -</span></span>  
  
 <span data-ttu-id="7d50d-225">非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上進行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-225">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span>  
  
 <span data-ttu-id="7d50d-226">\-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-226">\- or -</span></span>  
  
 <span data-ttu-id="7d50d-227">同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-227">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-228">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-228">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-229">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-229">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-230">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上開始非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-230">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-231"><xref:System.Diagnostics.Process.StandardOutput%2A>同步或非同步方式，就可以讀取資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-231">The <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="7d50d-232">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流上的同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-232">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="7d50d-233">這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-233">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="7d50d-234">相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-234">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-235">這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-235">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="7d50d-236">請遵循下列步驟來執行非同步的讀取的作業上<xref:System.Diagnostics.Process.StandardOutput%2A>如<xref:System.Diagnostics.Process>:</span><span class="sxs-lookup"><span data-stu-id="7d50d-236">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="7d50d-237">請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-237">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="7d50d-238">請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-238">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="7d50d-239">加入事件處理常式<xref:System.Diagnostics.Process.OutputDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-239">Add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="7d50d-240">事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。</span><span class="sxs-lookup"><span data-stu-id="7d50d-240">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="7d50d-241">啟動<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-241">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="7d50d-242">呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>如<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-242">Call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="7d50d-243">此呼叫在開始非同步讀取的作業<xref:System.Diagnostics.Process.StandardOutput%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-243">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span>  
  
 <span data-ttu-id="7d50d-244">當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>將某行的文字寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-244">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-245">您可以藉由呼叫取消非同步讀取的作業<xref:System.Diagnostics.Process.CancelOutputRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-245">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span> <span data-ttu-id="7d50d-246">讀取的作業可以取消由呼叫端事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-246">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="7d50d-247">之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 以繼續執行非同步的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-247">After canceling, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-248">您不能混用重新導向資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-248">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="7d50d-249">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-249">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="7d50d-250">例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="7d50d-250">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="7d50d-251">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-251">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="7d50d-252">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-252">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-253">下列範例說明如何執行非同步的讀取的作業上的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流`sort`命令。</span><span class="sxs-lookup"><span data-stu-id="7d50d-253">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command.</span></span> <span data-ttu-id="7d50d-254">`sort`命令是主控台應用程式讀取及排序文字輸入。</span><span class="sxs-lookup"><span data-stu-id="7d50d-254">The `sort` command is a console application that reads and sorts text input.</span></span>  
  
 <span data-ttu-id="7d50d-255">此範例會建立為事件委派`SortOutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-255">The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="7d50d-256">此事件處理常式收到來自的重新導向的文字行<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將文字寫入至螢幕。</span><span class="sxs-lookup"><span data-stu-id="7d50d-256">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-257"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 屬性為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-257">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.</span></span>  
  
 <span data-ttu-id="7d50d-258">\-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-258">\- or -</span></span>  
  
 <span data-ttu-id="7d50d-259">非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上進行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-259">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span>  
  
 <span data-ttu-id="7d50d-260">\-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-260">\- or -</span></span>  
  
 <span data-ttu-id="7d50d-261">同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-261">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-262">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-262">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-263">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-263">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-264">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上取消非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-264">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-265"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-265"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="7d50d-266"><xref:System.Diagnostics.Process.CancelErrorRead%2A> 結束非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-266"><xref:System.Diagnostics.Process.CancelErrorRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="7d50d-267">之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>一次。</span><span class="sxs-lookup"><span data-stu-id="7d50d-267">After canceling, you can resume the asynchronous read operation by calling <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="7d50d-268">當您呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>，則所有進行中讀取作業<xref:System.Diagnostics.Process.StandardError%2A>完成，則會停用此事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-268">When you call <xref:System.Diagnostics.Process.CancelErrorRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardError%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="7d50d-269">所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardError%2A>儲存在緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7d50d-269">All further redirected output to <xref:System.Diagnostics.Process.StandardError%2A> is saved in a buffer.</span></span> <span data-ttu-id="7d50d-270">如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、 儲存的輸出會傳送至事件處理常式和非同步讀取的作業繼續執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-270">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="7d50d-271">如果您想要變更的事件處理常式，繼續進行非同步讀取的作業之前，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：</span><span class="sxs-lookup"><span data-stu-id="7d50d-271">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-272">您不能混用非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-272">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="7d50d-273">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-273">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="7d50d-274">如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>，必須從資料流讀取一次，您必須使用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>繼續非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-274">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardError%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="7d50d-275">請勿遵循<xref:System.Diagnostics.Process.CancelErrorRead%2A>讀取並具有呼叫同步方法<xref:System.Diagnostics.Process.StandardError%2A>例如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-275">Do not follow <xref:System.Diagnostics.Process.CancelErrorRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardError%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-276">下列範例會啟動`nmake`命令與使用者提供的引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-276">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="7d50d-277">錯誤和輸出資料流讀取以非同步的方式;收集的文字行所顯示到主控台，以及寫入記錄檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-277">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="7d50d-278">如果命令輸出超過指定的行數，則會取消非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-278">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-279">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-279">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-280">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-280">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-281">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-281">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-282">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上取消非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-282">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-283"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-283"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-284"><xref:System.Diagnostics.Process.CancelOutputRead%2A> 結束非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-284"><xref:System.Diagnostics.Process.CancelOutputRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="7d50d-285">之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>一次。</span><span class="sxs-lookup"><span data-stu-id="7d50d-285">After canceling, you can resume asynchronous read operations by calling <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="7d50d-286">當您呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>，則所有進行中讀取作業<xref:System.Diagnostics.Process.StandardOutput%2A>完成，則會停用此事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-286">When you call <xref:System.Diagnostics.Process.CancelOutputRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardOutput%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="7d50d-287">所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardOutput%2A>儲存在緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7d50d-287">All further redirected output to <xref:System.Diagnostics.Process.StandardOutput%2A> is saved in a buffer.</span></span> <span data-ttu-id="7d50d-288">如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、 儲存的輸出會傳送至事件處理常式和非同步讀取的作業繼續執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-288">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="7d50d-289">如果您想要變更的事件處理常式，繼續進行非同步讀取的作業之前，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：</span><span class="sxs-lookup"><span data-stu-id="7d50d-289">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-290">您不能混用非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-290">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-291">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-291">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="7d50d-292">如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>，必須從資料流讀取一次，您必須使用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>繼續非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-292">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardOutput%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="7d50d-293">請勿遵循<xref:System.Diagnostics.Process.CancelOutputRead%2A>讀取並具有呼叫同步方法<xref:System.Diagnostics.Process.StandardOutput%2A>例如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-293">Do not follow <xref:System.Diagnostics.Process.CancelOutputRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardOutput%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-294">下列範例會啟動`nmake`命令與使用者提供的引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-294">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="7d50d-295">錯誤和輸出資料流讀取以非同步的方式;收集的文字行所顯示到主控台，以及寫入記錄檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-295">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="7d50d-296">如果命令輸出超過指定的行數，則會取消非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-296">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-297">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-297">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-298">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-298">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-299">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-299">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-300">釋放與這個元件相關的所有資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-300">Frees all the resources that are associated with this component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-301"><xref:System.Diagnostics.Process.Close%2A>方法會導致處理程序停止等候結束等候它，如果關閉處理序控制代碼，並清除處理序專屬的屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-301">The <xref:System.Diagnostics.Process.Close%2A> method causes the process to stop waiting for exit if it was waiting, closes the process handle, and clears process-specific properties.</span></span> <span data-ttu-id="7d50d-302"><xref:System.Diagnostics.Process.Close%2A> 不會關閉的標準輸出、 輸入和錯誤的讀取器和寫入器，如果它們要從外部參考。</span><span class="sxs-lookup"><span data-stu-id="7d50d-302"><xref:System.Diagnostics.Process.Close%2A> does not close the standard output, input, and error readers and writers in case they are being referenced externally.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-303"><xref:System.Diagnostics.Process.Dispose%2A> 方法呼叫 <xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-303">The <xref:System.Diagnostics.Process.Dispose%2A> method calls <xref:System.Diagnostics.Process.Close%2A>.</span></span> <span data-ttu-id="7d50d-304">放置<xref:System.Diagnostics.Process>物件存放至`using`區塊處置的資源，而不需要呼叫<xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-304">Placing the <xref:System.Diagnostics.Process> object in a `using` block disposes of resources without the need to call <xref:System.Diagnostics.Process.Close%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-305">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-305">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-306">然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 秒間隔的最大值為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-306">It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="7d50d-307">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-307">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="7d50d-308">如果它仍在執行 10 秒後，此範例會關閉處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-308">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-309">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-309">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-310">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-310">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-311">關閉有使用者介面的處理序，方法是傳送關閉訊息至其主視窗。</span><span class="sxs-lookup"><span data-stu-id="7d50d-311">Closes a process that has a user interface by sending a close message to its main window.</span></span></summary>
        <returns>
          <span data-ttu-id="7d50d-312">如果已成功傳送關閉訊息，則為 <see langword="true" />；如果相關聯處理序沒有主視窗或主視窗已停用 (例如，如果正在顯示強制回應對話方塊)，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-312"><see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-313">當執行程序時，其訊息迴圈會處於等候狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-313">When a process is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="7d50d-314">每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7d50d-314">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="7d50d-315">呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>接近主要視窗中，且格式正確的應用程式中，在關閉子視窗，並撤銷應用程式的所有執行訊息迴圈傳送的要求。</span><span class="sxs-lookup"><span data-stu-id="7d50d-315">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="7d50d-316">藉由呼叫結束程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-316">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="7d50d-317">應用程式可以要求使用者驗證，才能結束，或它可以拒絕結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-317">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="7d50d-318">若要強制執行應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-318">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="7d50d-319">行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗使用 [系統] 功能表的使用者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-319">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="7d50d-320">因此，要求關閉主視窗結束處理程序不會強制立即結束應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-320">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
 <span data-ttu-id="7d50d-321">編輯程序的資料或配置給處理序的資源可能會遺失如果您呼叫<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-321">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-322"><xref:System.Diagnostics.Process.Kill%2A> 導致處理程序異常終止，並在必要時才應該使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-322"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination, and should be used only when necessary.</span></span> <span data-ttu-id="7d50d-323"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此最好有一個介面的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-323"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="7d50d-324">如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-324">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="7d50d-325"><xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-325"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="7d50d-326">您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-326">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="7d50d-327">若要結束遠端電腦上，您無法讓處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-327">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="7d50d-328">您只能檢視遠端電腦上執行的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-328">You can only view information for processes running on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-329">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-329">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-330">然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 的第二個時間間隔，最多為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-330">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="7d50d-331">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-331">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="7d50d-332">如果它仍在執行 10 秒後，此範例會關閉處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-332">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-333">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-333">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-334">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-334">The process has already exited.</span></span>  
  
 <span data-ttu-id="7d50d-335">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-335">-or-</span></span>  
  
 <span data-ttu-id="7d50d-336">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-336">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-337">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-337">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-338">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-338">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="7d50d-339"><see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-339"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="7d50d-340">釋放這個處理序使用的所有資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-340">Release all resources used by this process.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-341">取得或設定是否應該在處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-341">Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</span></span></summary>
        <value>
          <span data-ttu-id="7d50d-342">如果應該在相關聯處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件 (經由結束或呼叫 <see cref="M:System.Diagnostics.Process.Kill" />)，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-342"><see langword="true" /> if the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the associated process is terminated (through either an exit or a call to <see cref="M:System.Diagnostics.Process.Kill" />); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="7d50d-343">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-343">The default is <see langword="false" />.</span></span> <span data-ttu-id="7d50d-344">請注意，<see cref="E:System.Diagnostics.Process.Exited" />引發即使值<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />是<see langword="false" />於期間的處理序結束時，或使用者執行<see cref="P:System.Diagnostics.Process.HasExited" />檢查。</span><span class="sxs-lookup"><span data-stu-id="7d50d-344">Note that the <see cref="E:System.Diagnostics.Process.Exited" /> event is raised even if the value of <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> is <see langword="false" /> when the process exits during or before the user performs a <see cref="P:System.Diagnostics.Process.HasExited" /> check.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="7d50d-345"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性建議當作業系統已關閉處理序時，是否應該通知元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-345">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property suggests whether the component should be notified when the operating system has shut down a process.</span></span> <span data-ttu-id="7d50d-346"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性來處理非同步通知的處理序已結束您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-346">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is used in asynchronous processing to notify your application that a process has exited.</span></span> <span data-ttu-id="7d50d-347">若要強制同步等候結束事件 （會中斷應用程式的處理，直到結束事件發生） 的應用程式，請使用<xref:System.Diagnostics.Process.WaitForExit%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-347">To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the <xref:System.Diagnostics.Process.WaitForExit%2A> method.</span></span>

> [!NOTE]
> <span data-ttu-id="7d50d-348">如果您使用 Visual Studio，並按兩下<xref:System.Diagnostics.Process>元件在專案中，<xref:System.Diagnostics.Process.Exited>事件委派和事件處理常式會自動產生。</span><span class="sxs-lookup"><span data-stu-id="7d50d-348">If you're using Visual Studio and double-click a <xref:System.Diagnostics.Process> component in your project, an <xref:System.Diagnostics.Process.Exited> event delegate and event handler are automatically generated.</span></span> <span data-ttu-id="7d50d-349">其他的程式碼集<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性`false`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-349">Additional code sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to `false`.</span></span> <span data-ttu-id="7d50d-350">您必須變更此屬性為`true`相關聯的處理序結束時，要執行事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-350">You must change this property to `true` for your event handler to execute when the associated process exits.</span></span>

<span data-ttu-id="7d50d-351">如果元件的<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>值是`true`，或當<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`false`和<xref:System.Diagnostics.Process.HasExited%2A>核取叫用元件，元件可以存取的相關聯的處理序會保留的系統管理資訊儲存作業系統。</span><span class="sxs-lookup"><span data-stu-id="7d50d-351">If the component's <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> value is `true`, or when <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `false` and a <xref:System.Diagnostics.Process.HasExited%2A> check is invoked by the component, the component can access the administrative information for the associated process, which remains stored by the operating system.</span></span> <span data-ttu-id="7d50d-352">這類資訊包括<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.ExitCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-352">Such information includes the <xref:System.Diagnostics.Process.ExitTime%2A> and the <xref:System.Diagnostics.Process.ExitCode%2A>.</span></span>

<span data-ttu-id="7d50d-353">相關聯的處理序結束之後，<xref:System.Diagnostics.Process.Handle%2A>的元件不會再指向現有的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-353">After the associated process exits, the <xref:System.Diagnostics.Process.Handle%2A> of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="7d50d-354">相反地，它可以只可用來存取作業系統的處理序資源相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-354">Instead, it can only be used to access the operating system's information about the process resource.</span></span> <span data-ttu-id="7d50d-355">作業系統是感知會結束處理程序尚未釋放的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保存<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>記憶體中的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-355">The operating system is aware that there are handles to exited processes that haven't been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory.</span></span>

<span data-ttu-id="7d50d-356">沒有相關聯的處理序結束監看的成本。</span><span class="sxs-lookup"><span data-stu-id="7d50d-356">There's a cost associated with watching for a process to exit.</span></span> <span data-ttu-id="7d50d-357">如果<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`true`、<xref:System.Diagnostics.Process.Exited>相關聯的處理序終止時，就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-357">If <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `true`, the <xref:System.Diagnostics.Process.Exited> event is raised when the associated process terminates.</span></span> <span data-ttu-id="7d50d-358">您的程序<xref:System.Diagnostics.Process.Exited>事件在那時候執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-358">Your procedures for the <xref:System.Diagnostics.Process.Exited> event run at that time.</span></span>

<span data-ttu-id="7d50d-359">有時候，您的應用程式啟動的處理序，但是不需要關閉的通知。</span><span class="sxs-lookup"><span data-stu-id="7d50d-359">Sometimes, your application starts a process but doesn't require notification of its closure.</span></span> <span data-ttu-id="7d50d-360">例如，您的應用程式可以啟動 [記事本] 來允許使用者執行文字編輯，但沒有進一步地使用 「 記事本 」 應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-360">For example, your application can start Notepad to allow the user to perform text editing but make no further use of the Notepad application.</span></span> <span data-ttu-id="7d50d-361">您可以選擇避免處理序結束，因為它不是適用於您的應用程式繼續作業的通知。</span><span class="sxs-lookup"><span data-stu-id="7d50d-361">You can choose to avoid notification when the process exits because it's not relevant to the continued operation of your application.</span></span> <span data-ttu-id="7d50d-362">設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>至`false`可以節省系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-362">Setting <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> to `false` can save system resources.</span></span>

## Examples  
<span data-ttu-id="7d50d-363">下列程式碼範例會建立會列印檔案的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-363">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="7d50d-364">它會設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性，讓處理程序引發<xref:System.Diagnostics.Process.Exited>在結束時的事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-364">It sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits.</span></span> <span data-ttu-id="7d50d-365"><xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-365">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-366">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-366">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-367">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-367">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-368">啟用目前執行緒上的原生屬性 <see langword="SeDebugPrivilege" />，將 <see cref="T:System.Diagnostics.Process" /> 元件置於某種狀態，以便與使用特殊模式執行的作業系統處理序互動。</span><span class="sxs-lookup"><span data-stu-id="7d50d-368">Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-369">某些作業系統處理程序執行中使用特殊模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-369">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="7d50d-370">嘗試讀取的屬性，或附加至這些處理序不能除非您已經呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。</span><span class="sxs-lookup"><span data-stu-id="7d50d-370">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="7d50d-371">呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取特殊模式執行這些程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-371">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-372">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-372">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-373">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-373">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-374">發生於應用程式寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流時。</span><span class="sxs-lookup"><span data-stu-id="7d50d-374">Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-375"><xref:System.Diagnostics.Process.ErrorDataReceived>事件表示相關聯的處理序已寫入至其重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-375">The <xref:System.Diagnostics.Process.ErrorDataReceived> event indicates that the associated process has written to its redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-376">事件只發生在非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-376">The event only occurs during asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span> <span data-ttu-id="7d50d-377">若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式來<xref:System.Diagnostics.Process.ErrorDataReceived>事件和呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-377">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardError%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event, and call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</span></span> <span data-ttu-id="7d50d-378">此後，<xref:System.Diagnostics.Process.ErrorDataReceived>事件訊號處理程序將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardError%2A>串流處理，直到處理程序會結束或呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-378">Thereafter, the <xref:System.Diagnostics.Process.ErrorDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-379">正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit>方法，以確保已清除輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7d50d-379">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit> method to ensure that the output buffer has been flushed.</span></span> <span data-ttu-id="7d50d-380">請注意，使用該指定逾時<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>多載沒有*不*確保已清除輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7d50d-380">Note that specifying a timeout by using the <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> overload does *not* ensure the output buffer has been flushed.</span></span>
  
   
  
## Examples  
 <span data-ttu-id="7d50d-381">下列範例會使用`net view`命令，列出在遠端電腦上的可用的網路資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-381">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="7d50d-382">使用者提供的目標電腦名稱做為命令列引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-382">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="7d50d-383">使用者也可以提供錯誤輸出的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-383">The user can also supply a file name for error output.</span></span> <span data-ttu-id="7d50d-384">此範例會收集的 net 命令、 等候處理程序完成，然後再寫入至主控台的輸出結果的輸出。</span><span class="sxs-lookup"><span data-stu-id="7d50d-384">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="7d50d-385">如果使用者提供選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-385">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-386">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-386">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-387">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-387">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-388">取得相關處理序終止時指定的值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-388">Gets the value that the associated process specified when it terminated.</span></span></summary>
        <value><span data-ttu-id="7d50d-389">相關處理序終止時指定的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-389">The code that the associated process specified when it terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-390">使用<xref:System.Diagnostics.Process.ExitCode%2A>來取得系統處理序傳回其結束時的狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-390">Use <xref:System.Diagnostics.Process.ExitCode%2A> to get the status that the system process returned when it exited.</span></span> <span data-ttu-id="7d50d-391">您可以使用結束程式碼更像整數傳回的值從`main()`程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-391">You can use the exit code much like an integer return value from a `main()` procedure.</span></span>  
  
 <span data-ttu-id="7d50d-392"><xref:System.Diagnostics.Process.ExitCode%2A>處理程序會反映該處理程序的應用程式開發人員所實作的特定慣例的值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-392">The <xref:System.Diagnostics.Process.ExitCode%2A> value for a process reflects the specific convention implemented by the application developer for that process.</span></span> <span data-ttu-id="7d50d-393">如果您決定您的程式碼中使用的結束代碼值，請確定您知道應用程式處理序所使用的結束代碼慣例。</span><span class="sxs-lookup"><span data-stu-id="7d50d-393">If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</span></span>  
  
 <span data-ttu-id="7d50d-394">開發人員通常會表示成功的結束<xref:System.Diagnostics.Process.ExitCode%2A>值零，而指定的錯誤則為非零值呼叫的方法可以用來識別處理程序異常終止的原因。</span><span class="sxs-lookup"><span data-stu-id="7d50d-394">Developers usually indicate a successful exit by an <xref:System.Diagnostics.Process.ExitCode%2A> value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination.</span></span> <span data-ttu-id="7d50d-395">不需要遵循下列指導方針，但它們是慣例。</span><span class="sxs-lookup"><span data-stu-id="7d50d-395">It is not necessary to follow these guidelines, but they are the convention.</span></span>  
  
 <span data-ttu-id="7d50d-396">如果您嘗試取得<xref:System.Diagnostics.Process.ExitCode%2A>處理序已經結束之前，嘗試就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-396">If you try to get the <xref:System.Diagnostics.Process.ExitCode%2A> before the process has exited, the attempt throws an exception.</span></span> <span data-ttu-id="7d50d-397">檢查<xref:System.Diagnostics.Process.HasExited%2A>屬性第一次，確認是否已終止相關的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-397">Examine the <xref:System.Diagnostics.Process.HasExited%2A> property first to verify whether the associated process has terminated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-398">當非同步事件處理常式已經重新導向標準輸出時，您就可以確認輸出處理尚未完成時<xref:System.Diagnostics.Process.HasExited%2A>傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-398">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when <xref:System.Diagnostics.Process.HasExited%2A> returns `true`.</span></span> <span data-ttu-id="7d50d-399">若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前會採用任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-399">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
 <span data-ttu-id="7d50d-400">您可以使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>方法，讓相關聯的處理序結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-400">You can use the <xref:System.Diagnostics.Process.CloseMainWindow%2A> or the <xref:System.Diagnostics.Process.Kill%2A> method to cause an associated process to exit.</span></span>  
  
 <span data-ttu-id="7d50d-401">有兩種方式的相關聯的處理序結束時通知： 同步和非同步方式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-401">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="7d50d-402">同步通知依賴呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以暫停您的應用程式的處理，直到結束相關聯的元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-402">Synchronous notification relies on calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to pause the processing of your application until the associated component exits.</span></span> <span data-ttu-id="7d50d-403">非同步通知依賴<xref:System.Diagnostics.Process.Exited>事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-403">Asynchronous notification relies on the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="7d50d-404">當使用非同步通知，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`如<xref:System.Diagnostics.Process>元件來接收通知的處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-404">When using asynchronous notification, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the <xref:System.Diagnostics.Process> component to receive notification that the process has exited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-405">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-405">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-406">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-406">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-407">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-407">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-408">遠端處理序尚未結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-408">The process has not exited.</span></span>  
  
 <span data-ttu-id="7d50d-409">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-409">-or-</span></span>  
  
 <span data-ttu-id="7d50d-410">處理序 <see cref="P:System.Diagnostics.Process.Handle" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-410">The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-411">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-411">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-412">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-412">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-413">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-413">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-414">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-414">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-415">發生於處理序結束時。</span><span class="sxs-lookup"><span data-stu-id="7d50d-415">Occurs when a process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-416"><xref:System.Diagnostics.Process.Exited>事件表示相關聯的處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-416">The <xref:System.Diagnostics.Process.Exited> event indicates that the associated process exited.</span></span> <span data-ttu-id="7d50d-417">此項目表示處理程序結束 （中止） 或成功關閉。</span><span class="sxs-lookup"><span data-stu-id="7d50d-417">This occurrence means either that the process terminated (aborted) or successfully closed.</span></span> <span data-ttu-id="7d50d-418">只有當，可能會發生此事件的值<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-418">This event can occur only if the value of the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="7d50d-419">有兩種方式的相關聯的處理序結束時通知： 同步和非同步方式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-419">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="7d50d-420">同步通知表示呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來封鎖目前的執行緒，直到結束處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-420">Synchronous notification means calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to block the current thread until the process exits.</span></span> <span data-ttu-id="7d50d-421">使用非同步通知<xref:System.Diagnostics.Process.Exited>事件，可讓呼叫執行緒能夠繼續在同時執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-421">Asynchronous notification uses the <xref:System.Diagnostics.Process.Exited> event, which allows the calling thread to continue execution in the meantime.</span></span> <span data-ttu-id="7d50d-422">在後者的情況下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`呼叫的應用程式接收訊號事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-422">In the latter case, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the calling application to receive the Exited event.</span></span>  
  
 <span data-ttu-id="7d50d-423">當作業系統關機程序時，它會通知所有已註冊的 Exited 事件處理常式的其他處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-423">When the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event.</span></span> <span data-ttu-id="7d50d-424">在這個階段中，只要結束處理序控制代碼可用來存取某些屬性，例如<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.HasExited%2A>作業系統會維護，直到它完全解除該控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-424">At this time, the handle of the process that just exited can be used to access some properties such as  <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.HasExited%2A> that the operating system maintains until it releases that handle completely.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-425">即使您擁有已結束的處理序控制代碼時，您不能呼叫<xref:System.Diagnostics.Process.Start%2A>，重新連線至相同的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-425">Even if you have a handle to an exited process, you cannot call <xref:System.Diagnostics.Process.Start%2A> again to reconnect to the same process.</span></span> <span data-ttu-id="7d50d-426">呼叫<xref:System.Diagnostics.Process.Start%2A>自動釋出相關的處理序，並連接到處理程序相同的檔案，但全新<xref:System.Diagnostics.Process.Handle%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-426">Calling <xref:System.Diagnostics.Process.Start%2A> automatically releases the associated process and connects to a process with the same file but an entirely new <xref:System.Diagnostics.Process.Handle%2A>.</span></span>  
  
 <span data-ttu-id="7d50d-427">如需有關使用<xref:System.Diagnostics.Process.Exited>事件在 Windows Forms 應用程式，請參閱<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-427">For more information about the use of the <xref:System.Diagnostics.Process.Exited> event in Windows Forms applications, see the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-428">下列程式碼範例會建立會列印檔案的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-428">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="7d50d-429">它會引發<xref:System.Diagnostics.Process.Exited>事件的處理序結束，因為<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>建立處理程序時，已設定屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-429">It raises the <xref:System.Diagnostics.Process.Exited> event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created.</span></span> <span data-ttu-id="7d50d-430"><xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-430">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-431">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-431">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-432">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-432">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-433">取得相關的處理序結束的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-433">Gets the time that the associated process exited.</span></span></summary>
        <value><span data-ttu-id="7d50d-434"><see cref="T:System.DateTime" />，表示相關聯處理序何時終止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-434">A <see cref="T:System.DateTime" /> that indicates when the associated process was terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-435">如果還沒有終止處理程序，嘗試擷取<xref:System.Diagnostics.Process.ExitTime%2A>屬性會擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-435">If the process has not terminated, attempting to retrieve the <xref:System.Diagnostics.Process.ExitTime%2A> property throws an exception.</span></span> <span data-ttu-id="7d50d-436">使用<xref:System.Diagnostics.Process.HasExited%2A>再取得<xref:System.Diagnostics.Process.ExitTime%2A>屬性來判斷是否已終止相關的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-436">Use <xref:System.Diagnostics.Process.HasExited%2A> before getting the <xref:System.Diagnostics.Process.ExitTime%2A> property to determine whether the associated process has terminated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-437">下列程式碼範例會建立會列印檔案的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-437">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="7d50d-438">處理序引發<xref:System.Diagnostics.Process.Exited>時結束為止，事件和事件處理常式顯示<xref:System.Diagnostics.Process.ExitTime%2A>屬性和其他處理資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-438">The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the <xref:System.Diagnostics.Process.ExitTime%2A> property and other process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-439">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-439">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-440">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-440">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-441">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-441">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-442">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-442">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-443">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-443">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-444">取得新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與目前現用處理序相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-444">Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</span></span></summary>
        <returns><span data-ttu-id="7d50d-445">新的 <see cref="T:System.Diagnostics.Process" /> 元件，與正在執行呼叫應用程式的處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-445">A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-446">使用這個方法來建立新<xref:System.Diagnostics.Process>執行個體，並將它與本機電腦上的處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-446">Use this method to create a new <xref:System.Diagnostics.Process> instance and associate it with the process resource on the local computer.</span></span>  
  
 <span data-ttu-id="7d50d-447">例如，類似<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcessesByName%2A>，和<xref:System.Diagnostics.Process.GetProcesses%2A>方法<xref:System.Diagnostics.Process.GetCurrentProcess%2A>將現有的資源與新<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-447">Like the similar <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, and <xref:System.Diagnostics.Process.GetProcesses%2A> methods, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associates an existing resource with a new <xref:System.Diagnostics.Process> component.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-448">下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-448">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="7d50d-449">然後，它會擷取相同的程序的遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-449">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-450">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-450">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-451">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-451">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7d50d-452">建立新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與您指定的現有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-452">Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="7d50d-453">處理序資源的系統唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-453">The system-unique identifier of a process resource.</span></span></param>
        <summary><span data-ttu-id="7d50d-454">傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定本機電腦上的處理序識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-454">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</span></span></summary>
        <returns><span data-ttu-id="7d50d-455"><see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的本機處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-455">A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-456">使用這個方法來建立新<xref:System.Diagnostics.Process>元件並將它與本機電腦上的處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-456">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on the local computer.</span></span> <span data-ttu-id="7d50d-457">處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>並不會建立系統資源，但而不是關聯應用程式所產生的資源<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-457">The process resource must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="7d50d-458">處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-458">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="7d50d-459">在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>擲回例外狀況，如果您傳遞給它過期的識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-459">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="7d50d-460">在任何特定電腦上的處理程序的識別項是唯一的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-460">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="7d50d-461"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多會傳回其中一個處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-461"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> returns one process at most.</span></span> <span data-ttu-id="7d50d-462">如果您想要取得執行特定應用程式使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-462">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="7d50d-463">如果執行指定的應用程式的電腦上存在多個處理序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，其中包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-463">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="7d50d-464">您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-464">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="7d50d-465">可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-465">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="7d50d-466">`PID`資料行會顯示指派給處理程序的處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-466">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-467">下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-467">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="7d50d-468">然後，它會擷取相同的程序的遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-468">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7d50d-469"><paramref name="processId" /> 參數指定的處理序未執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-469">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="7d50d-470">識別碼可能過期。</span><span class="sxs-lookup"><span data-stu-id="7d50d-470">The identifier might be expired.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-471">這個物件未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-471">The process was not started by this object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-472">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-472">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-473">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-473">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="7d50d-474">處理序資源的系統唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-474">The system-unique identifier of a process resource.</span></span></param>
        <param name="machineName"><span data-ttu-id="7d50d-475">網路上的電腦名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-475">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="7d50d-476">傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定網路上電腦的處理序識別項和名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-476">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</span></span></summary>
        <returns><span data-ttu-id="7d50d-477"><see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的遠端處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-477">A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-478">使用這個方法來建立新<xref:System.Diagnostics.Process>元件並將它與網路上的遠端電腦上的處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-478">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on a remote computer on the network.</span></span> <span data-ttu-id="7d50d-479">處理序資源必須已經存在於指定的電腦，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>並不會建立系統資源，但而不是關聯應用程式所產生的資源<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-479">The process resource must already exist on the specified computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="7d50d-480">處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-480">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="7d50d-481">在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>擲回例外狀況，如果您傳遞給它過期的識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-481">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="7d50d-482">在任何特定電腦上的處理程序的識別項是唯一的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-482">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="7d50d-483"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多會傳回其中一個處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-483"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> returns one process at most.</span></span> <span data-ttu-id="7d50d-484">如果您想要取得執行特定應用程式使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-484">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="7d50d-485">如果執行指定的應用程式的電腦上存在多個處理序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，其中包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-485">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="7d50d-486">您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-486">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="7d50d-487">可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-487">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="7d50d-488">`PID`資料行會顯示指派給處理程序的處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-488">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="7d50d-489">如果您未指定`machineName`，會使用本機電腦。</span><span class="sxs-lookup"><span data-stu-id="7d50d-489">If you do not specify a `machineName`, the local computer is used.</span></span> <span data-ttu-id="7d50d-490">或者，您可以指定本機電腦，藉由設定`machineName`值 」。 「 或為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="7d50d-490">Alternatively, you can specify the local computer by setting `machineName` to the value "." or to an empty string ("").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-491">下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-491">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="7d50d-492">然後，它會擷取相同的程序的遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-492">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7d50d-493"><paramref name="processId" /> 參數指定的處理序未執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-493">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="7d50d-494">識別項可能過期。</span><span class="sxs-lookup"><span data-stu-id="7d50d-494">The identifier might be expired.</span></span>  
  
 <span data-ttu-id="7d50d-495">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-495">-or-</span></span>  
  
 <span data-ttu-id="7d50d-496"><paramref name="machineName" /> 參數的語法無效。</span><span class="sxs-lookup"><span data-stu-id="7d50d-496">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="7d50d-497">其長度有可能為零 (0)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-497">The name might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7d50d-498"><paramref name="machineName" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-498">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-499">這個物件未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-499">The process was not started by this object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-500">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-500">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-501">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-501">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7d50d-502">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與現有的處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-502">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-503">為本機電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-503">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</span></span></summary>
        <returns><span data-ttu-id="7d50d-504"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在本機電腦上執行的所有處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-504">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-505">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與本機電腦上的所有處理序資源建立關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-505">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the local computer.</span></span> <span data-ttu-id="7d50d-506">處理序資源必須已經存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>並不會建立系統資源，但而是將資源與應用程式產生相關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-506">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="7d50d-507">因為作業系統本身已執行背景處理程序，這個陣列絕不會是空的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-507">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="7d50d-508">如果不想擷取所有的電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-508">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="7d50d-509"><xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>與傳遞至方法的處理序識別碼所識別的系統上的處理序相關聯的元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-509"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="7d50d-510"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立的陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-510"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-511">可以載入多個 Windows 服務，服務主機處理序 (svchost.exe) 相同的執行個體內。</span><span class="sxs-lookup"><span data-stu-id="7d50d-511">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="7d50d-512">GetProcesses 不會識別這些個別的服務。因此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-512">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-513">下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-513">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="7d50d-514">然後，它會擷取相同的程序的遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-514">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-515">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-515">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-516">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-516">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="7d50d-517">要讀取處理序清單的電腦。</span><span class="sxs-lookup"><span data-stu-id="7d50d-517">The computer from which to read the list of processes.</span></span></param>
        <summary><span data-ttu-id="7d50d-518">為指定電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-518">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="7d50d-519"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在指定的電腦上執行的所有處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-519">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-520">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與指定的 （通常是遠端） 電腦上的所有處理序資源建立關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-520">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the specified (usually remote) computer.</span></span> <span data-ttu-id="7d50d-521">處理序資源必須已經存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>並不會建立系統資源，但而是將資源與應用程式產生相關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-521">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="7d50d-522">因為作業系統本身已執行背景處理程序，這個陣列絕不會是空的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-522">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="7d50d-523">如果不想擷取所有的電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-523">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="7d50d-524"><xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>與傳遞至方法的處理序識別碼所識別的系統上的處理序相關聯的元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-524"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="7d50d-525"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立的陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-525"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
 <span data-ttu-id="7d50d-526">這個多載<xref:System.Diagnostics.Process.GetProcesses%2A>方法通常用來擷取在網路上，在遠端電腦上執行的處理序資源的清單，但是您可以指定本機電腦，藉由傳遞 」。 」。</span><span class="sxs-lookup"><span data-stu-id="7d50d-526">This overload of the <xref:System.Diagnostics.Process.GetProcesses%2A> method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing ".".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-527">可以載入多個 Windows 服務，服務主機處理序 (svchost.exe) 相同的執行個體內。</span><span class="sxs-lookup"><span data-stu-id="7d50d-527">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="7d50d-528">GetProcesses 不會識別這些個別的服務。因此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-528">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-529">下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-529">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="7d50d-530">然後，它會擷取相同的程序的遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-530">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7d50d-531"><paramref name="machineName" /> 參數的語法無效。</span><span class="sxs-lookup"><span data-stu-id="7d50d-531">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="7d50d-532">其長度有可能為零 (0)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-532">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7d50d-533"><paramref name="machineName" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-533">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-534">作業系統平台不支援遠端電腦上的這項作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-534">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-535">存取 API 用來取得處理序資訊的效能計數器時發生問題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-535">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="7d50d-536">此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-536">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-537">存取基礎系統 API 時發生問題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-537">A problem occurred accessing an underlying system API.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-538">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-538">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-539">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-539">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7d50d-540">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與所有共用指定處理序名稱的現有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-540">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="7d50d-541">處理序的易記名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-541">The friendly name of the process.</span></span></param>
        <summary><span data-ttu-id="7d50d-542">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與本機電腦上共用指定處理序名稱的所有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-542">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="7d50d-543"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-543">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-544">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與相同的可執行檔在本機電腦上執行的所有處理序資源建立關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-544">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the local computer.</span></span> <span data-ttu-id="7d50d-545">處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>並不會建立系統資源，但而是將其與應用程式產生聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-545">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="7d50d-546">A`processName`可以指定可執行檔不目前正在執行的本機電腦上，讓該方法會傳回的陣列可以是空的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-546">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="7d50d-547">處理序名稱是此程序，例如 Outlook、 不包含副檔名為.exe 或路徑的好記名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-547">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="7d50d-548"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-548"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="7d50d-549">例如，您可以傳遞做為可執行檔名稱`processName`參數，以便關閉該可執行檔的所有執行的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-549">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="7d50d-550">雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-550">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="7d50d-551">因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，其中包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-551">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="7d50d-552">如果您需要管理處理序使用標準的應用程式開發介面呼叫，您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-552">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="7d50d-553">您無法存取處理序資源，透過單獨處理序名稱，但是，一旦您已擷取的陣列<xref:System.Diagnostics.Process>相關聯的元件與處理序資源，開始、 結束及操作的系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-553">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-554">下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-554">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="7d50d-555">然後，它會擷取相同的程序的遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-555">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-556">存取 API 用來取得處理序資訊的效能計數器時發生問題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-556">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="7d50d-557">此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-557">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-558">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-558">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-559">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-559">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="7d50d-560">處理序的易記名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-560">The friendly name of the process.</span></span></param>
        <param name="machineName"><span data-ttu-id="7d50d-561">網路上的電腦名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-561">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="7d50d-562">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與遠端電腦上共用指定處理序名稱的所有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-562">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="7d50d-563"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-563">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-564">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件，並與相同的可執行檔指定的電腦上執行的所有處理序資源建立關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-564">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the specified computer.</span></span> <span data-ttu-id="7d50d-565">處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>並不會建立系統資源，但而是將其與應用程式產生聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-565">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="7d50d-566">A`processName`可以指定可執行檔不目前正在執行的本機電腦上，讓該方法會傳回的陣列可以是空的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-566">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="7d50d-567">處理序名稱是此程序，例如 Outlook、 不包含副檔名為.exe 或路徑的好記名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-567">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="7d50d-568"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-568"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="7d50d-569">例如，您可以傳遞做為可執行檔名稱`processName`參數，以便關閉該可執行檔的所有執行的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-569">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="7d50d-570">雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-570">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="7d50d-571">因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，其中包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-571">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="7d50d-572">如果您需要管理處理序使用標準的應用程式開發介面呼叫，您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-572">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="7d50d-573">您無法存取處理序資源，透過單獨處理序名稱，但是，一旦您已擷取的陣列<xref:System.Diagnostics.Process>相關聯的元件與處理序資源，開始、 結束及操作的系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-573">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
 <span data-ttu-id="7d50d-574">取得處理程序，在本機電腦上以及遠端電腦上，您可以使用這個多載。</span><span class="sxs-lookup"><span data-stu-id="7d50d-574">You can use this overload to get processes on the local computer as well as on a remote computer.</span></span> <span data-ttu-id="7d50d-575">使用 」。 「 若要指定本機電腦。</span><span class="sxs-lookup"><span data-stu-id="7d50d-575">Use "." to specify the local computer.</span></span> <span data-ttu-id="7d50d-576">另一個多載存在預設使用本機電腦。</span><span class="sxs-lookup"><span data-stu-id="7d50d-576">Another overload exists that uses the local computer by default.</span></span>  
  
 <span data-ttu-id="7d50d-577">您可以存取遠端電腦上只檢視處理序的相關資訊，例如統計資料、 處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-577">You can access processes on remote computers only to view information, such as statistics, about the processes.</span></span> <span data-ttu-id="7d50d-578">您無法關閉，終止 (使用<xref:System.Diagnostics.Process.Kill%2A>)，或在遠端電腦上啟動處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-578">You cannot close, terminate (using <xref:System.Diagnostics.Process.Kill%2A>), or start processes on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-579">下列範例會擷取目前的處理序的資訊在本機電腦，[記事本] 在本機電腦和本機電腦上的特定處理序上執行的所有執行個體上執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-579">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="7d50d-580">然後，它會擷取相同的程序的遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-580">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7d50d-581"><paramref name="machineName" /> 參數的語法無效。</span><span class="sxs-lookup"><span data-stu-id="7d50d-581">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="7d50d-582">其長度有可能為零 (0)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-582">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7d50d-583"><paramref name="machineName" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-583">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-584">作業系統平台不支援遠端電腦上的這項作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-584">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-585">存取 API 用來取得處理序資訊的效能計數器時發生問題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-585">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="7d50d-586">此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-586">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-587">存取基礎系統 API 時發生問題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-587">A problem occurred accessing an underlying system API.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-588">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-588">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-589">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-589">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7d50d-590">呼叫 unmanaged 程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-590">to call unmanaged code.</span></span> <span data-ttu-id="7d50d-591">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="7d50d-591">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-592">取得相關處理序的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-592">Gets the native handle of the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-593">處理序啟動時，作業系統指派給相關處理序的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-593">The handle that the operating system assigned to the associated process when the process was started.</span></span> <span data-ttu-id="7d50d-594">系統會用這個控制代碼追蹤處理序屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-594">The system uses this handle to keep track of process attributes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-595">應用程式可以取得可用來做為許多的處理程序資訊及控制函數參數的程序的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-595">An application can obtain a handle to a process that can be used as a parameter to many process-information and control functions.</span></span> <span data-ttu-id="7d50d-596">您可以使用此控制代碼初始化<xref:System.Threading.WaitHandle>或呼叫與平台的原生方法叫用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-596">You can use this handle to initialize a <xref:System.Threading.WaitHandle> or to call native methods with platform invoke.</span></span>  
  
 <span data-ttu-id="7d50d-597">此處理序控制代碼是私用應用程式--也就是說，不能共用控制代碼的程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-597">This process handle is private to an application--in other words, process handles cannot be shared.</span></span> <span data-ttu-id="7d50d-598">處理程序也有程序<xref:System.Diagnostics.Process.Id%2A>其不同的是<xref:System.Diagnostics.Process.Handle%2A>，是唯一的因此，在整個系統有效。</span><span class="sxs-lookup"><span data-stu-id="7d50d-598">A process also has a process <xref:System.Diagnostics.Process.Id%2A> which, unlike the <xref:System.Diagnostics.Process.Handle%2A>, is unique and, therefore, valid throughout the system.</span></span>  
  
 <span data-ttu-id="7d50d-599">只有處理序啟動透過呼叫<xref:System.Diagnostics.Process.Start%2A>設定<xref:System.Diagnostics.Process.Handle%2A>對應<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-599">Only processes started through a call to <xref:System.Diagnostics.Process.Start%2A> set the <xref:System.Diagnostics.Process.Handle%2A> property of the corresponding <xref:System.Diagnostics.Process> instances.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-600">處理序尚未啟動或已結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-600">The process has not been started or has exited.</span></span> <span data-ttu-id="7d50d-601">無法讀取 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性，因為沒有與此 <see cref="T:System.Diagnostics.Process" /> 執行個體相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-601">The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
 <span data-ttu-id="7d50d-602">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-602">-or-</span></span>  
  
 <span data-ttu-id="7d50d-603"><see cref="T:System.Diagnostics.Process" /> 執行個體已附加至執行中的處理序，但沒有取得具有完整存取權限之控制代碼的必要權限。</span><span class="sxs-lookup"><span data-stu-id="7d50d-603">The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-604">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-604">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-605">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-605">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-606">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-606">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-607">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-607">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-608">取得處理序開啟的控制代碼數目。</span><span class="sxs-lookup"><span data-stu-id="7d50d-608">Gets the number of handles opened by the process.</span></span></summary>
        <value><span data-ttu-id="7d50d-609">處理序已開啟的作業系統控制代碼數目。</span><span class="sxs-lookup"><span data-stu-id="7d50d-609">The number of operating system handles the process has opened.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-610">控制代碼為提供的方式來參考物件的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-610">Handles provide a way for a process to refer to objects.</span></span> <span data-ttu-id="7d50d-611">處理程序可以取得檔案、 資源、 訊息佇列和許多其他作業系統物件的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-611">A process can obtain handles to files, resources, message queues, and many other operating system objects.</span></span> <span data-ttu-id="7d50d-612">作業系統會回收控制代碼計數為零時，才與處理序相關聯的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-612">The operating system reclaims the memory associated with the process only when the handle count is zero.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-613">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-613">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-614">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-614">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-615">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-615">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-616">取得值，指出相關的處理序是否已經終止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-616">Gets a value indicating whether the associated process has been terminated.</span></span></summary>
        <value>
          <span data-ttu-id="7d50d-617">如果 <see cref="T:System.Diagnostics.Process" /> 元件所參考的作業系統處理序已終止，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-617"><see langword="true" /> if the operating system process referenced by the <see cref="T:System.Diagnostics.Process" /> component has terminated; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-618">值為`true`如<xref:System.Diagnostics.Process.HasExited%2A>指出相關聯的處理序已結束，正常或不正常。</span><span class="sxs-lookup"><span data-stu-id="7d50d-618">A value of `true` for <xref:System.Diagnostics.Process.HasExited%2A> indicates that the associated process has terminated, either normally or abnormally.</span></span> <span data-ttu-id="7d50d-619">您可以要求或強制結束藉由呼叫相關聯的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-619">You can request or force the associated process to exit by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-620">如果已開啟處理序的控制代碼，作業系統會釋放處理程序記憶體時的處理序已結束，但會保留系統管理處理程序控制代碼，結束代碼和結束時間等相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-620">If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time.</span></span> <span data-ttu-id="7d50d-621">若要取得這項資訊，您可以使用<xref:System.Diagnostics.Process.ExitCode%2A>和<xref:System.Diagnostics.Process.ExitTime%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-621">To get this information, you can use the <xref:System.Diagnostics.Process.ExitCode%2A> and <xref:System.Diagnostics.Process.ExitTime%2A> properties.</span></span> <span data-ttu-id="7d50d-622">這些屬性會自動填入這個元件已啟動的處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-622">These properties are populated automatically for processes that were started by this component.</span></span> <span data-ttu-id="7d50d-623">系統管理資訊發行時所有<xref:System.Diagnostics.Process>與系統處理序相關聯的元件會終結並保存至已結束的處理序沒有更多的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-623">The administrative information is released when all the <xref:System.Diagnostics.Process> components that are associated with the system process are destroyed and hold no more handles to the exited process.</span></span>  
  
 <span data-ttu-id="7d50d-624">處理程序可以與您的程式碼分開來終止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-624">A process can terminate independently of your code.</span></span> <span data-ttu-id="7d50d-625">如果您啟動使用這個元件的處理序時，系統會更新的值<xref:System.Diagnostics.Process.HasExited%2A>自動，即使在相關聯的處理序結束獨立。</span><span class="sxs-lookup"><span data-stu-id="7d50d-625">If you started the process using this component, the system updates the value of <xref:System.Diagnostics.Process.HasExited%2A> automatically, even if the associated process exits independently.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-626">當非同步事件處理常式已經重新導向標準輸出時，您就可以確認輸出處理尚未完成時，這個屬性會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-626">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns `true`.</span></span> <span data-ttu-id="7d50d-627">若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前會採用任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-627">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-628">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-628">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-629">然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 的第二個時間間隔，最多為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-629">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="7d50d-630">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-630">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="7d50d-631">如果它仍在執行 10 秒後，此範例會關閉處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-631">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-632">沒有與這個物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-632">There is no process associated with the object.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-633">無法擷取處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-633">The exit code for the process could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-634">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-634">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-635">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-635">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-636">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-636">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-637">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-637">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-638">取得相關處理序的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-638">Gets the unique identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-639">這個 <see cref="T:System.Diagnostics.Process" /> 執行個體所參考的處理序之系統產生的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-639">The system-generated unique identifier of the process that is referenced by this <see cref="T:System.Diagnostics.Process" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-640">處理程序<xref:System.Diagnostics.Process.Id%2A>不正確，如果相關聯的處理序並未執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-640">The process <xref:System.Diagnostics.Process.Id%2A> is not valid if the associated process is not running.</span></span> <span data-ttu-id="7d50d-641">因此，您應該確定處理序正在執行，然後嘗試擷取<xref:System.Diagnostics.Process.Id%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-641">Therefore, you should ensure that the process is running before attempting to retrieve the <xref:System.Diagnostics.Process.Id%2A> property.</span></span> <span data-ttu-id="7d50d-642">除非在處理序終止時，處理序識別碼可唯一識別整個系統的程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-642">Until the process terminates, the process identifier uniquely identifies the process throughout the system.</span></span>  
  
 <span data-ttu-id="7d50d-643">您可以連接至新的本機或遠端電腦執行的處理序<xref:System.Diagnostics.Process>藉由傳遞至處理序識別碼的執行個體<xref:System.Diagnostics.Process.GetProcessById%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-643">You can connect a process that is running on a local or remote computer to a new <xref:System.Diagnostics.Process> instance by passing the process identifier to the <xref:System.Diagnostics.Process.GetProcessById%2A> method.</span></span> <span data-ttu-id="7d50d-644"><xref:System.Diagnostics.Process.GetProcessById%2A> 是`static`會建立新元件的方法，並設定<xref:System.Diagnostics.Process.Id%2A>新屬性<xref:System.Diagnostics.Process>自動執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-644"><xref:System.Diagnostics.Process.GetProcessById%2A> is a `static` method that creates a new component and sets the <xref:System.Diagnostics.Process.Id%2A> property for the new <xref:System.Diagnostics.Process> instance automatically.</span></span>  
  
 <span data-ttu-id="7d50d-645">系統可以重複使用處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-645">Process identifiers can be reused by the system.</span></span> <span data-ttu-id="7d50d-646"><xref:System.Diagnostics.Process.Id%2A>屬性值是唯一的只有當相關聯的處理序正在執行時。</span><span class="sxs-lookup"><span data-stu-id="7d50d-646">The <xref:System.Diagnostics.Process.Id%2A> property value is unique only while the associated process is running.</span></span> <span data-ttu-id="7d50d-647">系統處理序已終止之後，可以重複使用<xref:System.Diagnostics.Process.Id%2A>不相關的處理序的屬性值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-647">After the process has terminated, the system can reuse the <xref:System.Diagnostics.Process.Id%2A> property value for an unrelated process.</span></span>  
  
 <span data-ttu-id="7d50d-648">因為此識別碼是唯一的系統上，您可以傳遞給它其他執行緒以傳遞替代<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-648">Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-649">這個動作可節省系統資源，又保證正確地識別出程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-649">This action can save system resources yet guarantee that the process is correctly identified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-650">下列範例示範如何取得<xref:System.Diagnostics.Process.Id%2A>所有執行中的應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-650">The following example demonstrates how to obtain the <xref:System.Diagnostics.Process.Id%2A> for all running instances of an application.</span></span> <span data-ttu-id="7d50d-651">程式碼建立 「 記事本 」 的新執行個體列出的 「 記事本 」 中的所有執行個體，然後可讓使用者輸入<xref:System.Diagnostics.Process.Id%2A>移除特定的執行個體的數目。</span><span class="sxs-lookup"><span data-stu-id="7d50d-651">The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the <xref:System.Diagnostics.Process.Id%2A> number to remove a specific instance.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-652">處理序的 <see cref="P:System.Diagnostics.Process.Id" /> 屬性未設定。</span><span class="sxs-lookup"><span data-stu-id="7d50d-652">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.</span></span>  
  
 <span data-ttu-id="7d50d-653">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-653">-or-</span></span>  
  
 <span data-ttu-id="7d50d-654">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-654">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-655">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-655">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-656">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-656">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-657">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-657">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-658">立即停止相關的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-658">Immediately stops the associated process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-659"><xref:System.Diagnostics.Process.Kill%2A> 強制終止程序，而<xref:System.Diagnostics.Process.CloseMainWindow%2A>只會要求終止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-659"><xref:System.Diagnostics.Process.Kill%2A> forces a termination of the process, while <xref:System.Diagnostics.Process.CloseMainWindow%2A> only requests a termination.</span></span> <span data-ttu-id="7d50d-660">當執行圖形化介面的處理序時，其訊息迴圈會處於等候狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-660">When a process with a graphical interface is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="7d50d-661">每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7d50d-661">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="7d50d-662">呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>接近主要視窗中，且格式正確的應用程式中，在關閉子視窗，並撤銷應用程式的所有執行訊息迴圈傳送的要求。</span><span class="sxs-lookup"><span data-stu-id="7d50d-662">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="7d50d-663">藉由呼叫結束程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-663">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="7d50d-664">應用程式可以要求使用者驗證，才能結束，或它可以拒絕結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-664">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="7d50d-665">若要強制執行應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-665">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="7d50d-666">行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗使用 [系統] 功能表的使用者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-666">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="7d50d-667">因此，要求關閉主視窗結束處理程序不會強制立即結束應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-667">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-668"><xref:System.Diagnostics.Process.Kill%2A>方法以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-668">The <xref:System.Diagnostics.Process.Kill%2A> method executes asynchronously.</span></span> <span data-ttu-id="7d50d-669">在呼叫<xref:System.Diagnostics.Process.Kill%2A>方法，請呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來等候處理序結束，或者檢查<xref:System.Diagnostics.Process.HasExited%2A>屬性來判斷是否已經結束處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-669">After calling the <xref:System.Diagnostics.Process.Kill%2A> method, call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to wait for the process to exit, or check the <xref:System.Diagnostics.Process.HasExited%2A> property to determine if the process has exited.</span></span>  
  
 <span data-ttu-id="7d50d-670">編輯程序的資料或配置給處理序的資源可能會遺失如果您呼叫<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-670">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-671"><xref:System.Diagnostics.Process.Kill%2A> 導致處理程序異常終止，並在必要時才應該使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-671"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination and should be used only when necessary.</span></span> <span data-ttu-id="7d50d-672"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此最好有一個介面的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-672"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="7d50d-673">如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-673">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="7d50d-674"><xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-674"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="7d50d-675">您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-675">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="7d50d-676">若要結束遠端電腦上，您無法讓處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-676">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="7d50d-677">您只能檢視遠端電腦上執行的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-677">You can only view information for processes running on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-678">如果呼叫<xref:System.Diagnostics.Process.Kill%2A>方法由目前正在終止處理程序，而<xref:System.ComponentModel.Win32Exception>就會擲回的拒絕存取。</span><span class="sxs-lookup"><span data-stu-id="7d50d-678">If the call to the <xref:System.Diagnostics.Process.Kill%2A> method is made while the process is currently terminating, a <xref:System.ComponentModel.Win32Exception> is thrown for Access Denied.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-679">相關的處理序無法終止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-679">The associated process could not be terminated.</span></span>  
  
 <span data-ttu-id="7d50d-680">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-680">-or-</span></span>  
  
 <span data-ttu-id="7d50d-681">正在結束處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-681">The process is terminating.</span></span>  
  
 <span data-ttu-id="7d50d-682">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-682">-or-</span></span>  
  
 <span data-ttu-id="7d50d-683">相關聯的處理序是 Win16 可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-683">The associated process is a Win16 executable.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-684">您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.Kill" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-684">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-685">這個方法僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-685">The method is available only for processes running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-686">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-686">The process has already exited.</span></span>  
  
 <span data-ttu-id="7d50d-687">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-687">-or-</span></span>  
  
 <span data-ttu-id="7d50d-688">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-688">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-689">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-689">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-690">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-690">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-691">讓 <see cref="T:System.Diagnostics.Process" /> 元件離開可與使用特殊模式執行的作業系統處理序互動的狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-691">Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-692">某些作業系統處理程序執行中使用特殊模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-692">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="7d50d-693">嘗試讀取的屬性，或附加至這些處理序不能除非您已經呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。</span><span class="sxs-lookup"><span data-stu-id="7d50d-693">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="7d50d-694">呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取特殊模式執行這些程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-694">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-695">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-695">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-696">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-696">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-697">取得相關處理序正在執行的所在電腦的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-697">Gets the name of the computer the associated process is running on.</span></span></summary>
        <value><span data-ttu-id="7d50d-698">相關處理序正在執行的所在電腦的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-698">The name of the computer that the associated process is running on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-699">您可以檢視統計資料，且無法呼叫程序，但您的遠端電腦上執行的處理程序資訊<xref:System.Diagnostics.Process.Start%2A>， <xref:System.Diagnostics.Process.CloseMainWindow%2A>，或<xref:System.Diagnostics.Process.Kill%2A>遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="7d50d-699">You can view statistical data and process information for processes running on remote computers but you cannot call <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, or <xref:System.Diagnostics.Process.Kill%2A> on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-700">當相關聯的處理序在本機電腦上執行時，這個屬性會傳回句號 ("。") 的機器名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-700">When the associated process is executing on the local machine, this property returns a period (".") for the machine name.</span></span> <span data-ttu-id="7d50d-701">您應該使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性來取得正確的電腦名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-701">You should use the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to get the correct machine name.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-702">若要使用下列的範例，您必須先執行會在遠端電腦上啟動 「 記事本 」 的至少一個執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-702">To use the following example you must first start at least one instance of Notepad on a remote computer.</span></span> <span data-ttu-id="7d50d-703">此範例要求的遠端電腦的 [記事本] 正在執行，而且接著會顯示個別名稱<xref:System.Diagnostics.Process.ProcessName%2A>， <xref:System.Diagnostics.Process.Id%2A>，和<xref:System.Diagnostics.Process.MachineName%2A>每個執行個體的屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-703">The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and <xref:System.Diagnostics.Process.MachineName%2A> properties for each instance.</span></span>  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-704">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-704">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-705">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-705">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-706">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-706">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-707">取得相關處理序的主要模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-707">Gets the main module for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-708"><see cref="T:System.Diagnostics.ProcessModule" />，用來啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-708">The <see cref="T:System.Diagnostics.ProcessModule" /> that was used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-709">處理序模組代表特定程序中載入.dll 或.exe 檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-709">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="7d50d-710"><xref:System.Diagnostics.Process.MainModule%2A>屬性可讓您檢視用來啟動處理程序，包括模組名稱、 檔案名稱和模組的記憶體詳細資訊的可執行檔的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-710">The <xref:System.Diagnostics.Process.MainModule%2A> property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-711">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainModule" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-711">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-712">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-712">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-713">32 位元處理序正嘗試存取 64 位元處理序的模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-713">A 32-bit process is trying to access the modules of a 64-bit process.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-714">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-714">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-715">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-715">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
 <span data-ttu-id="7d50d-716">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-716">-or-</span></span>  
  
 <span data-ttu-id="7d50d-717">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-717">The process has exited.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-718">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-718">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-719">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-719">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-720">取得相關處理序主視窗的視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-720">Gets the window handle of the main window of the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-721">由系統產生之相關處理序主視窗的視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-721">The system-generated window handle of the main window of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-722">主視窗是由目前具有焦點的處理序開啟的視窗 (<xref:System.Windows.Forms.Form.TopLevel%2A>形式)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-722">The main window is the window opened by the process that currently has the focus (the <xref:System.Windows.Forms.Form.TopLevel%2A> form).</span></span> <span data-ttu-id="7d50d-723">您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>來取得目前的主視窗控制代碼，如果已變更的物件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-723">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span> <span data-ttu-id="7d50d-724">一般而言，因為快取的視窗控制代碼，則使用<xref:System.Diagnostics.Process.Refresh%2A>事前保證您將會擷取目前的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-724">In general, because the window handle is cached, use <xref:System.Diagnostics.Process.Refresh%2A> beforehand to guarantee that you’ll retrieve the current handle.</span></span>  
  
 <span data-ttu-id="7d50d-725">您可以取得<xref:System.Diagnostics.Process.MainWindowHandle%2A>屬性只能供本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-725">You can get the <xref:System.Diagnostics.Process.MainWindowHandle%2A> property only for processes that are running on the local computer.</span></span> <span data-ttu-id="7d50d-726"><xref:System.Diagnostics.Process.MainWindowHandle%2A>屬性是可唯一識別與處理序相關聯的視窗的值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-726">The <xref:System.Diagnostics.Process.MainWindowHandle%2A> property is a value that uniquely identifies the window that is associated with the process.</span></span>  
  
 <span data-ttu-id="7d50d-727">在程序沒有處理序具有圖形化介面時，才與它相關聯的主視窗。</span><span class="sxs-lookup"><span data-stu-id="7d50d-727">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="7d50d-728">如果相關聯的處理序沒有主視窗、<xref:System.Diagnostics.Process.MainWindowHandle%2A>值為零。</span><span class="sxs-lookup"><span data-stu-id="7d50d-728">If the associated process does not have a main window, the <xref:System.Diagnostics.Process.MainWindowHandle%2A> value is zero.</span></span> <span data-ttu-id="7d50d-729">值也是零的處理序已經隱藏起來，也就是處理不會顯示在工作列中的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-729">The value is also zero for processes that have been hidden, that is, processes that are not visible in the taskbar.</span></span> <span data-ttu-id="7d50d-730">這可以是顯示為圖示在通知區域中，在工作列最右邊的處理程序的情況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-730">This can be the case for processes that appear as icons in the notification area, at the far right of the taskbar.</span></span>  
  
 <span data-ttu-id="7d50d-731">如果您剛啟動處理程序，並想要使用其主視窗控制代碼，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，以確保已經建立的主視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-731">If you have just started a process and want to use its main window handle, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="7d50d-732">否則便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-732">Otherwise, an exception will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-733"><see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 沒有定義，因為處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-733">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-734">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-734">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-735">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-735">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-736">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-736">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-737">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-737">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-738">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-738">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-739">取得處理序的主視窗標題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-739">Gets the caption of the main window of the process.</span></span></summary>
        <value><span data-ttu-id="7d50d-740">處理序的主視窗標題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-740">The main window title of the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-741">在程序沒有處理序具有圖形化介面時，才與它相關聯的主視窗。</span><span class="sxs-lookup"><span data-stu-id="7d50d-741">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="7d50d-742">如果相關聯的處理序沒有主視窗 (以便<xref:System.Diagnostics.Process.MainWindowHandle%2A>為零)，<xref:System.Diagnostics.Process.MainWindowTitle%2A>為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="7d50d-742">If the associated process does not have a main window (so that <xref:System.Diagnostics.Process.MainWindowHandle%2A> is zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> is an empty string ("").</span></span> <span data-ttu-id="7d50d-743">如果您剛啟動處理程序，並想要使用其主視窗標題，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，以確保已經建立的主視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-743">If you have just started a process and want to use its main window title, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="7d50d-744">否則，系統會擲回例外狀況 (Exception)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-744">Otherwise, the system throws an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-745">主視窗是目前擁有焦點，視窗請注意，這可能不是處理序主視窗。</span><span class="sxs-lookup"><span data-stu-id="7d50d-745">The main window is the window that currently has the focus; note that this might not be the primary window for the process.</span></span> <span data-ttu-id="7d50d-746">您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>來取得目前的主視窗控制代碼，如果已變更的物件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-746">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-747">下列範例會啟動 [記事本] 的執行個體，並擷取程序的主視窗的標題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-747">The following example starts an instance of Notepad and retrieves the caption of the main window of the process.</span></span>  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-748"><see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性沒有定義，因為處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-748">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-749">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-749">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-750">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-750">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-751">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-751">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-752">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-752">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-753">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-753">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-754">取得或設定關聯的處理序所允許的工作集大小上限，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-754">Gets or sets the maximum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-755">處理序所需記憶體中工作集大小的最大值，以位元組 (Byte) 為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-755">The maximum working set size that is allowed in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-756">處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-756">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="7d50d-757">這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-757">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="7d50d-758">工作集包括共用和私用資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-758">The working set includes both shared and private data.</span></span> <span data-ttu-id="7d50d-759">共用的資料包含頁面包含所有執行您的應用程式，包括.dll 檔案和 system.dll 檔案中頁面的指示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-759">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="7d50d-760">隨著工作集大小會增加，會增加記憶體需求。</span><span class="sxs-lookup"><span data-stu-id="7d50d-760">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="7d50d-761">處理序有最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-761">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="7d50d-762">每次處理序資源建立時，系統會保留等於工作集大小的處理程序的最小記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-762">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="7d50d-763">虛擬記憶體管理員會保留最少的最小記憶體數量常駐時處理程序為作用中，但不是會保持超過最大大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-763">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="7d50d-764">系統會設定預設的工作集大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-764">The system sets the default working set sizes.</span></span> <span data-ttu-id="7d50d-765">您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-765">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="7d50d-766">不過，設定這些值不保證記憶體會被保留或駐留。</span><span class="sxs-lookup"><span data-stu-id="7d50d-766">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-767">當您增加處理程序的工作集大小時，您可以採取遠離系統的其餘部分的實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-767">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="7d50d-768">請確定您沒有要求的是太大，因為這樣做可能會降低系統效能的最小值或最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-768">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7d50d-769">工作集大小上限無效。</span><span class="sxs-lookup"><span data-stu-id="7d50d-769">The maximum working set size is invalid.</span></span> <span data-ttu-id="7d50d-770">必須大於或等於工作集大小下限。</span><span class="sxs-lookup"><span data-stu-id="7d50d-770">It must be greater than or equal to the minimum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-771">無法從關聯的處理序資源擷取工作集資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-771">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
 <span data-ttu-id="7d50d-772">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-772">-or-</span></span>  
  
 <span data-ttu-id="7d50d-773">處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-773">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-774">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-774">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-775">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-775">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-776">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-776">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
 <span data-ttu-id="7d50d-777">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-777">-or-</span></span>  
  
 <span data-ttu-id="7d50d-778">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-778">The process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-779">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-779">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-780">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-780">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-781">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-781">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-782">取得或設定關聯的處理序所允許的工作集大小下限，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-782">Gets or sets the minimum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-783">處理序所需記憶體中工作集大小的最小值，以位元組 (Byte) 為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-783">The minimum working set size that is required in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-784">處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-784">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="7d50d-785">這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-785">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="7d50d-786">工作集包括共用和私用資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-786">The working set includes both shared and private data.</span></span> <span data-ttu-id="7d50d-787">共用的資料包含頁面包含所有執行您的應用程式，包括.dll 檔案和 system.dll 檔案中頁面的指示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-787">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="7d50d-788">隨著工作集大小會增加，會增加記憶體需求。</span><span class="sxs-lookup"><span data-stu-id="7d50d-788">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="7d50d-789">處理序有最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-789">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="7d50d-790">每次處理序資源建立時，系統會保留等於工作集大小的處理程序的最小記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-790">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="7d50d-791">虛擬記憶體管理員會保留最少的最小記憶體數量常駐時處理程序為作用中，但不是會保持超過最大大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-791">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="7d50d-792">系統會設定預設的工作集大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-792">The system sets the default working set sizes.</span></span> <span data-ttu-id="7d50d-793">您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-793">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="7d50d-794">不過，設定這些值不保證記憶體會被保留或駐留。</span><span class="sxs-lookup"><span data-stu-id="7d50d-794">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-795">當您增加處理程序的工作集大小時，您可以採取遠離系統的其餘部分的實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-795">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="7d50d-796">請確定您沒有要求的是太大，因為這樣做可能會降低系統效能的最小值或最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-796">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7d50d-797">工作集大小下限無效。</span><span class="sxs-lookup"><span data-stu-id="7d50d-797">The minimum working set size is invalid.</span></span> <span data-ttu-id="7d50d-798">必須小於或等於工作集大小上限。</span><span class="sxs-lookup"><span data-stu-id="7d50d-798">It must be less than or equal to the maximum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-799">無法從關聯的處理序資源擷取工作集資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-799">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
 <span data-ttu-id="7d50d-800">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-800">-or-</span></span>  
  
 <span data-ttu-id="7d50d-801">處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-801">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-802">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-802">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-803">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-803">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-804">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-804">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
 <span data-ttu-id="7d50d-805">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-805">-or-</span></span>  
  
 <span data-ttu-id="7d50d-806">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-806">The process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-807">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-807">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-808">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-808">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-809">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-809">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-810">取得相關的處理序所載入的模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-810">Gets the modules that have been loaded by the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-811"><see cref="T:System.Diagnostics.ProcessModule" /> 類型的陣列，代表相關聯處理序所載入的模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-811">An array of type <see cref="T:System.Diagnostics.ProcessModule" /> that represents the modules that have been loaded by the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-812">處理序模組代表特定程序中載入.dll 或.exe 檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-812">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="7d50d-813">A<xref:System.Diagnostics.ProcessModule>執行個體，可讓您檢視模組，包括模組名稱、 檔案名稱和模組的記憶體詳細資料的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-813">A <xref:System.Diagnostics.ProcessModule> instance lets you view information about a module, including the module name, file name, and module memory details.</span></span>  
  
 <span data-ttu-id="7d50d-814">處理程序可以將多個模組載入記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-814">A process can load multiple modules into memory.</span></span> <span data-ttu-id="7d50d-815">例如，載入額外的.dll 檔案的.exe 檔案有多個模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-815">For example,.exe files that load additional .dll files have multiple modules.</span></span>  
  
 <span data-ttu-id="7d50d-816">之後啟動處理序，這個集合是空的直到系統載入程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-816">After starting the process, this collection is empty until the system has loaded the process.</span></span> <span data-ttu-id="7d50d-817">如果處理序主視窗，您可以呼叫<xref:System.Diagnostics.Process.WaitForInputIdle%2A>之前擷取這個屬性，以確保該集合不是空的時，您取得的清單。</span><span class="sxs-lookup"><span data-stu-id="7d50d-817">If the process has a main window, you can call <xref:System.Diagnostics.Process.WaitForInputIdle%2A> before retrieving this property to ensure that the collection is nonempty when you get the list.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-818">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-818">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-819">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-819">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-820">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-820">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-821">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-821">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-822">您嘗試存取系統處理序或閒置處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-822">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process.</span></span> <span data-ttu-id="7d50d-823">這些程序並沒有模組。</span><span class="sxs-lookup"><span data-stu-id="7d50d-823">These processes do not have modules.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-824">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-824">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-825">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-825">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-826">取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-826">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-827">記憶體量 (以位元組為單位)，指系統已配置給不能寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-827">The amount of memory, in bytes, the system has allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-828">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-828">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-829">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-829">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-830">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-830">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-831">取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-831">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-832">配置給關聯處理序的系統記憶體量 (以位元組為單位)，不能寫入虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-832">The amount of system memory, in bytes, allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-833">這個屬性所傳回的值代表目前的處理序，以位元組為單位所使用的未分頁的系統記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-833">The value returned by this property represents the current size of nonpaged system memory used by the process, in bytes.</span></span> <span data-ttu-id="7d50d-834">系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。</span><span class="sxs-lookup"><span data-stu-id="7d50d-834">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="7d50d-835">非分頁的記憶體配置保留在系統記憶體和並未輸出分頁虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-835">Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</span></span>  
  
 <span data-ttu-id="7d50d-836">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-836">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-837">屬性值相當於**Pool Nonpaged Bytes**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-837">The property value is equivalent to the **Pool Nonpaged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-838">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-838">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-839">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-839">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-840">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-840">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-841">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-841">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-842">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-842">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-843">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-843">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-844">引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-844">Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-845"><xref:System.Diagnostics.Process.OnExited%2A> 引發的應用程式開發介面方法<xref:System.Diagnostics.Process.Exited>事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-845"><xref:System.Diagnostics.Process.OnExited%2A> is the API method that raises the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="7d50d-846">呼叫<xref:System.Diagnostics.Process.OnExited%2A>導致<xref:System.Diagnostics.Process.Exited>事件發生和是唯一的方法來引發事件使用<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-846">Calling <xref:System.Diagnostics.Process.OnExited%2A> causes the <xref:System.Diagnostics.Process.Exited> event to occur and is the only way to raise the event using the <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="7d50d-847"><xref:System.Diagnostics.Process.OnExited%2A> 主要用元件從衍生類別時。</span><span class="sxs-lookup"><span data-stu-id="7d50d-847"><xref:System.Diagnostics.Process.OnExited%2A> is primarily used when deriving classes from the component.</span></span>  
  
 <span data-ttu-id="7d50d-848">做為替代<xref:System.Diagnostics.Process.OnExited%2A>，您可以撰寫您自己的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-848">As an alternative to <xref:System.Diagnostics.Process.OnExited%2A>, you can write your own event handler.</span></span> <span data-ttu-id="7d50d-849">您可以建立您自己的事件處理常式委派和事件處理方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-849">You create your own event handler delegate and your own event-handling method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-850">如果您使用 Visual Studio 環境時，事件處理常式委派 (AddOnExited) 和事件處理方法 (Process1_Exited) 會為您建立拖曳<xref:System.Diagnostics.Process>元件拖曳至表單，然後按兩下圖示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-850">If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a <xref:System.Diagnostics.Process> component onto a form and double-click the icon.</span></span> <span data-ttu-id="7d50d-851">建立時要執行的程式碼<xref:System.Diagnostics.Process.Exited>進入 Process1_Exited 程序發生的事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-851">The code you create to run when the <xref:System.Diagnostics.Process.Exited> event occurs is entered into the Process1_Exited procedure.</span></span> <span data-ttu-id="7d50d-852">您不需要建立<xref:System.Diagnostics.Process.OnExited%2A>成員，因為它會為您實作。</span><span class="sxs-lookup"><span data-stu-id="7d50d-852">You do not need to create the <xref:System.Diagnostics.Process.OnExited%2A> member, because it is implemented for you.</span></span>  
  
 <span data-ttu-id="7d50d-853">引發事件會透過委派叫用此事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-853">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="7d50d-854">如需概觀，請參閱[處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-854">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-855">下列範例示範如何使用<xref:System.Diagnostics.Process.OnExited%2A>方法在衍生類別中的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-855">The following example shows how to use the <xref:System.Diagnostics.Process.OnExited%2A> method in a derived class.</span></span>  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-856">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-856">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-857">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-857">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-858">發生於應用程式將某行寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流時。</span><span class="sxs-lookup"><span data-stu-id="7d50d-858">Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-859"><xref:System.Diagnostics.Process.OutputDataReceived>事件表示相關聯<xref:System.Diagnostics.Process>已寫入線條，以新行字元至其重新導向終止<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-859">The <xref:System.Diagnostics.Process.OutputDataReceived> event indicates that the associated <xref:System.Diagnostics.Process> has written a line, terminating with a newline character, to its redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-860">非同步讀取作業期間啟用事件上<xref:System.Diagnostics.Process.StandardOutput%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-860">The event is enabled during asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span> <span data-ttu-id="7d50d-861">若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式來<xref:System.Diagnostics.Process.OutputDataReceived>事件和呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-861">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardOutput%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event, and call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</span></span> <span data-ttu-id="7d50d-862">此後，<xref:System.Diagnostics.Process.OutputDataReceived>事件訊號處理程序將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，直到處理程序會結束或呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-862">Thereafter, the <xref:System.Diagnostics.Process.OutputDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-863">正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以確保已清除輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="7d50d-863">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to ensure that the output buffer has been flushed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-864">下列範例說明如何執行非同步的讀取的作業上的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流`ipconfig`命令。</span><span class="sxs-lookup"><span data-stu-id="7d50d-864">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.</span></span>  
  
 <span data-ttu-id="7d50d-865">此範例會建立為事件委派`OutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-865">The example creates an event delegate for the `OutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="7d50d-866">此事件處理常式收到來自的重新導向的文字行<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將它儲存在更新版本中所顯示的範例主控台視窗輸出字串中。</span><span class="sxs-lookup"><span data-stu-id="7d50d-866">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-867">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-867">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-868">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-868">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-869">取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-869">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-870">記憶體量 (以位元組為單位)，指由關聯的處理序所配置，且可以寫入虛擬記憶體分頁檔案的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-870">The amount of memory, in bytes, allocated by the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-871">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-871">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-872">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-872">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-873">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-873">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-874">取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-874">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-875">虛擬記憶體分頁檔案中，配置給關聯處理序的記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-875">The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-876">這個屬性所傳回的值代表目前的處理序，以位元組為單位所使用之虛擬記憶體分頁檔中的記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-876">The value returned by this property represents the current size of memory in the virtual memory paging file used by the process, in bytes.</span></span> <span data-ttu-id="7d50d-877">作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用來管理每個處理序虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-877">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="7d50d-878">可分頁記憶體不在使用中時，它可以傳輸至磁碟上的虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-878">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="7d50d-879">若要取得使用由作業系統處理序的記憶體大小，請使用<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-879">To obtain the size of memory used by the operating system for the process, use the <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="7d50d-880">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-880">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-881">屬性值相當於**分頁檔位元組**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-881">The property value is equivalent to the **Page File Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-882">下列程式碼範例啟動 「 記事本 」 應用程式的執行個體，然後擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-882">The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-883">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-883">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-884">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-884">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-885">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-885">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-886">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-886">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-887">取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-887">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-888">記憶體量 (以位元組為單位)，指系統已配置給可以寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-888">The amount of memory, in bytes, the system has allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-889">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-889">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-890">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-890">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-891">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-891">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-892">取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-892">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-893">配置給關聯處理序的系統記憶體量 (以位元組為單位)，可以寫入虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-893">The amount of system memory, in bytes, allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-894">這個屬性值所傳回的值表示目前的處理序，以位元組為單位所使用的可分頁系統記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-894">The value returned by this property value represents the current size of pageable system memory used by the process, in bytes.</span></span> <span data-ttu-id="7d50d-895">系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。</span><span class="sxs-lookup"><span data-stu-id="7d50d-895">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="7d50d-896">可分頁記憶體不在使用中時，它可以傳輸至磁碟上的虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-896">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="7d50d-897">取得處理序所使用的應用程式記憶體的大小，請使用<xref:System.Diagnostics.Process.PagedMemorySize64%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-897">To obtain the size of the application memory used by the process, use the <xref:System.Diagnostics.Process.PagedMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="7d50d-898">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-898">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-899">屬性值相當於**Pool Paged Bytes**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-899">The property value is equivalent to the **Pool Paged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-900">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-900">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-901">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-901">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-902">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-902">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-903">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-903">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-904">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-904">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-905">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-905">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-906">取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-906">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-907">最大記憶體量 (以位元組為單位)，指由關聯的處理序配置給可以寫入虛擬記憶體分頁檔案的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-907">The maximum amount of memory, in bytes, allocated by the associated process that could be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-908">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-908">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-909">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-909">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-910">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-910">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-911">取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-911">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-912">虛擬記憶體分頁檔案中，從啟動以來配置給關聯處理序的最大記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-912">The maximum amount of memory, in bytes, allocated in the virtual memory paging file for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-913">這個屬性值所傳回的值代表自啟動，以位元組為單位，處理序所使用之虛擬記憶體分頁檔中的記憶體大小上限。</span><span class="sxs-lookup"><span data-stu-id="7d50d-913">The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started, in bytes.</span></span> <span data-ttu-id="7d50d-914">作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用來管理每個處理序虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-914">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="7d50d-915">可分頁記憶體不在使用中時，它可以傳輸至磁碟上的虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-915">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="7d50d-916">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-916">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-917">屬性值相當於**分頁檔位元組尖峰**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-917">The property value is equivalent to the **Page File Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-918">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-918">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-919">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-919">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-920">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-920">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-921">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-921">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-922">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-922">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-923">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-923">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-924">取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-924">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-925">最大虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-925">The maximum amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-926">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-926">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-927">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-927">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-928">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-928">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-929">取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-929">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-930">從啟動以來配置給關聯處理序的最大虛擬記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-930">The maximum amount of virtual memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-931">這個屬性所傳回的值代表自啟動，以位元組為單位的處理序使用的虛擬記憶體的大小上限。</span><span class="sxs-lookup"><span data-stu-id="7d50d-931">The value returned by this property represents the maximum size of virtual memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="7d50d-932">作業系統會對應至載入實體記憶體中，或網頁儲存在磁碟上的虛擬記憶體分頁檔案中每個處理序的虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-932">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="7d50d-933">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-933">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-934">屬性值相當於**虛擬位元組尖峰**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-934">The property value is equivalent to the **Virtual Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-935">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-935">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-936">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-936">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-937">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-937">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-938">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-938">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-939">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-939">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-940">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-940">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-941">取得相關處理序工作集大小的最大值 (位元組)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-941">Gets the peak working set size for the associated process, in bytes.</span></span></summary>
        <value><span data-ttu-id="7d50d-942">最大實體記憶體數量，為相關的處理序一次所需的量 (位元組)，</span><span class="sxs-lookup"><span data-stu-id="7d50d-942">The maximum amount of physical memory that the associated process has required all at once, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-943">處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-943">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="7d50d-944">這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-944">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="7d50d-945">工作集包括共用和私用資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-945">The working set includes both shared and private data.</span></span> <span data-ttu-id="7d50d-946">共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-946">The shared data includes the pages that contain all the instructions that the process executes, including process modules and the system libraries.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-947">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-947">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-948">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-948">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-949">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-949">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-950">取得關聯處理序所使用最大實體記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-950">Gets the maximum amount of physical memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-951">從啟動以來配置給關聯處理序的最大實體記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-951">The maximum amount of physical memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-952">這個屬性所傳回的值代表的工作集記憶體使用處理程序，因為它啟動，以位元組為單位的大小上限。</span><span class="sxs-lookup"><span data-stu-id="7d50d-952">The value returned by this property represents the maximum size of working set memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="7d50d-953">處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-953">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="7d50d-954">這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-954">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="7d50d-955">工作集包括共用和私用資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-955">The working set includes both shared and private data.</span></span> <span data-ttu-id="7d50d-956">共用的資料包含頁面包含所有處理序執行，包括指示從處理序模組和系統程式庫的指示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-956">The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="7d50d-957">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-957">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-958">屬性值相當於**工作集尖峰**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-958">The property value is equivalent to the **Working Set Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-959">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-959">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-960">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-960">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-961">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-961">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-962">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-962">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-963">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-963">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-964">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-964">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-965">取得或設定值，指出作業系統是否應該在主視窗有焦點 (Focus) 時，暫時提高相關的處理序優先權。</span><span class="sxs-lookup"><span data-stu-id="7d50d-965">Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</span></span></summary>
        <value>
          <span data-ttu-id="7d50d-966">當處理序離開等候狀態時，如果應動態提高處理序優先權，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-966"><see langword="true" /> if dynamic boosting of the process priority should take place for a process when it is taken out of the wait state; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="7d50d-967">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-967">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-968">當執行緒的優先權類別有一個動態優先順序列舉值的處理序中執行時 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)，系統暫時提升執行緒的優先順序，當它被帶離等候狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-968">When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), the system temporarily boosts the thread's priority when it is taken out of a wait state.</span></span> <span data-ttu-id="7d50d-969">這個動作可防止其他處理程序會中斷目前執行緒的處理。</span><span class="sxs-lookup"><span data-stu-id="7d50d-969">This action prevents other processes from interrupting the processing of the current thread.</span></span> <span data-ttu-id="7d50d-970"><xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定會影響所有現有的執行緒和任何後續程序所建立的執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-970">The <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> setting affects all the existing threads and any threads subsequently created by the process.</span></span> <span data-ttu-id="7d50d-971">若要還原正常的行為，請設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性`false`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-971">To restore normal behavior, set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-972">提高過度提高優先權可以耗盡必要作業系統和網路功能，導致問題的其他作業系統工作的資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-972">Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-973">無法從關聯的處理序資源擷取優先權提升資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-973">Priority boost information could not be retrieved from the associated process resource.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-974">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-974">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span>  
  
 <span data-ttu-id="7d50d-975">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-975">-or-</span></span>  
  
 <span data-ttu-id="7d50d-976">處理序識別碼或處理序控制代碼為零。</span><span class="sxs-lookup"><span data-stu-id="7d50d-976">The process identifier or process handle is zero.</span></span> <span data-ttu-id="7d50d-977">(尚未啟動處理序)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-977">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-978">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-978">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-979">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-979">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-980">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-980">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-981">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-981">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-982">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-982">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-983">取得或設定相關處理序的整體優先權分類。</span><span class="sxs-lookup"><span data-stu-id="7d50d-983">Gets or sets the overall priority category for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-984">相關聯處理序的優先權分類，處理序的 <see cref="P:System.Diagnostics.Process.BasePriority" /> 由此計算出來。</span><span class="sxs-lookup"><span data-stu-id="7d50d-984">The priority category for the associated process, from which the <see cref="P:System.Diagnostics.Process.BasePriority" /> of the process is calculated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-985">處理序優先權類別包含執行緒的優先順序層級的範圍。</span><span class="sxs-lookup"><span data-stu-id="7d50d-985">A process priority class encompasses a range of thread priority levels.</span></span> <span data-ttu-id="7d50d-986">具有不同優先順序執行相對於此程序的優先權等級的程序中執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-986">Threads with different priorities that are running in the process run relative to the priority class of the process.</span></span> <span data-ttu-id="7d50d-987">Win32 七個基本優先順序層級，每個類別會使用四個優先權類別。</span><span class="sxs-lookup"><span data-stu-id="7d50d-987">Win32 uses four priority classes with seven base priority levels per class.</span></span> <span data-ttu-id="7d50d-988">這些程序的優先順序類別所擷取的<xref:System.Diagnostics.ProcessPriorityClass>列舉型別，可讓您將處理序優先權設定為<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-988">These process priority classes are captured in the <xref:System.Diagnostics.ProcessPriorityClass> enumeration, which lets you set the process priority to <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>.</span></span> <span data-ttu-id="7d50d-989">根據 24 小時制或其他優先權的提高，基礎優先權層級可以變更作業系統，當處理程序必須晚於其他人存取置於處理器的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-989">Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor.</span></span> <span data-ttu-id="7d50d-990">此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>暫時提高已超出等候狀態的執行緒的優先權層級。</span><span class="sxs-lookup"><span data-stu-id="7d50d-990">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> to temporarily boost the priority level of threads that have been taken out of the wait state.</span></span> <span data-ttu-id="7d50d-991">處理程序會回到等候狀態時，會重設的優先順序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-991">The priority is reset when the process returns to the wait state.</span></span>  
  
 <span data-ttu-id="7d50d-992"><xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視指派給處理程序的起始優先權。</span><span class="sxs-lookup"><span data-stu-id="7d50d-992">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority that is assigned to a process.</span></span> <span data-ttu-id="7d50d-993">不過，因為它是唯讀，您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>屬性來設定處理序的優先順序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-993">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> property to set the priority of a process.</span></span> <span data-ttu-id="7d50d-994">若要變更優先順序，請使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性，取得或設定處理程序的整體優先權分類。</span><span class="sxs-lookup"><span data-stu-id="7d50d-994">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property, which gets or sets the overall priority category for the process.</span></span>  
  
 <span data-ttu-id="7d50d-995">無法使用 「 系統監視器檢視的優先權等級。</span><span class="sxs-lookup"><span data-stu-id="7d50d-995">The priority class cannot be viewed using System Monitor.</span></span> <span data-ttu-id="7d50d-996">下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-996">The following table shows the relationship between the <xref:System.Diagnostics.Process.BasePriority%2A> and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="7d50d-997">BasePriority</span><span class="sxs-lookup"><span data-stu-id="7d50d-997">BasePriority</span></span>|<span data-ttu-id="7d50d-998">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="7d50d-998">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="7d50d-999">4</span><span class="sxs-lookup"><span data-stu-id="7d50d-999">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="7d50d-1000">8</span><span class="sxs-lookup"><span data-stu-id="7d50d-1000">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="7d50d-1001">13</span><span class="sxs-lookup"><span data-stu-id="7d50d-1001">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="7d50d-1002">24</span><span class="sxs-lookup"><span data-stu-id="7d50d-1002">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1003">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1003">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1004">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1004">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1005">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1005">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1006">無法設定處理序優先順序的資訊，或從相關聯的處理序資源擷取。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1006">Process priority information could not be set or retrieved from the associated process resource.</span></span>  
  
 <span data-ttu-id="7d50d-1007">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1007">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1008">處理序識別碼或處理序控制代碼為零。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1008">The process identifier or process handle is zero.</span></span> <span data-ttu-id="7d50d-1009">(尚未啟動處理序)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1009">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1010">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1010">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1011">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1011">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1012">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1012">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1013">使用 Windows 98 或 Windows Millennium Edition (Windows Me) 時，<see cref="P:System.Diagnostics.Process.PriorityClass" /> 已設定為 <see langword="AboveNormal" /> 或 <see langword="BelowNormal" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1013">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me).</span></span> <span data-ttu-id="7d50d-1014">這些平台不支援優先權類別的這些值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1014">These platforms do not support those values for the priority class.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="7d50d-1015">無法設定優先權類別，因為它不使用如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列舉類型中所定義的有效值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1015">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1016">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1016">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1017">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1017">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1018">取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1018">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1019">相關的處理序配置的位元組數目，不能與其他處理序共用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1019">The number of bytes allocated by the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1020">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1020">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1021">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1021">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1022">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1022">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1023">取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1023">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1024">配置給關聯處理序的記憶體量 (以位元組為單位)，不能與其他處理序共用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1024">The amount of memory, in bytes, allocated for the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1025">這個屬性所傳回的值代表目前的處理序，以位元組為單位，不能與其他處理序共用所使用的記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1025">The value returned by this property represents the current size of memory used by the process, in bytes, that cannot be shared with other processes.</span></span>  
  
 <span data-ttu-id="7d50d-1026">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1026">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-1027">屬性值相當於**私用位元組**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1027">The property value is equivalent to the **Private Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1028">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1028">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-1029">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1029">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1030">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1030">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1031">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1031">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1032">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1032">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1033">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1033">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1034">取得這個處理序使用處理器的授權時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1034">Gets the privileged processor time for this process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1035"><see cref="T:System.TimeSpan" />，表示處理序在作業系統核心內執行程式碼所花費的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1035">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the process has spent running code inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7d50d-1036">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1036">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1037">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1037">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1038">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1038">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1039">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1039">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1040">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1040">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1041">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1041">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1042">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1042">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1043">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1043">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1044">取得處理序的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1044">Gets the name of the process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1045">名稱，系統用來向使用者識別處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1045">The name that the system uses to identify the process to the user.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1046"><xref:System.Diagnostics.Process.ProcessName%2A>屬性會保留的可執行檔名稱，例如 Outlook、 不包含副檔名為.exe 或路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1046">The <xref:System.Diagnostics.Process.ProcessName%2A> property holds an executable file name, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="7d50d-1047">它可協助取得和管理相同的可執行檔相關聯的所有處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1047">It is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1048">在[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]作業系統<xref:System.Diagnostics.Process.ProcessName%2A>屬性可能會被截斷為 15 個字元，如果無法取得處理序模組資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1048">On [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] operating systems, the <xref:System.Diagnostics.Process.ProcessName%2A> property may be truncated to 15 characters if the process module information cannot be obtained.</span></span>  
  
 <span data-ttu-id="7d50d-1049">您可以呼叫<xref:System.Diagnostics.Process.GetProcessesByName%2A>，它將可執行檔名稱，擷取陣列，其中包含指定的電腦上每個執行的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1049">You can call <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer.</span></span> <span data-ttu-id="7d50d-1050">您可以使用此陣列，例如，若要關閉的可執行檔的所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1050">You can use this array, for example, to shut down all the running instances of the executable file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1051">處理序沒有識別項，或沒有處理序與 <see cref="T:System.Diagnostics.Process" /> 相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1051">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.</span></span>  
  
 <span data-ttu-id="7d50d-1052">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1052">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1053">關聯處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1053">The associated process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1054">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1054">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1055">處理序不在這部電腦上。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1055">The process is not on this computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1056">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1056">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1057">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1057">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1058">取得或設定處理器，這個處理序中的執行緒可以在其上排程執行。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1058">Gets or sets the processors on which the threads in this process can be scheduled to run.</span></span></summary>
        <value><span data-ttu-id="7d50d-1059">位元遮罩，表示相關的處理序中的執行緒可以在其上執行的處理器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1059">A bitmask representing the processors that the threads in the associated process can run on.</span></span> <span data-ttu-id="7d50d-1060">預設值取決於電腦上的處理器數目。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1060">The default depends on the number of processors on the computer.</span></span> <span data-ttu-id="7d50d-1061">預設值為 2 <sup>n</sup> -1，其中 n 是處理器數目。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1061">The default value is 2 <sup>n</sup> -1, where n is the number of processors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1062">在 Windows 2000 和更新版本中，處理程序中的執行緒可以移轉處理器，以重新載入處理器快取每個移轉。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1062">In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="7d50d-1063">在繁重的系統負載下指定哪一個處理器應該執行特定的執行緒可以改善效能降低的次數會重新載入處理器快取。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1063">Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded.</span></span> <span data-ttu-id="7d50d-1064">處理器和執行緒之間的關聯則稱為處理器相似性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1064">The association between a processor and a thread is called the processor affinity.</span></span>  
  
 <span data-ttu-id="7d50d-1065">每個處理器是位元表示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1065">Each processor is represented as a bit.</span></span> <span data-ttu-id="7d50d-1066">位元 0 是第一個處理器，位元 1 是處理器兩個，依此類推。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1066">Bit 0 is processor one, bit 1 is processor two, and so forth.</span></span> <span data-ttu-id="7d50d-1067">如果您的位元設定為 1 的值，對應的處理器會選取進行執行緒指派。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1067">If you set a bit to the value 1, the corresponding processor is selected for thread assignment.</span></span> <span data-ttu-id="7d50d-1068">當您將<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值為零，作業系統的排程演算法設定執行緒的相似性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1068">When you set the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value to zero, the operating system's scheduling algorithms set the thread's affinity.</span></span> <span data-ttu-id="7d50d-1069">當<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值設定為任何非零值時，值會解譯為指定適合選取處理器的位元遮罩。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1069">When the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</span></span>  
  
 <span data-ttu-id="7d50d-1070">下表顯示選取的<xref:System.Diagnostics.Process.ProcessorAffinity%2A>八個處理器的系統值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1070">The following table shows a selection of <xref:System.Diagnostics.Process.ProcessorAffinity%2A> values for an eight-processor system.</span></span>  
  
|<span data-ttu-id="7d50d-1071">位元遮罩</span><span class="sxs-lookup"><span data-stu-id="7d50d-1071">Bitmask</span></span>|<span data-ttu-id="7d50d-1072">二進位值</span><span class="sxs-lookup"><span data-stu-id="7d50d-1072">Binary value</span></span>|<span data-ttu-id="7d50d-1073">可供選取的處理器</span><span class="sxs-lookup"><span data-stu-id="7d50d-1073">Eligible processors</span></span>|  
|-------------|------------------|-------------------------|  
|<span data-ttu-id="7d50d-1074">0x0001</span><span class="sxs-lookup"><span data-stu-id="7d50d-1074">0x0001</span></span>|<span data-ttu-id="7d50d-1075">00000000 00000001</span><span class="sxs-lookup"><span data-stu-id="7d50d-1075">00000000 00000001</span></span>|<span data-ttu-id="7d50d-1076">1</span><span class="sxs-lookup"><span data-stu-id="7d50d-1076">1</span></span>|  
|<span data-ttu-id="7d50d-1077">0x0003</span><span class="sxs-lookup"><span data-stu-id="7d50d-1077">0x0003</span></span>|<span data-ttu-id="7d50d-1078">00000000 00000011</span><span class="sxs-lookup"><span data-stu-id="7d50d-1078">00000000 00000011</span></span>|<span data-ttu-id="7d50d-1079">1 和 2</span><span class="sxs-lookup"><span data-stu-id="7d50d-1079">1 and 2</span></span>|  
|<span data-ttu-id="7d50d-1080">0x0007</span><span class="sxs-lookup"><span data-stu-id="7d50d-1080">0x0007</span></span>|<span data-ttu-id="7d50d-1081">00000000 00000111</span><span class="sxs-lookup"><span data-stu-id="7d50d-1081">00000000 00000111</span></span>|<span data-ttu-id="7d50d-1082">1、 2 和 3</span><span class="sxs-lookup"><span data-stu-id="7d50d-1082">1, 2 and 3</span></span>|  
|<span data-ttu-id="7d50d-1083">0x0009</span><span class="sxs-lookup"><span data-stu-id="7d50d-1083">0x0009</span></span>|<span data-ttu-id="7d50d-1084">00000000 00001001</span><span class="sxs-lookup"><span data-stu-id="7d50d-1084">00000000 00001001</span></span>|<span data-ttu-id="7d50d-1085">1 到 4</span><span class="sxs-lookup"><span data-stu-id="7d50d-1085">1 and 4</span></span>|  
|<span data-ttu-id="7d50d-1086">0x007F</span><span class="sxs-lookup"><span data-stu-id="7d50d-1086">0x007F</span></span>|<span data-ttu-id="7d50d-1087">00000000 01111111</span><span class="sxs-lookup"><span data-stu-id="7d50d-1087">00000000 01111111</span></span>|<span data-ttu-id="7d50d-1088">1、 2、 3、 4、 5、 6 和 7</span><span class="sxs-lookup"><span data-stu-id="7d50d-1088">1, 2, 3, 4, 5, 6 and 7</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          <span data-ttu-id="7d50d-1089"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 資訊無法設定或從相關聯的處理序資源擷取。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1089"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.</span></span>  
  
 <span data-ttu-id="7d50d-1090">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1090">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1091">處理序識別碼或處理序控制代碼為零。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1091">The process identifier or process handle is zero.</span></span> <span data-ttu-id="7d50d-1092">(尚未啟動處理序)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1092">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1093">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1093">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1094">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1094">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1095">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1095">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.</span></span>  
  
 <span data-ttu-id="7d50d-1096">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1096">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1097">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1097">The process has exited.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1098">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1098">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1099">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1099">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-1100">捨棄快取於處理序元件內之相關處理序的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1100">Discards any information about the associated process that has been cached inside the process component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1101">之後<xref:System.Diagnostics.Process.Refresh%2A>呼叫時，第一個要求的每個屬性的相關資訊會造成處理序元件從相關聯的處理序取得新的值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1101">After <xref:System.Diagnostics.Process.Refresh%2A> is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</span></span>  
  
 <span data-ttu-id="7d50d-1102">當<xref:System.Diagnostics.Process>元件是相關聯處理序資源，屬性值的<xref:System.Diagnostics.Process>立即填入依據相關聯的處理序的狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1102">When a <xref:System.Diagnostics.Process> component is associated with a process resource, the property values of the <xref:System.Diagnostics.Process> are immediately populated according to the status of the associated process.</span></span> <span data-ttu-id="7d50d-1103">如果後續變更之相關處理序的資訊，這些變更不會反映在<xref:System.Diagnostics.Process>元件的快取的值。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1103">If the information about the associated process subsequently changes, those changes are not reflected in the <xref:System.Diagnostics.Process> component's cached values.</span></span> <span data-ttu-id="7d50d-1104"><xref:System.Diagnostics.Process>元件是的快照集處理序資源在其相關聯的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1104">The <xref:System.Diagnostics.Process> component is a snapshot of the process resource at the time they are associated.</span></span> <span data-ttu-id="7d50d-1105">若要檢視關聯的處理序的目前值，呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1105">To view the current values for the associated process, call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1106">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1106">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1107">然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 的第二個時間間隔，最多為 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1107">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="7d50d-1108">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1108">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="7d50d-1109">如果它仍在執行 10 秒後，此範例會關閉處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1109">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1110">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1110">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1111">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1111">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1112">取得值，指出處理序的使用者介面是否正在回應。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1112">Gets a value indicating whether the user interface of the process is responding.</span></span></summary>
        <value>
          <span data-ttu-id="7d50d-1113">如果相關處理序的使用者介面正在回應系統，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1113"><see langword="true" /> if the user interface of the associated process is responding to the system; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1114">如果處理程序具有使用者介面，<xref:System.Diagnostics.Process.Responding%2A>屬性聯繫來判斷處理序是否正在回應使用者輸入的使用者介面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1114">If a process has a user interface, the <xref:System.Diagnostics.Process.Responding%2A> property contacts the user interface to determine whether the process is responding to user input.</span></span> <span data-ttu-id="7d50d-1115">如果介面不會立即回應<xref:System.Diagnostics.Process.Responding%2A>屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1115">If the interface does not respond immediately, the <xref:System.Diagnostics.Process.Responding%2A> property returns `false`.</span></span> <span data-ttu-id="7d50d-1116">使用這個屬性來判斷是否相關聯的處理序的介面已停止回應。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1116">Use this property to determine whether the interface of the associated process has stopped responding.</span></span>  
  
 <span data-ttu-id="7d50d-1117">如果處理程序並沒有<xref:System.Diagnostics.Process.MainWindowHandle%2A>，這個屬性會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1117">If the process does not have a <xref:System.Diagnostics.Process.MainWindowHandle%2A>, this property returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1118">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1118">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1119">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1119">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1120">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1120">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1121">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1121">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1122">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1122">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1123">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Responding" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1123">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1124">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1124">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1125">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1125">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1126">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1126">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1127">取得這個處理序的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1127">Gets the native handle to this process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1128">這個處理序的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1128">The native handle to this process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1129">控制代碼才可使用呼叫元件啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1129">The handle is only available if the calling component started the process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1130">取得相關處理序的終端機服務工作階段識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1130">Gets the Terminal Services session identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1131">相關處理序的終端機服務工作階段識別項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1131">The Terminal Services session identifier for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1132"><xref:System.Diagnostics.Process.SessionId%2A>屬性可識別目前執行中應用程式的工作階段。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1132">The <xref:System.Diagnostics.Process.SessionId%2A> property identifies the session in which the application is currently running.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="7d50d-1133">沒有與此處理序相關聯的工作階段。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1133">There is no session associated with this process.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1134">沒有與這個工作階段識別項相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1134">There is no process associated with this session identifier.</span></span>  
  
 <span data-ttu-id="7d50d-1135">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1135">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1136">相關的處理序不在此機器上。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1136">The associated process is not on this machine.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1137">Windows 98 不支援 <see cref="P:System.Diagnostics.Process.SessionId" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1137">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1138">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1138">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1139">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1139">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1140">取得用來讀取應用程式錯誤輸出的資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1140">Gets a stream used to read the error output of the application.</span></span></summary>
        <value><span data-ttu-id="7d50d-1141"><see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1141">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard error stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1142">當<xref:System.Diagnostics.Process>將文字寫入至其標準錯誤資料流，通常會在主控台上顯示文字。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1142">When a <xref:System.Diagnostics.Process> writes text to its standard error stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="7d50d-1143">藉由重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流，您可以操作或隱藏的錯誤輸出的處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1143">By redirecting the <xref:System.Diagnostics.Process.StandardError%2A> stream, you can manipulate or suppress the error output of a process.</span></span> <span data-ttu-id="7d50d-1144">比方說，您可以篩選文字、 以不同的方式，將其格式化或將輸出寫入主控台和指定的記錄檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1144">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1145">若要使用<xref:System.Diagnostics.Process.StandardError%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>至`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>至`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1145">To use <xref:System.Diagnostics.Process.StandardError%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="7d50d-1146">否則，讀取<xref:System.Diagnostics.Process.StandardError%2A>資料流擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1146">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="7d50d-1147">重新導向<xref:System.Diagnostics.Process.StandardError%2A>同步或非同步方式，就可以讀取資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1147">The redirected <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="7d50d-1148">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行同步處理程序的錯誤輸出資料流上的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1148">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="7d50d-1149">這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1149">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="7d50d-1150">相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1150">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="7d50d-1151">這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1151">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="7d50d-1152">同步讀取作業會讀取自呼叫端之間的相依性<xref:System.Diagnostics.Process.StandardError%2A>資料流及子處理序寫入該資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1152">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="7d50d-1153">這些相依性可能會導致死結狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1153">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="7d50d-1154">當呼叫端會從子處理序的重新導向資料流讀取時，它會相依於子系。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1154">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="7d50d-1155">呼叫端會在讀取作業，等到子寫入資料流，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1155">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="7d50d-1156">時子處理序寫入資料不足，無法填滿其重新導向資料流，它會相依於父代。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1156">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="7d50d-1157">子處理序會等候下一個寫入作業，直到父讀取完整的資料流，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1157">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="7d50d-1158">當呼叫端和子處理序互相等候完成作業，且無法繼續時，就會導致死結狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1158">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="7d50d-1159">您可以評估呼叫端和子處理序之間的相依性，以避免死結。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1159">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="7d50d-1160">例如，下列 C# 程式碼會示範如何從重新導向資料流讀取，並等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1160">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 <span data-ttu-id="7d50d-1161">程式碼範例可避免發生死結狀況呼叫`p.StandardError.ReadToEnd`之前`p.WaitForExit`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1161">The code example avoids a deadlock condition by calling `p.StandardError.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="7d50d-1162">如果父處理呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿重新導向資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1162">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardError.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="7d50d-1163">父處理序會無限期地等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1163">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="7d50d-1164">子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1164">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-1165">當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1165">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="7d50d-1166">下列 C# 程式碼，例如，執行兩個資料流上的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1166">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="7d50d-1167">程式碼範例可避免發生死結狀況執行非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1167">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-1168">如果父處理序的呼叫就會導致死結狀態`p.StandardOutput.ReadToEnd`後面`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1168">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="7d50d-1169">父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1169">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-1170">子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1170">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-1171">若要避免這些相依性和其潛在的死結，您可以使用非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1171">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="7d50d-1172">或者，您可以藉由建立兩個執行緒，並讀取每個個別執行緒上的資料流的輸出，避免發生死結狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1172">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1173">您不能混用重新導向資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1173">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="7d50d-1174">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1174">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="7d50d-1175">例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1175">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="7d50d-1176">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1176">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="7d50d-1177">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1177">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1178">下列範例會使用`net use`命令搭配使用者提供的引數對應網路資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1178">The following example uses the `net use` command together with a user supplied argument to map a network resource.</span></span> <span data-ttu-id="7d50d-1179">然後會讀取 net 命令標準錯誤資料流，並寫入至主控台。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1179">It then reads the standard error stream of the net command and writes it to console.</span></span>  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1180">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1180">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
 <span data-ttu-id="7d50d-1181">\-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1181">\- or -</span></span>  
  
 <span data-ttu-id="7d50d-1182">已開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 的非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1182">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1183">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1183">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1184">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1184">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1185">取得用來寫入應用程式輸入的資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1185">Gets a stream used to write the input of the application.</span></span></summary>
        <value><span data-ttu-id="7d50d-1186"><see cref="T:System.IO.StreamWriter" />，可用來寫入應用程式的標準輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1186">A <see cref="T:System.IO.StreamWriter" /> that can be used to write the standard input stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1187">A<xref:System.Diagnostics.Process>可以讀取其標準輸入資料流，一般是鍵盤輸入的文字。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1187">A <xref:System.Diagnostics.Process> can read input text from its standard input stream, typically the keyboard.</span></span> <span data-ttu-id="7d50d-1188">藉由重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流，您可以透過程式設計方式指定輸入。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1188">By redirecting the <xref:System.Diagnostics.Process.StandardInput%2A> stream, you can programmatically specify the input.</span></span> <span data-ttu-id="7d50d-1189">例如，而不是使用鍵盤輸入，您可以提供指定之檔案的內容中的文字或另一個應用程式的輸出。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1189">For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1190">若要使用<xref:System.Diagnostics.Process.StandardInput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>至`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>至`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1190">To use <xref:System.Diagnostics.Process.StandardInput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="7d50d-1191">否則，寫入<xref:System.Diagnostics.Process.StandardInput%2A>資料流擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1191">Otherwise, writing to the <xref:System.Diagnostics.Process.StandardInput%2A> stream throws an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1192">下列範例說明如何將重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流的處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1192">The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process.</span></span> <span data-ttu-id="7d50d-1193">此範例會啟動`sort`命令與重新導向輸入。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1193">The example starts the `sort` command with redirected input.</span></span> <span data-ttu-id="7d50d-1194">接著會提示使用者輸入的文字，並將其傳遞至`sort`透過重新導向處理序<xref:System.Diagnostics.Process.StandardInput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1194">It then prompts the user for text, and passes that to the `sort` process by means of the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream.</span></span> <span data-ttu-id="7d50d-1195">`sort`結果會顯示主控台使用者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1195">The `sort` results are displayed to the user on the console.</span></span>  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1196">尚未定義 <see cref="P:System.Diagnostics.Process.StandardInput" /> 資料流，因為 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 已設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1196">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1197">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1197">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1198">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1198">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1199">取得用來讀取應用程式文字輸出的資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1199">Gets a stream used to read the textual output of the application.</span></span></summary>
        <value><span data-ttu-id="7d50d-1200"><see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1200">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard output stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1201">當<xref:System.Diagnostics.Process>將文字寫入至其標準的資料流，通常會在主控台上顯示文字。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1201">When a <xref:System.Diagnostics.Process> writes text to its standard stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="7d50d-1202">藉由重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，您可以操作或隱藏程序的輸出。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1202">By redirecting the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, you can manipulate or suppress the output of a process.</span></span> <span data-ttu-id="7d50d-1203">比方說，您可以篩選文字、 以不同的方式，將其格式化或將輸出寫入主控台和指定的記錄檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1203">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1204">若要使用<xref:System.Diagnostics.Process.StandardOutput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>至`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>至`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1204">To use <xref:System.Diagnostics.Process.StandardOutput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="7d50d-1205">否則，讀取<xref:System.Diagnostics.Process.StandardOutput%2A>資料流擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1205">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="7d50d-1206">重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>同步或非同步方式，就可以讀取資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1206">The redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="7d50d-1207">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流上的同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1207">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="7d50d-1208">這些同步讀取作業不會完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1208">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="7d50d-1209">相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1209">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-1210">這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1210">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="7d50d-1211">同步讀取作業會讀取自呼叫端之間的相依性<xref:System.Diagnostics.Process.StandardOutput%2A>資料流及子處理序寫入該資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1211">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="7d50d-1212">這些相依性可能會導致死結狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1212">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="7d50d-1213">當呼叫端會從子處理序的重新導向資料流讀取時，它會相依於子系。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1213">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="7d50d-1214">呼叫端會在讀取作業，等到子寫入資料流，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1214">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="7d50d-1215">時子處理序寫入資料不足，無法填滿其重新導向資料流，它會相依於父代。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1215">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="7d50d-1216">子處理序會等候下一個寫入作業，直到父讀取完整的資料流，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1216">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="7d50d-1217">當呼叫端和子處理序互相等候完成作業，且無法繼續時，就會導致死結狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1217">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="7d50d-1218">您可以評估呼叫端和子處理序之間的相依性，以避免死結。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1218">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="7d50d-1219">例如，下列 C# 程式碼會示範如何從重新導向資料流讀取，並等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1219">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="7d50d-1220">程式碼範例可避免發生死結狀況呼叫`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1220">The code example avoids a deadlock condition by calling `p.StandardOutput.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="7d50d-1221">如果父處理呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子處理序寫入足夠的文字，以填滿重新導向資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1221">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardOutput.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="7d50d-1222">父處理序會無限期地等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1222">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="7d50d-1223">子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1223">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-1224">當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1224">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="7d50d-1225">下列 C# 程式碼，例如，執行兩個資料流上的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1225">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="7d50d-1226">程式碼範例可避免發生死結狀況執行非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1226">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-1227">如果父處理序的呼叫就會導致死結狀態`p.StandardOutput.ReadToEnd`後面`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1227">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="7d50d-1228">父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1228">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="7d50d-1229">子處理序會無限期地等候從完整讀取父<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1229">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="7d50d-1230">若要避免這些相依性和其潛在的死結，您可以使用非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1230">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="7d50d-1231">或者，您可以藉由建立兩個執行緒，並讀取每個個別執行緒上的資料流的輸出，避免發生死結狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1231">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1232">您不能混用重新導向資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1232">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="7d50d-1233">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步讀取該資料流上的作業必須在相同的模式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1233">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="7d50d-1234">例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1234">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="7d50d-1235">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1235">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="7d50d-1236">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1236">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1237">下列範例會執行 ipconfig.exe 命令，並將其標準輸出重新導向至主控台視窗中的範例。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1237">The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window.</span></span>  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1238">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1238">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
 <span data-ttu-id="7d50d-1239">\-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1239">\- or -</span></span>  
  
 <span data-ttu-id="7d50d-1240">已開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 的非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1240">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1241">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1241">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1242">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1242">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7d50d-1243">啟動處理序資源，並將其與 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1243">Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-1244">啟動 (或重複使用) 這個 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性指定的處理序資源，並將其與元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1244">Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</span></span></summary>
        <returns>
          <span data-ttu-id="7d50d-1245">如果啟動處理序資源，則為 <see langword="true" />；如果沒有啟動任何新的處理序資源 (例如，如果重複使用現有的處理序)，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1245"><see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1246">使用此多載，啟動處理序資源，並將它與目前關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1246">Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="7d50d-1247">傳回值`true`指出已啟動新的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1247">The return value `true` indicates that a new process resource was started.</span></span> <span data-ttu-id="7d50d-1248">如果所指定的處理序資源<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性已在電腦上執行，啟動任何其他處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1248">If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started.</span></span> <span data-ttu-id="7d50d-1249">相反地，執行的處理序資源會重複使用和`false`傳回。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1249">Instead, the running process resource is reused and `false` is returned.</span></span>  
  
 <span data-ttu-id="7d50d-1250">您可以藉由指定在原本安裝應用程式的位置 （例如，網址） 啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1250">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="7d50d-1251">無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1251">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1252">如果您使用 Visual Studio 中的這個多載<xref:System.Diagnostics.Process.Start%2A>方法是拖曳後插入程式碼的一個<xref:System.Diagnostics.Process>元件拖曳至設計工具。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1252">If you are using Visual Studio, this overload of the <xref:System.Diagnostics.Process.Start%2A> method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer.</span></span> <span data-ttu-id="7d50d-1253">使用`Properties`視窗中，展開`StartInfo`類別寫入至適當的值和`FileName`屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1253">Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property.</span></span> <span data-ttu-id="7d50d-1254">您的變更會出現在表單的`InitializeComponent`程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1254">Your changes will appear in the form's `InitializeComponent` procedure.</span></span>  
  
 <span data-ttu-id="7d50d-1255">這個多載<xref:System.Diagnostics.Process.Start%2A>不`static`方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1255">This overload of <xref:System.Diagnostics.Process.Start%2A> is not a `static` method.</span></span> <span data-ttu-id="7d50d-1256">您必須呼叫它的執行個體從<xref:System.Diagnostics.Process>類別。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1256">You must call it from an instance of the <xref:System.Diagnostics.Process> class.</span></span> <span data-ttu-id="7d50d-1257">然後再呼叫<xref:System.Diagnostics.Process.Start%2A>，您必須先指定<xref:System.Diagnostics.Process.StartInfo%2A>這個屬性資訊<xref:System.Diagnostics.Process>執行個體，因為該資訊用來判斷啟動的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1257">Before calling <xref:System.Diagnostics.Process.Start%2A>, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.</span></span>  
  
 <span data-ttu-id="7d50d-1258">其他多載的<xref:System.Diagnostics.Process.Start%2A>方法`static`成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1258">The other overloads of the <xref:System.Diagnostics.Process.Start%2A> method are `static` members.</span></span> <span data-ttu-id="7d50d-1259">您不需要建立的執行個體<xref:System.Diagnostics.Process>元件，才能呼叫這些方法多載。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1259">You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method.</span></span> <span data-ttu-id="7d50d-1260">相反地，您可以呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>類別本身，以及新<xref:System.Diagnostics.Process>如果處理序已啟動，則會建立元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1260">Instead, you can call <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started.</span></span> <span data-ttu-id="7d50d-1261">或者，`null`會傳回處理程序已重複使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1261">Or, `null` is returned if a process was reused.</span></span> <span data-ttu-id="7d50d-1262">處理序資源會自動關聯於新<xref:System.Diagnostics.Process>元件所傳回<xref:System.Diagnostics.Process.Start%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1262">The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the <xref:System.Diagnostics.Process.Start%2A> method.</span></span>  
  
 <span data-ttu-id="7d50d-1263"><xref:System.Diagnostics.Process.StartInfo%2A>成員可以用來複製功能的`Run`對話方塊中的 Windows `Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1263">The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="7d50d-1264">任何可以輸入命令列的項目可以藉由設定適當的值啟動<xref:System.Diagnostics.Process.StartInfo%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1264">Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="7d50d-1265">唯一<xref:System.Diagnostics.Process.StartInfo%2A>屬性必須設為<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1265">The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="7d50d-1266"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性沒有可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1266">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file.</span></span> <span data-ttu-id="7d50d-1267">它可以是任何的副檔名已經安裝在系統的應用程式相關聯的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1267">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="7d50d-1268">例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以具有副檔名為.txt，如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有副檔名為.doc。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1268">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="7d50d-1269">在命令列中，您可以指定特定的檔案類型的動作。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1269">In the command line, you can specify actions to take for certain types of files.</span></span> <span data-ttu-id="7d50d-1270">例如，您可以列印文件，或編輯文字檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1270">For example, you can print documents or edit text files.</span></span> <span data-ttu-id="7d50d-1271">指定使用這些動作<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1271">Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="7d50d-1272">對於其他類型的檔案，您可以指定命令列引數時開始從檔案`Run` 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1272">For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box.</span></span> <span data-ttu-id="7d50d-1273">例如，您可以將 URL 當做引數如果您指定做為您的瀏覽器<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1273">For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</span></span> <span data-ttu-id="7d50d-1274">這些引數可以指定在<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1274">These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.</span></span>  
  
 <span data-ttu-id="7d50d-1275">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1275">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="7d50d-1276">否則，系統將不到路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1276">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="7d50d-1277">例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1277">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1278">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1278">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="7d50d-1279">如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1279">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="7d50d-1280">處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1280">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="7d50d-1281">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1281">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="7d50d-1282">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1282">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-1283">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1283">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="7d50d-1284">這裡的附註中 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1284">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="7d50d-1285">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1285">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="7d50d-1286">否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1286">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="7d50d-1287">部分方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1287">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="7d50d-1288">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1288">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="7d50d-1289">不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1289">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1290">下列範例會使用的執行個體<xref:System.Diagnostics.Process>啟動處理序的類別。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1290">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1291">在 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1291">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.</span></span>
 <span data-ttu-id="7d50d-1292">或者，<see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 成員是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1292">-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1293">開啟關聯檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1293">There was an error in opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7d50d-1294">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1294">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1295">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1295">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1296">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1296">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1297">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1297">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo"><span data-ttu-id="7d50d-1298"><see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用來啟動處理序的資訊，包括檔名和任何命令列引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1298">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</span></span></param>
        <summary><span data-ttu-id="7d50d-1299">啟動含有處理序啟動資訊 (例如，要啟動之處理序的檔名) 的參數所指定的處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1299">Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="7d50d-1300">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1300">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="7d50d-1301">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1301">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="7d50d-1302">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1302">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="7d50d-1303">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1303">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1304">使用此多載來啟動處理序資源，藉由指定<xref:System.Diagnostics.ProcessStartInfo>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1304">Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span> <span data-ttu-id="7d50d-1305">多載會將資源與新<xref:System.Diagnostics.Process>物件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1305">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1306">若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1306">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="7d50d-1307">這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1307">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1308">使用此多載<xref:System.Diagnostics.ProcessStartInfo>參數是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定其<xref:System.Diagnostics.Process.StartInfo%2A>屬性，以及呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1308">Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="7d50d-1309">使用<xref:System.Diagnostics.ProcessStartInfo>執行個體，以參數可讓您呼叫<xref:System.Diagnostics.Process.Start%2A>最控制傳入啟動程序呼叫。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1309">Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process.</span></span> <span data-ttu-id="7d50d-1310">如果您需要將只能在檔案名稱或檔案名稱和引數傳遞，則不需要建立新<xref:System.Diagnostics.ProcessStartInfo>執行個體，雖然這是一個選項。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1310">If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option.</span></span> <span data-ttu-id="7d50d-1311">唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>屬性必須設為<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1311">The only <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="7d50d-1312"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1312">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="7d50d-1313">它可以是任何的副檔名已經安裝在系統的應用程式相關聯的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1313">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="7d50d-1314">例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以具有副檔名為.txt，如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有副檔名為.doc。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1314">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="7d50d-1315">您可以藉由指定在原本安裝應用程式的位置 （例如，網址） 啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1315">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="7d50d-1316">無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1316">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="7d50d-1317">如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>屬性<xref:System.Diagnostics.Process.StartInfo%2A>執行個體已設定，未受`CreateProcessWithLogonW`呼叫函式，以便啟動處理程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1317">If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7d50d-1318">如果<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>屬性是`null`、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>屬性必須是 UPN 格式*使用者*@*DNS_domain_name*。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1318">If the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> property is `null`, the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> property must be in UPN format, *user*@*DNS_domain_name*.</span></span>   
  
 <span data-ttu-id="7d50d-1319">不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1319">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="7d50d-1320">當您已經建立的多載的使用<xref:System.Diagnostics.Process>執行個體，指定的啟動資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1320">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1321">使用其中一種`static`多載，當您想要建立新<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1321">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="7d50d-1322">這個多載並沒有參數的多載可讓您使用指定的處理序資源的啟動資訊<xref:System.Diagnostics.ProcessStartInfo>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1322">Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span>  
  
 <span data-ttu-id="7d50d-1323">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1323">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="7d50d-1324">否則，系統將不到路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1324">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="7d50d-1325">例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1325">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1326">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1326">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="7d50d-1327">如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1327">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="7d50d-1328">處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1328">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="7d50d-1329">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1329">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="7d50d-1330">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1330">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-1331">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1331">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="7d50d-1332">這裡的附註中 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1332">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="7d50d-1333">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上`startInfo`參數，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1333">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="7d50d-1334">否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1334">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="7d50d-1335">部分方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1335">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="7d50d-1336">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1336">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="7d50d-1337">不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1337">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1338">下列範例首先會繁衍 Internet Explorer 的執行個體，並在瀏覽器會顯示 [我的最愛] 資料夾的內容。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1338">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="7d50d-1339">然後會啟動 Internet Explorer 的其他執行個體，並顯示一些特定網頁或網站。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1339">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="7d50d-1340">最後它會啟動 Internet Explorer 與正在瀏覽至特定網站時的最小化視窗。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1340">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 <span data-ttu-id="7d50d-1341">如需這個方法的其他用途的其他範例，請參閱個別屬性<xref:System.Diagnostics.ProcessStartInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1341">For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1342">在 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性沒有指定任何檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1342">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.</span></span>  
  
 <span data-ttu-id="7d50d-1343">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1343">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1344"><paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性也是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1344">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.</span></span>  
  
 <span data-ttu-id="7d50d-1345">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1345">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1346"><paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 屬性不是 <see langword="null" /> 或空白，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 屬性不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1346">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7d50d-1347"><paramref name="startInfo" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1347">The <paramref name="startInfo" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7d50d-1348">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1348">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="7d50d-1349">找不到 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性中所指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1349">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1350">開啟關聯檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1350">An error occurred when opening the associated file.</span></span>  
  
 <span data-ttu-id="7d50d-1351">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1351">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1352">引數長度和處理序完整路徑長度的總和超過 2080。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1352">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="7d50d-1353">與這個例外狀況相關聯的錯誤訊息可以是下列其中之一：「傳到系統呼叫的資料區域太小。」</span><span class="sxs-lookup"><span data-stu-id="7d50d-1353">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="7d50d-1354">或「拒絕存取」。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1354">or "Access is denied."</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1355">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1355">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1356">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1356">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1357">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1357">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7d50d-1358">要在處理序中執行之文件或應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1358">The name of a document or application file to run in the process.</span></span></param>
        <summary><span data-ttu-id="7d50d-1359">藉由指定文件或應用程式檔案的名稱啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1359">Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="7d50d-1360">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1360">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="7d50d-1361">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1361">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="7d50d-1362">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1362">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="7d50d-1363">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1363">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1364">您可以使用這個多載，指定其檔案名稱啟動處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1364">Use this overload to start a process resource by specifying its file name.</span></span> <span data-ttu-id="7d50d-1365">多載會將資源與新<xref:System.Diagnostics.Process>物件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1365">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1366">若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1366">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="7d50d-1367">這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1367">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1368">多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1368">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="7d50d-1369">您可以啟動 ClickOnce 應用程式設定`fileName`從中您原先安裝應用程式的位置 （例如，Web 位址） 的參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1369">You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="7d50d-1370">無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1370">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="7d50d-1371">藉由指定其檔案名稱啟動處理程序是類似於輸入中的資訊`Run`對話方塊中的 Windows `Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1371">Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="7d50d-1372">因此，檔案名稱不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1372">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="7d50d-1373">它可以是任何檔案類型，其副檔名已經相關聯的系統上安裝的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1373">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="7d50d-1374">例如如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有.doc 的檔案名稱可以有副檔名為.txt。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1374">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="7d50d-1375">同樣地，在相同的方式來`Run`對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1375">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="7d50d-1376">例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1376">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="7d50d-1377">這個多載不允許處理序的命令列引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1377">This overload does not allow command-line arguments for the process.</span></span> <span data-ttu-id="7d50d-1378">如果您需要指定一或多個處理程序的命令列引數，使用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>或<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>多載。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1378">If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overloads.</span></span>  
  
 <span data-ttu-id="7d50d-1379">不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1379">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="7d50d-1380">當您已經建立的多載的使用<xref:System.Diagnostics.Process>執行個體，指定的啟動資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1380">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1381">使用其中一種`static`多載，當您想要建立新<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1381">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="7d50d-1382">這個多載並沒有參數的多載可讓您指定要啟動的處理序資源的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1382">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.</span></span>  
  
 <span data-ttu-id="7d50d-1383">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1383">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="7d50d-1384">否則，系統將不到路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1384">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="7d50d-1385">例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1385">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1386">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1386">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="7d50d-1387">如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1387">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="7d50d-1388">處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1388">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="7d50d-1389">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1389">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="7d50d-1390">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1390">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-1391">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1391">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="7d50d-1392">這裡的附註中 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1392">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="7d50d-1393">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1393">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="7d50d-1394">否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1394">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="7d50d-1395">部分方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1395">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="7d50d-1396">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1396">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="7d50d-1397">不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1397">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1398">下列範例首先會繁衍 Internet Explorer 的執行個體，並在瀏覽器會顯示 [我的最愛] 資料夾的內容。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1398">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="7d50d-1399">然後會啟動 Internet Explorer 的其他執行個體，並顯示一些特定網頁或網站。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1399">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="7d50d-1400">最後它會啟動 Internet Explorer 與正在瀏覽至特定網站時的最小化視窗。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1400">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1401">開啟關聯的檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1401">An error occurred when opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7d50d-1402">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1402">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="7d50d-1403">PATH 環境變數具有含引號的字串。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1403">The PATH environment variable has a string containing quotes.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1404">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1404">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1405">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1405">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7d50d-1406">要在處理序中執行之應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1406">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="7d50d-1407">啟動處理程序時要傳遞的命令列引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1407">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="7d50d-1408">藉由指定應用程式的名稱和一組命令列引數來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1408">Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="7d50d-1409">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1409">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="7d50d-1410">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1410">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="7d50d-1411">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1411">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="7d50d-1412">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1412">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1413">使用這個多載來啟動處理序資源藉由指定其檔案名稱和命令列引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1413">Use this overload to start a process resource by specifying its file name and command-line arguments.</span></span> <span data-ttu-id="7d50d-1414">多載會將資源與新<xref:System.Diagnostics.Process>物件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1414">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1415">若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1415">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="7d50d-1416">這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1416">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1417">多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1417">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="7d50d-1418">啟動處理序藉由指定其檔案名稱和引數是類似於輸入檔案名稱及命令列引數中的`Run`對話方塊中的 Windows `Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1418">Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="7d50d-1419">因此，檔案名稱不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1419">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="7d50d-1420">它可以是任何檔案類型，其副檔名已經相關聯的系統上安裝的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1420">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="7d50d-1421">例如如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有.doc 的檔案名稱可以有副檔名為.txt。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1421">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="7d50d-1422">同樣地，在相同的方式來`Run`對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1422">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="7d50d-1423">例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1423">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="7d50d-1424">如果`fileName`參數所代表的可執行檔，`arguments`參數可能代表可以操作，例如文字檔的檔案`Notepad.exe myfile.txt`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1424">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span> <span data-ttu-id="7d50d-1425">如果`fileName`參數所代表的命令 (.cmd) 檔，`arguments`參數必須包含"`/c`「 或 」`/k`"引數來指定命令視窗是否會結束或完成之後會維持。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1425">If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a "`/c`" or "`/k`" argument to specify whether the command window exits or remains after completion.</span></span>  
  
 <span data-ttu-id="7d50d-1426">不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1426">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="7d50d-1427">當您已經建立的多載的使用<xref:System.Diagnostics.Process>執行個體，指定的啟動資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1427">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1428">使用其中一種`static`多載，當您想要建立新<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1428">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="7d50d-1429">這個多載並沒有參數的多載可讓您指定要傳遞的命令列引數與啟動的處理序資源的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1429">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.</span></span>  
  
 <span data-ttu-id="7d50d-1430">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到的任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1430">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="7d50d-1431">否則，系統將不到路徑。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1431">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="7d50d-1432">例如，如果`c:\mypath`不在您的路徑，也新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理程序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1432">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1433">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行的 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1433">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="7d50d-1434">如果您使用<xref:System.Diagnostics.Process.Start%2A>方法中的 ASP.NET Web 網頁或伺服器控制項，以限制權限在 Web 伺服器上執行新處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1434">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="7d50d-1435">處理程序不會為用戶端瀏覽器的同一內容中啟動，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1435">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="7d50d-1436">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1436">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="7d50d-1437">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1437">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-1438">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...</span><span class="sxs-lookup"><span data-stu-id="7d50d-1438">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
 <span data-ttu-id="7d50d-1439">這裡的附註中 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1439">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="7d50d-1440">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您設定您的應用程式上的執行緒模型，藉由設定屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1440">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="7d50d-1441">否則，managed 的執行緒可以在`unknown`狀態，或置於`MTA`狀態時，後者互相衝突<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1441">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="7d50d-1442">部分方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1442">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="7d50d-1443">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，且一旦設定 apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1443">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="7d50d-1444">不過，`MTA`造成作業系統 shell 來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1444">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1445">下列範例首先會繁衍 Internet Explorer 的執行個體，並在瀏覽器會顯示 [我的最愛] 資料夾的內容。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1445">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="7d50d-1446">然後會啟動 Internet Explorer 的其他執行個體，並顯示一些特定網頁或網站。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1446">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="7d50d-1447">最後它會啟動 Internet Explorer 與正在瀏覽至特定網站時的最小化視窗。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1447">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1448"><paramref name="fileName" /> 或 <paramref name="arguments" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1448">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1449">開啟關聯的檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1449">An error occurred when opening the associated file.</span></span>  
  
 <span data-ttu-id="7d50d-1450">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1450">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1451">引數長度和處理序完整路徑長度的總和超過 2080。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1451">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="7d50d-1452">與這個例外狀況相關聯的錯誤訊息可以是下列其中之一：「傳到系統呼叫的資料區域太小。」</span><span class="sxs-lookup"><span data-stu-id="7d50d-1452">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="7d50d-1453">或「拒絕存取」。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1453">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7d50d-1454">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1454">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="7d50d-1455">PATH 環境變數具有含引號的字串。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1455">The PATH environment variable has a string containing quotes.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1456">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1456">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1457">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1457">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7d50d-1458">要在處理序中執行之應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1458">The name of an application file to run in the process.</span></span></param>
        <param name="userName"><span data-ttu-id="7d50d-1459">要在啟動處理序時使用的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1459">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="7d50d-1460"><see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1460">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="7d50d-1461">要在啟動處理序時使用的網域。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1461">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="7d50d-1462">藉由指定應用程式的名稱、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1462">Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="7d50d-1463">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1463">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="7d50d-1464">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1464">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="7d50d-1465">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1465">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="7d50d-1466">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1466">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1467">您可以使用這個多載，指定其檔案名稱、 使用者名稱、 密碼和網域來建立新的程序，而且其主執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1467">Use this overload to create a new process and its primary thread by specifying its file name, user name, password, and domain.</span></span> <span data-ttu-id="7d50d-1468">新的處理序會指定可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1468">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1469">當可執行檔位於遠端的磁碟機上時，您必須使用統一資源識別元 (URI)，未連結的磁碟機代號來識別網路共用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1469">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1470">若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1470">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="7d50d-1471">這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1471">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1472">多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1472">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="7d50d-1473">同樣地，在相同的方式來**執行**對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1473">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="7d50d-1474">例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1474">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="7d50d-1475">如果`fileName`參數所代表的可執行檔，`arguments`參數可能代表可以操作，例如文字檔的檔案`Notepad.exe myfile.txt`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1475">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1476">檔案名稱必須代表在可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1476">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="7d50d-1477">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1477">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="7d50d-1478">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1478">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-1479">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...</span><span class="sxs-lookup"><span data-stu-id="7d50d-1479">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1480">下列程式碼範例將示範如何使用這個多載來啟動可執行檔，同時也會示範擲回的<xref:System.ComponentModel.Win32Exception>當嘗試啟動不可執行的檔案與相關聯的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1480">The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1481">未指定檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1481">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1482">開啟關聯檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1482">There was an error in opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7d50d-1483">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1483">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1484">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1484">Method not supported on Linux or macOS (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1485">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1485">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1486">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1486">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="7d50d-1487">要在處理序中執行之應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1487">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="7d50d-1488">啟動處理程序時要傳遞的命令列引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1488">Command-line arguments to pass when starting the process.</span></span></param>
        <param name="userName"><span data-ttu-id="7d50d-1489">要在啟動處理序時使用的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1489">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="7d50d-1490"><see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1490">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="7d50d-1491">要在啟動處理序時使用的網域。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1491">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="7d50d-1492">藉由指定應用程式的名稱、一組命令列引數、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1492">Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="7d50d-1493">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1493">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="7d50d-1494">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1494">Note that a new process that’s started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="7d50d-1495">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1495">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="7d50d-1496">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1496">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1497">您可以使用這個多載，指定其檔案名稱、 命令列引數、 使用者名稱、 密碼和網域來建立新的程序，而且其主執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1497">Use this overload to create a new process and its primary thread by specifying its file name, command-line arguments, user name, password, and domain.</span></span> <span data-ttu-id="7d50d-1498">新的處理序會指定可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1498">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1499">當可執行檔位於遠端的磁碟機上時，您必須使用統一資源識別元 (URI)，未連結的磁碟機代號來識別網路共用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1499">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1500">若要啟動之可執行檔的位址為 URL，如果未啟動處理程序和`null`傳回。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1500">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="7d50d-1501">這個多載可讓您啟動處理序沒有先建立新<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1501">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="7d50d-1502">多載是明確的步驟，建立新的替代方式<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1502">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="7d50d-1503">同樣地，在相同的方式來**執行**對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1503">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="7d50d-1504">例如，您可以設定`fileName`"Notepad.exe 」 或 「 記事本 」 的參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1504">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="7d50d-1505">如果`fileName`參數所代表的可執行檔，`arguments`參數可能代表可以操作，例如文字檔的檔案`Notepad.exe myfile.txt`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1505">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1506">檔案名稱必須代表在可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1506">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="7d50d-1507">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉或失去系統資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1507">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="7d50d-1508">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1508">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="7d50d-1509">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...</span><span class="sxs-lookup"><span data-stu-id="7d50d-1509">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1510">未指定檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1510">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1511">開啟關聯的檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1511">An error occurred when opening the associated file.</span></span>  
  
 <span data-ttu-id="7d50d-1512">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1512">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1513">引數長度和關聯檔案完整路徑長度的總和超過 2080。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1513">The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080.</span></span> <span data-ttu-id="7d50d-1514">與這個例外狀況關聯的錯誤訊息可以是下列其中之一：「傳遞到系統呼叫的資料區太小」，</span><span class="sxs-lookup"><span data-stu-id="7d50d-1514">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="7d50d-1515">或「拒絕存取」。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1515">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="7d50d-1516">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1516">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1517">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1517">Method not supported on Linux or macOS (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1518">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1518">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1519">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1519">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1520">取得或設定要傳遞給 <see cref="T:System.Diagnostics.Process" /> 之 <see cref="M:System.Diagnostics.Process.Start" /> 方法的屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1520">Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</span></span></summary>
        <value><span data-ttu-id="7d50d-1521"><see cref="T:System.Diagnostics.ProcessStartInfo" />，代表用來啟動處理序的資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1521">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that represents the data with which to start the process.</span></span> <span data-ttu-id="7d50d-1522">這些引數包括用來啟動處理序的可執行檔或文件的名稱。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1522">These arguments include the name of the executable file or document used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1523"><xref:System.Diagnostics.Process.StartInfo%2A> 表示要用來啟動處理程序的參數集。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1523"><xref:System.Diagnostics.Process.StartInfo%2A> represents the set of parameters to use to start a process.</span></span> <span data-ttu-id="7d50d-1524">當<xref:System.Diagnostics.Process.Start%2A>呼叫時，<xref:System.Diagnostics.Process.StartInfo%2A>用來指定要啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1524">When <xref:System.Diagnostics.Process.Start%2A> is called, the <xref:System.Diagnostics.Process.StartInfo%2A> is used to specify the process to start.</span></span> <span data-ttu-id="7d50d-1525">只需要<xref:System.Diagnostics.Process.StartInfo%2A>成員設定為<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1525">The only necessary <xref:System.Diagnostics.Process.StartInfo%2A> member to set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="7d50d-1526">藉由指定啟動處理序<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性是類似於輸入中的資訊**執行**對話方塊中的 Windows **啟動**功能表。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1526">Starting a process by specifying the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property is similar to typing the information in the **Run** dialog box of the Windows **Start** menu.</span></span> <span data-ttu-id="7d50d-1527">因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1527">Therefore, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="7d50d-1528">它可以是任何檔案類型，其副檔名已經相關聯的系統上安裝的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1528">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="7d50d-1529">例如<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>可以有副檔名為.txt，如果文字檔案關聯編輯器，例如 [記事本]，或者如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案可以有.doc。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1529">For example the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="7d50d-1530">同樣地，在相同的方式來**執行**對話方塊可以接受含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1530">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="7d50d-1531">例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"Notepad.exe 」 或 「 記事本 」 的屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1531">For example, you can set the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="7d50d-1532">您可以啟動 ClickOnce 應用程式設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>從中您原先安裝應用程式的位置 （例如，Web 位址） 的屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1532">You can start a ClickOnce application by setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="7d50d-1533">無法啟動 ClickOnce 應用程式藉由指定硬碟機上的安裝的位置。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1533">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="7d50d-1534">如果檔案名稱包含非執行檔，例如.doc 檔案，您可以包含指定要在檔案上採取的動作動詞命令。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1534">If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file.</span></span> <span data-ttu-id="7d50d-1535">例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>"Print"結尾.doc 副檔名的檔案。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1535">For example, you could set the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> to "Print" for a file ending in the .doc extension.</span></span> <span data-ttu-id="7d50d-1536">在指定的檔案名稱<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要有副檔名，如果您手動輸入的值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1536">The file name specified in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to have an extension if you manually enter a value for the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> property.</span></span> <span data-ttu-id="7d50d-1537">不過，如果您使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性來判斷哪些指令動詞可供使用，您必須包含副檔名。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1537">However, if you use the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property to determine what verbs are available, you must include the extension.</span></span>  
  
 <span data-ttu-id="7d50d-1538">您可以變更指定的參數<xref:System.Diagnostics.Process.StartInfo%2A>屬性最多的時間，讓您呼叫<xref:System.Diagnostics.Process.Start%2A>方法的程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1538">You can change the parameters specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property up to the time that you call the <xref:System.Diagnostics.Process.Start%2A> method on the process.</span></span> <span data-ttu-id="7d50d-1539">啟動程序之後，變更<xref:System.Diagnostics.Process.StartInfo%2A>值不影響或重新啟動相關的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1539">After you start the process, changing the <xref:System.Diagnostics.Process.StartInfo%2A> values does not affect or restart the associated process.</span></span> <span data-ttu-id="7d50d-1540">如果您呼叫<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>方法<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>屬性設定，未受`CreateProcessWithLogonW`呼叫函式，以便啟動處理程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1540">If you call the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> method with the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.</span></span>  
  
 <span data-ttu-id="7d50d-1541">如果您未使用<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理程序，<xref:System.Diagnostics.Process.StartInfo%2A>屬性並不會反映用來啟動處理序的參數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1541">If you did not use the <xref:System.Diagnostics.Process.Start%2A> method to start a process, the <xref:System.Diagnostics.Process.StartInfo%2A> property does not reflect the parameters used to start the process.</span></span> <span data-ttu-id="7d50d-1542">例如，如果您使用<xref:System.Diagnostics.Process.GetProcesses%2A>取得陣列的電腦上，執行的處理序<xref:System.Diagnostics.Process.StartInfo%2A>每個屬性<xref:System.Diagnostics.Process>不包含原始的檔案名稱或用來啟動處理序引數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1542">For example, if you use <xref:System.Diagnostics.Process.GetProcesses%2A> to get an array of processes running on the computer, the <xref:System.Diagnostics.Process.StartInfo%2A> property of each <xref:System.Diagnostics.Process> does not contain the original file name or arguments used to start the process.</span></span>  
  
 <span data-ttu-id="7d50d-1543">檔案名稱處理程序啟動時，會填入 （唯讀） 的檔案<xref:System.Diagnostics.Process.MainModule%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1543">When the process is started, the file name is the file that populates the (read-only) <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="7d50d-1544">如果您想要擷取可執行檔所關聯之處理序啟動處理程序之後，請使用<xref:System.Diagnostics.Process.MainModule%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1544">If you want to retrieve the executable file that is associated with the process after the process has started, use the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="7d50d-1545">如果您想要設定的可執行檔<xref:System.Diagnostics.Process>其相關聯的處理序尚未啟動執行個體，請使用<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1545">If you want to set the executable file of a <xref:System.Diagnostics.Process> instance for which an associated process has not been started, use the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="7d50d-1546">因為成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性是引數傳遞至<xref:System.Diagnostics.Process.Start%2A>方法的程序中，然後再變更<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性相關聯的處理序啟動後不會重設<xref:System.Diagnostics.Process.MainModule%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1546">Because the members of the <xref:System.Diagnostics.Process.StartInfo%2A> property are arguments that are passed to the <xref:System.Diagnostics.Process.Start%2A> method of a process, changing the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property after the associated process has started will not reset the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="7d50d-1547">這些屬性只能用於初始化相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1547">These properties are used only to initialize the associated process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1548">下列範例會填入<xref:System.Diagnostics.Process.StartInfo%2A>来執行的檔案，與它執行動作，以及是否應該顯示使用者介面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1548">The following example populates a <xref:System.Diagnostics.Process.StartInfo%2A> with the file to execute, the action performed on it and whether it should displays a user interface.</span></span> <span data-ttu-id="7d50d-1549">如需其他範例，請參閱屬性的參考頁面<xref:System.Diagnostics.ProcessStartInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1549">For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7d50d-1550">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1550">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1551">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1551">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1552">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1552">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1553">取得相關的處理序啟動的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1553">Gets the time that the associated process was started.</span></span></summary>
        <value><span data-ttu-id="7d50d-1554">物件，指出處理序何時啟動。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1554">An object  that indicates when the process started.</span></span> <span data-ttu-id="7d50d-1555">如果處理序並未執行，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1555">An exception is thrown if the process is not running.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1556">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1556">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1557">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.StartTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1557">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1558">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1558">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1559">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1559">The process has exited.</span></span>  
  
 <span data-ttu-id="7d50d-1560">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1560">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1561">尚未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1561">The process has not been started.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1562">呼叫 Windows 函式時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1562">An error occurred in the call to the Windows function.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1563">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1563">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1564">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1564">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1565">取得或設定物件，用以封送處理因處理序結束事件而發出的事件處理常式呼叫。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1565">Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</span></span></summary>
        <value><span data-ttu-id="7d50d-1566"><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用以封送處理因處理序上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而發出的事件處理常式呼叫。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1566">The <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> used to marshal event handler calls that are issued as a result of an <see cref="E:System.Diagnostics.Process.Exited" /> event on the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1567">當<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，處理方法<xref:System.Diagnostics.Process.Exited>系統執行緒集區的執行緒上呼叫事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1567">When <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> is `null`, methods that handle the <xref:System.Diagnostics.Process.Exited> event are called on a thread from the system thread pool.</span></span> <span data-ttu-id="7d50d-1568">如需系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1568">For more information about system thread pools, see <xref:System.Threading.ThreadPool>.</span></span>  
  
 <span data-ttu-id="7d50d-1569">當<xref:System.Diagnostics.Process.Exited>事件由 visual 的 Windows Form 元件，例如<xref:System.Windows.Forms.Button>，透過系統執行緒集區存取元件可能無法運作，或可能會導致例外狀況。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1569">When the <xref:System.Diagnostics.Process.Exited> event is handled by a visual Windows Forms component, such as a <xref:System.Windows.Forms.Button>, accessing the component through the system thread pool might not work, or might result in an exception.</span></span> <span data-ttu-id="7d50d-1570">避免這種設定<xref:System.Diagnostics.Process.SynchronizingObject%2A>給 Windows Form 元件時，會導致處理方法<xref:System.Diagnostics.Process.Exited>元件建立所在的相同執行緒上呼叫的事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1570">Avoid this by setting <xref:System.Diagnostics.Process.SynchronizingObject%2A> to a Windows Forms component, which causes the methods handling the <xref:System.Diagnostics.Process.Exited> event to be called on the same thread on which the component was created.</span></span>  
  
 <span data-ttu-id="7d50d-1571">如果<xref:System.Diagnostics.Process>內使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.Diagnostics.Process.SynchronizingObject%2A>會自動設定為包含的控制項<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1571">If the <xref:System.Diagnostics.Process> is used inside [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in a Windows Forms designer, <xref:System.Diagnostics.Process.SynchronizingObject%2A> is automatically set to the control that contains the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="7d50d-1572">例如，如果您將<xref:System.Diagnostics.Process>的設計工具上`Form1`(繼承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性<xref:System.Diagnostics.Process>設為執行個體`Form1`:</span><span class="sxs-lookup"><span data-stu-id="7d50d-1572">For example, if you place a <xref:System.Diagnostics.Process> on a designer for `Form1` (which inherits from <xref:System.Windows.Forms.Form>) the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property of <xref:System.Diagnostics.Process> is set to the instance of `Form1`:</span></span>  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 <span data-ttu-id="7d50d-1573">一般而言，這個屬性設定時元件會放置在控制項或表單，因為這些元件會繫結至特定執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1573">Typically, this property is set when the component is placed inside a control or form, because those components are bound to a specific thread.</span></span>  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1574">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1574">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1575">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1575">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1576">取得正在相關的處理序中執行的執行緒集。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1576">Gets the set of threads that are running in the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1577"><see cref="T:System.Diagnostics.ProcessThread" /> 類型的陣列，代表目前正在相關聯處理序中執行的作業系統執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1577">An array of type <see cref="T:System.Diagnostics.ProcessThread" /> representing the operating system threads currently running in the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1578">執行緒處理序中執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1578">A thread executes code in a process.</span></span> <span data-ttu-id="7d50d-1579">每個處理序會啟動與單一執行緒，其主要執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1579">Each process is started with a single thread, its primary thread.</span></span> <span data-ttu-id="7d50d-1580">任何執行緒可以建立額外的執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1580">Any thread can create additional threads.</span></span> <span data-ttu-id="7d50d-1581">執行緒處理序內共用處理序的位址空間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1581">Threads within a process share the address space of the process.</span></span>  
  
 <span data-ttu-id="7d50d-1582">使用<xref:System.Diagnostics.ProcessThread>，取得與目前的處理序相關聯的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1582">Use <xref:System.Diagnostics.ProcessThread> to get all the threads associated with the current process.</span></span> <span data-ttu-id="7d50d-1583">主執行緒不一定是索引位置為零的陣列中。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1583">The primary thread is not necessarily at index zero in the array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="7d50d-1584">處理序沒有 <see cref="P:System.Diagnostics.Process.Id" />，或沒有與 <see cref="T:System.Diagnostics.Process" /> 執行個體關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1584">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
 <span data-ttu-id="7d50d-1585">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1585">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1586">關聯處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1586">The associated process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1587">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1587">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1588">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1588">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1589">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1589">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-1590">將處理序的名稱格式化為字串，如果適用，將它和父代 (Parent) 元件類型結合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1590">Formats the process's name as a string, combined with the parent component type, if applicable.</span></span></summary>
        <returns><span data-ttu-id="7d50d-1591"><see cref="P:System.Diagnostics.Process.ProcessName" />，與基底元件的 <see cref="M:System.Object.ToString" /> 傳回值搭配相結合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1591">The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7d50d-1592">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1592">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1593">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1593">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1594">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1594">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="7d50d-1595">Windows 98 不支援 <see cref="M:System.Diagnostics.Process.ToString" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1595"><see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1596">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1596">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1597">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1597">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1598">取得這個處理序的總處理器時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1598">Gets the total processor time for this process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1599"><see cref="T:System.TimeSpan" />，表示相關聯處理序花在使用 CPU 的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1599">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent utilizing the CPU.</span></span> <span data-ttu-id="7d50d-1600">這個值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的總和。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1600">This value is the sum of the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> and the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7d50d-1601">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1601">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1602">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1602">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1603">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1603">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1604">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1604">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1605">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1605">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1606">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1606">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1607">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1607">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1608">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1608">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1609">取得這個處理序的使用者處理器時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1609">Gets the user processor time for this process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1610"><see cref="T:System.TimeSpan" />，表示相關聯處理序花在處理序的應用程式部分內 (而不是在作業系統核心內) 執行程式碼的時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1610">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent running code inside the application portion of the process (not inside the operating system core).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7d50d-1611">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1611">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1612">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1612">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1613">該範例會偵測處理序結束，並顯示處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1613">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1614">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1614">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7d50d-1615">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1615">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1616">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1616">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1617">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1617">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1618">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1618">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1619">取得處理序的虛擬記憶體的大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1619">Gets the size of the process's virtual memory, in bytes.</span></span></summary>
        <value><span data-ttu-id="7d50d-1620">虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1620">The amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1621">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1621">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1622">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1622">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1623">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1623">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1624">取得配置給關聯處理序的虛擬記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1624">Gets the amount of the virtual memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1625">配置給關聯處理序的虛擬記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1625">The amount of virtual memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1626">這個屬性所傳回的值代表目前的程序，以位元組為單位使用的虛擬記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1626">The value returned by this property represents the current size of virtual memory used by the process, in bytes.</span></span> <span data-ttu-id="7d50d-1627">作業系統會對應至載入實體記憶體中，或網頁儲存在磁碟上的虛擬記憶體分頁檔案中每個處理序的虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1627">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="7d50d-1628">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1628">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-1629">屬性值相當於**虛擬位元組**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1629">The property value is equivalent to the **Virtual Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1630">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1630">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-1631">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1631">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1632">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1632">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1633">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1633">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1634">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1634">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1635">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1635">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7d50d-1636">設定要等待相關的處理序結束的時間，並且阻止目前的執行緒執行，直到等候時間耗盡或者處理序已經結束為止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1636">Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited.</span></span> <span data-ttu-id="7d50d-1637">為避免封鎖目前的執行緒，請使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1637">To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span>  
  
 <span data-ttu-id="7d50d-1638">對於程式碼範例，請參閱 <see cref="P:System.Diagnostics.Process.StandardError" /> 與 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性參考頁面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1638">For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-1639">指示 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1639">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1640"><xref:System.Diagnostics.Process.WaitForExit> 可讓目前的執行緒等候，直到相關聯的處理序終止為止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1640"><xref:System.Diagnostics.Process.WaitForExit> makes the current thread wait until the associated process terminates.</span></span>  <span data-ttu-id="7d50d-1641">所有其他方法會呼叫的程序之後，應該要進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1641">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="7d50d-1642">為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1642">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="7d50d-1643">這個方法會指示<xref:System.Diagnostics.Process>等待時間結束的處理程序和事件處理常式無限數量的元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1643">This method instructs the <xref:System.Diagnostics.Process> component to wait an infinite amount of time for the process and event handlers to exit.</span></span> <span data-ttu-id="7d50d-1644">這會造成應用程式停止回應。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1644">This can cause an application to stop responding.</span></span> <span data-ttu-id="7d50d-1645">例如，如果您呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>程序中具有使用者介面，作業系統終止相關的處理序的要求可能不會處理程序寫入永遠不會進入其訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1645">For example, if you call <xref:System.Diagnostics.Process.CloseMainWindow%2A> for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1646">在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]及更新版本、<xref:System.Diagnostics.Process.WaitForExit>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），非無限期。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1646">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, the <xref:System.Diagnostics.Process.WaitForExit> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span> <span data-ttu-id="7d50d-1647">此外，舊版未等待事件處理常式，如果結束完整<xref:System.Int32.MaxValue>已達時間。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1647">Also, previous versions did not wait for the event handlers to exit if the full <xref:System.Int32.MaxValue> time was reached.</span></span>  
  
 <span data-ttu-id="7d50d-1648">這個多載可確保，所有處理都完成後，包括重新導向標準輸出的非同步事件處理。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1648">This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output.</span></span> <span data-ttu-id="7d50d-1649">您應該使用這個多載呼叫後<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>標準輸出已重新導向至非同步事件處理常式時，多載。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1649">You should use this overload after a call to the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload when standard output has been redirected to asynchronous event handlers.</span></span>  
  
 <span data-ttu-id="7d50d-1650">系統時相關聯的處理序結束時 （亦即，它會關閉程式透過標準或不正常終止的作業系統），儲存系統管理程序的詳細資訊，並傳回給已經呼叫元件<xref:System.Diagnostics.Process.WaitForExit>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1650">When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit>.</span></span> <span data-ttu-id="7d50d-1651"><xref:System.Diagnostics.Process>元件可以存取資訊，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>已結束的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1651">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="7d50d-1652">相關聯的處理序已結束，因為<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1652">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="7d50d-1653">相反地，控制代碼可用來存取作業系統的處理序資源相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1653">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="7d50d-1654">系統會考慮到已結束處理程序未釋放的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保存<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>資訊在記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1654">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="7d50d-1655">基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體，請呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序已終止，您不再需要任何系統管理相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1655">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="7d50d-1656"><xref:System.Diagnostics.Process.Close%2A> 釋出配置給已結束處理程序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1656"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1657">請參閱 < 備註 > 一節的<xref:System.Diagnostics.Process.StandardError%2A>屬性參考頁面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1657">See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1658">無法存取等候設定。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1658">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="7d50d-1659">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1659">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
 <span data-ttu-id="7d50d-1660">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1660">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1661">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1661">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
 <span data-ttu-id="7d50d-1662">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1662">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1663">您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.WaitForExit" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1663">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1664">這個方法僅適用於在本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1664">This method is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1665">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1665">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1666">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1666">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="7d50d-1667">等候相關的處理序結束的時間量，以毫秒計算。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1667">The amount of time, in milliseconds, to wait for the associated process to exit.</span></span> <span data-ttu-id="7d50d-1668">最大值是 32 位元整數的最大可能值，對作業系統來說，這表示無限。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1668">The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</span></span></param>
        <summary><span data-ttu-id="7d50d-1669">指示 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序結束的指定毫秒數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1669">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</span></span></summary>
        <returns>
          <span data-ttu-id="7d50d-1670">如果相關聯處理序已結束，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1670"><see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1671"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 可讓目前的執行緒等候，直到相關聯的處理序終止為止。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1671"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> makes the current thread wait until the associated process terminates.</span></span> <span data-ttu-id="7d50d-1672">所有其他方法會呼叫的程序之後，應該要進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1672">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="7d50d-1673">為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1673">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="7d50d-1674">這個方法會指示<xref:System.Diagnostics.Process>等候處理序結束的時間有限數量的元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1674">This method instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to exit.</span></span> <span data-ttu-id="7d50d-1675">如果相關聯的處理序未結束的間隔端點所終止要求遭到拒絕，因為`false`會傳回到呼叫的程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1675">If the associated process does not exit by the end of the interval because the request to terminate is denied, `false` is returned to the calling procedure.</span></span> <span data-ttu-id="7d50d-1676">您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>如`milliseconds`，和<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>行為相同<xref:System.Diagnostics.Process.WaitForExit>多載。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1676">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for `milliseconds`, and <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> will behave the same as the <xref:System.Diagnostics.Process.WaitForExit> overload.</span></span> <span data-ttu-id="7d50d-1677">如果您將 0 （零） 傳遞至方法，它會傳回`true`只有當處理序已經結束; 否則會立即傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1677">If you pass 0 (zero) to the method, it returns `true` only if the process has already exited; otherwise, it immediately returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7d50d-1678">在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和舊版中，如果`milliseconds`是-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），非無限期。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1678">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, if `milliseconds` was -1, the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span>  
  
 <span data-ttu-id="7d50d-1679">當已將標準輸出重新導向至非同步事件處理常式時，它有可能，輸出處理尚未完成此方法傳回時。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1679">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns.</span></span> <span data-ttu-id="7d50d-1680">若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>在收到後會採用任何參數的多載`true`從這個多載。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1680">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter after receiving a `true` from this overload.</span></span> <span data-ttu-id="7d50d-1681">為協助確保<xref:System.Diagnostics.Process.Exited>Windows Forms 應用程式中正確地處理事件，請將設定<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1681">To help ensure that the <xref:System.Diagnostics.Process.Exited> event is handled correctly in Windows Forms applications, set the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
 <span data-ttu-id="7d50d-1682">相關聯的處理序結束時 （已關閉作業系統，透過標準或不正常終止），系統會儲存系統管理程序的詳細資訊，並傳回給已呼叫的元件<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1682">When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>.</span></span> <span data-ttu-id="7d50d-1683"><xref:System.Diagnostics.Process>元件可以存取資訊，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>已結束的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1683">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="7d50d-1684">相關聯的處理序已結束，因為<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1684">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="7d50d-1685">相反地，控制代碼可用來存取作業系統的處理序資源相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1685">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="7d50d-1686">系統會考慮到已結束處理程序未釋放的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保存<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>資訊在記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1686">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="7d50d-1687">基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體，請呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序已終止，您不再需要任何系統管理相關資訊。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1687">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="7d50d-1688"><xref:System.Diagnostics.Process.Close%2A> 釋出配置給已結束處理程序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1688"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1689">請參閱程式碼範例，取得<xref:System.Diagnostics.Process.ExitCode%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1689">See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="7d50d-1690">無法存取等候設定。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1690">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="7d50d-1691">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1691">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
 <span data-ttu-id="7d50d-1692">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1692">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1693">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1693">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
 <span data-ttu-id="7d50d-1694">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1694">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1695">您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1695">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="7d50d-1696">這個方法僅適用於在本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1696">This method is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7d50d-1697"><paramref name="milliseconds" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1697"><paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1698">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1698">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1699">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1699">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7d50d-1700">讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1700">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7d50d-1701">讓 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1701">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state.</span></span> <span data-ttu-id="7d50d-1702">這個多載只適用於具有使用者介面和訊息迴圈的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1702">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns>
          <span data-ttu-id="7d50d-1703">如果關聯的處理序已經達到閒置狀態，則為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1703"><see langword="true" /> if the associated process has reached an idle state.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1704">使用<xref:System.Diagnostics.Process.WaitForInputIdle>強制應用程式等候，直到訊息迴圈已返回閒置狀態的處理。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1704">Use <xref:System.Diagnostics.Process.WaitForInputIdle> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="7d50d-1705">當執行使用者介面的處理序時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1705">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="7d50d-1706">在處理序再傳回至訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1706">The process then returns to the message loop.</span></span> <span data-ttu-id="7d50d-1707">處理程序即處於閒置狀態時它正在等待訊息迴圈內的訊息。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1707">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="7d50d-1708">此狀態會很有用，比方說，當您的應用程式需要等候完成建立其主視窗之前在應用程式傳送與該視窗啟動的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1708">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="7d50d-1709">如果處理程序並沒有訊息迴圈，<xref:System.Diagnostics.Process.WaitForInputIdle>會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1709">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="7d50d-1710"><xref:System.Diagnostics.Process.WaitForInputIdle>多載會指示<xref:System.Diagnostics.Process>無限期地等待處理序變成閒置訊息迴圈中的元件。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1710">The <xref:System.Diagnostics.Process.WaitForInputIdle> overload instructs the <xref:System.Diagnostics.Process> component to wait indefinitely for the process to become idle in the message loop.</span></span> <span data-ttu-id="7d50d-1711">此指示可能會導致應用程式停止回應。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1711">This instruction can cause an application to stop responding.</span></span> <span data-ttu-id="7d50d-1712">例如，如果處理程序撰寫為永遠其訊息迴圈會立即結束，如程式碼片段所示`while(true)`。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1712">For example, if the process is written to always exit its message loop immediately, as in the code fragment `while(true)`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1713">處理序沒有圖形化介面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1713">The process does not have a graphical interface.</span></span>  
  
 <span data-ttu-id="7d50d-1714">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1714">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1715">發生未知的錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1715">An unknown error occurred.</span></span> <span data-ttu-id="7d50d-1716">處理序無法進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1716">The process failed to enter an idle state.</span></span>  
  
 <span data-ttu-id="7d50d-1717">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1717">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1718">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1718">The process has already exited.</span></span>  
  
 <span data-ttu-id="7d50d-1719">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1719">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1720">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1720">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1721">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1721">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1722">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1722">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="7d50d-1723">1 到 <see cref="F:System.Int32.MaxValue" /> 的值，指定等候相關聯處理序變成閒置的時間 (毫秒)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1723">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle.</span></span> <span data-ttu-id="7d50d-1724">值為 0 時，指定立即傳回，而值為 -1 時則指定無限期等候。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1724">A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="7d50d-1725">讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態的指定毫秒數。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1725">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state.</span></span> <span data-ttu-id="7d50d-1726">這個多載只適用於具有使用者介面和訊息迴圈的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1726">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns>
          <span data-ttu-id="7d50d-1727">如果相關的處理序已經達到閒置狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1727"><see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1728">使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>強制應用程式等候，直到訊息迴圈已返回閒置狀態的處理。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1728">Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="7d50d-1729">當執行使用者介面的處理序時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1729">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="7d50d-1730">在處理序再傳回至訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1730">The process then returns to the message loop.</span></span> <span data-ttu-id="7d50d-1731">處理程序即處於閒置狀態時它正在等待訊息迴圈內的訊息。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1731">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="7d50d-1732">此狀態會很有用，比方說，當您的應用程式需要等候完成建立其主視窗之前在應用程式傳送與該視窗啟動的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1732">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="7d50d-1733">如果處理程序並沒有訊息迴圈，<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1733">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="7d50d-1734"><xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>多載會指示<xref:System.Diagnostics.Process>元件等候在有限的一段時間閒置訊息迴圈中處理程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1734">The <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> overload instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to become idle in the message loop.</span></span> <span data-ttu-id="7d50d-1735">相關聯的處理序已不變成閒置狀態時的時間間隔結束迴圈仍在處理訊息，因為`false`會傳回到呼叫的程序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1735">If the associated process has not become idle by the end of the interval because the loop is still processing messages, `false` is returned to the calling procedure.</span></span>  
  
 <span data-ttu-id="7d50d-1736">如需處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1736">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="7d50d-1737">處理序沒有圖形化介面。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1737">The process does not have a graphical interface.</span></span>  
  
 <span data-ttu-id="7d50d-1738">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1738">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1739">發生未知的錯誤。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1739">An unknown error occurred.</span></span> <span data-ttu-id="7d50d-1740">處理序無法進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1740">The process failed to enter an idle state.</span></span>  
  
 <span data-ttu-id="7d50d-1741">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1741">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1742">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1742">The process has already exited.</span></span>  
  
 <span data-ttu-id="7d50d-1743">-或-</span><span class="sxs-lookup"><span data-stu-id="7d50d-1743">-or-</span></span>  
  
 <span data-ttu-id="7d50d-1744">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1744">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1745">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1745">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1746">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1746">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1747">取得相關處理序的實體記憶體使用量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1747">Gets the associated process's physical memory usage, in bytes.</span></span></summary>
        <value><span data-ttu-id="7d50d-1748">相關的處理序正在使用的實體記憶體的總量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1748">The total amount of physical memory the associated process is using, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1749">這個屬性所傳回的值代表目前的工作集記憶體使用此程序，以位元組為單位的大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1749">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="7d50d-1750">處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1750">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="7d50d-1751">這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1751">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="7d50d-1752">工作集包括共用和私用資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1752">The working set includes both shared and private data.</span></span> <span data-ttu-id="7d50d-1753">共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1753">The shared data includes the pages that contain all the instructions that the process executes, including the process modules and the system libraries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1754">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1754">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="7d50d-1755">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1755">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1756">該範例會偵測處理序結束，並顯示指定的處理序結束代碼。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1756">The example detects when the process exits, and displays the process' exit code.</span></span>  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1757">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1757">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1758">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1758">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1759">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1759">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7d50d-1760">取得配置給關聯處理序的實體記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1760">Gets the amount of physical memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="7d50d-1761">配置給關聯處理序的實體記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1761">The amount of physical memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7d50d-1762">這個屬性所傳回的值代表目前的工作集記憶體使用此程序，以位元組為單位的大小。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1762">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="7d50d-1763">處理程序的工作集是實體 RAM 記憶體中的目前可見程序的記憶體分頁的集合。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1763">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="7d50d-1764">這些頁面是常駐的而且可供使用，而不會觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1764">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="7d50d-1765">工作集包括共用和私用資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1765">The working set includes both shared and private data.</span></span> <span data-ttu-id="7d50d-1766">共用的資料包含頁面包含所有處理序執行，包括指示處理序模組和系統程式庫中的指示。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1766">The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="7d50d-1767">這個屬性可以用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1767">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="7d50d-1768">屬性值相當於**工作組**處理序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1768">The property value is equivalent to the **Working Set** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7d50d-1769">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1769">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="7d50d-1770">此範例會擷取並顯示各種內容相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1770">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="7d50d-1771">該範例會偵測處理序結束，並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1771">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="7d50d-1772">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1772">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="7d50d-1773">針對完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1773">for full trust for the immediate caller.</span></span> <span data-ttu-id="7d50d-1774">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="7d50d-1774">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>