<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="679f97dd2feb4951d29bb5743d495fed37342b87" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56369963" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供對本機和遠端處理序的存取，並讓您能夠啟動和停止本機系統處理序。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>元件提供存取權的電腦執行的處理程序。 處理序，最簡單的說，是執行中應用程式。 執行緒是作業系統會配置處理器時間的基本單位。 執行緒可以執行此程序，包括部分由另一個執行緒目前正在執行的程式任何的碼部分。  
  
 <xref:System.Diagnostics.Process>元件是一個有用的工具來啟動、 停止、 控制和監視應用程式。 您可以使用<xref:System.Diagnostics.Process>元件，以取得正在執行的處理程序的清單，或者您可以啟動新的處理序。 A<xref:System.Diagnostics.Process>元件用來存取系統處理序。 之後<xref:System.Diagnostics.Process>元件已經初始化，它可以用來取得執行程序的相關資訊。 這類資訊包括的執行緒，載入的模組 （.dll 和.exe 檔案），並使用效能資訊，例如處理程序的記憶體數量。  
  
 此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `finally`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
> [!NOTE]
>  32 位元處理序無法存取 64 位元處理序的模組。 如果您嘗試從 32 位元處理序取得 64 位元處理程序的相關資訊，您會收到<xref:System.ComponentModel.Win32Exception>例外狀況。 相反地，64 位元處理程序，可以存取 32 位元處理序的模組。  
  
 處理序元件會取得一組屬性的相關資訊全部一次。 在後<xref:System.Diagnostics.Process>元件已取得的任何群組的一個成員的相關資訊，它會快取該群組中的其他屬性的值，並無法取得群組的其他成員相關的新資訊，直到您呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。 因此，如果屬性值不保證能夠比上次呼叫任何新<xref:System.Diagnostics.Process.Refresh%2A>方法。 群組之細項具有作業系統相依性。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。 否則，系統將無法找到路徑。 例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。  
  
 系統處理序是以唯一識別系統上處理序識別碼。 就像許多 Windows 資源，其控制代碼，可能不是唯一的電腦上也會識別處理程序。 控制代碼是資源的泛型的詞彙，識別項。 作業系統仍然存在處理序控制代碼，可透過<xref:System.Diagnostics.Process.Handle%2A>屬性<xref:System.Diagnostics.Process>元件，即使在處理序已結束。 因此，您可以取得處理程序的系統管理資訊，例如<xref:System.Diagnostics.Process.ExitCode%2A>（通常是零的成功或非零的錯誤碼） 和<xref:System.Diagnostics.Process.ExitTime%2A>。 控制代碼會是非常重要的資源，所以遺漏控制更 virulent 比流失記憶體。  
  
> [!NOTE]
>  這個類別包含的連結要求和繼承要求套用到所有成員的類別層級。 A<xref:System.Security.SecurityException>立即呼叫端或衍生的類別不具有完全信任權限時，會擲回。 如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)。  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] 附註  
 在.NET Framework 中，<xref:System.Diagnostics.Process>預設使用的類別<xref:System.Console>編碼方式，通常是程式碼頁的編碼方式，輸入、 輸出和錯誤資料流。 取得範例程式碼，在系統上文化特性是英文 （美國），字碼頁 437 則是預設編碼方式<xref:System.Console>類別。 不過，[!INCLUDE[net_core](~/includes/net-core-md.md)]可以提供可用的只有這些編碼方式的有限的子集。 如果發生這種情況，它會使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>做為預設的編碼方式。  
  
 如果<xref:System.Diagnostics.Process>物件相依於特定字碼頁編碼方式，您仍然可以在它們可執行下列作業*之前*呼叫任何<xref:System.Diagnostics.Process>方法：  
  
1.  您可以將 System.Text.Encoding.CodePages.dll 組件的參考加入專案。  
  
2.  擷取<xref:System.Text.EncodingProvider>物件從<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>屬性。  
  
3.  傳遞<xref:System.Text.EncodingProvider>物件至<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>進行編碼的提供者所支援的其他編碼的方法。  
  
 <xref:System.Diagnostics.Process>類別會再自動使用預設系統編碼方式 」，而不 UTF8，前提是您註冊編碼提供者之前呼叫任何<xref:System.Diagnostics.Process>方法。  
  
   
  
## Examples  
 下列範例使用的執行個體<xref:System.Diagnostics.Process>類別來啟動處理序。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 下列範例會使用<xref:System.Diagnostics.Process>類別本身和靜態<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理程序。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 下列F#範例會定義`runProc`啟動的處理序的函式會擷取所有輸出和錯誤的資訊，並記錄的程序執行的毫秒數。  `runProc`函式有三個參數： 若要啟動，引數提供給應用程式，並起始目錄的應用程式的名稱。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 程式碼`runProc`函式由撰寫[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)而且經過[Microsoft 公用授權](https://opensource.org/licenses/ms-pl)。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個類別不能由部分信任的程式碼。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">針對繼承者完全信任。 這個類別無法繼承由部分信任的程式碼。</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">使用.NET Process 類別</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.Process" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未指定<xref:System.Diagnostics.Process.MachineName%2A>屬性，預設值為本機電腦 ("。")。  
  
 您有兩個選項可建立新的關聯<xref:System.Diagnostics.Process>元件之電腦上的處理序。 第一個選項是使用建構函式來建立<xref:System.Diagnostics.Process>元件，設定的適當成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性並呼叫<xref:System.Diagnostics.Process.Start%2A>關聯<xref:System.Diagnostics.Process>與新的系統處理序。 第二個選項是將建立關聯<xref:System.Diagnostics.Process>執行的系統程序，利用<xref:System.Diagnostics.Process.GetProcessById%2A>或其中一個<xref:System.Diagnostics.Process.GetProcesses%2A>傳回值。  
  
 如果您使用`static`多載<xref:System.Diagnostics.Process.Start%2A>方法來啟動新的系統處理序方法建立新<xref:System.Diagnostics.Process>元件，並產生關聯的處理程序。  
  
 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>屬性設定為其預設值`true`，您可以使用類似的方式啟動應用程式和文件`Run`對話方塊中的 Windows`Start`功能表。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>是`false`，您可以開始只可執行檔。  
  
 您可以從命令列呼叫任何可執行檔可以啟動兩種方式之一： 藉由設定適當的成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>方法使用任何參數，或藉由傳遞至適當的參數`static` <xref:System.Diagnostics.Process.Start%2A>成員。  
  
 您可以建立<xref:System.Diagnostics.Process>元件所使用的建構函式，其中一個靜態<xref:System.Diagnostics.Process.Start%2A>多載，或任何<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcesses%2A>，或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 完成此動作之後，您會有相關聯的處理序的檢視。 這不是在記憶體中處理序屬性變更時自動更新本身的動態檢視。 相反地，您必須呼叫<xref:System.Diagnostics.Process.Refresh%2A>更新元件<xref:System.Diagnostics.Process>應用程式中的屬性資訊。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的基礎優先權 (Base Priority)。</summary>
        <value>基礎優先權，它是從相關聯處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 計算出來的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A>程序是針對相關聯的處理序中建立的執行緒開始的優先順序。 您可以檢視的基底的優先順序，透過 「 系統監視器的優先權基底計數器的相關資訊。  
  
 根據 24 小時制或其他的增加，作業系統可以變更的基底的優先順序，當處理程序應該放置領先其他人的時間。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視指派給處理程序的起始優先權。 不過，因為它是唯讀的您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>設定程序的優先順序。 若要變更的優先順序，使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性。 <xref:System.Diagnostics.Process.BasePriority%2A>就可以使用 「 系統監視器，而<xref:System.Diagnostics.Process.PriorityClass%2A>不是。 同時<xref:System.Diagnostics.Process.BasePriority%2A>而<xref:System.Diagnostics.Process.PriorityClass%2A>可以以程式設計方式檢視。 下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>值和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設為 <see langword="false" /> 以存取 Windows 98 和 Windows me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">處理序已經結束。  
  
-或- 
處理序尚未啟動，因此沒有處理序 ID。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上開始非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A>可以讀取資料流，同步或非同步。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的錯誤輸出資料流同步讀取的作業。 這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。 這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。  
  
 請遵循下列步驟來執行非同步讀取的操作<xref:System.Diagnostics.Process.StandardError%2A>針對<xref:System.Diagnostics.Process>:  
  
1.  請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。  
  
2.  請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 為 `true`。  
  
3.  新增您的事件處理常式來<xref:System.Diagnostics.Process.ErrorDataReceived>事件。 事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。  
  
4.  啟動<xref:System.Diagnostics.Process>。  
  
5.  呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>針對<xref:System.Diagnostics.Process>。 在此呼叫會啟動的非同步讀取的作業<xref:System.Diagnostics.Process.StandardError%2A>。  
  
 當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>寫入一行文字到其<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 您可以取消非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>。 您可以取消讀取的作業，由呼叫端或事件處理常式。 之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>一次，繼續非同步讀取的作業。  
  
> [!NOTE]
>  您不能混用重新導向的資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，或反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
   
  
## Examples  
 下列範例會使用`net view`命令來列出可用的網路資源，在遠端電腦上。 使用者所提供的目標電腦名稱做為命令列引數。 使用者也可以提供錯誤輸出的檔案名稱。 此範例會收集的 net 命令、 等候處理序完成，然後再寫入至主控台的輸出結果的輸出。 如果使用者所提供的選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性為 <see langword="false" />。  
  
-或- 
非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上進行。  
  
-或- 
同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上開始非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A>可以讀取資料流，同步或非同步。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流同步讀取的作業。 這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 這個方法可讓資料流輸出指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。  
  
 請遵循下列步驟來執行非同步讀取的操作<xref:System.Diagnostics.Process.StandardOutput%2A>針對<xref:System.Diagnostics.Process>:  
  
1.  請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。  
  
2.  請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 為 `true`。  
  
3.  新增您的事件處理常式來<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。  
  
4.  啟動<xref:System.Diagnostics.Process>。  
  
5.  呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>針對<xref:System.Diagnostics.Process>。 在此呼叫會啟動的非同步讀取的作業<xref:System.Diagnostics.Process.StandardOutput%2A>。  
  
 當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>寫入一行文字到其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
 您可以取消非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>。 您可以取消讀取的作業，由呼叫端或事件處理常式。 之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>一次，繼續非同步讀取的作業。  
  
> [!NOTE]
>  您不能混用重新導向的資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，或反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
   
  
## Examples  
 下列範例說明如何執行非同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>的資料流`sort`命令。 `sort`命令是主控台應用程式讀取及排序文字輸入。  
  
 此範例會建立事件的委派`SortOutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件處理常式收到文字行的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將文字寫入至螢幕。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 屬性為 <see langword="false" />。  
  
-或- 
非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上進行。  
  
-或- 
同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上取消非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardError%2A>資料流。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 結束非同步讀取作業。  
  
 之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>一次。  
  
 當您呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>，則所有進行中讀取作業的<xref:System.Diagnostics.Process.StandardError%2A>完成，則會停用事件處理常式。 所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardError%2A>都將遺失。 如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、 非同步讀取作業繼續。 如果您想要變更的事件處理常式，再繼續非同步讀取的作業，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  您不能混合非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。 如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>，然後從資料流讀取一次，您必須使用需要<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>繼續非同步讀取的作業。 請勿遵循<xref:System.Diagnostics.Process.CancelErrorRead%2A>同步呼叫讀取方法<xref:System.Diagnostics.Process.StandardError%2A>這類<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下列範例會啟動`nmake`命令與使用者提供的引數。 以非同步的方式; 讀取的錯誤和輸出資料流收集到的文字行會顯示到主控台，以及寫入記錄檔。 如果命令輸出超過指定的行數，則會取消非同步讀取的作業。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上取消非同步讀取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 結束非同步讀取作業。  
  
 之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>一次。  
  
 當您呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>，則所有進行中讀取作業的<xref:System.Diagnostics.Process.StandardOutput%2A>完成，則會停用事件處理常式。 所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardOutput%2A>會儲存在緩衝區中。 如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、 已儲存的輸出會傳送至事件處理常式和非同步讀取的作業繼續。 如果您想要變更的事件處理常式，再繼續非同步讀取的作業，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  您不能混合非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。 如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>，然後從資料流讀取一次，您必須使用需要<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>繼續非同步讀取的作業。 請勿遵循<xref:System.Diagnostics.Process.CancelOutputRead%2A>同步呼叫讀取方法<xref:System.Diagnostics.Process.StandardOutput%2A>這類<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下列範例會啟動`nmake`命令與使用者提供的引數。 以非同步的方式; 讀取的錯誤和輸出資料流收集到的文字行會顯示到主控台，以及寫入記錄檔。 如果命令輸出超過指定的行數，則會取消非同步讀取的作業。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放與這個元件相關的所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A>方法會導致處理序停止等候結束等候它，如果關閉處理序控制代碼，而且清除處理序專屬的屬性。 <xref:System.Diagnostics.Process.Close%2A> 不會關閉標準輸出、 輸入和錯誤的讀取器和寫入器，以防它們外部參考。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> 方法呼叫 <xref:System.Diagnostics.Process.Close%2A>。 放置<xref:System.Diagnostics.Process>中的物件`using`區塊處置的資源，而不需要呼叫<xref:System.Diagnostics.Process.Close%2A>。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 秒的間隔，最多 10 秒。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，範例就會關閉程序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉有使用者介面的處理序，方法是傳送關閉訊息至其主視窗。</summary>
        <returns>如果已成功傳送關閉訊息，則為 <see langword="true" />；如果相關聯處理序沒有主視窗或主視窗已停用 (例如，如果正在顯示強制回應對話方塊)，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當處理程序執行時，其訊息迴圈就會處於等候狀態。 每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。 呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>傳送要求以接近主視窗中，這在格式正確的應用程式中，關閉子視窗，並撤銷應用程式的所有執行訊息迴圈。 結束藉由呼叫的程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。 應用程式可以要求使用者確認之前結束，或者它可以拒絕結束。 若要強制應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗中使用 [系統] 功能表的使用者。 因此，藉由關閉主視窗結束程序要求不會強制應用程式立即結束。  
  
 編輯程序的資料或資源配置給處理程序不會遺失您呼叫<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 會造成異常的程序終止時，而且應該在必要時才使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此很適合使用介面的應用程式。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。 <xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。  
  
 您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。 您無法使處理序結束的遠端電腦上。 您只能檢視在遠端電腦上執行的程序資訊。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 10 秒，最多達 2 秒的間隔。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，範例就會關閉程序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設為 <see langword="false" /> 以存取 Windows 98 和 Windows me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">處理程序已經結束。  
  
-或- 
沒有和這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放這個處理序使用的所有資源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定是否應該在處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <value>如果應該在相關聯處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件 (經由結束或呼叫 <see cref="M:System.Diagnostics.Process.Kill" />)，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。 請注意，<see cref="E:System.Diagnostics.Process.Exited" />就會引發事件，即使的值<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />是<see langword="false" />期間的處理序結束時，或使用者執行前<see cref="P:System.Diagnostics.Process.HasExited" />檢查。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性表示作業系統已關閉程序時，是否應該收到通知的元件。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性來通知您的處理序已結束的應用程式時，會在非同步處理。 若要強制您的應用程式來同步等候結束事件 （會中斷應用程式的處理，直到結束事件已發生），使用<xref:System.Diagnostics.Process.WaitForExit%2A>方法。

> [!NOTE]
> 如果您使用 Visual Studio，然後按兩下<xref:System.Diagnostics.Process>元件在專案中，<xref:System.Diagnostics.Process.Exited>事件委派和事件處理常式會自動產生。 額外的程式碼集<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性設`false`。 您必須變更此屬性為`true`相關聯的處理序結束時，要執行事件處理常式。

如果元件<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>值是`true`，或當<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`false`和<xref:System.Diagnostics.Process.HasExited%2A>檢查會叫用元件，元件可以存取相關聯的處理程序會維持系統管理資訊由作業系統所儲存。 這類資訊包括<xref:System.Diagnostics.Process.ExitTime%2A>而<xref:System.Diagnostics.Process.ExitCode%2A>。

相關聯的處理序結束之後，<xref:System.Diagnostics.Process.Handle%2A>的元件不會再指向現有的處理序資源。 相反地，它只可用來存取的處理序資源相關的作業系統的資訊。 作業系統是感知有未發行的結束處理程序的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>在記憶體中的資訊。

沒有相關聯的處理序結束監看的成本。 如果<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>已`true`，則<xref:System.Diagnostics.Process.Exited>相關聯的處理序終止時，會引發事件。 您的程序<xref:System.Diagnostics.Process.Exited>在該時間執行的事件。

有時候，您的應用程式啟動的處理序，但不需要其 closure 的通知。 例如，您的應用程式可以啟動 [記事本]，以允許使用者執行的文字編輯，但沒有進一步讓使用 「 記事本 」 應用程式。 您可以選擇以避免處理序結束，因為它不是與您的應用程式的持續運作時的通知。 設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>至`false`可以節省系統資源。

## Examples  
下列程式碼範例會建立會列印檔案的程序。 它會設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性，讓處理程序引發<xref:System.Diagnostics.Process.Exited>結束時的事件。 <xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟用目前執行緒上的原生屬性 <see langword="SeDebugPrivilege" />，將 <see cref="T:System.Diagnostics.Process" /> 元件置於某種狀態，以便與使用特殊模式執行的作業系統處理序互動。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些作業系統處理程序以特殊模式執行。 嘗試讀取的屬性，或附加至這些處理序不能除非您呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。 呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取權以特殊模式執行這些程序。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於應用程式寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived>事件可讓您表示相關聯的處理序已經寫入至其重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 事件只發生在非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>。 若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardError%2A>的資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式，來<xref:System.Diagnostics.Process.ErrorDataReceived>事件，並呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 之後，<xref:System.Diagnostics.Process.ErrorDataReceived>事件訊號處理程序會將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardError%2A>串流處理，直到處理程序結束或呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>。  
  
> [!NOTE]
>  正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit>方法，以確保已排清輸出緩衝區。 請注意，使用該指定逾時<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>多載未*不*確保已排清輸出緩衝區。
  
   
  
## Examples  
 下列範例會使用`net view`命令來列出可用的網路資源，在遠端電腦上。 使用者所提供的目標電腦名稱做為命令列引數。 使用者也可以提供錯誤輸出的檔案名稱。 此範例會收集的 net 命令、 等候處理序完成，然後再寫入至主控台的輸出結果的輸出。 如果使用者所提供的選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序終止時指定的值。</summary>
        <value>相關處理序終止時指定的程式碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.ExitCode%2A>來取得系統處理序會傳回它結束時的狀態。 您可以使用結束代碼更像是整數傳回的值從`main()`程序。  
  
 <xref:System.Diagnostics.Process.ExitCode%2A>處理程序會反映該處理程序的應用程式開發人員所實作的特定慣例的值。 如果您使用的結束代碼值在您的程式碼中進行決策時，務必知道您的應用程式處理序所使用的結束程式碼慣例。  
  
 開發人員通常會表示成功結束<xref:System.Diagnostics.Process.ExitCode%2A>值所呼叫的方法可用來找出異常的處理序終止原因的非零值零，且指定的錯誤。 您不需要遵循下列指導方針，但它們是慣例。  
  
 如果您嘗試取得<xref:System.Diagnostics.Process.ExitCode%2A>處理序已結束之前，嘗試就會擲回例外狀況。 檢查<xref:System.Diagnostics.Process.HasExited%2A>; 屬性第一次，確認是否已終止相關聯的處理序。  
  
> [!NOTE]
>  當非同步事件處理常式已重新導向標準輸出時，有可能，輸出處理尚未完成的時機<xref:System.Diagnostics.Process.HasExited%2A>傳回`true`。 若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前接受任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。  
  
 您可以使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>方法，讓相關聯的處理序結束。  
  
 有兩種方式的相關聯的處理序結束時所通知： 同步和非同步的方式。 同步通知依賴呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以暫停您的應用程式的處理，直到相關聯的元件會結束。 非同步通知依賴<xref:System.Diagnostics.Process.Exited>事件。 使用非同步通知時<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`如<xref:System.Diagnostics.Process>元件來接收通知的處理序已結束。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">遠端處理序尚未結束。  
  
-或- 
處理序 <see cref="P:System.Diagnostics.Process.Handle" /> 無法使用。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於處理序結束時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited>事件表示相關聯的處理序已結束。 此項目表示程序結束 （中止） 或成功關閉。 只有當，就會發生此事件的值<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性是`true`。  
  
 有兩種方式的相關聯的處理序結束時所通知： 同步和非同步的方式。 同步通知表示呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來封鎖目前的執行緒，直到處理序結束為止。 使用非同步通知<xref:System.Diagnostics.Process.Exited>事件，可讓呼叫執行緒能夠繼續在同時執行。 在後者的情況下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`呼叫的應用程式接收訊號事件。  
  
 當作業系統關機程序時，它會通知所有其他已註冊的訊號事件處理常式的處理序。 此時，只要結束處理程序的控制代碼可用來存取某些屬性，例如<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.HasExited%2A>作業系統會維護，直到它完全釋放該控制代碼。  
  
> [!NOTE]
>  即使您有結束的處理程序的控制代碼，您不能呼叫<xref:System.Diagnostics.Process.Start%2A>，重新連線至相同的程序。 呼叫<xref:System.Diagnostics.Process.Start%2A>自動釋放相關聯的處理序，並連線到處理序中，使用相同的檔案，但全新<xref:System.Diagnostics.Process.Handle%2A>。  
  
 如需使用詳細資訊<xref:System.Diagnostics.Process.Exited>事件，在 Windows Forms 應用程式，請參閱<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例會建立會列印檔案的程序。 它會引發<xref:System.Diagnostics.Process.Exited>事件的處理序結束，因為時<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>建立程序時，已設定屬性。 <xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關的處理序結束的時間。</summary>
        <value><see cref="T:System.DateTime" />，表示相關聯處理序何時終止。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果還沒有終止程序，嘗試擷取<xref:System.Diagnostics.Process.ExitTime%2A>屬性會擲回的例外狀況。 使用<xref:System.Diagnostics.Process.HasExited%2A>才能<xref:System.Diagnostics.Process.ExitTime%2A>屬性來判斷是否已終止相關聯的處理序。  
  
   
  
## Examples  
 下列程式碼範例會建立會列印檔案的程序。 處理程序會引發<xref:System.Diagnostics.Process.Exited>時結束時，事件和事件處理常式顯示<xref:System.Diagnostics.Process.ExitTime%2A>屬性和其他處理資訊。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與目前現用處理序相關聯。</summary>
        <returns>新的 <see cref="T:System.Diagnostics.Process" /> 元件，與正在執行呼叫應用程式的處理序資源相關聯。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新<xref:System.Diagnostics.Process>執行個體，並將它與本機電腦上的處理序資源關聯。  
  
 例如，類似<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcessesByName%2A>，和<xref:System.Diagnostics.Process.GetProcesses%2A>方法，<xref:System.Diagnostics.Process.GetCurrentProcess%2A>將現有的資源與新<xref:System.Diagnostics.Process>元件。  
  
   
  
## Examples  
 下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。 然後，它會擷取相同的處理程序在遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與您指定的現有處理序資源相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">處理序資源的系統唯一識別項。</param>
        <summary>傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定本機電腦上的處理序識別項。</summary>
        <returns><see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的本機處理序資源相關聯。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新<xref:System.Diagnostics.Process>元件和其關聯處理序資源在本機電腦上。 處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>不會建立系統資源，但而不是建立與應用程式所產生的關聯資源<xref:System.Diagnostics.Process>元件。 處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理程序。 在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>擲回例外狀況，如果傳遞的過期的識別項。  
  
 在任何特定的電腦上的處理程序的識別碼是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多會傳回其中一個處理序。 如果您想要取得執行特定的應用程式，使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果執行指定的應用程式的電腦上的多個處理序存在<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，包含所有相關聯的處理序。 您可以查詢每個這些處理序的識別碼。 您可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員 」 中。 `PID`資料行會顯示指派給處理程序的處理序識別碼。  
  
 `processId`參數是<xref:System.Int32>（32 位元帶正負號的整數），雖然基礎的 Windows API 使用`DWORD`（帶正負號的 32 位元整數） 類似的 api。 這是基於歷程原因。
  
## Examples  
 下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。 然後，它會擷取相同的處理程序在遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> 參數指定的處理序未執行。 識別項可能過期。</exception>
        <exception cref="T:System.InvalidOperationException">這個物件未啟動處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">處理序資源的系統唯一識別項。</param>
        <param name="machineName">網路上的電腦名稱。</param>
        <summary>傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定網路上電腦的處理序識別項和名稱。</summary>
        <returns><see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的遠端處理序資源相關聯。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新<xref:System.Diagnostics.Process>元件和其關聯處理序資源在網路上的遠端電腦上。 處理序資源必須已經存在於指定的電腦，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>不會建立系統資源，但而不是建立與應用程式所產生的關聯資源<xref:System.Diagnostics.Process>元件。 處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理程序。 在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>擲回例外狀況，如果傳遞的過期的識別項。  
  
 在任何特定的電腦上的處理程序的識別碼是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多會傳回其中一個處理序。 如果您想要取得執行特定的應用程式，使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果執行指定的應用程式的電腦上的多個處理序存在<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，包含所有相關聯的處理序。 您可以查詢每個這些處理序的識別碼。 您可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員 」 中。 `PID`資料行會顯示指派給處理程序的處理序識別碼。  
  
 如果您未指定`machineName`，會使用本機電腦。 或者，您可以指定本機電腦，藉由設定`machineName`值"。"或空字串 ("")。  
  
 `processId`參數是<xref:System.Int32>（32 位元帶正負號的整數），雖然基礎的 Windows API 使用`DWORD`（帶正負號的 32 位元整數） 類似的 api。 這是基於歷程原因。   
  
## Examples  
 下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。 然後，它會擷取相同的處理程序在遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> 參數指定的處理序未執行。 識別項可能過期。  
  
-或- 
<paramref name="machineName" /> 參數的語法無效。 其長度有可能為零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">這個物件未啟動處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與現有的處理序資源相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為本機電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</summary>
        <returns><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在本機電腦上執行的所有處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將其與本機電腦上的所有處理序資源關聯。 處理序資源必須已存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>不會建立系統資源，但而是將資源與產生的應用程式相關聯<xref:System.Diagnostics.Process>元件。 因為作業系統本身會執行背景處理程序，這個陣列不會是空的。  
  
 如果您不想要擷取所有電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>元件，您傳遞給方法的處理序識別碼所識別的系統上的程序與相關聯。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。  
  
> [!NOTE]
>  多個 Windows 服務可以載入相同的執行個體，服務主機處理序 (svchost.exe)。 GetProcesses 不會識別這些個別的服務;為此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。 然後，它會擷取相同的處理程序在遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">要讀取處理序清單的電腦。</param>
        <summary>為指定電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</summary>
        <returns><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在指定的電腦上執行的所有處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將它們指定 （通常是遠端） 電腦上的所有處理序資源關聯。 處理序資源必須已存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>不會建立系統資源，但而是將資源與產生的應用程式相關聯<xref:System.Diagnostics.Process>元件。 因為作業系統本身會執行背景處理程序，這個陣列不會是空的。  
  
 如果您不想要擷取所有電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>元件，您傳遞給方法的處理序識別碼所識別的系統上的程序與相關聯。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。  
  
 這個多載<xref:System.Diagnostics.Process.GetProcesses%2A>方法通常用來擷取在網路上的遠端電腦上執行的處理序資源的清單，但是您可以指定本機電腦，藉由傳遞 」。 」。  
  
> [!NOTE]
>  多個 Windows 服務可以載入相同的執行個體，服務主機處理序 (svchost.exe)。 GetProcesses 不會識別這些個別的服務;為此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。 然後，它會擷取相同的處理程序在遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 參數的語法無效。 其長度有可能為零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">作業系統平台不支援遠端電腦上的這項作業。</exception>
        <exception cref="T:System.InvalidOperationException">存取 API 用來取得處理序資訊的效能計數器時發生問題。 此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取基礎系統 API 時發生問題。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與所有共用指定處理序名稱的現有處理序資源相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">處理序的易記名稱。</param>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與本機電腦上共用指定處理序名稱的所有處理序資源相關聯。</summary>
        <returns><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將它們正在執行相同的可執行檔，在本機電腦上的所有處理序資源關聯。 處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>不會建立系統資源，但而是將它們與應用程式產生關聯<xref:System.Diagnostics.Process>元件。 A`processName`可以指定為目前未執行的本機電腦，所以此方法會傳回陣列可以是空的可執行檔。  
  
 處理序名稱是處理程序，例如 Outlook、.exe 副檔名或路徑不包含的易記名稱。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。 比方說，您可以傳遞可執行檔名稱做為`processName`參數，以便關閉該可執行檔的所有執行的執行個體。  
  
 雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，包含所有相關聯的處理序。 如果您要管理使用標準 API 呼叫的程序，您可以查詢每個這些處理序的識別碼。 透過單獨的處理序名稱，但，一旦您已擷取的陣列，您無法存取處理序資源<xref:System.Diagnostics.Process>相關聯的元件與處理序資源中，啟動、 終止，及操作的系統資源。  
  
   
  
## Examples  
 下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。 然後，它會擷取相同的處理程序在遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">存取 API 用來取得處理序資訊的效能計數器時發生問題。 此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">處理序的易記名稱。</param>
        <param name="machineName">網路上的電腦名稱。</param>
        <summary>建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與遠端電腦上共用指定處理序名稱的所有處理序資源相關聯。</summary>
        <returns><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將它們正在執行相同的可執行檔，指定的電腦上的所有處理序資源關聯。 處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>不會建立系統資源，但而是將它們與應用程式產生關聯<xref:System.Diagnostics.Process>元件。 A`processName`可以指定為目前未執行的本機電腦，所以此方法會傳回陣列可以是空的可執行檔。  
  
 處理序名稱是處理程序，例如 Outlook、.exe 副檔名或路徑不包含的易記名稱。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。 比方說，您可以傳遞可執行檔名稱做為`processName`參數，以便關閉該可執行檔的所有執行的執行個體。  
  
 雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。 因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，包含所有相關聯的處理序。 如果您要管理使用標準 API 呼叫的程序，您可以查詢每個這些處理序的識別碼。 透過單獨的處理序名稱，但，一旦您已擷取的陣列，您無法存取處理序資源<xref:System.Diagnostics.Process>相關聯的元件與處理序資源中，啟動、 終止，及操作的系統資源。  
  
 取得處理程序，在本機電腦上以及遠端電腦上，您可以使用這個多載。 使用 」。 「 若要指定本機電腦。 另一個多載存在，預設會使用本機電腦。  
  
 您可以存取遠端電腦上只檢視處理序的相關資訊，例如統計資料、 處理序。 您無法關閉，終止 (使用<xref:System.Diagnostics.Process.Kill%2A>)，或在遠端電腦上啟動處理序。  
  
   
  
## Examples  
 下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。 然後，它會擷取相同的處理程序在遠端電腦上的資訊。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 參數的語法無效。 其長度有可能為零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">作業系統平台不支援遠端電腦上的這項作業。</exception>
        <exception cref="T:System.InvalidOperationException">嘗試連線到 <paramref name="machineName" /> 失敗。

-或- 
存取 API 用來取得處理序資訊的效能計數器時發生問題。 此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">存取基礎系統 API 時發生問題。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的原生控制代碼。</summary>
        <value>處理序啟動時，作業系統指派給相關處理序的控制代碼。 系統會用這個控制代碼追蹤處理序屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 應用程式可以取得可用做為許多處理序資訊和控制項函式的參數的程序的控制代碼。 您可以使用此控制代碼來初始化<xref:System.Threading.WaitHandle>或呼叫與平台的原生方法叫用。  
  
 此處理序控制代碼是私用應用程式--亦即，不能共用控制代碼的程序。 處理程序也會有一個程序<xref:System.Diagnostics.Process.Id%2A>其不同的是<xref:System.Diagnostics.Process.Handle%2A>，是唯一的因此，在整個系統有效。  
  
 只有處理序啟動透過呼叫<xref:System.Diagnostics.Process.Start%2A>設定<xref:System.Diagnostics.Process.Handle%2A>屬性對應<xref:System.Diagnostics.Process>執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序尚未啟動或已結束。 無法讀取 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性，因為沒有與此 <see cref="T:System.Diagnostics.Process" /> 執行個體相關聯的處理序。  
  
-或- 
<see cref="T:System.Diagnostics.Process" /> 執行個體已附加至執行中的處理序，但沒有取得具有完整存取權限之控制代碼的必要權限。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序開啟的控制代碼數目。</summary>
        <value>處理序已開啟的作業系統控制代碼數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制代碼可讓處理序參考的物件。 處理程序可以取得檔案、 資源、 訊息佇列和其他許多作業系統物件的控制代碼。 作業系統會回收控制代碼計數是 0 時，才使用此程序相關聯的記憶體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設為 <see langword="false" /> 以存取 Windows 98 和 Windows me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出相關的處理序是否已經終止。</summary>
        <value>如果 <see cref="T:System.Diagnostics.Process" /> 元件所參考的作業系統處理序已終止，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值為`true`針對<xref:System.Diagnostics.Process.HasExited%2A>表示相關聯的處理序已終止，正常或不正常。 您可以要求或強制結束藉由呼叫相關聯的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 如果處理程序來開啟控制代碼，作業系統的程序已結束，但會保留系統管理程序資訊，例如控制代碼，結束代碼結束，結束時間與時，就會釋放處理程序記憶體。 若要取得這項資訊，您可以使用<xref:System.Diagnostics.Process.ExitCode%2A>和<xref:System.Diagnostics.Process.ExitTime%2A>屬性。 這些屬性會自動填入此元件所啟動的處理程序。 會釋出系統管理資訊時所有<xref:System.Diagnostics.Process>系統處理序相關聯的元件會終結並沒有更多的控制代碼可要抓緊頭結束處理程序。  
  
 處理程序可以與您的程式碼分開來終止。 如果您開始使用此元件的程序時，系統會更新的值<xref:System.Diagnostics.Process.HasExited%2A>自動執行，即使在相關聯的處理序獨立結束。  
  
> [!NOTE]
>  當非同步事件處理常式已重新導向標準輸出時，有可能，輸出處理尚未完成時，這個屬性會傳回`true`。 若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前接受任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 10 秒，最多達 2 秒的間隔。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，範例就會關閉程序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有與這個物件關聯的處理序。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">無法擷取處理序的結束代碼。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的唯一識別項。</summary>
        <value>這個 <see cref="T:System.Diagnostics.Process" /> 執行個體所參考的處理序之系統產生的唯一識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此程序<xref:System.Diagnostics.Process.Id%2A>不正確，如果相關聯的處理序未執行。 因此，您應該確定處理序正在執行後嘗試擷取<xref:System.Diagnostics.Process.Id%2A>屬性。 在處理序終止，直到處理序識別碼可唯一識別整個系統的程序。  
  
 您可以連接至新的本機或遠端電腦執行的處理程序<xref:System.Diagnostics.Process>藉由傳遞至處理序識別碼的執行個體<xref:System.Diagnostics.Process.GetProcessById%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 已`static`方法，以建立新的元件，並設定<xref:System.Diagnostics.Process.Id%2A>新的屬性<xref:System.Diagnostics.Process>執行個體會自動。  
  
 系統可以重複使用處理序識別碼。 <xref:System.Diagnostics.Process.Id%2A>屬性值是唯一的只會執行相關聯的處理序時。 系統處理序已終止之後，可以重複使用<xref:System.Diagnostics.Process.Id%2A>不相關的處理序的屬性值。  
  
 此識別碼是在系統上唯一的因為您可以將它的其他執行緒傳遞替代<xref:System.Diagnostics.Process>執行個體。 這個動作可節省系統資源，同時又確保會正確地識別程序。  
  
   
  
## Examples  
 下列範例示範濆爧髍孮<xref:System.Diagnostics.Process.Id%2A>所有執行的應用程式的執行個體。 程式碼會建立 「 記事本 」 的新執行個體，會列出的 「 記事本 」 中的所有執行個體並可讓使用者輸入<xref:System.Diagnostics.Process.Id%2A>移除特定的執行個體的數目。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序的 <see cref="P:System.Diagnostics.Process.Id" /> 屬性未設定。  
  
-或- 
沒有任何與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設為 <see langword="false" /> 以存取 Windows 98 和 Windows me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>立即停止相關的處理序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> 強制終止的處理序，而<xref:System.Diagnostics.Process.CloseMainWindow%2A>只要求終止。 當具有圖形化介面的程序執行時，其訊息迴圈就會處於等候狀態。 每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。 呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>傳送要求以接近主視窗中，這在格式正確的應用程式中，關閉子視窗，並撤銷應用程式的所有執行訊息迴圈。 結束藉由呼叫的程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。 應用程式可以要求使用者確認之前結束，或者它可以拒絕結束。 若要強制應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗中使用 [系統] 功能表的使用者。 因此，藉由關閉主視窗結束程序要求不會強制應用程式立即結束。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A>方法以非同步方式執行。 之後呼叫<xref:System.Diagnostics.Process.Kill%2A>方法中，呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來等候處理序結束，或者檢查<xref:System.Diagnostics.Process.HasExited%2A>屬性來判斷是否已經結束處理程序。  
  
 編輯程序的資料或資源配置給處理程序不會遺失您呼叫<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 會造成異常的處理序終止，而且應該在必要時才使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此很適合使用介面的應用程式。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。 <xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。  
  
 您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。 您無法使處理序結束的遠端電腦上。 您只能檢視在遠端電腦上執行的程序資訊。  
  
> [!NOTE]
>  如果在呼叫<xref:System.Diagnostics.Process.Kill%2A>方法由目前正在終止此程序，而<xref:System.ComponentModel.Win32Exception>拒絕存取時擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">相關的處理序無法終止。  
  
-或- 
正在結束處理序。  
  
-或- 
相關聯的處理序是 Win16 可執行檔。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試為遠端電腦上執行的處理序呼叫 <see cref="M:System.Diagnostics.Process.Kill" />。 這個方法僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理程序已經結束。  
  
-或- 
沒有任何與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件離開可與使用特殊模式執行的作業系統處理序互動的狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些作業系統處理程序以特殊模式執行。 嘗試讀取的屬性，或附加至這些處理序不能除非您呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。 呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取權以特殊模式執行這些程序。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序正在執行的所在電腦的名稱。</summary>
        <value>相關處理序正在執行的所在電腦的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以檢視統計資料和處理程序，但您的遠端電腦上執行的處理程序資訊無法呼叫<xref:System.Diagnostics.Process.Start%2A>， <xref:System.Diagnostics.Process.CloseMainWindow%2A>，或<xref:System.Diagnostics.Process.Kill%2A>在遠端電腦上。  
  
> [!NOTE]
>  當相關聯的處理序在本機電腦上執行時，這個屬性會傳回一個句點 ("。") 的機器名稱。 您應該使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性來取得正確的電腦名稱。  
  
   
  
## Examples  
 若要使用下列的範例，您必須先執行會啟動 「 記事本 」 的至少一個執行個體，在遠端電腦上。 範例會要求遠端電腦，[記事本] 正在執行，而且接著會顯示個別的名稱<xref:System.Diagnostics.Process.ProcessName%2A>， <xref:System.Diagnostics.Process.Id%2A>，和<xref:System.Diagnostics.Process.MachineName%2A>每個執行個體的屬性。  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">沒有任何與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的主要模組。</summary>
        <value><see cref="T:System.Diagnostics.ProcessModule" />，用來啟動處理序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理序模組表示會載入特定的處理序的.dll 或.exe 檔。 <xref:System.Diagnostics.Process.MainModule%2A>屬性可讓您檢視用來啟動處理序，包括模組名稱、 檔案名稱和模組記憶體詳細資料的可執行檔的相關資訊。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainModule" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 位元處理序正嘗試存取 64 位元處理序的模組。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
-或- 
處理序已經結束。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序主視窗的視窗控制代碼。</summary>
        <value>由系統產生之相關處理序主視窗的視窗控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主視窗是目前具有焦點的程序所開啟的視窗 (<xref:System.Windows.Forms.Form.TopLevel%2A>表單)。 您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>取得目前的主視窗控制代碼，如果它已變更的物件。 一般情況下，因為快取的視窗控制代碼，則使用<xref:System.Diagnostics.Process.Refresh%2A>事先保證，您會擷取目前的控制代碼。  
  
 您可以取得<xref:System.Diagnostics.Process.MainWindowHandle%2A>只能供本機電腦執行的處理序的屬性。 <xref:System.Diagnostics.Process.MainWindowHandle%2A>屬性是可唯一識別與處理程序相關聯的視窗的值。  
  
 在程序沒有主視窗程序具有圖形化介面時，才與它相關聯。 如果相關聯的處理序沒有主視窗、<xref:System.Diagnostics.Process.MainWindowHandle%2A>值為零。 這個值也是零的處理序都已隱藏起來，也就是處理不會顯示在工作列中。 這可以是顯示為圖示在工作列最右邊的 [通知] 區域中的程序的情況。  
  
 如果您剛啟動處理程序，並想要使用其主視窗控制代碼，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，確保已建立的主視窗控制代碼。 否則便會擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">因為處理序已經結束，所以未定義 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序的主視窗標題。</summary>
        <value>處理序的主視窗標題。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在程序沒有主視窗程序具有圖形化介面時，才與它相關聯。 如果相關聯的處理序沒有主視窗 (以便<xref:System.Diagnostics.Process.MainWindowHandle%2A>為零)，<xref:System.Diagnostics.Process.MainWindowTitle%2A>為空字串 ("")。 如果您剛啟動處理程序，並想要使用其主視窗標題，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，確保已建立的主視窗控制代碼。 否則，系統會擲回例外狀況 (Exception)。  
  
> [!NOTE]
>  主視窗是視窗目前具有焦點;請注意，這可能不是程序的主視窗。 您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>取得目前的主視窗控制代碼，如果它已變更的物件。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體，並擷取程序的主視窗的標題。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">因為處理序已經結束，所以未定義 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定關聯的處理序所允許的工作集大小上限，以位元組為單位。</summary>
        <value>處理序所需記憶體中工作集大小的最大值，以位元組 (Byte) 為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。 這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用的資料。 共用的資料包含頁面包含所有執行您的應用程式，包括頁面在您的.dll 檔案和 system.dll 檔案中的指示。 隨著工作集大小會增加，也會增加記憶體需求。  
  
 處理序有最小和最大工作集大小。 每次處理序資源建立時，系統會保留等於工作集大小的處理序的最小記憶體數量。 虛擬記憶體管理員會嘗試的 8kb 至少最小記憶體數量時的處理序正在使用，但永遠不會保留超過最大的大小。  
  
 系統會設定預設工作集大小。 您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。 不過，設定這些值不保證記憶體會保留或駐留。  
  
> [!NOTE]
>  當您增加處理程序工作集大小時，您需要從系統的其餘部分的實體記憶體。 請確定不會要求是太大，因為這樣做可能會降低系統效能的最小值或最大的工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">工作集大小上限無效。 必須大於或等於工作集大小下限。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">無法從關聯的處理序資源擷取工作集資訊。  
  
-或- 
處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
-或- 
處理序已經結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定關聯的處理序所允許的工作集大小下限，以位元組為單位。</summary>
        <value>處理序所需記憶體中工作集大小的最小值，以位元組 (Byte) 為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。 這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用的資料。 共用的資料包含頁面包含所有執行您的應用程式，包括頁面在您的.dll 檔案和 system.dll 檔案中的指示。 隨著工作集大小會增加，也會增加記憶體需求。  
  
 處理序有最小和最大工作集大小。 每次處理序資源建立時，系統會保留等於工作集大小的處理序的最小記憶體數量。 虛擬記憶體管理員會嘗試的 8kb 至少最小記憶體數量時的處理序正在使用，但永遠不會保留超過最大的大小。  
  
 系統會設定預設工作集大小。 您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。 不過，設定這些值不保證記憶體會保留或駐留。  
  
> [!NOTE]
>  當您增加處理程序工作集大小時，您需要從系統的其餘部分的實體記憶體。 請確定不會要求是太大，因為這樣做可能會降低系統效能的最小值或最大的工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">工作集大小下限無效。 必須小於或等於工作集大小上限。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">無法從關聯的處理序資源擷取工作集資訊。  
  
-或- 
處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
-或- 
處理序已經結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關的處理序所載入的模組。</summary>
        <value><see cref="T:System.Diagnostics.ProcessModule" /> 類型的陣列，代表相關聯處理序所載入的模組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理序模組表示會載入特定的處理序的.dll 或.exe 檔。 A<xref:System.Diagnostics.ProcessModule>執行個體可讓您檢視模組，包括模組名稱、 檔案名稱和模組記憶體詳細資料的相關資訊。  
  
 處理程序都可以將多個模組載入記憶體。 比方說，載入其他的.dll 檔案的.exe 檔案有多個模組。  
  
 啟動程序之後, 這個集合是空的直到系統有載入程序。 如果處理序具有主視窗，您可以呼叫<xref:System.Diagnostics.Process.WaitForInputIdle%2A>然後再擷取此屬性可確保集合的非空白時，您取得清單。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">您嘗試存取系統處理序或閒置處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。 這些程序並沒有模組。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>記憶體量 (以位元組為單位)，指系統已配置給不能寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>配置給關聯處理序的系統記憶體量 (以位元組為單位)，不能寫入虛擬記憶體分頁檔案。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值表示目前程序，以位元組為單位使用的未分頁的系統記憶體的大小。 系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。 非分頁的記憶體配置會保留在系統記憶體，而且未分頁移出至虛擬記憶體分頁檔。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**Pool Nonpaged Bytes**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 引發的 API 方法<xref:System.Diagnostics.Process.Exited>事件。 呼叫<xref:System.Diagnostics.Process.OnExited%2A>會導致<xref:System.Diagnostics.Process.Exited>事件發生來引發事件的使用是唯一的方式和<xref:System.Diagnostics.Process>元件。 <xref:System.Diagnostics.Process.OnExited%2A> 主要使用衍生類別元件時。  
  
 做為替代<xref:System.Diagnostics.Process.OnExited%2A>，您可以撰寫您自己的事件處理常式。 建立您自己的事件處理常式委派和事件處理方法。  
  
> [!NOTE]
>  如果您使用 Visual Studio 環境時，事件處理常式委派 (AddOnExited) 和事件處理方法 (Process1_Exited) 會針對您拖曳時<xref:System.Diagnostics.Process>元件拖曳至表單，然後按兩下的圖示。 建立時要執行的程式碼<xref:System.Diagnostics.Process.Exited>Process1_Exited 程序輸入發生的事件。 您不需要建立<xref:System.Diagnostics.Process.OnExited%2A>成員，因為它會為您實作。  
  
 引發事件會透過委派叫用此事件處理常式。 如需概觀，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Diagnostics.Process.OnExited%2A>衍生類別中的方法。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於應用程式將某行寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived>事件指出相關聯<xref:System.Diagnostics.Process>已撰寫程式，以新行字元，其重新導向至終止<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
 事件上啟用非同步讀取作業期間<xref:System.Diagnostics.Process.StandardOutput%2A>。 若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>的資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式，來<xref:System.Diagnostics.Process.OutputDataReceived>事件，並呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 之後，<xref:System.Diagnostics.Process.OutputDataReceived>事件訊號處理程序會將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，直到處理程序結束或呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>。  
  
> [!NOTE]
>  正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以確保已排清輸出緩衝區。  
  
   
  
## Examples  
 下列範例說明如何執行非同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>的資料流`ipconfig`命令。  
  
 此範例會建立事件的委派`OutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件處理常式收到文字行的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將它儲存在稍後會在此範例的主控台視窗中顯示輸出字串。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</summary>
        <value>記憶體量 (以位元組為單位)，指由關聯的處理序所配置，且可以寫入虛擬記憶體分頁檔案的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</summary>
        <value>虛擬記憶體分頁檔案中，配置給關聯處理序的記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值表示目前程序，以位元組為單位使用之虛擬記憶體分頁檔中的記憶體大小。 作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用，來管理每個處理序虛擬位址空間。 當可分頁記憶體不在使用中時，它可以傳輸到磁碟上的虛擬記憶體分頁檔案。 若要取得作業系統所使用的處理序記憶體的大小，請使用<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>屬性。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**分頁檔位元組**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例啟動 「 記事本 」 應用程式的執行個體，然後擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>記憶體量 (以位元組為單位)，指系統已配置給可以寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</summary>
        <value>配置給關聯處理序的系統記憶體量 (以位元組為單位)，可以寫入虛擬記憶體分頁檔案。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性值所傳回的值表示目前程序，以位元組為單位使用的可分頁系統記憶體的大小。 系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。 當可分頁記憶體不在使用中時，它可以傳輸到磁碟上的虛擬記憶體分頁檔案。 若要取得處理序所使用的應用程式記憶體的大小，請使用<xref:System.Diagnostics.Process.PagedMemorySize64%2A>屬性。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**Pool Paged Bytes**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量 (以位元組為單位)。</summary>
        <value>最大記憶體量 (以位元組為單位)，指由關聯的處理序配置給可以寫入虛擬記憶體分頁檔案的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量 (以位元組為單位)。</summary>
        <value>虛擬記憶體分頁檔案中，從啟動以來配置給關聯處理序的最大記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性值所傳回的值代表自啟動，以位元組為單位的處理序使用之虛擬記憶體分頁檔中的記憶體大小上限。 作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用，來管理每個處理序虛擬位址空間。 當可分頁記憶體不在使用中時，它可以傳輸到磁碟上的虛擬記憶體分頁檔案。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**分頁檔位元組尖峰**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</summary>
        <value>最大虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</summary>
        <value>從啟動以來配置給關聯處理序的最大虛擬記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表自啟動，以位元組為單位的處理序使用的虛擬記憶體的大小上限。 作業系統會對應到頁面載入的實體記憶體，或儲存在磁碟上的虛擬記憶體分頁檔案中的頁面每個處理序虛擬位址空間。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**虛擬位元組尖峰**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序工作集大小的最大值 (位元組)。</summary>
        <value>最大實體記憶體數量，為相關的處理序一次所需的量 (位元組)，</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。 這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用的資料。 共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯處理序所使用最大實體記憶體量 (以位元組為單位)。</summary>
        <value>從啟動以來配置給關聯處理序的最大實體記憶體量 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值代表工作集由處理序，因為它啟動，以位元組為單位的記憶體的大小上限。 處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。 這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用的資料。 共用的資料包含頁面包含所有處理序執行，包括指示，從處理序模組和系統程式庫的指示。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**工作集尖峰**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出作業系統是否應該在主視窗有焦點 (Focus) 時，暫時提高相關的處理序優先權。</summary>
        <value>當處理序離開等候狀態時，如果應動態提高處理序優先權，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當執行緒的優先權類別具有動態優先順序列舉值的其中一個處理序中執行時 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)，系統暫時增加執行緒的優先順序，當它被帶離等候狀態。 這個動作可防止其他處理序中斷目前執行緒的處理。 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定會影響所有現有的執行緒和任何後續的程序所建立的執行緒。 若要還原的正常行為，請設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性設`false`。  
  
> [!NOTE]
>  提升提高優先權可能會耗盡必要作業系統和網路功能，導致問題的其他作業系統工作的資源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法從關聯的處理序資源擷取優先權提升資訊。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。  
  
-或- 
處理序識別碼或處理序控制代碼為零。 (尚未啟動處理序)。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定相關處理序的整體優先權分類。</summary>
        <value>相關聯處理序的優先權分類，處理序的 <see cref="P:System.Diagnostics.Process.BasePriority" /> 由此計算出來。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 處理序優先權類別涵蓋了各種執行緒優先順序層級。 具有不同的優先權，相對於處理程序的優先權等級執行之處理序中執行的執行緒。 Win32 與每個類別的七個基底的優先順序層級使用四個優先權類別。 這些程序的優先順序類別會擷取<xref:System.Diagnostics.ProcessPriorityClass>列舉型別，可讓您設定為處理序優先權<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。 根據 24 小時制或其他的增加，基底的優先權層級可以變更作業系統，當處理程序需要領先其他人存取放到處理器的時間。 此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>暫時提高已脫離等候狀態的執行緒的優先權層級。 處理程序會回到等候狀態時，會重設的優先順序。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視開始指派給處理程序的優先順序。 不過，因為它是唯讀的您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>屬性來設定處理序的優先順序。 若要變更的優先順序，使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性，取得或設定處理程序的整體優先權分類。  
  
 無法使用系統監視器來檢視的優先權等級。 下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法設定處理序優先順序的資訊，或從相關聯的處理序資源擷取。  
  
-或- 
處理序識別碼或處理序控制代碼為零。 (尚未啟動處理序)。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">使用 Windows 98 或 Windows Millennium Edition (Windows Me) 時，<see cref="P:System.Diagnostics.Process.PriorityClass" /> 已設定為 <see langword="AboveNormal" /> 或 <see langword="BelowNormal" />。 這些平台不支援優先權類別的這些值。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">無法設定優先權類別，因為它不使用如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列舉類型中所定義的有效值。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</summary>
        <value>相關的處理序配置的位元組數目，不能與其他處理序共用。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</summary>
        <value>配置給關聯處理序的記憶體量 (以位元組為單位)，不能與其他處理序共用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值表示目前程序，以位元組為單位，不能與其他處理序共用所使用的記憶體大小。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**私用位元組**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序使用處理器的授權時間。</summary>
        <value><see cref="T:System.TimeSpan" />，表示處理序在作業系統核心內執行程式碼所花費的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序的名稱。</summary>
        <value>名稱，系統用來向使用者識別處理序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A>屬性會保留的可執行檔名稱，例如 Outlook、 不包含副檔名為.exe 或路徑。 它可協助取得和管理相同的可執行檔相關聯的所有處理序。  
  
> [!NOTE]
>  在 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]作業系統，<xref:System.Diagnostics.Process.ProcessName%2A>屬性可能會被截斷為 15 個字元，如果無法取得處理序模組資訊。  
  
 您可以呼叫<xref:System.Diagnostics.Process.GetProcessesByName%2A>，傳遞的可執行檔名稱，來擷取陣列，其中包含每個指定的電腦上執行的執行個體。 您可以使用這個陣列，例如，若要關閉的可執行檔的所有執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序沒有識別項，或沒有處理序與 <see cref="T:System.Diagnostics.Process" /> 相關聯。  
  
-或- 
關聯處理序已結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">處理序不在這部電腦上。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定處理器，這個處理序中的執行緒可以在其上排程執行。</summary>
        <value>位元遮罩，表示相關的處理序中的執行緒可以在其上執行的處理器。 預設值取決於電腦上的處理器數目。 預設值為 2 <sup>n</sup> -1，其中 n 是處理器數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 Windows 2000 和更新版本中，處理程序中的執行緒可以移轉處理器，以重新載入處理器快取每個移轉。 在繁重的系統負載下指定哪一個處理器應該執行特定的執行緒可以改善效能降低的次數會重新載入處理器快取。 處理器和執行緒之間的關聯稱為處理器相似性。  
  
 位元表示每個處理器。 位元 0 是第一個處理器，位元 1 是第二個，處理器等等。 如果您將設定位元為 1 的值，對應的處理器會選取進行執行緒指派。 當您將設定<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值為零，作業系統的排程演算法設定執行緒的相似性。 當<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值設定為任何非零值，值會解譯為指定適合選取之處理器的位元遮罩。  
  
 下表顯示選取的<xref:System.Diagnostics.Process.ProcessorAffinity%2A>八個處理器的系統值。  
  
|位元遮罩|二進位值|符合資格的處理器|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 和 2|  
|0x0007|00000000 00000111|1、 2 和 3|  
|0x0009|00000000 00001001|1 到 4|  
|0x007F|00000000 01111111|1、 2、 3、 4、 5、 6 和 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 資訊無法設定或從相關聯的處理序資源擷取。  
  
-或- 
處理序識別碼或處理序控制代碼為零。 (尚未啟動處理序)。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。  
  
-或- 
處理序已經結束。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>捨棄快取於處理序元件內之相關處理序的任何資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之後<xref:System.Diagnostics.Process.Refresh%2A>呼叫時，第一個要求的每一個屬性的相關資訊會導致處理序元件，從相關聯的處理序中取得新的值。  
  
 當<xref:System.Diagnostics.Process>元件是與處理序資源，屬性值相關聯<xref:System.Diagnostics.Process>立即填入根據相關聯的處理序的狀態。 如果後續變更相關聯的處理序的相關資訊，這些變更不會反映在<xref:System.Diagnostics.Process>元件的快取的值。 <xref:System.Diagnostics.Process>元件會將快照集的處理序資源位於與其相關聯的時間。 若要檢視相關聯的處理序的目前值，請呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 然後，它會擷取相關聯的處理序的實體記憶體使用量在 10 秒，最多達 2 秒的間隔。 此範例會偵測處理序結束之前經過 10 秒。 如果它仍在執行 10 秒後，範例就會關閉程序。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出處理序的使用者介面是否正在回應。</summary>
        <value>如果相關聯處理序的使用者介面正在回應系統，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果處理程序具有使用者介面，<xref:System.Diagnostics.Process.Responding%2A>屬性連絡使用者介面，以判斷處理序是否正在回應使用者輸入。 如果介面沒有回應，立即<xref:System.Diagnostics.Process.Responding%2A>屬性會傳回`false`。 使用這個屬性來判斷相關聯的處理序的介面是否已停止回應。  
  
 如果處理程序並沒有<xref:System.Diagnostics.Process.MainWindowHandle%2A>，這個屬性會傳回`true`。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <exception cref="T:System.InvalidOperationException">沒有任何與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Responding" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序的原生控制代碼。</summary>
        <value>這個處理序的原生控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控制代碼才可使用呼叫元件已啟動的程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的終端機服務工作階段識別項。</summary>
        <value>相關處理序的終端機服務工作階段識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A>屬性識別目前執行中應用程式的工作階段。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">沒有與此處理序相關聯的工作階段。</exception>
        <exception cref="T:System.InvalidOperationException">沒有與這個工作階段識別項相關聯的處理序。  
  
-或- 
相關的處理序不在此機器上。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 不支援 <see cref="P:System.Diagnostics.Process.SessionId" /> 屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來讀取應用程式錯誤輸出的資料流。</summary>
        <value><see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準錯誤資料流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.Process>將文字寫入至其標準錯誤資料流中，文字通常會顯示在主控台上。 藉由重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流，您可以操作或隱藏的錯誤輸出的處理程序。 例如，您可以篩選文字、 格式，或將輸出寫入到主控台和指定的記錄檔。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardError%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>要`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>到`true`。 否則，讀取<xref:System.Diagnostics.Process.StandardError%2A>資料流則會擲回例外狀況。  
  
 重新導向<xref:System.Diagnostics.Process.StandardError%2A>可以讀取資料流，同步或非同步。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的錯誤輸出資料流同步讀取的作業。 這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。 這個方法可讓資料流輸出指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。  
  
 同步讀取作業採用之間讀取呼叫端相依性<xref:System.Diagnostics.Process.StandardError%2A>資料流和子處理該資料流寫入。 這些相依性可能會導致死結狀況。 呼叫端會從子處理序的重新導向資料流讀取，時，取決於子系。 呼叫者會等候讀取作業，直到寫入資料流中的子系，或關閉資料流。 子處理序寫入資料不足，無法填滿其重新導向的資料流，時，相依於父代。 子處理序會等候下一個寫入作業，直到父從完整的資料流讀取，或關閉資料流。 當呼叫端和子處理序等待彼此完成作業時，且無法繼續時，就會導致死結狀態。 您可以評估子處理序與呼叫端之間的相依性，以避免死結。  
  
 例如，下列 C# 程式碼會示範如何讀取重新導向資料流，並等候子處理序結束。  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 藉由呼叫程式碼範例可避免的鎖死的情況`p.StandardError.ReadToEnd`之前`p.WaitForExit`。 如果父系處理程序的呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的重新導向的資料流。 父處理序會無限期等候子處理序結束。 子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。 下列 C# 程式碼，例如，會執行兩個資料流上的讀取的作業。  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 在程式碼範例執行非同步讀取作業，在避免發生死結狀況<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 如果父系處理程序的呼叫會產生鎖死的情況`p.StandardOutput.ReadToEnd`後面接著`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿其錯誤資料流。 父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 您可以使用非同步讀取的作業，以避免這些相依性，以及其潛在的死結。 或者，您可以藉由建立兩個執行緒，並讀取每個個別的執行緒上的資料流的輸出，避免發生死結狀況。  
  
> [!NOTE]
>  您不能混用重新導向的資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，或反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
   
  
## Examples  
 下列範例會使用`net use`命令搭配使用者提供的引數，以對應的網路資源。 然後讀取，net 命令標準錯誤資料流，並寫入至主控台。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。  
  
-或- 
已開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 的非同步讀取作業。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來寫入應用程式輸入的資料流。</summary>
        <value><see cref="T:System.IO.StreamWriter" />，可用來寫入應用程式的標準輸入資料流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>可以讀取其標準輸入資料流，一般是鍵盤輸入的文字。 藉由重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流，您可以透過程式設計方式指定輸入。 比方說，而不是使用鍵盤輸入，您可以提供從指定的檔案內容的文字或另一個應用程式的輸出。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardInput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>要`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>到`true`。 否則，寫入<xref:System.Diagnostics.Process.StandardInput%2A>資料流則會擲回例外狀況。  
  
   
  
## Examples  
 下列範例說明如何將重新導向<xref:System.Diagnostics.Process.StandardInput%2A>程序的資料流。 此範例會啟動`sort`命令搭配重新導向的輸入。 接著會提示使用者輸入文字，並將其傳遞至`sort`處理序，透過重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流。 `sort`結果會顯示在主控台上的使用者。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未定義 <see cref="P:System.Diagnostics.Process.StandardInput" /> 資料流，因為 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 已設定為 <see langword="false" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來讀取應用程式文字輸出的資料流。</summary>
        <value><see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準輸出資料流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.Process>將文字寫入至其標準的資料流，文字通常會顯示在主控台上。 藉由重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，您可以操作或隱藏程序的輸出。 例如，您可以篩選文字、 格式，或將輸出寫入到主控台和指定的記錄檔。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardOutput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>要`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>到`true`。 否則，讀取<xref:System.Diagnostics.Process.StandardOutput%2A>資料流則會擲回例外狀況。  
  
 重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>可以讀取資料流，同步或非同步。 這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流同步讀取的作業。 這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。  
  
 相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 這個方法可讓資料流輸出指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。  
  
 同步讀取作業採用之間讀取呼叫端相依性<xref:System.Diagnostics.Process.StandardOutput%2A>資料流和子處理該資料流寫入。 這些相依性可能會導致死結狀況。 呼叫端會從子處理序的重新導向資料流讀取，時，取決於子系。 呼叫者會等候讀取作業，直到寫入資料流中的子系，或關閉資料流。 子處理序寫入資料不足，無法填滿其重新導向的資料流，時，相依於父代。 子處理序會等候下一個寫入作業，直到父從完整的資料流讀取，或關閉資料流。 當呼叫端和子處理序等待彼此完成作業時，且無法繼續時，就會導致死結狀態。 您可以評估子處理序與呼叫端之間的相依性，以避免死結。  
  
 例如，下列 C# 程式碼會示範如何讀取重新導向資料流，並等候子處理序結束。  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 藉由呼叫程式碼範例可避免的鎖死的情況`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。 如果父系處理程序的呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子處理序寫入足夠的文字，以填滿的重新導向的資料流。 父處理序會無限期等候子處理序結束。 子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。  
  
 當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。 下列 C# 程式碼，例如，會執行兩個資料流上的讀取的作業。  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 在程式碼範例執行非同步讀取作業，在避免發生死結狀況<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 如果父系處理程序的呼叫會產生鎖死的情況`p.StandardOutput.ReadToEnd`後面接著`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿其錯誤資料流。 父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。 子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
 您可以使用非同步讀取的作業，以避免這些相依性，以及其潛在的死結。 或者，您可以藉由建立兩個執行緒，並讀取每個個別的執行緒上的資料流的輸出，避免發生死結狀況。  
  
> [!NOTE]
>  您不能混用重新導向的資料流的非同步和同步讀取的作業。 一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。 例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，或反之亦然。 不過，您可以讀取在不同模式中的兩個不同資料流。 例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。  
  
   
  
## Examples  
 下列範例執行 ipconfig.exe 命令，並將其標準輸出重新導向至範例的 [主控台] 視窗。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。  
  
-或- 
已開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 的非同步讀取作業。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>啟動處理序資源，並將其與 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動 (或重複使用) 這個 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性指定的處理序資源，並將其與元件相關聯。</summary>
        <returns>如果啟動處理序資源，則為 <see langword="true" />；如果沒有啟動任何新的處理序資源 (例如，如果重複使用現有的處理序)，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來啟動處理序資源，並將它與目前的關聯<xref:System.Diagnostics.Process>元件。 傳回值`true`指出已啟動新的處理序資源。 如果所指定的處理序資源<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性已在電腦上執行，沒有啟動任何額外的處理序資源。 相反地，執行處理序資源會重複使用和`false`會傳回。  
  
 您可以藉由指定從中您原先安裝應用程式的位置 （例如，Web 位址） 來啟動 ClickOnce 應用程式。 藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。  
  
> [!NOTE]
>  如果您使用 Visual Studio 中的這個多載<xref:System.Diagnostics.Process.Start%2A>方法就是拖曳後，您將您的程式碼插入<xref:System.Diagnostics.Process>元件拖曳至設計工具。 使用`Properties`視窗中，展開`StartInfo`類別目錄和寫入至適當的值`FileName`屬性。 您的變更會出現在表單的`InitializeComponent`程序。  
  
 這個多載<xref:System.Diagnostics.Process.Start%2A>不是`static`方法。 您必須呼叫它的執行個體從<xref:System.Diagnostics.Process>類別。 然後再呼叫<xref:System.Diagnostics.Process.Start%2A>，您必須先指定<xref:System.Diagnostics.Process.StartInfo%2A>屬性資訊<xref:System.Diagnostics.Process>執行個體，因為該資訊來判斷啟動的處理序資源。  
  
 其他多載<xref:System.Diagnostics.Process.Start%2A>方法會`static`成員。 您不需要建立的執行個體<xref:System.Diagnostics.Process>元件才能呼叫方法的多載。 相反地，您可以呼叫<xref:System.Diagnostics.Process.Start%2A>for<xref:System.Diagnostics.Process>類別本身，以及新<xref:System.Diagnostics.Process>如果處理序已啟動，則會建立元件。 或者，`null`會傳回處理程序已重複使用。 處理序資源會自動與新的關聯<xref:System.Diagnostics.Process>所傳回的元件<xref:System.Diagnostics.Process.Start%2A>方法。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A>成員可以用來複製的功能`Run`對話方塊中的 Windows`Start`功能表。 任何可以輸入命令列的項目可以啟動程式中設定適當的值<xref:System.Diagnostics.Process.StartInfo%2A>屬性。 唯一<xref:System.Diagnostics.Process.StartInfo%2A>必須設定的屬性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性沒有可執行檔。 它可以是任何的延伸模組已安裝在系統的應用程式相關聯的檔案類型。 比方說，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以有副檔名為.txt，如果您的文字檔案關聯的編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有副檔名為.doc。  
  
 在命令列中，您可以指定要用於特定類型的檔案所採取的動作。 例如，您可以列印文件，或編輯文字檔。 指定使用這些動作<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性。 對於其他類型的檔案中，您可以指定命令列引數時開始從檔案`Run` 對話方塊。 比方說，您可以傳遞 URL 作為引數如果您指定做為您的瀏覽器<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 中可以指定這些引數<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成員。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。 否則，系統將無法找到路徑。 例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。 處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。  
  
 這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。 Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。 不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例使用的執行個體<xref:System.Diagnostics.Process>類別來啟動處理序。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定檔案名稱。
或者，<see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 成員是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 是 <see langword="true" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯檔案時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo"><see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用來啟動處理序的資訊，包括檔名和任何命令列引數。</param>
        <summary>啟動含有處理序啟動資訊 (例如，要啟動之處理序的檔名) 的參數所指定的處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此多載來啟動處理序資源，藉由指定<xref:System.Diagnostics.ProcessStartInfo>執行個體。 多載會將資源與新<xref:System.Diagnostics.Process>物件。  
  
> [!NOTE]
>  如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。  
  
 這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。 使用這個多載<xref:System.Diagnostics.ProcessStartInfo>參數是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定其<xref:System.Diagnostics.Process.StartInfo%2A>內容，然後呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。  
  
 使用<xref:System.Diagnostics.ProcessStartInfo>執行個體如下參數可讓您呼叫<xref:System.Diagnostics.Process.Start%2A>控制最傳入啟動程序呼叫。 如果您需要將只能在檔案名稱或檔案名稱和引數傳遞，不需要建立新<xref:System.Diagnostics.ProcessStartInfo>執行個體，雖然這是一個選項。 唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>必須設定的屬性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。 它可以是任何的延伸模組已安裝在系統的應用程式相關聯的檔案類型。 比方說，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以有副檔名為.txt，如果您的文字檔案關聯的編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有副檔名為.doc。  
  
 您可以藉由指定從中您原先安裝應用程式的位置 （例如，Web 位址） 來啟動 ClickOnce 應用程式。 藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。  
  
 如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>並<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>的屬性<xref:System.Diagnostics.Process.StartInfo%2A>執行個體設定，未受管理`CreateProcessWithLogonW`呼叫函式，這會啟動程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>。 如果<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>屬性是`null`，則<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>屬性必須以 UPN 格式*使用者*@*DNS_domain_name*。   
  
 不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。 使用當您已建立多載<xref:System.Diagnostics.Process>執行個體，指定的開始資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。 使用其中一種`static`當您想要建立新的多載<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的程序。 這個多載並沒有參數的多載可讓您藉由使用指定的處理序資源的啟動資訊<xref:System.Diagnostics.ProcessStartInfo>執行個體。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。 否則，系統將無法找到路徑。 例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。 處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。  
  
 這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>已`true`上`startInfo`參數，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。 Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。 不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例首先會繁衍的 Internet Explorer 執行個體，並會顯示在瀏覽器中的 [我的最愛] 資料夾的內容。 然後會啟動 Internet Explorer 的某些其他執行個體，並會顯示一些特定的網頁或網站。 最後它會啟動 Internet Explorer 與正在同時瀏覽至特定站台的最小化視窗。  
  
 這個方法的其他用途的其他範例，請參閱個別屬性的<xref:System.Diagnostics.ProcessStartInfo>類別。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性沒有指定任何檔案名稱。  
  
-或- 
<paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性也是 <see langword="true" />。  
  
-或- 
<paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 屬性不是 <see langword="null" /> 或空白，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 屬性不是 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startInfo" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性中所指定的檔案。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯的檔案時發生錯誤。  
  
-或- 
引數長度和處理序完整路徑長度的總和超過 2080。 與此例外狀況建立關聯的錯誤訊息可以是下列其中一項：「傳遞到系統呼叫的資料區域太小。」 或「拒絕存取」。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之文件或應用程式檔案的名稱。</param>
        <summary>藉由指定文件或應用程式檔案的名稱啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載來啟動處理序資源指定檔案名稱。 多載會將資源與新<xref:System.Diagnostics.Process>物件。  
  
> [!NOTE]
>  如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。  
  
 這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性，然後呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。  
  
 您可以啟動 ClickOnce 應用程式設定`fileName`參數，以在原本安裝的應用程式的位置 （例如，Web 位址）。 藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。  
  
 藉由指定其檔案名稱啟動處理序是類似於輸入中的資訊`Run`對話方塊中的 Windows`Start`功能表。 因此，檔案名稱不需要代表可執行檔。 它可以是任何的副檔名已經相關聯的系統上安裝的應用程式的檔案類型。 比方說如果文字檔聯編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有.doc 的檔案名稱可以有副檔名為.txt。 同樣地，在相同方式來`Run` 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。  
  
 這個多載不允許處理序的命令列引數。 如果您需要指定處理序的一或多個命令列引數，使用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>或<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>多載。  
  
 不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。 使用當您已建立多載<xref:System.Diagnostics.Process>執行個體，指定的開始資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。 使用其中一種`static`當您想要建立新的多載<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的程序。 這個多載並沒有參數的多載可讓您指定要啟動的處理序資源的檔案名稱。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。 否則，系統將無法找到路徑。 例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。 處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。  
  
 這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。 Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。 不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例首先會繁衍的 Internet Explorer 執行個體，並會顯示在瀏覽器中的 [我的最愛] 資料夾的內容。 然後會啟動 Internet Explorer 的某些其他執行個體，並會顯示一些特定的網頁或網站。 最後它會啟動 Internet Explorer 與正在同時瀏覽至特定站台的最小化視窗。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯的檔案時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境變數具有含引號的字串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之應用程式檔案的名稱。</param>
        <param name="arguments">啟動處理程序時要傳遞的命令列引數。</param>
        <summary>藉由指定應用程式的名稱和一組命令列引數來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要啟動處理序資源，藉由指定其檔案名稱和命令列引數中使用此多載。 多載會將資源與新<xref:System.Diagnostics.Process>物件。  
  
> [!NOTE]
>  如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。  
  
 這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>並<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>的成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，以及呼叫<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>執行個體。  
  
 藉由指定其檔案名稱和引數啟動程序是類似於輸入的檔案名稱和中的命令列引數`Run`對話方塊中的 Windows`Start`功能表。 因此，檔案名稱不需要代表可執行檔。 它可以是任何的副檔名已經相關聯的系統上安裝的應用程式的檔案類型。 比方說如果文字檔聯編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有.doc 的檔案名稱可以有副檔名為.txt。 同樣地，在相同方式來`Run` 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。 如果`fileName`參數表示可執行檔`arguments`參數可能代表採取動作，例如文字檔案中的檔案`Notepad.exe myfile.txt`。 如果`fileName`參數代表命令 (.cmd) 檔`arguments`參數必須包含 「`/c`「 或 」`/k`"引數來指定是否在命令視窗結束或完成後仍會保持。  
  
 不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。 使用當您已建立多載<xref:System.Diagnostics.Process>執行個體，指定的開始資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。 使用其中一種`static`當您想要建立新的多載<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的程序。 這個多載並沒有參數的多載可讓您指定要傳遞的命令列引數與啟動的處理序資源的檔案名稱。  
  
 如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。 否則，系統將無法找到路徑。 例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。  
  
> [!NOTE]
>  ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。  如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。 處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。 
  
 這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。 當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。 Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法需要的 apartment 狀態不是`unknown`。 如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。 不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。  
  
   
  
## Examples  
 下列範例首先會繁衍的 Internet Explorer 執行個體，並會顯示在瀏覽器中的 [我的最愛] 資料夾的內容。 然後會啟動 Internet Explorer 的某些其他執行個體，並會顯示一些特定的網頁或網站。 最後它會啟動 Internet Explorer 與正在同時瀏覽至特定站台的最小化視窗。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="fileName" /> 或 <paramref name="arguments" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯的檔案時發生錯誤。  
  
-或- 
引數長度和處理序完整路徑長度的總和超過 2080。 與此例外狀況建立關聯的錯誤訊息可以是下列其中一項：「傳遞到系統呼叫的資料區域太小。」 或「拒絕存取」。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境變數具有含引號的字串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之應用程式檔案的名稱。</param>
        <param name="userName">要在啟動處理序時使用的使用者名稱。</param>
        <param name="password"><see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</param>
        <param name="domain">要在啟動處理序時使用的網域。</param>
        <summary>藉由指定應用程式的名稱、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此多載，藉由指定其檔案名稱、 使用者名稱、 密碼和網域中建立新的處理序和其主要的執行緒。 新的處理序再執行指定的可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。  
  
> [!NOTE]
>  當可執行檔位於遠端的磁碟機中時，您必須使用統一資源識別元 (URI) 未連結的磁碟機代號來識別網路共用。  
  
> [!NOTE]
>  如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。  
  
 這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，並<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>執行個體。  
  
 同樣地，在相同方式來**執行** 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。 如果`fileName`參數表示可執行檔`arguments`參數可能代表採取動作，例如文字檔案中的檔案`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  檔案名稱必須代表的可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。 
  
   
  
## Examples  
 下列程式碼範例將示範如何使用此多載，來啟動可執行檔，並也會示範擲回<xref:System.ComponentModel.Win32Exception>時嘗試啟動不可執行的檔案相關聯的應用程式。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定檔案名稱。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯檔案時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在處理序中執行之應用程式檔案的名稱。</param>
        <param name="arguments">啟動處理程序時要傳遞的命令列引數。</param>
        <param name="userName">要在啟動處理序時使用的使用者名稱。</param>
        <param name="password"><see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</param>
        <param name="domain">要在啟動處理序時使用的網域。</param>
        <summary>藉由指定應用程式的名稱、一組命令列引數、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</summary>
        <returns>與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。 請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。 此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。 在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此多載，藉由指定其檔案名稱、 命令列引數、 使用者名稱、 密碼和網域中建立新的處理序和其主要的執行緒。 新的處理序再執行指定的可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。  
  
> [!NOTE]
>  當可執行檔位於遠端的磁碟機中時，您必須使用統一資源識別元 (URI) 未連結的磁碟機代號來識別網路共用。  
  
> [!NOTE]
>  如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。  
  
 這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。 多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，然後呼叫<xref:System.Diagnostics.Process.Start%2A>針對<xref:System.Diagnostics.Process>執行個體。  
  
 同樣地，在相同方式來**執行** 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。 例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。 如果`fileName`參數表示可執行檔`arguments`參數可能代表採取動作，例如文字檔案中的檔案`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  檔案名稱必須代表的可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。  
  
 每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。 關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定檔案名稱。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">開啟關聯的檔案時發生錯誤。  
  
-或- 
引數長度和關聯檔案完整路徑長度的總和超過 2080。 與此例外狀況建立關聯的錯誤訊息可以是下列其中一項：「傳遞到系統呼叫的資料區域太小。」 或「拒絕存取」。</exception>
        <exception cref="T:System.ObjectDisposedException">處理序物件已經處置。</exception>
        <exception cref="T:System.PlatformNotSupportedException">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要傳遞給 <see cref="T:System.Diagnostics.Process" /> 之 <see cref="M:System.Diagnostics.Process.Start" /> 方法的屬性。</summary>
        <value><see cref="T:System.Diagnostics.ProcessStartInfo" />，代表用來啟動處理序的資料。 這些引數包括用來啟動處理序的可執行檔或文件的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 表示要用來啟動處理程序的參數組。 當<xref:System.Diagnostics.Process.Start%2A>呼叫時，<xref:System.Diagnostics.Process.StartInfo%2A>用來指定要啟動處理序。 只有必要的時候<xref:System.Diagnostics.Process.StartInfo%2A>若要設定的成員是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。 藉由指定啟動處理序<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性是類似於輸入中的資訊**執行**Windows 對話方塊**啟動**功能表。 因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。 它可以是任何的副檔名已經相關聯的系統上安裝的應用程式的檔案類型。 例如<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>可以有副檔名為.txt，如果您文字的檔案關聯的編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有.doc。 同樣地，在相同方式來**執行** 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性在<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。 例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"Notepad.exe"或"Notepad"的屬性。  
  
 您可以啟動 ClickOnce 應用程式設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>在原本安裝的應用程式的位置 （例如，Web 位址） 的屬性。 藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。  
  
 如果檔案名稱包含非執行檔的檔案，例如.doc 檔案，您可以包含指定要對檔案執行的動作動詞命令。 例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>"Print"，結尾為.doc 副檔名的檔案。 在指定的檔名<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要有副檔名，如果您手動輸入的值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性。 不過，如果您使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性來判斷何種動詞可供使用，您必須包含副檔名。  
  
 您可以變更中指定的參數<xref:System.Diagnostics.Process.StartInfo%2A>屬性，讓您呼叫為止<xref:System.Diagnostics.Process.Start%2A>程序的方法。 啟動程序之後，變更<xref:System.Diagnostics.Process.StartInfo%2A>值不會影響或重新啟動相關的處理序。 如果您呼叫<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>方法<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>並<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>屬性集，如果未受管理`CreateProcessWithLogonW`呼叫函式，這會啟動程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden>。  
  
 如果您未使用<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理程序，<xref:System.Diagnostics.Process.StartInfo%2A>屬性不會反映使用啟動程序的參數。 例如，如果您使用<xref:System.Diagnostics.Process.GetProcesses%2A>以取得陣列的電腦上，執行的處理序<xref:System.Diagnostics.Process.StartInfo%2A>每個屬性<xref:System.Diagnostics.Process>不包含原始的檔案名稱或用來啟動處理程序的引數。  
  
 檔案名稱啟動處理程序時，會填入 （唯讀） 檔案<xref:System.Diagnostics.Process.MainModule%2A>屬性。 如果您想要擷取可執行檔所關聯的處理序啟動程序之後，請使用<xref:System.Diagnostics.Process.MainModule%2A>屬性。 如果您想要設定的可執行檔<xref:System.Diagnostics.Process>執行個體的相關聯的處理序尚未啟動，請使用<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。 因為成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性會傳遞至引數<xref:System.Diagnostics.Process.Start%2A>方法的程序中，然後再變更<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>不會重設屬性相關聯的處理序啟動之後<xref:System.Diagnostics.Process.MainModule%2A>屬性。 這些屬性是只能用來初始化相關聯的處理序。  
  
   
  
## Examples  
 下列範例會填入<xref:System.Diagnostics.Process.StartInfo%2A>與要執行的檔案，它執行動作，以及是否應該顯示使用者介面。 如需其他範例，請參閱參考頁面屬性的<xref:System.Diagnostics.ProcessStartInfo>類別。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值是 <see langword="null" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關的處理序啟動的時間。</summary>
        <value>物件，指出處理序何時啟動。 如果處理序並未執行，則會擲回例外狀況。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.StartTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <exception cref="T:System.InvalidOperationException">處理序已經結束。  
  
-或- 
尚未啟動處理序。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">呼叫 Windows 函式時發生錯誤。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定物件，用以封送處理因處理序結束事件而發出的事件處理常式呼叫。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用以封送處理因處理序上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而發出的事件處理常式呼叫。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>已`null`，處理方法<xref:System.Diagnostics.Process.Exited>系統執行緒集區的執行緒上呼叫事件。 如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。  
  
 當<xref:System.Diagnostics.Process.Exited>事件由 visual 的 Windows Form 元件，例如<xref:System.Windows.Forms.Button>，透過系統執行緒集區中存取元件可能無法運作，或可能會導致例外狀況。 藉由設定避免這<xref:System.Diagnostics.Process.SynchronizingObject%2A>至 Windows Form 元件，因而導致處理方法<xref:System.Diagnostics.Process.Exited>元件建立所在的相同執行緒上呼叫的事件。  
  
 如果<xref:System.Diagnostics.Process>使用於內部[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.Diagnostics.Process.SynchronizingObject%2A>會自動設為包含的控制項<xref:System.Diagnostics.Process>。 比方說，如果您放置<xref:System.Diagnostics.Process>設計工具上`Form1`(繼承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性<xref:System.Diagnostics.Process>設定為執行個體`Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 一般而言，這個屬性設定時元件會放置在控制項或表單中，因為這些元件會繫結至特定執行緒。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得正在相關的處理序中執行的執行緒集。</summary>
        <value><see cref="T:System.Diagnostics.ProcessThread" /> 類型的陣列，代表目前正在相關聯處理序中執行的作業系統執行緒。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒處理序中執行程式碼。 每個處理序會啟動具有單一執行緒，其主要執行緒。 任何執行緒可以建立額外的執行緒。 在處理序中的執行緒共用處理序位址空間。  
  
 使用<xref:System.Diagnostics.ProcessThread>，取得目前的處理序相關聯的所有執行緒。 主要執行緒不一定是在陣列中的索引為零。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">處理序沒有 <see cref="P:System.Diagnostics.Process.Id" />，或沒有與 <see cref="T:System.Diagnostics.Process" /> 執行個體關聯的處理序。  
  
-或- 
關聯處理序已結束。</exception>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將處理序的名稱格式化為字串，如果適用，將它和父代 (Parent) 元件類型結合。</summary>
        <returns><see cref="P:System.Diagnostics.Process.ProcessName" />，與基底元件的 <see cref="M:System.Object.ToString" /> 傳回值搭配相結合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 不支援 <see cref="M:System.Diagnostics.Process.ToString" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序的總處理器時間。</summary>
        <value><see cref="T:System.TimeSpan" />，表示相關聯處理序花在使用 CPU 的時間。 這個值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的總和。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個處理序的使用者處理器時間。</summary>
        <value><see cref="T:System.TimeSpan" />，表示相關聯處理序花在處理序的應用程式部分內 (而不是在作業系統核心內) 執行程式碼的時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <exception cref="T:System.NotSupportedException">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 屬性。 這個屬性僅供在本機電腦執行的處理序使用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理序的虛擬記憶體的大小 (以位元組為單位)。</summary>
        <value>虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的虛擬記憶體量，以位元組為單位。</summary>
        <value>配置給關聯處理序的虛擬記憶體量，以位元組為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值表示目前程序，以位元組為單位使用的虛擬記憶體的大小。 作業系統會對應到頁面載入的實體記憶體，或儲存在磁碟上的虛擬記憶體分頁檔案中的頁面每個處理序虛擬位址空間。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**Virtual Bytes**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定要等待相關的處理序結束的時間，並且阻止目前的執行緒執行，直到等候時間耗盡或者處理序已經結束為止。 為避免封鎖目前的執行緒，請使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。  
  
對於程式碼範例，請參閱 <see cref="P:System.Diagnostics.Process.StandardError" /> 與 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性參考頁面。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序結束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 可讓目前的執行緒等候相關聯的處理序終止為止。  所有其他方法會呼叫程序之後，應該要進行呼叫。 為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 這個方法會指示<xref:System.Diagnostics.Process>元件等候無限量的時間到結束的處理程序和事件處理常式。 這會造成停止回應的應用程式。 例如，如果您呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>具有使用者介面程序中，要求作業系統終止相關聯的處理序可能不會處理如果處理程序撰寫永遠不會輸入其訊息迴圈。  
  
> [!NOTE]
>  中[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和更早的版本<xref:System.Diagnostics.Process.WaitForExit>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），不無限期。 此外，舊版未等待事件處理常式，如果結束完整<xref:System.Int32.MaxValue>已到達時間。  
  
 這個多載可確保，所有處理都完成之後，包括重新導向標準輸出的非同步事件的處理。 您應該使用這個多載之後呼叫<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>多載時非同步事件處理常式已重新導向標準輸出。  
  
 時相關聯的處理序結束時 （也就是它遭到關閉作業系統正常或不正常終止） 時，系統會儲存程序的系統管理資訊，並傳回給已呼叫元件<xref:System.Diagnostics.Process.WaitForExit>。 <xref:System.Diagnostics.Process>元件可以存取的資訊，包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>結束程序。  
  
 因為相關聯的處理序已結束，<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。 相反地，控制代碼可用來存取的處理序資源相關的作業系統的資訊。 系統所知的控點來結束處理程序尚未發行所<xref:System.Diagnostics.Process>元件，因此它會保留<xref:System.Diagnostics.Process.ExitTime%2A>並<xref:System.Diagnostics.Process.Handle%2A>資訊中記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。 基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>for<xref:System.Diagnostics.Process>執行個體，呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序終止為止，您不再需要任何系統管理相關資訊。 <xref:System.Diagnostics.Process.Close%2A> 釋放配置給結束的處理序的記憶體。  
  
   
  
## Examples  
 請參閱 < 備註 > 一節的<xref:System.Diagnostics.Process.StandardError%2A>屬性參考頁面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法存取等候設定。</exception>
        <exception cref="T:System.SystemException">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。  
  
-或- 
沒有任何與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。  
  
-或- 
您正在嘗試為遠端電腦上執行的處理序呼叫 <see cref="M:System.Diagnostics.Process.WaitForExit" />。 這個方法僅適用於在本機電腦執行的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">等候相關的處理序結束的時間量，以毫秒計算。 最大值是 32 位元整數的最大可能值，對作業系統來說，這表示無限。</param>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序結束的指定毫秒數。</summary>
        <returns>如果相關聯處理序已結束，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 可讓目前的執行緒等候相關聯的處理序終止為止。 所有其他方法會呼叫程序之後，應該要進行呼叫。 為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 這個方法會指示<xref:System.Diagnostics.Process>元件等候一段有限的處理序結束的時間。 如果相關聯的處理序未結束的間隔結束時終止要求遭到拒絕，因為`false`會傳回到呼叫的程序。 您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>for `milliseconds`，並<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>行為與相同<xref:System.Diagnostics.Process.WaitForExit>多載。 如果您將 0 （零） 傳遞給方法，它會傳回`true`只有當 proces byl již ukončen; 否則會立即傳回`false`。  
  
> [!NOTE]
>  在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和更早版本，如果`milliseconds`為-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），不無限期。  
  
 當非同步事件處理常式已重新導向標準輸出時，它有可能，輸出處理尚未完成此方法傳回時。 若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>多載會採用任何參數，在收到之後`true`從這個多載。 為協助確保<xref:System.Diagnostics.Process.Exited>Windows Forms 應用程式中正確地處理事件，請將<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。  
  
 相關聯的處理序結束時 （關閉作業系統正常或不正常終止），系統會儲存程序的系統管理資訊，並傳回給已呼叫元件<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>。 <xref:System.Diagnostics.Process>元件可以存取的資訊，包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>結束程序。  
  
 因為相關聯的處理序已結束，<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。 相反地，控制代碼可用來存取的處理序資源相關的作業系統的資訊。 系統所知的控點來結束處理程序尚未發行所<xref:System.Diagnostics.Process>元件，因此它會保留<xref:System.Diagnostics.Process.ExitTime%2A>並<xref:System.Diagnostics.Process.Handle%2A>資訊中記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。 基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>for<xref:System.Diagnostics.Process>執行個體，呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序終止為止，您不再需要任何系統管理相關資訊。 <xref:System.Diagnostics.Process.Close%2A> 釋放配置給結束的處理序的記憶體。  
  
   
  
## Examples  
 程式碼範例，請參閱<xref:System.Diagnostics.Process.ExitCode%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">無法存取等候設定。</exception>
        <exception cref="T:System.SystemException">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。  
  
-或- 
沒有任何與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。  
  
-或- 
您正在嘗試為遠端電腦上執行的處理序呼叫 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />。 這個方法僅適用於在本機電腦執行的處理序。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序進入閒置狀態。 這個多載只適用於具有使用者介面和訊息迴圈的處理序。</summary>
        <returns>如果相關聯處理序已經達到閒置狀態，則為 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle>強制您的應用程式等候，直到訊息迴圈已閒置狀態恢復處理。 當具有使用者介面的程序正在執行時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。 此程序則會傳回至訊息迴圈。 處理程序即處於閒置狀態，當它正在等候訊息迴圈內的訊息。 此狀態時很有用，例如，您的應用程式必須等候完成建立其主視窗，才能在應用程式傳送與該視窗啟動的處理序。  
  
 如果沒有訊息迴圈，處理程序。<xref:System.Diagnostics.Process.WaitForInputIdle>會擲回<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle>多載會指示<xref:System.Diagnostics.Process>無限期地等待處理序變成閒置訊息迴圈中的元件。 此指令，可能會造成停止回應的應用程式。 例如，如果處理程序撰寫為永遠其訊息迴圈立即結束，如程式碼片段所示`while(true)`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序沒有圖形化介面。  
  
-或- 
發生未知的錯誤。 處理序無法進入閒置狀態。  
  
-或- 
處理程序已經結束。  
  
-或- 
沒有和這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">1 到 <see cref="F:System.Int32.MaxValue" /> 的值，指定等候相關聯處理序變成閒置的時間 (毫秒)。 值為 0 時，指定立即傳回，而值為 -1 時則指定無限期等候。</param>
        <summary>讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態的指定毫秒數。 這個多載只適用於具有使用者介面和訊息迴圈的處理序。</summary>
        <returns>如果相關聯處理序已經達到閒置狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>強制您的應用程式等候，直到訊息迴圈已閒置狀態恢復處理。 當具有使用者介面的程序正在執行時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。 此程序則會傳回至訊息迴圈。 處理程序即處於閒置狀態，當它正在等候訊息迴圈內的訊息。 此狀態時很有用，例如，您的應用程式必須等候完成建立其主視窗，才能在應用程式傳送與該視窗啟動的處理序。  
  
 如果沒有訊息迴圈，處理程序。<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>會擲回<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>多載會指示<xref:System.Diagnostics.Process>元件等候一段有限的處理序變成閒置訊息迴圈中的時間。 相關聯的處理序已不變成閒置狀態時的時間間隔結束迴圈仍在處理訊息，因為`false`會傳回到呼叫的程序。  
  
 如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">處理序沒有圖形化介面。  
  
-或- 
發生未知的錯誤。 處理序無法進入閒置狀態。  
  
-或- 
處理程序已經結束。  
  
-或- 
沒有和這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得相關處理序的實體記憶體使用量 (以位元組為單位)。</summary>
        <value>相關的處理序正在使用的實體記憶體的總量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值表示目前的工作集由處理序，以位元組為單位的記憶體大小。 處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。 這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用的資料。 共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。  
  
   
  
## Examples  
 下列範例會啟動 「 記事本 」 的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示該處理序的結束代碼。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得配置給關聯處理序的實體記憶體量，以位元組為單位。</summary>
        <value>配置給關聯處理序的實體記憶體量，以位元組為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性所傳回的值表示目前的工作集由處理序，以位元組為單位的記憶體大小。 處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。 這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。  
  
 工作集包括共用和私用的資料。 共用的資料包含頁面包含所有處理序執行，包括指示處理序模組和系統程式庫中的指示。  
  
 這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。 屬性值相當於**工作組**處理程序的效能計數器。  
  
   
  
## Examples  
 下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。 此範例會擷取並顯示相關聯的處理序的各種屬性。 在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>