<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="67628b4e8ee5ca6153c80b553dc136354165e028" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52598950" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="31dae-101">提供對本機和遠端處理序的存取，並讓您能夠啟動和停止本機系統處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-101">Provides access to local and remote processes and enables you to start and stop local system processes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-102">A<xref:System.Diagnostics.Process>元件提供存取權的電腦執行的處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-102">A <xref:System.Diagnostics.Process> component provides access to a process that is running on a computer.</span></span> <span data-ttu-id="31dae-103">處理序，最簡單的說，是執行中應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-103">A process, in the simplest terms, is a running app.</span></span> <span data-ttu-id="31dae-104">執行緒是作業系統會配置處理器時間的基本單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-104">A thread is the basic unit to which the operating system allocates processor time.</span></span> <span data-ttu-id="31dae-105">執行緒可以執行此程序，包括部分由另一個執行緒目前正在執行的程式任何的碼部分。</span><span class="sxs-lookup"><span data-stu-id="31dae-105">A thread can execute any part of the code of the process, including parts currently being executed by another thread.</span></span>  
  
 <span data-ttu-id="31dae-106"><xref:System.Diagnostics.Process>元件是一個有用的工具來啟動、 停止、 控制和監視應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-106">The <xref:System.Diagnostics.Process> component is a useful tool for starting, stopping, controlling, and monitoring apps.</span></span> <span data-ttu-id="31dae-107">您可以使用<xref:System.Diagnostics.Process>元件，以取得正在執行的處理程序的清單，或者您可以啟動新的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-107">You can use the <xref:System.Diagnostics.Process> component, to obtain a list of the processes that are running, or you can start a new process.</span></span> <span data-ttu-id="31dae-108">A<xref:System.Diagnostics.Process>元件用來存取系統處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-108">A <xref:System.Diagnostics.Process> component is used to access system processes.</span></span> <span data-ttu-id="31dae-109">之後<xref:System.Diagnostics.Process>元件已經初始化，它可以用來取得執行程序的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-109">After a <xref:System.Diagnostics.Process> component has been initialized, it can be used to obtain information about the running process.</span></span> <span data-ttu-id="31dae-110">這類資訊包括的執行緒，載入的模組 （.dll 和.exe 檔案），並使用效能資訊，例如處理程序的記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="31dae-110">Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.</span></span>  
  
 <span data-ttu-id="31dae-111">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="31dae-111">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="31dae-112">當您完成使用型別時，您應該處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="31dae-112">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="31dae-113">若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="31dae-113">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`finally` block.</span></span> <span data-ttu-id="31dae-114">若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="31dae-114">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="31dae-115">如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="31dae-115">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-116">32 位元處理序無法存取 64 位元處理序的模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-116">32-bit processes cannot access the modules of a 64-bit process.</span></span> <span data-ttu-id="31dae-117">如果您嘗試從 32 位元處理序取得 64 位元處理程序的相關資訊，您會收到<xref:System.ComponentModel.Win32Exception>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-117">If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception.</span></span> <span data-ttu-id="31dae-118">相反地，64 位元處理程序，可以存取 32 位元處理序的模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-118">A 64-bit process, on the other hand, can access the modules of a 32-bit process.</span></span>  
  
 <span data-ttu-id="31dae-119">處理序元件會取得一組屬性的相關資訊全部一次。</span><span class="sxs-lookup"><span data-stu-id="31dae-119">The process component obtains information about a group of properties all at once.</span></span> <span data-ttu-id="31dae-120">在後<xref:System.Diagnostics.Process>元件已取得的任何群組的一個成員的相關資訊，它會快取該群組中的其他屬性的值，並無法取得群組的其他成員相關的新資訊，直到您呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-120">After the <xref:System.Diagnostics.Process> component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="31dae-121">因此，如果屬性值不保證能夠比上次呼叫任何新<xref:System.Diagnostics.Process.Refresh%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-121">Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="31dae-122">群組之細項具有作業系統相依性。</span><span class="sxs-lookup"><span data-stu-id="31dae-122">The group breakdowns are operating-system dependent.</span></span>  
  
 <span data-ttu-id="31dae-123">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-123">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="31dae-124">否則，系統將無法找到路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-124">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="31dae-125">例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="31dae-125">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
 <span data-ttu-id="31dae-126">系統處理序是以唯一識別系統上處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-126">A system process is uniquely identified on the system by its process identifier.</span></span> <span data-ttu-id="31dae-127">就像許多 Windows 資源，其控制代碼，可能不是唯一的電腦上也會識別處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-127">Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer.</span></span> <span data-ttu-id="31dae-128">控制代碼是資源的泛型的詞彙，識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-128">A handle is the generic term for an identifier of a resource.</span></span> <span data-ttu-id="31dae-129">作業系統仍然存在處理序控制代碼，可透過<xref:System.Diagnostics.Process.Handle%2A>屬性<xref:System.Diagnostics.Process>元件，即使在處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-129">The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the <xref:System.Diagnostics.Process> component, even when the process has exited.</span></span> <span data-ttu-id="31dae-130">因此，您可以取得處理程序的系統管理資訊，例如<xref:System.Diagnostics.Process.ExitCode%2A>（通常是零的成功或非零的錯誤碼） 和<xref:System.Diagnostics.Process.ExitTime%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-130">Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>.</span></span> <span data-ttu-id="31dae-131">控制代碼會是非常重要的資源，所以遺漏控制更 virulent 比流失記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-131">Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-132">這個類別包含的連結要求和繼承要求套用到所有成員的類別層級。</span><span class="sxs-lookup"><span data-stu-id="31dae-132">This class contains a link demand and an inheritance demand at the class level that applies to all members.</span></span> <span data-ttu-id="31dae-133">A<xref:System.Security.SecurityException>立即呼叫端或衍生的類別不具有完全信任權限時，會擲回。</span><span class="sxs-lookup"><span data-stu-id="31dae-133">A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission.</span></span> <span data-ttu-id="31dae-134">如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)。</span><span class="sxs-lookup"><span data-stu-id="31dae-134">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md).</span></span>  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] <span data-ttu-id="31dae-135">附註</span><span class="sxs-lookup"><span data-stu-id="31dae-135">Notes</span></span>  
 <span data-ttu-id="31dae-136">在.NET Framework 中，<xref:System.Diagnostics.Process>預設使用的類別<xref:System.Console>編碼方式，通常是程式碼頁的編碼方式，輸入、 輸出和錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-136">In the .NET Framework, the <xref:System.Diagnostics.Process> class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams.</span></span> <span data-ttu-id="31dae-137">取得範例程式碼，在系統上文化特性是英文 （美國），字碼頁 437 則是預設編碼方式<xref:System.Console>類別。</span><span class="sxs-lookup"><span data-stu-id="31dae-137">For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class.</span></span> <span data-ttu-id="31dae-138">不過，[!INCLUDE[net_core](~/includes/net-core-md.md)]可以提供可用的只有這些編碼方式的有限的子集。</span><span class="sxs-lookup"><span data-stu-id="31dae-138">However, [!INCLUDE[net_core](~/includes/net-core-md.md)] may make only a limited subset of these encodings available.</span></span> <span data-ttu-id="31dae-139">如果發生這種情況，它會使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>做為預設的編碼方式。</span><span class="sxs-lookup"><span data-stu-id="31dae-139">If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> as the default encoding.</span></span>  
  
 <span data-ttu-id="31dae-140">如果<xref:System.Diagnostics.Process>物件相依於特定字碼頁編碼方式，您仍然可以在它們可執行下列作業*之前*呼叫任何<xref:System.Diagnostics.Process>方法：</span><span class="sxs-lookup"><span data-stu-id="31dae-140">If a <xref:System.Diagnostics.Process> object depends on specific code page encodings, you can still make them available by doing the following *before* you call any <xref:System.Diagnostics.Process> methods:</span></span>  
  
1.  <span data-ttu-id="31dae-141">您可以將 System.Text.Encoding.CodePages.dll 組件的參考加入專案。</span><span class="sxs-lookup"><span data-stu-id="31dae-141">Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.</span></span>  
  
2.  <span data-ttu-id="31dae-142">擷取<xref:System.Text.EncodingProvider>物件從<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-142">Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> property.</span></span>  
  
3.  <span data-ttu-id="31dae-143">傳遞<xref:System.Text.EncodingProvider>物件至<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>進行編碼的提供者所支援的其他編碼的方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-143">Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> method to make the additional encodings supported by the encoding provider available.</span></span>  
  
 <span data-ttu-id="31dae-144"><xref:System.Diagnostics.Process>類別會再自動使用預設系統編碼方式 」，而不 UTF8，前提是您註冊編碼提供者之前呼叫任何<xref:System.Diagnostics.Process>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-144">The <xref:System.Diagnostics.Process> class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any <xref:System.Diagnostics.Process> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-145">下列範例使用的執行個體<xref:System.Diagnostics.Process>類別來啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-145">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 <span data-ttu-id="31dae-146">下列範例會使用<xref:System.Diagnostics.Process>類別本身和靜態<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-146">The following example uses the <xref:System.Diagnostics.Process> class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 <span data-ttu-id="31dae-147">下列F#範例會定義`runProc`啟動的處理序的函式會擷取所有輸出和錯誤的資訊，並記錄的程序執行的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="31dae-147">The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.</span></span>  <span data-ttu-id="31dae-148">`runProc`函式有三個參數： 若要啟動，引數提供給應用程式，並起始目錄的應用程式的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-148">The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.</span></span>  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 <span data-ttu-id="31dae-149">程式碼`runProc`函式由撰寫[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)而且經過[Microsoft 公用授權](https://opensource.org/licenses/ms-pl)。</span><span class="sxs-lookup"><span data-stu-id="31dae-149">The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](https://opensource.org/licenses/ms-pl).</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-150">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-150">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-151">這個類別不能由部分信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-151">This class cannot be used by partially trusted code.</span></span></permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="31dae-152">針對繼承者完全信任。</span><span class="sxs-lookup"><span data-stu-id="31dae-152">for full trust for inheritors.</span></span> <span data-ttu-id="31dae-153">這個類別無法繼承由部分信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-153">This class cannot be inherited by partially trusted code.</span></span></permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef"><span data-ttu-id="31dae-154">使用.NET Process 類別</span><span class="sxs-lookup"><span data-stu-id="31dae-154">Using the .NET Process Class</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-155">初始化 <see cref="T:System.Diagnostics.Process" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-155">Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-156">如果您未指定<xref:System.Diagnostics.Process.MachineName%2A>屬性，預設值為本機電腦 ("。")。</span><span class="sxs-lookup"><span data-stu-id="31dae-156">If you do not specify the <xref:System.Diagnostics.Process.MachineName%2A> property, the default is the local computer, (".").</span></span>  
  
 <span data-ttu-id="31dae-157">您有兩個選項可建立新的關聯<xref:System.Diagnostics.Process>元件之電腦上的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-157">You have two options for associating a new <xref:System.Diagnostics.Process> component with a process on the computer.</span></span> <span data-ttu-id="31dae-158">第一個選項是使用建構函式來建立<xref:System.Diagnostics.Process>元件，設定的適當成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性並呼叫<xref:System.Diagnostics.Process.Start%2A>關聯<xref:System.Diagnostics.Process>與新的系統處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-158">The first option is to use the constructor to create the <xref:System.Diagnostics.Process> component, set the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and call <xref:System.Diagnostics.Process.Start%2A> to associate the <xref:System.Diagnostics.Process> with a new system process.</span></span> <span data-ttu-id="31dae-159">第二個選項是將建立關聯<xref:System.Diagnostics.Process>執行的系統程序，利用<xref:System.Diagnostics.Process.GetProcessById%2A>或其中一個<xref:System.Diagnostics.Process.GetProcesses%2A>傳回值。</span><span class="sxs-lookup"><span data-stu-id="31dae-159">The second option is to associate the <xref:System.Diagnostics.Process> with a running system process by using <xref:System.Diagnostics.Process.GetProcessById%2A> or one of the <xref:System.Diagnostics.Process.GetProcesses%2A> return values.</span></span>  
  
 <span data-ttu-id="31dae-160">如果您使用`static`多載<xref:System.Diagnostics.Process.Start%2A>方法來啟動新的系統處理序方法建立新<xref:System.Diagnostics.Process>元件，並產生關聯的處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-160">If you use a `static` overload of the <xref:System.Diagnostics.Process.Start%2A> method to start a new system process, the method creates a new <xref:System.Diagnostics.Process> component and associates it with the process.</span></span>  
  
 <span data-ttu-id="31dae-161">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>屬性設定為其預設值`true`，您可以使用類似的方式啟動應用程式和文件`Run`對話方塊中的 Windows`Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="31dae-161">When the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> property is set to its default value, `true`, you can start applications and documents in a way that is similar to using the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="31dae-162">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>是`false`，您可以開始只可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-162">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> is `false`, you can start only executables.</span></span>  
  
 <span data-ttu-id="31dae-163">您可以從命令列呼叫任何可執行檔可以啟動兩種方式之一： 藉由設定適當的成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>方法使用任何參數，或藉由傳遞至適當的參數`static` <xref:System.Diagnostics.Process.Start%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-163">Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and calling the <xref:System.Diagnostics.Process.Start%2A> method with no parameters, or by passing the appropriate parameter to the `static`<xref:System.Diagnostics.Process.Start%2A> member.</span></span>  
  
 <span data-ttu-id="31dae-164">您可以建立<xref:System.Diagnostics.Process>元件所使用的建構函式，其中一個靜態<xref:System.Diagnostics.Process.Start%2A>多載，或任何<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcesses%2A>，或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-164">You can create a <xref:System.Diagnostics.Process> component by using the constructor, one of the static <xref:System.Diagnostics.Process.Start%2A> overloads, or any of the <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, or <xref:System.Diagnostics.Process.GetProcessesByName%2A> methods.</span></span> <span data-ttu-id="31dae-165">完成此動作之後，您會有相關聯的處理序的檢視。</span><span class="sxs-lookup"><span data-stu-id="31dae-165">After you have done so, you have a view into the associated process.</span></span> <span data-ttu-id="31dae-166">這不是在記憶體中處理序屬性變更時自動更新本身的動態檢視。</span><span class="sxs-lookup"><span data-stu-id="31dae-166">This is not a dynamic view that updates itself automatically when the process properties have changed in memory.</span></span> <span data-ttu-id="31dae-167">相反地，您必須呼叫<xref:System.Diagnostics.Process.Refresh%2A>更新元件<xref:System.Diagnostics.Process>應用程式中的屬性資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-167">Instead, you must call <xref:System.Diagnostics.Process.Refresh%2A> for the component to update the <xref:System.Diagnostics.Process> property information in your application.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-168">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-168">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-169">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-169">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-170">取得相關處理序的基礎優先權 (Base Priority)。</span><span class="sxs-lookup"><span data-stu-id="31dae-170">Gets the base priority of the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-171">基礎優先權，它是從相關聯處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 計算出來的。</span><span class="sxs-lookup"><span data-stu-id="31dae-171">The base priority, which is computed from the <see cref="P:System.Diagnostics.Process.PriorityClass" /> of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-172"><xref:System.Diagnostics.Process.BasePriority%2A>程序是針對相關聯的處理序中建立的執行緒開始的優先順序。</span><span class="sxs-lookup"><span data-stu-id="31dae-172">The <xref:System.Diagnostics.Process.BasePriority%2A> of the process is the starting priority for threads created within the associated process.</span></span> <span data-ttu-id="31dae-173">您可以檢視的基底的優先順序，透過 「 系統監視器的優先權基底計數器的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-173">You can view information about the base priority through the System Monitor's Priority Base counter.</span></span>  
  
 <span data-ttu-id="31dae-174">根據 24 小時制或其他的增加，作業系統可以變更的基底的優先順序，當處理程序應該放置領先其他人的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-174">Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</span></span>  
  
 <span data-ttu-id="31dae-175"><xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視指派給處理程序的起始優先權。</span><span class="sxs-lookup"><span data-stu-id="31dae-175">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority assigned to a process.</span></span> <span data-ttu-id="31dae-176">不過，因為它是唯讀的您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>設定程序的優先順序。</span><span class="sxs-lookup"><span data-stu-id="31dae-176">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> to set the priority of the process.</span></span> <span data-ttu-id="31dae-177">若要變更的優先順序，使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-177">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property.</span></span> <span data-ttu-id="31dae-178"><xref:System.Diagnostics.Process.BasePriority%2A>就可以使用 「 系統監視器，而<xref:System.Diagnostics.Process.PriorityClass%2A>不是。</span><span class="sxs-lookup"><span data-stu-id="31dae-178">The <xref:System.Diagnostics.Process.BasePriority%2A> is viewable using the System Monitor, while the <xref:System.Diagnostics.Process.PriorityClass%2A> is not.</span></span> <span data-ttu-id="31dae-179">同時<xref:System.Diagnostics.Process.BasePriority%2A>而<xref:System.Diagnostics.Process.PriorityClass%2A>可以以程式設計方式檢視。</span><span class="sxs-lookup"><span data-stu-id="31dae-179">Both the <xref:System.Diagnostics.Process.BasePriority%2A> and the <xref:System.Diagnostics.Process.PriorityClass%2A> can be viewed programmatically.</span></span> <span data-ttu-id="31dae-180">下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>值和<xref:System.Diagnostics.Process.PriorityClass%2A>值。</span><span class="sxs-lookup"><span data-stu-id="31dae-180">The following table shows the relationship between <xref:System.Diagnostics.Process.BasePriority%2A> values and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="31dae-181">BasePriority</span><span class="sxs-lookup"><span data-stu-id="31dae-181">BasePriority</span></span>|<span data-ttu-id="31dae-182">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="31dae-182">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="31dae-183">4</span><span class="sxs-lookup"><span data-stu-id="31dae-183">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="31dae-184">8</span><span class="sxs-lookup"><span data-stu-id="31dae-184">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="31dae-185">13</span><span class="sxs-lookup"><span data-stu-id="31dae-185">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="31dae-186">24</span><span class="sxs-lookup"><span data-stu-id="31dae-186">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="31dae-187">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-187">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-188">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-188">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-189">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-189">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-190">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-190">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-191">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-191">The process has exited.</span></span>  
  
<span data-ttu-id="31dae-192">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-192">-or-</span></span> 
<span data-ttu-id="31dae-193">處理序尚未啟動，因此沒有處理序 ID。</span><span class="sxs-lookup"><span data-stu-id="31dae-193">The process has not started, so there is no process ID.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-194">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-194">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-195">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-195">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-196">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上開始非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-196">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-197"><xref:System.Diagnostics.Process.StandardError%2A>可以讀取資料流，同步或非同步。</span><span class="sxs-lookup"><span data-stu-id="31dae-197">The <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="31dae-198">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的錯誤輸出資料流同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-198">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="31dae-199">這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-199">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="31dae-200">相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-200">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="31dae-201">這個方法可讓資料流輸出的指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-201">This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="31dae-202">請遵循下列步驟來執行非同步讀取的操作<xref:System.Diagnostics.Process.StandardError%2A>針對<xref:System.Diagnostics.Process>:</span><span class="sxs-lookup"><span data-stu-id="31dae-202">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="31dae-203">請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="31dae-203">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="31dae-204">請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-204">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="31dae-205">新增您的事件處理常式來<xref:System.Diagnostics.Process.ErrorDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-205">Add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event.</span></span> <span data-ttu-id="31dae-206">事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。</span><span class="sxs-lookup"><span data-stu-id="31dae-206">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="31dae-207">啟動<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="31dae-207">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="31dae-208">呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>針對<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="31dae-208">Call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="31dae-209">在此呼叫會啟動的非同步讀取的作業<xref:System.Diagnostics.Process.StandardError%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-209">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span>  
  
 <span data-ttu-id="31dae-210">當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>寫入一行文字到其<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-210">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-211">您可以取消非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-211">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span> <span data-ttu-id="31dae-212">您可以取消讀取的作業，由呼叫端或事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-212">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="31dae-213">之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>一次，繼續非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-213">After canceling, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-214">您不能混用重新導向的資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-214">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="31dae-215">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。</span><span class="sxs-lookup"><span data-stu-id="31dae-215">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="31dae-216">例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，或反之亦然。</span><span class="sxs-lookup"><span data-stu-id="31dae-216">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="31dae-217">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-217">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="31dae-218">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-218">For example, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-219">下列範例會使用`net view`命令來列出可用的網路資源，在遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-219">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="31dae-220">使用者所提供的目標電腦名稱做為命令列引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-220">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="31dae-221">使用者也可以提供錯誤輸出的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-221">The user can also supply a file name for error output.</span></span> <span data-ttu-id="31dae-222">此範例會收集的 net 命令、 等候處理序完成，然後再寫入至主控台的輸出結果的輸出。</span><span class="sxs-lookup"><span data-stu-id="31dae-222">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="31dae-223">如果使用者所提供的選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-223">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-224"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-224">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="31dae-225">\-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-225">\- or -</span></span> 
<span data-ttu-id="31dae-226">非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上進行。</span><span class="sxs-lookup"><span data-stu-id="31dae-226">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span>  
  
<span data-ttu-id="31dae-227">\-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-227">\- or -</span></span> 
<span data-ttu-id="31dae-228">同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-228">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-229">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-229">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-230">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-230">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-231">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上開始非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-231">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-232"><xref:System.Diagnostics.Process.StandardOutput%2A>可以讀取資料流，同步或非同步。</span><span class="sxs-lookup"><span data-stu-id="31dae-232">The <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="31dae-233">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-233">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="31dae-234">這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-234">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="31dae-235">相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-235">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-236">這個方法可讓資料流輸出指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-236">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="31dae-237">請遵循下列步驟來執行非同步讀取的操作<xref:System.Diagnostics.Process.StandardOutput%2A>針對<xref:System.Diagnostics.Process>:</span><span class="sxs-lookup"><span data-stu-id="31dae-237">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="31dae-238">請設定 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 為 `false`。</span><span class="sxs-lookup"><span data-stu-id="31dae-238">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="31dae-239">請設定 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-239">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="31dae-240">新增您的事件處理常式來<xref:System.Diagnostics.Process.OutputDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-240">Add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="31dae-241">事件處理常式必須符合<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委派簽章。</span><span class="sxs-lookup"><span data-stu-id="31dae-241">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="31dae-242">啟動<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="31dae-242">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="31dae-243">呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>針對<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="31dae-243">Call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="31dae-244">在此呼叫會啟動的非同步讀取的作業<xref:System.Diagnostics.Process.StandardOutput%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-244">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span>  
  
 <span data-ttu-id="31dae-245">當非同步讀取的作業開始時，事件處理常式會呼叫每個時間相關聯<xref:System.Diagnostics.Process>寫入一行文字到其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-245">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-246">您可以取消非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-246">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span> <span data-ttu-id="31dae-247">您可以取消讀取的作業，由呼叫端或事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-247">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="31dae-248">之後取消，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>一次，繼續非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-248">After canceling, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-249">您不能混用重新導向的資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-249">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="31dae-250">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。</span><span class="sxs-lookup"><span data-stu-id="31dae-250">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="31dae-251">例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，或反之亦然。</span><span class="sxs-lookup"><span data-stu-id="31dae-251">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="31dae-252">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-252">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="31dae-253">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-253">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-254">下列範例說明如何執行非同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>的資料流`sort`命令。</span><span class="sxs-lookup"><span data-stu-id="31dae-254">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command.</span></span> <span data-ttu-id="31dae-255">`sort`命令是主控台應用程式讀取及排序文字輸入。</span><span class="sxs-lookup"><span data-stu-id="31dae-255">The `sort` command is a console application that reads and sorts text input.</span></span>  
  
 <span data-ttu-id="31dae-256">此範例會建立事件的委派`SortOutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-256">The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="31dae-257">事件處理常式收到文字行的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將文字寫入至螢幕。</span><span class="sxs-lookup"><span data-stu-id="31dae-257">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-258"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 屬性為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-258">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="31dae-259">\-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-259">\- or -</span></span> 
<span data-ttu-id="31dae-260">非同步讀取作業已在 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上進行。</span><span class="sxs-lookup"><span data-stu-id="31dae-260">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span>  
  
<span data-ttu-id="31dae-261">\-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-261">\- or -</span></span> 
<span data-ttu-id="31dae-262">同步讀取作業已使用此 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-262">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-263">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-263">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-264">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-264">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-265">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流上取消非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-265">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-266"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-266"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="31dae-267"><xref:System.Diagnostics.Process.CancelErrorRead%2A> 結束非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-267"><xref:System.Diagnostics.Process.CancelErrorRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="31dae-268">之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>一次。</span><span class="sxs-lookup"><span data-stu-id="31dae-268">After canceling, you can resume the asynchronous read operation by calling <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="31dae-269">當您呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>，則所有進行中讀取作業的<xref:System.Diagnostics.Process.StandardError%2A>完成，則會停用事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-269">When you call <xref:System.Diagnostics.Process.CancelErrorRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardError%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="31dae-270">所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardError%2A>會儲存在緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="31dae-270">All further redirected output to <xref:System.Diagnostics.Process.StandardError%2A> is saved in a buffer.</span></span> <span data-ttu-id="31dae-271">如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、 已儲存的輸出會傳送至事件處理常式和非同步讀取的作業繼續。</span><span class="sxs-lookup"><span data-stu-id="31dae-271">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="31dae-272">如果您想要變更的事件處理常式，再繼續非同步讀取的作業，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：</span><span class="sxs-lookup"><span data-stu-id="31dae-272">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="31dae-273">您不能混合非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-273">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="31dae-274">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。</span><span class="sxs-lookup"><span data-stu-id="31dae-274">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="31dae-275">如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>，然後從資料流讀取一次，您必須使用需要<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>繼續非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-275">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardError%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="31dae-276">請勿遵循<xref:System.Diagnostics.Process.CancelErrorRead%2A>同步呼叫讀取方法<xref:System.Diagnostics.Process.StandardError%2A>這類<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-276">Do not follow <xref:System.Diagnostics.Process.CancelErrorRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardError%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-277">下列範例會啟動`nmake`命令與使用者提供的引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-277">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="31dae-278">以非同步的方式; 讀取的錯誤和輸出資料流收集到的文字行會顯示到主控台，以及寫入記錄檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-278">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="31dae-279">如果命令輸出超過指定的行數，則會取消非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-279">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-280">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-280">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-281">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-281">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-282">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-282">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-283">在應用程式的重新導向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流上取消非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-283">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-284"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 開始非同步讀取作業<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-284"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-285"><xref:System.Diagnostics.Process.CancelOutputRead%2A> 結束非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-285"><xref:System.Diagnostics.Process.CancelOutputRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="31dae-286">之後取消，您可以繼續非同步讀取的作業，藉由呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>一次。</span><span class="sxs-lookup"><span data-stu-id="31dae-286">After canceling, you can resume asynchronous read operations by calling <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="31dae-287">當您呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>，則所有進行中讀取作業的<xref:System.Diagnostics.Process.StandardOutput%2A>完成，則會停用事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-287">When you call <xref:System.Diagnostics.Process.CancelOutputRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardOutput%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="31dae-288">所有進一步重新導向輸出至<xref:System.Diagnostics.Process.StandardOutput%2A>會儲存在緩衝區中。</span><span class="sxs-lookup"><span data-stu-id="31dae-288">All further redirected output to <xref:System.Diagnostics.Process.StandardOutput%2A> is saved in a buffer.</span></span> <span data-ttu-id="31dae-289">如果您重新啟用事件處理常式呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、 已儲存的輸出會傳送至事件處理常式和非同步讀取的作業繼續。</span><span class="sxs-lookup"><span data-stu-id="31dae-289">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="31dae-290">如果您想要變更的事件處理常式，再繼續非同步讀取的作業，您必須移除現有的事件處理常式，然後再加入新的事件處理常式：</span><span class="sxs-lookup"><span data-stu-id="31dae-290">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="31dae-291">您不能混合非同步和同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-291">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-292">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。</span><span class="sxs-lookup"><span data-stu-id="31dae-292">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="31dae-293">如果您取消非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>，然後從資料流讀取一次，您必須使用需要<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>繼續非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-293">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardOutput%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="31dae-294">請勿遵循<xref:System.Diagnostics.Process.CancelOutputRead%2A>同步呼叫讀取方法<xref:System.Diagnostics.Process.StandardOutput%2A>這類<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-294">Do not follow <xref:System.Diagnostics.Process.CancelOutputRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardOutput%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-295">下列範例會啟動`nmake`命令與使用者提供的引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-295">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="31dae-296">以非同步的方式; 讀取的錯誤和輸出資料流收集到的文字行會顯示到主控台，以及寫入記錄檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-296">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="31dae-297">如果命令輸出超過指定的行數，則會取消非同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-297">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-298">未因非同步讀取作業之故開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-298">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-299">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-299">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-300">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-300">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-301">釋放與這個元件相關的所有資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-301">Frees all the resources that are associated with this component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-302"><xref:System.Diagnostics.Process.Close%2A>方法會導致處理序停止等候結束等候它，如果關閉處理序控制代碼，而且清除處理序專屬的屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-302">The <xref:System.Diagnostics.Process.Close%2A> method causes the process to stop waiting for exit if it was waiting, closes the process handle, and clears process-specific properties.</span></span> <span data-ttu-id="31dae-303"><xref:System.Diagnostics.Process.Close%2A> 不會關閉標準輸出、 輸入和錯誤的讀取器和寫入器，以防它們外部參考。</span><span class="sxs-lookup"><span data-stu-id="31dae-303"><xref:System.Diagnostics.Process.Close%2A> does not close the standard output, input, and error readers and writers in case they are being referenced externally.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-304"><xref:System.Diagnostics.Process.Dispose%2A> 方法呼叫 <xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-304">The <xref:System.Diagnostics.Process.Dispose%2A> method calls <xref:System.Diagnostics.Process.Close%2A>.</span></span> <span data-ttu-id="31dae-305">放置<xref:System.Diagnostics.Process>中的物件`using`區塊處置的資源，而不需要呼叫<xref:System.Diagnostics.Process.Close%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-305">Placing the <xref:System.Diagnostics.Process> object in a `using` block disposes of resources without the need to call <xref:System.Diagnostics.Process.Close%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-306">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-306">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-307">然後，它會擷取相關聯的處理序的實體記憶體使用量在 2 秒的間隔，最多 10 秒。</span><span class="sxs-lookup"><span data-stu-id="31dae-307">It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="31dae-308">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="31dae-308">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="31dae-309">如果它仍在執行 10 秒後，範例就會關閉程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-309">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-310">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-310">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-311">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-311">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-312">關閉有使用者介面的處理序，方法是傳送關閉訊息至其主視窗。</span><span class="sxs-lookup"><span data-stu-id="31dae-312">Closes a process that has a user interface by sending a close message to its main window.</span></span></summary>
        <returns><span data-ttu-id="31dae-313">如果已成功傳送關閉訊息，則為 <see langword="true" />；如果相關聯處理序沒有主視窗或主視窗已停用 (例如，如果正在顯示強制回應對話方塊)，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-313"><see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-314">當處理程序執行時，其訊息迴圈就會處於等候狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-314">When a process is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="31dae-315">每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="31dae-315">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="31dae-316">呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>傳送要求以接近主視窗中，這在格式正確的應用程式中，關閉子視窗，並撤銷應用程式的所有執行訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="31dae-316">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="31dae-317">結束藉由呼叫的程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-317">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="31dae-318">應用程式可以要求使用者確認之前結束，或者它可以拒絕結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-318">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="31dae-319">若要強制應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-319">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="31dae-320">行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗中使用 [系統] 功能表的使用者。</span><span class="sxs-lookup"><span data-stu-id="31dae-320">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="31dae-321">因此，藉由關閉主視窗結束程序要求不會強制應用程式立即結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-321">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
 <span data-ttu-id="31dae-322">編輯程序的資料或資源配置給處理程序不會遺失您呼叫<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-322">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-323"><xref:System.Diagnostics.Process.Kill%2A> 會造成異常的程序終止時，而且應該在必要時才使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-323"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination, and should be used only when necessary.</span></span> <span data-ttu-id="31dae-324"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此很適合使用介面的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-324"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="31dae-325">如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-325">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="31dae-326"><xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="31dae-326"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="31dae-327">您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-327">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="31dae-328">您無法使處理序結束的遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-328">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="31dae-329">您只能檢視在遠端電腦上執行的程序資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-329">You can only view information for processes running on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-330">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-330">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-331">然後，它會擷取相關聯的處理序的實體記憶體使用量在 10 秒，最多達 2 秒的間隔。</span><span class="sxs-lookup"><span data-stu-id="31dae-331">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="31dae-332">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="31dae-332">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="31dae-333">如果它仍在執行 10 秒後，範例就會關閉程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-333">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-334">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-334">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-335">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-335">The process has already exited.</span></span>  
  
<span data-ttu-id="31dae-336">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-336">-or-</span></span> 
<span data-ttu-id="31dae-337">沒有和這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-337">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-338">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-338">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-339">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-339">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="31dae-340"><see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-340"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="31dae-341">釋放這個處理序使用的所有資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-341">Release all resources used by this process.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-342">取得或設定是否應該在處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-342">Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</span></span></summary>
        <value><span data-ttu-id="31dae-343">如果應該在相關聯處理序終止時引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件 (經由結束或呼叫 <see cref="M:System.Diagnostics.Process.Kill" />)，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-343"><see langword="true" /> if the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the associated process is terminated (through either an exit or a call to <see cref="M:System.Diagnostics.Process.Kill" />); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="31dae-344">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-344">The default is <see langword="false" />.</span></span> <span data-ttu-id="31dae-345">請注意，<see cref="E:System.Diagnostics.Process.Exited" />就會引發事件，即使的值<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />是<see langword="false" />期間的處理序結束時，或使用者執行前<see cref="P:System.Diagnostics.Process.HasExited" />檢查。</span><span class="sxs-lookup"><span data-stu-id="31dae-345">Note that the <see cref="E:System.Diagnostics.Process.Exited" /> event is raised even if the value of <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> is <see langword="false" /> when the process exits during or before the user performs a <see cref="P:System.Diagnostics.Process.HasExited" /> check.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="31dae-346"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性表示作業系統已關閉程序時，是否應該收到通知的元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-346">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property suggests whether the component should be notified when the operating system has shut down a process.</span></span> <span data-ttu-id="31dae-347"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性來通知您的處理序已結束的應用程式時，會在非同步處理。</span><span class="sxs-lookup"><span data-stu-id="31dae-347">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is used in asynchronous processing to notify your application that a process has exited.</span></span> <span data-ttu-id="31dae-348">若要強制您的應用程式來同步等候結束事件 （會中斷應用程式的處理，直到結束事件已發生），使用<xref:System.Diagnostics.Process.WaitForExit%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-348">To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the <xref:System.Diagnostics.Process.WaitForExit%2A> method.</span></span>

> [!NOTE]
> <span data-ttu-id="31dae-349">如果您使用 Visual Studio，然後按兩下<xref:System.Diagnostics.Process>元件在專案中，<xref:System.Diagnostics.Process.Exited>事件委派和事件處理常式會自動產生。</span><span class="sxs-lookup"><span data-stu-id="31dae-349">If you're using Visual Studio and double-click a <xref:System.Diagnostics.Process> component in your project, an <xref:System.Diagnostics.Process.Exited> event delegate and event handler are automatically generated.</span></span> <span data-ttu-id="31dae-350">額外的程式碼集<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性設`false`。</span><span class="sxs-lookup"><span data-stu-id="31dae-350">Additional code sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to `false`.</span></span> <span data-ttu-id="31dae-351">您必須變更此屬性為`true`相關聯的處理序結束時，要執行事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-351">You must change this property to `true` for your event handler to execute when the associated process exits.</span></span>

<span data-ttu-id="31dae-352">如果元件<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>值是`true`，或當<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`false`和<xref:System.Diagnostics.Process.HasExited%2A>檢查會叫用元件，元件可以存取相關聯的處理程序會維持系統管理資訊由作業系統所儲存。</span><span class="sxs-lookup"><span data-stu-id="31dae-352">If the component's <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> value is `true`, or when <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `false` and a <xref:System.Diagnostics.Process.HasExited%2A> check is invoked by the component, the component can access the administrative information for the associated process, which remains stored by the operating system.</span></span> <span data-ttu-id="31dae-353">這類資訊包括<xref:System.Diagnostics.Process.ExitTime%2A>而<xref:System.Diagnostics.Process.ExitCode%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-353">Such information includes the <xref:System.Diagnostics.Process.ExitTime%2A> and the <xref:System.Diagnostics.Process.ExitCode%2A>.</span></span>

<span data-ttu-id="31dae-354">相關聯的處理序結束之後，<xref:System.Diagnostics.Process.Handle%2A>的元件不會再指向現有的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-354">After the associated process exits, the <xref:System.Diagnostics.Process.Handle%2A> of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="31dae-355">相反地，它只可用來存取的處理序資源相關的作業系統的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-355">Instead, it can only be used to access the operating system's information about the process resource.</span></span> <span data-ttu-id="31dae-356">作業系統是感知有未發行的結束處理程序的控制代碼<xref:System.Diagnostics.Process>元件，因此它會保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>在記憶體中的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-356">The operating system is aware that there are handles to exited processes that haven't been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory.</span></span>

<span data-ttu-id="31dae-357">沒有相關聯的處理序結束監看的成本。</span><span class="sxs-lookup"><span data-stu-id="31dae-357">There's a cost associated with watching for a process to exit.</span></span> <span data-ttu-id="31dae-358">如果<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>已`true`，則<xref:System.Diagnostics.Process.Exited>相關聯的處理序終止時，會引發事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-358">If <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `true`, the <xref:System.Diagnostics.Process.Exited> event is raised when the associated process terminates.</span></span> <span data-ttu-id="31dae-359">您的程序<xref:System.Diagnostics.Process.Exited>在該時間執行的事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-359">Your procedures for the <xref:System.Diagnostics.Process.Exited> event run at that time.</span></span>

<span data-ttu-id="31dae-360">有時候，您的應用程式啟動的處理序，但不需要其 closure 的通知。</span><span class="sxs-lookup"><span data-stu-id="31dae-360">Sometimes, your application starts a process but doesn't require notification of its closure.</span></span> <span data-ttu-id="31dae-361">例如，您的應用程式可以啟動 [記事本]，以允許使用者執行的文字編輯，但沒有進一步讓使用 「 記事本 」 應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-361">For example, your application can start Notepad to allow the user to perform text editing but make no further use of the Notepad application.</span></span> <span data-ttu-id="31dae-362">您可以選擇以避免處理序結束，因為它不是與您的應用程式的持續運作時的通知。</span><span class="sxs-lookup"><span data-stu-id="31dae-362">You can choose to avoid notification when the process exits because it's not relevant to the continued operation of your application.</span></span> <span data-ttu-id="31dae-363">設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>至`false`可以節省系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-363">Setting <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> to `false` can save system resources.</span></span>

## Examples  
<span data-ttu-id="31dae-364">下列程式碼範例會建立會列印檔案的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-364">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="31dae-365">它會設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性，讓處理程序引發<xref:System.Diagnostics.Process.Exited>結束時的事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-365">It sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits.</span></span> <span data-ttu-id="31dae-366"><xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-366">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-367">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-367">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-368">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-368">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-369">啟用目前執行緒上的原生屬性 <see langword="SeDebugPrivilege" />，將 <see cref="T:System.Diagnostics.Process" /> 元件置於某種狀態，以便與使用特殊模式執行的作業系統處理序互動。</span><span class="sxs-lookup"><span data-stu-id="31dae-369">Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-370">某些作業系統處理程序以特殊模式執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-370">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="31dae-371">嘗試讀取的屬性，或附加至這些處理序不能除非您呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。</span><span class="sxs-lookup"><span data-stu-id="31dae-371">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="31dae-372">呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取權以特殊模式執行這些程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-372">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-373">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-373">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-374">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-374">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-375">發生於應用程式寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流時。</span><span class="sxs-lookup"><span data-stu-id="31dae-375">Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-376"><xref:System.Diagnostics.Process.ErrorDataReceived>事件可讓您表示相關聯的處理序已經寫入至其重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-376">The <xref:System.Diagnostics.Process.ErrorDataReceived> event indicates that the associated process has written to its redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-377">事件只發生在非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-377">The event only occurs during asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span> <span data-ttu-id="31dae-378">若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardError%2A>的資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式，來<xref:System.Diagnostics.Process.ErrorDataReceived>事件，並呼叫<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-378">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardError%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event, and call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</span></span> <span data-ttu-id="31dae-379">之後，<xref:System.Diagnostics.Process.ErrorDataReceived>事件訊號處理程序會將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardError%2A>串流處理，直到處理程序結束或呼叫<xref:System.Diagnostics.Process.CancelErrorRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-379">Thereafter, the <xref:System.Diagnostics.Process.ErrorDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-380">正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit>方法，以確保已排清輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="31dae-380">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit> method to ensure that the output buffer has been flushed.</span></span> <span data-ttu-id="31dae-381">請注意，使用該指定逾時<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>多載未*不*確保已排清輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="31dae-381">Note that specifying a timeout by using the <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> overload does *not* ensure the output buffer has been flushed.</span></span>
  
   
  
## Examples  
 <span data-ttu-id="31dae-382">下列範例會使用`net view`命令來列出可用的網路資源，在遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-382">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="31dae-383">使用者所提供的目標電腦名稱做為命令列引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-383">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="31dae-384">使用者也可以提供錯誤輸出的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-384">The user can also supply a file name for error output.</span></span> <span data-ttu-id="31dae-385">此範例會收集的 net 命令、 等候處理序完成，然後再寫入至主控台的輸出結果的輸出。</span><span class="sxs-lookup"><span data-stu-id="31dae-385">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="31dae-386">如果使用者所提供的選擇性的錯誤檔案，則此範例會將錯誤寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-386">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-387">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-387">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-388">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-388">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-389">取得相關處理序終止時指定的值。</span><span class="sxs-lookup"><span data-stu-id="31dae-389">Gets the value that the associated process specified when it terminated.</span></span></summary>
        <value><span data-ttu-id="31dae-390">相關處理序終止時指定的程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-390">The code that the associated process specified when it terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-391">使用<xref:System.Diagnostics.Process.ExitCode%2A>來取得系統處理序會傳回它結束時的狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-391">Use <xref:System.Diagnostics.Process.ExitCode%2A> to get the status that the system process returned when it exited.</span></span> <span data-ttu-id="31dae-392">您可以使用結束代碼更像是整數傳回的值從`main()`程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-392">You can use the exit code much like an integer return value from a `main()` procedure.</span></span>  
  
 <span data-ttu-id="31dae-393"><xref:System.Diagnostics.Process.ExitCode%2A>處理程序會反映該處理程序的應用程式開發人員所實作的特定慣例的值。</span><span class="sxs-lookup"><span data-stu-id="31dae-393">The <xref:System.Diagnostics.Process.ExitCode%2A> value for a process reflects the specific convention implemented by the application developer for that process.</span></span> <span data-ttu-id="31dae-394">如果您使用的結束代碼值在您的程式碼中進行決策時，務必知道您的應用程式處理序所使用的結束程式碼慣例。</span><span class="sxs-lookup"><span data-stu-id="31dae-394">If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</span></span>  
  
 <span data-ttu-id="31dae-395">開發人員通常會表示成功結束<xref:System.Diagnostics.Process.ExitCode%2A>值所呼叫的方法可用來找出異常的處理序終止原因的非零值零，且指定的錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-395">Developers usually indicate a successful exit by an <xref:System.Diagnostics.Process.ExitCode%2A> value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination.</span></span> <span data-ttu-id="31dae-396">您不需要遵循下列指導方針，但它們是慣例。</span><span class="sxs-lookup"><span data-stu-id="31dae-396">It is not necessary to follow these guidelines, but they are the convention.</span></span>  
  
 <span data-ttu-id="31dae-397">如果您嘗試取得<xref:System.Diagnostics.Process.ExitCode%2A>處理序已結束之前，嘗試就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-397">If you try to get the <xref:System.Diagnostics.Process.ExitCode%2A> before the process has exited, the attempt throws an exception.</span></span> <span data-ttu-id="31dae-398">檢查<xref:System.Diagnostics.Process.HasExited%2A>; 屬性第一次，確認是否已終止相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-398">Examine the <xref:System.Diagnostics.Process.HasExited%2A> property first to verify whether the associated process has terminated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-399">當非同步事件處理常式已重新導向標準輸出時，有可能，輸出處理尚未完成的時機<xref:System.Diagnostics.Process.HasExited%2A>傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-399">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when <xref:System.Diagnostics.Process.HasExited%2A> returns `true`.</span></span> <span data-ttu-id="31dae-400">若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前接受任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-400">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
 <span data-ttu-id="31dae-401">您可以使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>方法，讓相關聯的處理序結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-401">You can use the <xref:System.Diagnostics.Process.CloseMainWindow%2A> or the <xref:System.Diagnostics.Process.Kill%2A> method to cause an associated process to exit.</span></span>  
  
 <span data-ttu-id="31dae-402">有兩種方式的相關聯的處理序結束時所通知： 同步和非同步的方式。</span><span class="sxs-lookup"><span data-stu-id="31dae-402">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="31dae-403">同步通知依賴呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以暫停您的應用程式的處理，直到相關聯的元件會結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-403">Synchronous notification relies on calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to pause the processing of your application until the associated component exits.</span></span> <span data-ttu-id="31dae-404">非同步通知依賴<xref:System.Diagnostics.Process.Exited>事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-404">Asynchronous notification relies on the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="31dae-405">使用非同步通知時<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`如<xref:System.Diagnostics.Process>元件來接收通知的處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-405">When using asynchronous notification, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the <xref:System.Diagnostics.Process> component to receive notification that the process has exited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-406">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-406">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-407">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-407">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-408">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-408">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-409">遠端處理序尚未結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-409">The process has not exited.</span></span>  
  
<span data-ttu-id="31dae-410">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-410">-or-</span></span> 
<span data-ttu-id="31dae-411">處理序 <see cref="P:System.Diagnostics.Process.Handle" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-411">The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-412">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-412">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-413">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-413">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-414">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-414">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-415">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-415">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-416">發生於處理序結束時。</span><span class="sxs-lookup"><span data-stu-id="31dae-416">Occurs when a process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-417"><xref:System.Diagnostics.Process.Exited>事件表示相關聯的處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-417">The <xref:System.Diagnostics.Process.Exited> event indicates that the associated process exited.</span></span> <span data-ttu-id="31dae-418">此項目表示程序結束 （中止） 或成功關閉。</span><span class="sxs-lookup"><span data-stu-id="31dae-418">This occurrence means either that the process terminated (aborted) or successfully closed.</span></span> <span data-ttu-id="31dae-419">只有當，就會發生此事件的值<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-419">This event can occur only if the value of the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="31dae-420">有兩種方式的相關聯的處理序結束時所通知： 同步和非同步的方式。</span><span class="sxs-lookup"><span data-stu-id="31dae-420">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="31dae-421">同步通知表示呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來封鎖目前的執行緒，直到處理序結束為止。</span><span class="sxs-lookup"><span data-stu-id="31dae-421">Synchronous notification means calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to block the current thread until the process exits.</span></span> <span data-ttu-id="31dae-422">使用非同步通知<xref:System.Diagnostics.Process.Exited>事件，可讓呼叫執行緒能夠繼續在同時執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-422">Asynchronous notification uses the <xref:System.Diagnostics.Process.Exited> event, which allows the calling thread to continue execution in the meantime.</span></span> <span data-ttu-id="31dae-423">在後者的情況下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必須設為`true`呼叫的應用程式接收訊號事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-423">In the latter case, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the calling application to receive the Exited event.</span></span>  
  
 <span data-ttu-id="31dae-424">當作業系統關機程序時，它會通知所有其他已註冊的訊號事件處理常式的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-424">When the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event.</span></span> <span data-ttu-id="31dae-425">此時，只要結束處理程序的控制代碼可用來存取某些屬性，例如<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.HasExited%2A>作業系統會維護，直到它完全釋放該控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-425">At this time, the handle of the process that just exited can be used to access some properties such as  <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.HasExited%2A> that the operating system maintains until it releases that handle completely.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-426">即使您有結束的處理程序的控制代碼，您不能呼叫<xref:System.Diagnostics.Process.Start%2A>，重新連線至相同的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-426">Even if you have a handle to an exited process, you cannot call <xref:System.Diagnostics.Process.Start%2A> again to reconnect to the same process.</span></span> <span data-ttu-id="31dae-427">呼叫<xref:System.Diagnostics.Process.Start%2A>自動釋放相關聯的處理序，並連線到處理序中，使用相同的檔案，但全新<xref:System.Diagnostics.Process.Handle%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-427">Calling <xref:System.Diagnostics.Process.Start%2A> automatically releases the associated process and connects to a process with the same file but an entirely new <xref:System.Diagnostics.Process.Handle%2A>.</span></span>  
  
 <span data-ttu-id="31dae-428">如需使用詳細資訊<xref:System.Diagnostics.Process.Exited>事件，在 Windows Forms 應用程式，請參閱<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-428">For more information about the use of the <xref:System.Diagnostics.Process.Exited> event in Windows Forms applications, see the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-429">下列程式碼範例會建立會列印檔案的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-429">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="31dae-430">它會引發<xref:System.Diagnostics.Process.Exited>事件的處理序結束，因為時<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>建立程序時，已設定屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-430">It raises the <xref:System.Diagnostics.Process.Exited> event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created.</span></span> <span data-ttu-id="31dae-431"><xref:System.Diagnostics.Process.Exited>事件處理常式會顯示處理程序資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-431">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-432">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-432">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-433">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-433">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-434">取得相關的處理序結束的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-434">Gets the time that the associated process exited.</span></span></summary>
        <value><span data-ttu-id="31dae-435"><see cref="T:System.DateTime" />，表示相關聯處理序何時終止。</span><span class="sxs-lookup"><span data-stu-id="31dae-435">A <see cref="T:System.DateTime" /> that indicates when the associated process was terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-436">如果還沒有終止程序，嘗試擷取<xref:System.Diagnostics.Process.ExitTime%2A>屬性會擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-436">If the process has not terminated, attempting to retrieve the <xref:System.Diagnostics.Process.ExitTime%2A> property throws an exception.</span></span> <span data-ttu-id="31dae-437">使用<xref:System.Diagnostics.Process.HasExited%2A>才能<xref:System.Diagnostics.Process.ExitTime%2A>屬性來判斷是否已終止相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-437">Use <xref:System.Diagnostics.Process.HasExited%2A> before getting the <xref:System.Diagnostics.Process.ExitTime%2A> property to determine whether the associated process has terminated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-438">下列程式碼範例會建立會列印檔案的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-438">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="31dae-439">處理程序會引發<xref:System.Diagnostics.Process.Exited>時結束時，事件和事件處理常式顯示<xref:System.Diagnostics.Process.ExitTime%2A>屬性和其他處理資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-439">The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the <xref:System.Diagnostics.Process.ExitTime%2A> property and other process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-440">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-440">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-441">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-441">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-442">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-442">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-443">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-443">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-444">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-444">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-445">取得新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與目前現用處理序相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-445">Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</span></span></summary>
        <returns><span data-ttu-id="31dae-446">新的 <see cref="T:System.Diagnostics.Process" /> 元件，與正在執行呼叫應用程式的處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-446">A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-447">使用這個方法來建立新<xref:System.Diagnostics.Process>執行個體，並將它與本機電腦上的處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-447">Use this method to create a new <xref:System.Diagnostics.Process> instance and associate it with the process resource on the local computer.</span></span>  
  
 <span data-ttu-id="31dae-448">例如，類似<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcessesByName%2A>，和<xref:System.Diagnostics.Process.GetProcesses%2A>方法，<xref:System.Diagnostics.Process.GetCurrentProcess%2A>將現有的資源與新<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-448">Like the similar <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, and <xref:System.Diagnostics.Process.GetProcesses%2A> methods, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associates an existing resource with a new <xref:System.Diagnostics.Process> component.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-449">下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-449">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="31dae-450">然後，它會擷取相同的處理程序在遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-450">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-451">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-451">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-452">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-452">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31dae-453">建立新的 <see cref="T:System.Diagnostics.Process" /> 元件，並將其與您指定的現有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-453">Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="31dae-454">處理序資源的系統唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-454">The system-unique identifier of a process resource.</span></span></param>
        <summary><span data-ttu-id="31dae-455">傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定本機電腦上的處理序識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-455">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</span></span></summary>
        <returns><span data-ttu-id="31dae-456"><see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的本機處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-456">A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-457">使用這個方法來建立新<xref:System.Diagnostics.Process>元件和其關聯處理序資源在本機電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-457">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on the local computer.</span></span> <span data-ttu-id="31dae-458">處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>不會建立系統資源，但而不是建立與應用程式所產生的關聯資源<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-458">The process resource must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="31dae-459">處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-459">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="31dae-460">在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>擲回例外狀況，如果傳遞的過期的識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-460">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="31dae-461">在任何特定的電腦上的處理程序的識別碼是唯一的。</span><span class="sxs-lookup"><span data-stu-id="31dae-461">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="31dae-462"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多會傳回其中一個處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-462"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> returns one process at most.</span></span> <span data-ttu-id="31dae-463">如果您想要取得執行特定的應用程式，使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="31dae-463">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="31dae-464">如果執行指定的應用程式的電腦上的多個處理序存在<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-464">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="31dae-465">您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-465">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="31dae-466">您可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員 」 中。</span><span class="sxs-lookup"><span data-stu-id="31dae-466">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="31dae-467">`PID`資料行會顯示指派給處理程序的處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-467">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="31dae-468">`processId`參數是<xref:System.Int32>（32 位元帶正負號的整數），雖然基礎的 Windows API 使用`DWORD`（帶正負號的 32 位元整數） 類似的 api。</span><span class="sxs-lookup"><span data-stu-id="31dae-468">The `processId` parameter is an <xref:System.Int32> (a 32-bit signed integer), although the underlying Windows API uses a `DWORD` (an unsigned 32-bit integer) for similar APIs.</span></span> <span data-ttu-id="31dae-469">這是基於歷程原因。</span><span class="sxs-lookup"><span data-stu-id="31dae-469">This is for historical reasons.</span></span>
  
## Examples  
 <span data-ttu-id="31dae-470">下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-470">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="31dae-471">然後，它會擷取相同的處理程序在遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-471">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31dae-472"><paramref name="processId" /> 參數指定的處理序未執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-472">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="31dae-473">識別碼可能過期。</span><span class="sxs-lookup"><span data-stu-id="31dae-473">The identifier might be expired.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-474">這個物件未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-474">The process was not started by this object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-475">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-475">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-476">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-476">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="31dae-477">處理序資源的系統唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-477">The system-unique identifier of a process resource.</span></span></param>
        <param name="machineName"><span data-ttu-id="31dae-478">網路上的電腦名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-478">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="31dae-479">傳回新的 <see cref="T:System.Diagnostics.Process" /> 元件，需指定網路上電腦的處理序識別項和名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-479">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</span></span></summary>
        <returns><span data-ttu-id="31dae-480"><see cref="T:System.Diagnostics.Process" /> 元件，與 <paramref name="processId" /> 參數所識別的遠端處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-480">A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-481">使用這個方法來建立新<xref:System.Diagnostics.Process>元件和其關聯處理序資源在網路上的遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-481">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on a remote computer on the network.</span></span> <span data-ttu-id="31dae-482">處理序資源必須已經存在於指定的電腦，因為<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>不會建立系統資源，但而不是建立與應用程式所產生的關聯資源<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-482">The process resource must already exist on the specified computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="31dae-483">處理程序<xref:System.Diagnostics.Process.Id%2A>可以擷取只會針對目前在電腦執行的處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-483">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="31dae-484">在處理序終止之後，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>擲回例外狀況，如果傳遞的過期的識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-484">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="31dae-485">在任何特定的電腦上的處理程序的識別碼是唯一的。</span><span class="sxs-lookup"><span data-stu-id="31dae-485">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="31dae-486"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多會傳回其中一個處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-486"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> returns one process at most.</span></span> <span data-ttu-id="31dae-487">如果您想要取得執行特定的應用程式，使用的所有處理程序<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="31dae-487">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="31dae-488">如果執行指定的應用程式的電腦上的多個處理序存在<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>傳回陣列，包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-488">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="31dae-489">您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-489">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="31dae-490">您可以在檢視的處理序識別碼`Processes`面板的 Windows 工作管理員 」 中。</span><span class="sxs-lookup"><span data-stu-id="31dae-490">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="31dae-491">`PID`資料行會顯示指派給處理程序的處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-491">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="31dae-492">如果您未指定`machineName`，會使用本機電腦。</span><span class="sxs-lookup"><span data-stu-id="31dae-492">If you do not specify a `machineName`, the local computer is used.</span></span> <span data-ttu-id="31dae-493">或者，您可以指定本機電腦，藉由設定`machineName`值"。"或空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="31dae-493">Alternatively, you can specify the local computer by setting `machineName` to the value "." or to an empty string ("").</span></span>  
  
 <span data-ttu-id="31dae-494">`processId`參數是<xref:System.Int32>（32 位元帶正負號的整數），雖然基礎的 Windows API 使用`DWORD`（帶正負號的 32 位元整數） 類似的 api。</span><span class="sxs-lookup"><span data-stu-id="31dae-494">The `processId` parameter is an <xref:System.Int32> (a 32-bit signed integer), although the underlying Windows API uses a `DWORD` (an unsigned 32-bit integer) for similar APIs.</span></span> <span data-ttu-id="31dae-495">這是基於歷程原因。</span><span class="sxs-lookup"><span data-stu-id="31dae-495">This is for historical reasons.</span></span>   
  
## Examples  
 <span data-ttu-id="31dae-496">下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-496">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="31dae-497">然後，它會擷取相同的處理程序在遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-497">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31dae-498"><paramref name="processId" /> 參數指定的處理序未執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-498">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="31dae-499">識別項可能過期。</span><span class="sxs-lookup"><span data-stu-id="31dae-499">The identifier might be expired.</span></span>  
  
<span data-ttu-id="31dae-500">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-500">-or-</span></span> 
<span data-ttu-id="31dae-501"><paramref name="machineName" /> 參數的語法無效。</span><span class="sxs-lookup"><span data-stu-id="31dae-501">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="31dae-502">其長度有可能為零 (0)。</span><span class="sxs-lookup"><span data-stu-id="31dae-502">The name might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31dae-503"><paramref name="machineName" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-503">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-504">這個物件未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-504">The process was not started by this object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-505">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-505">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-506">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-506">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31dae-507">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與現有的處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-507">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-508">為本機電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-508">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</span></span></summary>
        <returns><span data-ttu-id="31dae-509"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在本機電腦上執行的所有處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-509">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-510">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將其與本機電腦上的所有處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-510">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the local computer.</span></span> <span data-ttu-id="31dae-511">處理序資源必須已存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>不會建立系統資源，但而是將資源與產生的應用程式相關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-511">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="31dae-512">因為作業系統本身會執行背景處理程序，這個陣列不會是空的。</span><span class="sxs-lookup"><span data-stu-id="31dae-512">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="31dae-513">如果您不想要擷取所有電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-513">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="31dae-514"><xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>元件，您傳遞給方法的處理序識別碼所識別的系統上的程序與相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-514"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="31dae-515"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-515"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-516">多個 Windows 服務可以載入相同的執行個體，服務主機處理序 (svchost.exe)。</span><span class="sxs-lookup"><span data-stu-id="31dae-516">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="31dae-517">GetProcesses 不會識別這些個別的服務;為此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-517">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-518">下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-518">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="31dae-519">然後，它會擷取相同的處理程序在遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-519">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-520">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-520">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-521">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-521">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="31dae-522">要讀取處理序清單的電腦。</span><span class="sxs-lookup"><span data-stu-id="31dae-522">The computer from which to read the list of processes.</span></span></param>
        <summary><span data-ttu-id="31dae-523">為指定電腦上的每個處理序資源建立新的 <see cref="T:System.Diagnostics.Process" /> 元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-523">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="31dae-524"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在指定的電腦上執行的所有處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-524">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-525">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將它們指定 （通常是遠端） 電腦上的所有處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-525">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the specified (usually remote) computer.</span></span> <span data-ttu-id="31dae-526">處理序資源必須已存在於本機電腦，因為<xref:System.Diagnostics.Process.GetProcesses%2A>不會建立系統資源，但而是將資源與產生的應用程式相關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-526">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="31dae-527">因為作業系統本身會執行背景處理程序，這個陣列不會是空的。</span><span class="sxs-lookup"><span data-stu-id="31dae-527">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="31dae-528">如果您不想要擷取所有電腦上執行的處理程序，您可以使用來限制其數目<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-528">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="31dae-529"><xref:System.Diagnostics.Process.GetProcessById%2A> 建立<xref:System.Diagnostics.Process>元件，您傳遞給方法的處理序識別碼所識別的系統上的程序與相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-529"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="31dae-530"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 建立陣列<xref:System.Diagnostics.Process>傳遞至方法的元件，其相關聯的處理序資源共用的可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-530"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
 <span data-ttu-id="31dae-531">這個多載<xref:System.Diagnostics.Process.GetProcesses%2A>方法通常用來擷取在網路上的遠端電腦上執行的處理序資源的清單，但是您可以指定本機電腦，藉由傳遞 」。 」。</span><span class="sxs-lookup"><span data-stu-id="31dae-531">This overload of the <xref:System.Diagnostics.Process.GetProcesses%2A> method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing ".".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-532">多個 Windows 服務可以載入相同的執行個體，服務主機處理序 (svchost.exe)。</span><span class="sxs-lookup"><span data-stu-id="31dae-532">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="31dae-533">GetProcesses 不會識別這些個別的服務;為此，請參閱<xref:System.ServiceProcess.ServiceController.GetServices%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-533">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-534">下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-534">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="31dae-535">然後，它會擷取相同的處理程序在遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-535">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31dae-536"><paramref name="machineName" /> 參數的語法無效。</span><span class="sxs-lookup"><span data-stu-id="31dae-536">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="31dae-537">其長度有可能為零 (0)。</span><span class="sxs-lookup"><span data-stu-id="31dae-537">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31dae-538"><paramref name="machineName" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-538">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-539">作業系統平台不支援遠端電腦上的這項作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-539">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-540">存取 API 用來取得處理序資訊的效能計數器時發生問題。</span><span class="sxs-lookup"><span data-stu-id="31dae-540">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="31dae-541">此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-541">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-542">存取基礎系統 API 時發生問題。</span><span class="sxs-lookup"><span data-stu-id="31dae-542">A problem occurred accessing an underlying system API.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-543">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-543">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-544">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-544">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31dae-545">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與所有共用指定處理序名稱的現有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-545">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="31dae-546">處理序的易記名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-546">The friendly name of the process.</span></span></param>
        <summary><span data-ttu-id="31dae-547">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與本機電腦上共用指定處理序名稱的所有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-547">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="31dae-548"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-548">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-549">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將它們正在執行相同的可執行檔，在本機電腦上的所有處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-549">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the local computer.</span></span> <span data-ttu-id="31dae-550">處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>不會建立系統資源，但而是將它們與應用程式產生關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-550">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="31dae-551">A`processName`可以指定為目前未執行的本機電腦，所以此方法會傳回陣列可以是空的可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-551">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="31dae-552">處理序名稱是處理程序，例如 Outlook、.exe 副檔名或路徑不包含的易記名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-552">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="31dae-553"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-553"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="31dae-554">比方說，您可以傳遞可執行檔名稱做為`processName`參數，以便關閉該可執行檔的所有執行的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-554">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="31dae-555">雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-555">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="31dae-556">因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-556">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="31dae-557">如果您要管理使用標準 API 呼叫的程序，您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-557">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="31dae-558">透過單獨的處理序名稱，但，一旦您已擷取的陣列，您無法存取處理序資源<xref:System.Diagnostics.Process>相關聯的元件與處理序資源中，啟動、 終止，及操作的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-558">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-559">下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-559">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="31dae-560">然後，它會擷取相同的處理程序在遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-560">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-561">存取 API 用來取得處理序資訊的效能計數器時發生問題。</span><span class="sxs-lookup"><span data-stu-id="31dae-561">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="31dae-562">此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-562">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-563">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-563">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-564">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-564">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="31dae-565">處理序的易記名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-565">The friendly name of the process.</span></span></param>
        <param name="machineName"><span data-ttu-id="31dae-566">網路上的電腦名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-566">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="31dae-567">建立新 <see cref="T:System.Diagnostics.Process" /> 元件的陣列，並將其與遠端電腦上共用指定處理序名稱的所有處理序資源相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-567">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="31dae-568"><see cref="T:System.Diagnostics.Process" /> 類型的陣列，代表正在執行指定的應用程式或檔案的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-568">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-569">使用這個方法來建立新的陣列<xref:System.Diagnostics.Process>元件並將它們正在執行相同的可執行檔，指定的電腦上的所有處理序資源關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-569">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the specified computer.</span></span> <span data-ttu-id="31dae-570">處理序資源必須已經存在的電腦上，因為<xref:System.Diagnostics.Process.GetProcessesByName%2A>不會建立系統資源，但而是將它們與應用程式產生關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-570">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="31dae-571">A`processName`可以指定為目前未執行的本機電腦，所以此方法會傳回陣列可以是空的可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-571">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="31dae-572">處理序名稱是處理程序，例如 Outlook、.exe 副檔名或路徑不包含的易記名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-572">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="31dae-573"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 可協助取得和管理相同的可執行檔相關聯的所有處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-573"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="31dae-574">比方說，您可以傳遞可執行檔名稱做為`processName`參數，以便關閉該可執行檔的所有執行的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-574">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="31dae-575">雖然程序<xref:System.Diagnostics.Process.Id%2A>是唯一的系統上的單一處理序資源，在本機電腦上的多個處理序可以執行指定的應用程式`processName`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-575">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="31dae-576">因此，<xref:System.Diagnostics.Process.GetProcessById%2A>最多會傳回其中一個處理序，但<xref:System.Diagnostics.Process.GetProcessesByName%2A>傳回陣列，包含所有相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-576">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="31dae-577">如果您要管理使用標準 API 呼叫的程序，您可以查詢每個這些處理序的識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-577">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="31dae-578">透過單獨的處理序名稱，但，一旦您已擷取的陣列，您無法存取處理序資源<xref:System.Diagnostics.Process>相關聯的元件與處理序資源中，啟動、 終止，及操作的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-578">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
 <span data-ttu-id="31dae-579">取得處理程序，在本機電腦上以及遠端電腦上，您可以使用這個多載。</span><span class="sxs-lookup"><span data-stu-id="31dae-579">You can use this overload to get processes on the local computer as well as on a remote computer.</span></span> <span data-ttu-id="31dae-580">使用 」。 「 若要指定本機電腦。</span><span class="sxs-lookup"><span data-stu-id="31dae-580">Use "." to specify the local computer.</span></span> <span data-ttu-id="31dae-581">另一個多載存在，預設會使用本機電腦。</span><span class="sxs-lookup"><span data-stu-id="31dae-581">Another overload exists that uses the local computer by default.</span></span>  
  
 <span data-ttu-id="31dae-582">您可以存取遠端電腦上只檢視處理序的相關資訊，例如統計資料、 處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-582">You can access processes on remote computers only to view information, such as statistics, about the processes.</span></span> <span data-ttu-id="31dae-583">您無法關閉，終止 (使用<xref:System.Diagnostics.Process.Kill%2A>)，或在遠端電腦上啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-583">You cannot close, terminate (using <xref:System.Diagnostics.Process.Kill%2A>), or start processes on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-584">下列範例會擷取本機電腦，也就是 「 記事本 」，在本機電腦，並在本機電腦上的特定處理序上執行的所有執行個體上執行的處理序目前的處理序的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-584">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="31dae-585">然後，它會擷取相同的處理程序在遠端電腦上的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-585">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31dae-586"><paramref name="machineName" /> 參數的語法無效。</span><span class="sxs-lookup"><span data-stu-id="31dae-586">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="31dae-587">其長度有可能為零 (0)。</span><span class="sxs-lookup"><span data-stu-id="31dae-587">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31dae-588"><paramref name="machineName" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-588">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-589">作業系統平台不支援遠端電腦上的這項作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-589">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-590">嘗試連線到 <paramref name="machineName" /> 失敗。</span><span class="sxs-lookup"><span data-stu-id="31dae-590">The attempt to connect to <paramref name="machineName" /> has failed.</span></span>

<span data-ttu-id="31dae-591">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-591">-or-</span></span> 
<span data-ttu-id="31dae-592">存取 API 用來取得處理序資訊的效能計數器時發生問題。</span><span class="sxs-lookup"><span data-stu-id="31dae-592">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="31dae-593">此為 Windows NT、Windows 2000 和 Windows XP 的特有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-593">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-594">存取基礎系統 API 時發生問題。</span><span class="sxs-lookup"><span data-stu-id="31dae-594">A problem occurred accessing an underlying system API.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-595">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-595">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-596">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-596">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="31dae-597">呼叫 unmanaged 程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-597">to call unmanaged code.</span></span> <span data-ttu-id="31dae-598">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="31dae-598">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-599">取得相關處理序的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-599">Gets the native handle of the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-600">處理序啟動時，作業系統指派給相關處理序的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-600">The handle that the operating system assigned to the associated process when the process was started.</span></span> <span data-ttu-id="31dae-601">系統會用這個控制代碼追蹤處理序屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-601">The system uses this handle to keep track of process attributes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-602">應用程式可以取得可用做為許多處理序資訊和控制項函式的參數的程序的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-602">An application can obtain a handle to a process that can be used as a parameter to many process-information and control functions.</span></span> <span data-ttu-id="31dae-603">您可以使用此控制代碼來初始化<xref:System.Threading.WaitHandle>或呼叫與平台的原生方法叫用。</span><span class="sxs-lookup"><span data-stu-id="31dae-603">You can use this handle to initialize a <xref:System.Threading.WaitHandle> or to call native methods with platform invoke.</span></span>  
  
 <span data-ttu-id="31dae-604">此處理序控制代碼是私用應用程式--亦即，不能共用控制代碼的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-604">This process handle is private to an application--in other words, process handles cannot be shared.</span></span> <span data-ttu-id="31dae-605">處理程序也會有一個程序<xref:System.Diagnostics.Process.Id%2A>其不同的是<xref:System.Diagnostics.Process.Handle%2A>，是唯一的因此，在整個系統有效。</span><span class="sxs-lookup"><span data-stu-id="31dae-605">A process also has a process <xref:System.Diagnostics.Process.Id%2A> which, unlike the <xref:System.Diagnostics.Process.Handle%2A>, is unique and, therefore, valid throughout the system.</span></span>  
  
 <span data-ttu-id="31dae-606">只有處理序啟動透過呼叫<xref:System.Diagnostics.Process.Start%2A>設定<xref:System.Diagnostics.Process.Handle%2A>屬性對應<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-606">Only processes started through a call to <xref:System.Diagnostics.Process.Start%2A> set the <xref:System.Diagnostics.Process.Handle%2A> property of the corresponding <xref:System.Diagnostics.Process> instances.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-607">處理序尚未啟動或已結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-607">The process has not been started or has exited.</span></span> <span data-ttu-id="31dae-608">無法讀取 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性，因為沒有與此 <see cref="T:System.Diagnostics.Process" /> 執行個體相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-608">The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
<span data-ttu-id="31dae-609">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-609">-or-</span></span> 
<span data-ttu-id="31dae-610"><see cref="T:System.Diagnostics.Process" /> 執行個體已附加至執行中的處理序，但沒有取得具有完整存取權限之控制代碼的必要權限。</span><span class="sxs-lookup"><span data-stu-id="31dae-610">The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-611">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Handle" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-611">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-612">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-612">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-613">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-613">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-614">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-614">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-615">取得處理序開啟的控制代碼數目。</span><span class="sxs-lookup"><span data-stu-id="31dae-615">Gets the number of handles opened by the process.</span></span></summary>
        <value><span data-ttu-id="31dae-616">處理序已開啟的作業系統控制代碼數目。</span><span class="sxs-lookup"><span data-stu-id="31dae-616">The number of operating system handles the process has opened.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-617">控制代碼可讓處理序參考的物件。</span><span class="sxs-lookup"><span data-stu-id="31dae-617">Handles provide a way for a process to refer to objects.</span></span> <span data-ttu-id="31dae-618">處理程序可以取得檔案、 資源、 訊息佇列和其他許多作業系統物件的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-618">A process can obtain handles to files, resources, message queues, and many other operating system objects.</span></span> <span data-ttu-id="31dae-619">作業系統會回收控制代碼計數是 0 時，才使用此程序相關聯的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-619">The operating system reclaims the memory associated with the process only when the handle count is zero.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-620">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-620">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-621">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-621">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-622">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-622">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-623">取得值，指出相關的處理序是否已經終止。</span><span class="sxs-lookup"><span data-stu-id="31dae-623">Gets a value indicating whether the associated process has been terminated.</span></span></summary>
        <value><span data-ttu-id="31dae-624">如果 <see cref="T:System.Diagnostics.Process" /> 元件所參考的作業系統處理序已終止，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-624"><see langword="true" /> if the operating system process referenced by the <see cref="T:System.Diagnostics.Process" /> component has terminated; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-625">值為`true`針對<xref:System.Diagnostics.Process.HasExited%2A>表示相關聯的處理序已終止，正常或不正常。</span><span class="sxs-lookup"><span data-stu-id="31dae-625">A value of `true` for <xref:System.Diagnostics.Process.HasExited%2A> indicates that the associated process has terminated, either normally or abnormally.</span></span> <span data-ttu-id="31dae-626">您可以要求或強制結束藉由呼叫相關聯的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-626">You can request or force the associated process to exit by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-627">如果處理程序來開啟控制代碼，作業系統的程序已結束，但會保留系統管理程序資訊，例如控制代碼，結束代碼結束，結束時間與時，就會釋放處理程序記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-627">If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time.</span></span> <span data-ttu-id="31dae-628">若要取得這項資訊，您可以使用<xref:System.Diagnostics.Process.ExitCode%2A>和<xref:System.Diagnostics.Process.ExitTime%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-628">To get this information, you can use the <xref:System.Diagnostics.Process.ExitCode%2A> and <xref:System.Diagnostics.Process.ExitTime%2A> properties.</span></span> <span data-ttu-id="31dae-629">這些屬性會自動填入此元件所啟動的處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-629">These properties are populated automatically for processes that were started by this component.</span></span> <span data-ttu-id="31dae-630">會釋出系統管理資訊時所有<xref:System.Diagnostics.Process>系統處理序相關聯的元件會終結並沒有更多的控制代碼可要抓緊頭結束處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-630">The administrative information is released when all the <xref:System.Diagnostics.Process> components that are associated with the system process are destroyed and hold no more handles to the exited process.</span></span>  
  
 <span data-ttu-id="31dae-631">處理程序可以與您的程式碼分開來終止。</span><span class="sxs-lookup"><span data-stu-id="31dae-631">A process can terminate independently of your code.</span></span> <span data-ttu-id="31dae-632">如果您開始使用此元件的程序時，系統會更新的值<xref:System.Diagnostics.Process.HasExited%2A>自動執行，即使在相關聯的處理序獨立結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-632">If you started the process using this component, the system updates the value of <xref:System.Diagnostics.Process.HasExited%2A> automatically, even if the associated process exits independently.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-633">當非同步事件處理常式已重新導向標準輸出時，有可能，輸出處理尚未完成時，這個屬性會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-633">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns `true`.</span></span> <span data-ttu-id="31dae-634">若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>檢查之前接受任何參數的多載<xref:System.Diagnostics.Process.HasExited%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-634">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-635">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-635">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-636">然後，它會擷取相關聯的處理序的實體記憶體使用量在 10 秒，最多達 2 秒的間隔。</span><span class="sxs-lookup"><span data-stu-id="31dae-636">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="31dae-637">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="31dae-637">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="31dae-638">如果它仍在執行 10 秒後，範例就會關閉程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-638">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-639">沒有與這個物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-639">There is no process associated with the object.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-640">無法擷取處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-640">The exit code for the process could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-641">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-641">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-642">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-642">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-643">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-643">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-644">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-644">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-645">取得相關處理序的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-645">Gets the unique identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-646">這個 <see cref="T:System.Diagnostics.Process" /> 執行個體所參考的處理序之系統產生的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-646">The system-generated unique identifier of the process that is referenced by this <see cref="T:System.Diagnostics.Process" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-647">此程序<xref:System.Diagnostics.Process.Id%2A>不正確，如果相關聯的處理序未執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-647">The process <xref:System.Diagnostics.Process.Id%2A> is not valid if the associated process is not running.</span></span> <span data-ttu-id="31dae-648">因此，您應該確定處理序正在執行後嘗試擷取<xref:System.Diagnostics.Process.Id%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-648">Therefore, you should ensure that the process is running before attempting to retrieve the <xref:System.Diagnostics.Process.Id%2A> property.</span></span> <span data-ttu-id="31dae-649">在處理序終止，直到處理序識別碼可唯一識別整個系統的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-649">Until the process terminates, the process identifier uniquely identifies the process throughout the system.</span></span>  
  
 <span data-ttu-id="31dae-650">您可以連接至新的本機或遠端電腦執行的處理程序<xref:System.Diagnostics.Process>藉由傳遞至處理序識別碼的執行個體<xref:System.Diagnostics.Process.GetProcessById%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-650">You can connect a process that is running on a local or remote computer to a new <xref:System.Diagnostics.Process> instance by passing the process identifier to the <xref:System.Diagnostics.Process.GetProcessById%2A> method.</span></span> <span data-ttu-id="31dae-651"><xref:System.Diagnostics.Process.GetProcessById%2A> 已`static`方法，以建立新的元件，並設定<xref:System.Diagnostics.Process.Id%2A>新的屬性<xref:System.Diagnostics.Process>執行個體會自動。</span><span class="sxs-lookup"><span data-stu-id="31dae-651"><xref:System.Diagnostics.Process.GetProcessById%2A> is a `static` method that creates a new component and sets the <xref:System.Diagnostics.Process.Id%2A> property for the new <xref:System.Diagnostics.Process> instance automatically.</span></span>  
  
 <span data-ttu-id="31dae-652">系統可以重複使用處理序識別碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-652">Process identifiers can be reused by the system.</span></span> <span data-ttu-id="31dae-653"><xref:System.Diagnostics.Process.Id%2A>屬性值是唯一的只會執行相關聯的處理序時。</span><span class="sxs-lookup"><span data-stu-id="31dae-653">The <xref:System.Diagnostics.Process.Id%2A> property value is unique only while the associated process is running.</span></span> <span data-ttu-id="31dae-654">系統處理序已終止之後，可以重複使用<xref:System.Diagnostics.Process.Id%2A>不相關的處理序的屬性值。</span><span class="sxs-lookup"><span data-stu-id="31dae-654">After the process has terminated, the system can reuse the <xref:System.Diagnostics.Process.Id%2A> property value for an unrelated process.</span></span>  
  
 <span data-ttu-id="31dae-655">此識別碼是在系統上唯一的因為您可以將它的其他執行緒傳遞替代<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-655">Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-656">這個動作可節省系統資源，同時又確保會正確地識別程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-656">This action can save system resources yet guarantee that the process is correctly identified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-657">下列範例示範濆爧髍孮<xref:System.Diagnostics.Process.Id%2A>所有執行的應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-657">The following example demonstrates how to obtain the <xref:System.Diagnostics.Process.Id%2A> for all running instances of an application.</span></span> <span data-ttu-id="31dae-658">程式碼會建立 「 記事本 」 的新執行個體，會列出的 「 記事本 」 中的所有執行個體並可讓使用者輸入<xref:System.Diagnostics.Process.Id%2A>移除特定的執行個體的數目。</span><span class="sxs-lookup"><span data-stu-id="31dae-658">The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the <xref:System.Diagnostics.Process.Id%2A> number to remove a specific instance.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-659">處理序的 <see cref="P:System.Diagnostics.Process.Id" /> 屬性未設定。</span><span class="sxs-lookup"><span data-stu-id="31dae-659">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.</span></span>  
  
<span data-ttu-id="31dae-660">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-660">-or-</span></span> 
<span data-ttu-id="31dae-661">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-661">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-662">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-662">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-663">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-663">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-664">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-664">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-665">立即停止相關的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-665">Immediately stops the associated process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-666"><xref:System.Diagnostics.Process.Kill%2A> 強制終止的處理序，而<xref:System.Diagnostics.Process.CloseMainWindow%2A>只要求終止。</span><span class="sxs-lookup"><span data-stu-id="31dae-666"><xref:System.Diagnostics.Process.Kill%2A> forces a termination of the process, while <xref:System.Diagnostics.Process.CloseMainWindow%2A> only requests a termination.</span></span> <span data-ttu-id="31dae-667">當具有圖形化介面的程序執行時，其訊息迴圈就會處於等候狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-667">When a process with a graphical interface is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="31dae-668">每次 Windows 訊息傳送至處理序的作業系統，則會執行訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="31dae-668">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="31dae-669">呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>傳送要求以接近主視窗中，這在格式正確的應用程式中，關閉子視窗，並撤銷應用程式的所有執行訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="31dae-669">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="31dae-670">結束藉由呼叫的程序要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不會強制應用程式結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-670">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="31dae-671">應用程式可以要求使用者確認之前結束，或者它可以拒絕結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-671">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="31dae-672">若要強制應用程式結束，請使用<xref:System.Diagnostics.Process.Kill%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-672">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="31dae-673">行為<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同於關閉應用程式的主視窗中使用 [系統] 功能表的使用者。</span><span class="sxs-lookup"><span data-stu-id="31dae-673">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="31dae-674">因此，藉由關閉主視窗結束程序要求不會強制應用程式立即結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-674">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-675"><xref:System.Diagnostics.Process.Kill%2A>方法以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-675">The <xref:System.Diagnostics.Process.Kill%2A> method executes asynchronously.</span></span> <span data-ttu-id="31dae-676">之後呼叫<xref:System.Diagnostics.Process.Kill%2A>方法中，呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法來等候處理序結束，或者檢查<xref:System.Diagnostics.Process.HasExited%2A>屬性來判斷是否已經結束處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-676">After calling the <xref:System.Diagnostics.Process.Kill%2A> method, call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to wait for the process to exit, or check the <xref:System.Diagnostics.Process.HasExited%2A> property to determine if the process has exited.</span></span>  
  
 <span data-ttu-id="31dae-677">編輯程序的資料或資源配置給處理程序不會遺失您呼叫<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-677">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-678"><xref:System.Diagnostics.Process.Kill%2A> 會造成異常的處理序終止，而且應該在必要時才使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-678"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination and should be used only when necessary.</span></span> <span data-ttu-id="31dae-679"><xref:System.Diagnostics.Process.CloseMainWindow%2A> 啟用程序有條理地終止，並關閉所有視窗，因此很適合使用介面的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-679"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="31dae-680">如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失敗，您可以使用<xref:System.Diagnostics.Process.Kill%2A>結束這個處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-680">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="31dae-681"><xref:System.Diagnostics.Process.Kill%2A> 是終止處理序沒有圖形化介面的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="31dae-681"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="31dae-682">您可以呼叫<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>只能供本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-682">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="31dae-683">您無法使處理序結束的遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-683">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="31dae-684">您只能檢視在遠端電腦上執行的程序資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-684">You can only view information for processes running on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-685">如果在呼叫<xref:System.Diagnostics.Process.Kill%2A>方法由目前正在終止此程序，而<xref:System.ComponentModel.Win32Exception>拒絕存取時擲回。</span><span class="sxs-lookup"><span data-stu-id="31dae-685">If the call to the <xref:System.Diagnostics.Process.Kill%2A> method is made while the process is currently terminating, a <xref:System.ComponentModel.Win32Exception> is thrown for Access Denied.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-686">相關的處理序無法終止。</span><span class="sxs-lookup"><span data-stu-id="31dae-686">The associated process could not be terminated.</span></span>  
  
<span data-ttu-id="31dae-687">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-687">-or-</span></span> 
<span data-ttu-id="31dae-688">正在結束處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-688">The process is terminating.</span></span>  
  
<span data-ttu-id="31dae-689">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-689">-or-</span></span> 
<span data-ttu-id="31dae-690">相關聯的處理序是 Win16 可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-690">The associated process is a Win16 executable.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-691">您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.Kill" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-691">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-692">這個方法僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-692">The method is available only for processes running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-693">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-693">The process has already exited.</span></span>  
  
<span data-ttu-id="31dae-694">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-694">-or-</span></span> 
<span data-ttu-id="31dae-695">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-695">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-696">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-696">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-697">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-697">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-698">讓 <see cref="T:System.Diagnostics.Process" /> 元件離開可與使用特殊模式執行的作業系統處理序互動的狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-698">Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-699">某些作業系統處理程序以特殊模式執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-699">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="31dae-700">嘗試讀取的屬性，或附加至這些處理序不能除非您呼叫<xref:System.Diagnostics.Process.EnterDebugMode%2A>元件上。</span><span class="sxs-lookup"><span data-stu-id="31dae-700">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="31dae-701">呼叫<xref:System.Diagnostics.Process.LeaveDebugMode%2A>當您不再需要存取權以特殊模式執行這些程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-701">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-702">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-702">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-703">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-703">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-704">取得相關處理序正在執行的所在電腦的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-704">Gets the name of the computer the associated process is running on.</span></span></summary>
        <value><span data-ttu-id="31dae-705">相關處理序正在執行的所在電腦的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-705">The name of the computer that the associated process is running on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-706">您可以檢視統計資料和處理程序，但您的遠端電腦上執行的處理程序資訊無法呼叫<xref:System.Diagnostics.Process.Start%2A>， <xref:System.Diagnostics.Process.CloseMainWindow%2A>，或<xref:System.Diagnostics.Process.Kill%2A>在遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-706">You can view statistical data and process information for processes running on remote computers but you cannot call <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, or <xref:System.Diagnostics.Process.Kill%2A> on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-707">當相關聯的處理序在本機電腦上執行時，這個屬性會傳回一個句點 ("。") 的機器名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-707">When the associated process is executing on the local machine, this property returns a period (".") for the machine name.</span></span> <span data-ttu-id="31dae-708">您應該使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>屬性來取得正確的電腦名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-708">You should use the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to get the correct machine name.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-709">若要使用下列的範例，您必須先執行會啟動 「 記事本 」 的至少一個執行個體，在遠端電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-709">To use the following example you must first start at least one instance of Notepad on a remote computer.</span></span> <span data-ttu-id="31dae-710">範例會要求遠端電腦，[記事本] 正在執行，而且接著會顯示個別的名稱<xref:System.Diagnostics.Process.ProcessName%2A>， <xref:System.Diagnostics.Process.Id%2A>，和<xref:System.Diagnostics.Process.MachineName%2A>每個執行個體的屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-710">The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and <xref:System.Diagnostics.Process.MachineName%2A> properties for each instance.</span></span>  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-711">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-711">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-712">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-712">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-713">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-713">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-714">取得相關處理序的主要模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-714">Gets the main module for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-715"><see cref="T:System.Diagnostics.ProcessModule" />，用來啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-715">The <see cref="T:System.Diagnostics.ProcessModule" /> that was used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-716">處理序模組表示會載入特定的處理序的.dll 或.exe 檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-716">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="31dae-717"><xref:System.Diagnostics.Process.MainModule%2A>屬性可讓您檢視用來啟動處理序，包括模組名稱、 檔案名稱和模組記憶體詳細資料的可執行檔的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-717">The <xref:System.Diagnostics.Process.MainModule%2A> property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-718">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainModule" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-718">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-719">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-719">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-720">32 位元處理序正嘗試存取 64 位元處理序的模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-720">A 32-bit process is trying to access the modules of a 64-bit process.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-721">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" /> 以存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-721">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-722">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-722">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="31dae-723">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-723">-or-</span></span> 
<span data-ttu-id="31dae-724">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-724">The process has exited.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-725">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-725">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-726">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-726">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-727">取得相關處理序主視窗的視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-727">Gets the window handle of the main window of the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-728">由系統產生之相關處理序主視窗的視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-728">The system-generated window handle of the main window of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-729">主視窗是目前具有焦點的程序所開啟的視窗 (<xref:System.Windows.Forms.Form.TopLevel%2A>表單)。</span><span class="sxs-lookup"><span data-stu-id="31dae-729">The main window is the window opened by the process that currently has the focus (the <xref:System.Windows.Forms.Form.TopLevel%2A> form).</span></span> <span data-ttu-id="31dae-730">您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>取得目前的主視窗控制代碼，如果它已變更的物件。</span><span class="sxs-lookup"><span data-stu-id="31dae-730">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span> <span data-ttu-id="31dae-731">一般情況下，因為快取的視窗控制代碼，則使用<xref:System.Diagnostics.Process.Refresh%2A>事先保證，您會擷取目前的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-731">In general, because the window handle is cached, use <xref:System.Diagnostics.Process.Refresh%2A> beforehand to guarantee that you'll retrieve the current handle.</span></span>  
  
 <span data-ttu-id="31dae-732">您可以取得<xref:System.Diagnostics.Process.MainWindowHandle%2A>只能供本機電腦執行的處理序的屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-732">You can get the <xref:System.Diagnostics.Process.MainWindowHandle%2A> property only for processes that are running on the local computer.</span></span> <span data-ttu-id="31dae-733"><xref:System.Diagnostics.Process.MainWindowHandle%2A>屬性是可唯一識別與處理程序相關聯的視窗的值。</span><span class="sxs-lookup"><span data-stu-id="31dae-733">The <xref:System.Diagnostics.Process.MainWindowHandle%2A> property is a value that uniquely identifies the window that is associated with the process.</span></span>  
  
 <span data-ttu-id="31dae-734">在程序沒有主視窗程序具有圖形化介面時，才與它相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-734">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="31dae-735">如果相關聯的處理序沒有主視窗、<xref:System.Diagnostics.Process.MainWindowHandle%2A>值為零。</span><span class="sxs-lookup"><span data-stu-id="31dae-735">If the associated process does not have a main window, the <xref:System.Diagnostics.Process.MainWindowHandle%2A> value is zero.</span></span> <span data-ttu-id="31dae-736">這個值也是零的處理序都已隱藏起來，也就是處理不會顯示在工作列中。</span><span class="sxs-lookup"><span data-stu-id="31dae-736">The value is also zero for processes that have been hidden, that is, processes that are not visible in the taskbar.</span></span> <span data-ttu-id="31dae-737">這可以是顯示為圖示在工作列最右邊的 [通知] 區域中的程序的情況。</span><span class="sxs-lookup"><span data-stu-id="31dae-737">This can be the case for processes that appear as icons in the notification area, at the far right of the taskbar.</span></span>  
  
 <span data-ttu-id="31dae-738">如果您剛啟動處理程序，並想要使用其主視窗控制代碼，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，確保已建立的主視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-738">If you have just started a process and want to use its main window handle, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="31dae-739">否則便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-739">Otherwise, an exception will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-740">因為處理序已經結束，所以未定義 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-740">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-741">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-741">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-742">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-742">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-743">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-743">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-744">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-744">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-745">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-745">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-746">取得處理序的主視窗標題。</span><span class="sxs-lookup"><span data-stu-id="31dae-746">Gets the caption of the main window of the process.</span></span></summary>
        <value><span data-ttu-id="31dae-747">處理序的主視窗標題。</span><span class="sxs-lookup"><span data-stu-id="31dae-747">The main window title of the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-748">在程序沒有主視窗程序具有圖形化介面時，才與它相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-748">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="31dae-749">如果相關聯的處理序沒有主視窗 (以便<xref:System.Diagnostics.Process.MainWindowHandle%2A>為零)，<xref:System.Diagnostics.Process.MainWindowTitle%2A>為空字串 ("")。</span><span class="sxs-lookup"><span data-stu-id="31dae-749">If the associated process does not have a main window (so that <xref:System.Diagnostics.Process.MainWindowHandle%2A> is zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> is an empty string ("").</span></span> <span data-ttu-id="31dae-750">如果您剛啟動處理程序，並想要使用其主視窗標題，請考慮使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法，以允許程序完成從開始，確保已建立的主視窗控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-750">If you have just started a process and want to use its main window title, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="31dae-751">否則，系統會擲回例外狀況 (Exception)。</span><span class="sxs-lookup"><span data-stu-id="31dae-751">Otherwise, the system throws an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-752">主視窗是視窗目前具有焦點;請注意，這可能不是程序的主視窗。</span><span class="sxs-lookup"><span data-stu-id="31dae-752">The main window is the window that currently has the focus; note that this might not be the primary window for the process.</span></span> <span data-ttu-id="31dae-753">您必須使用<xref:System.Diagnostics.Process.Refresh%2A>方法，以重新整理<xref:System.Diagnostics.Process>取得目前的主視窗控制代碼，如果它已變更的物件。</span><span class="sxs-lookup"><span data-stu-id="31dae-753">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-754">下列範例會啟動 「 記事本 」 的執行個體，並擷取程序的主視窗的標題。</span><span class="sxs-lookup"><span data-stu-id="31dae-754">The following example starts an instance of Notepad and retrieves the caption of the main window of the process.</span></span>  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-755">因為處理序已經結束，所以未定義 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-755">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-756">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-756">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-757">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-757">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-758">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-758">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-759">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-759">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-760">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-760">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-761">取得或設定關聯的處理序所允許的工作集大小上限，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-761">Gets or sets the maximum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-762">處理序所需記憶體中工作集大小的最大值，以位元組 (Byte) 為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-762">The maximum working set size that is allowed in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-763">處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。</span><span class="sxs-lookup"><span data-stu-id="31dae-763">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="31dae-764">這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-764">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="31dae-765">工作集包括共用和私用的資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-765">The working set includes both shared and private data.</span></span> <span data-ttu-id="31dae-766">共用的資料包含頁面包含所有執行您的應用程式，包括頁面在您的.dll 檔案和 system.dll 檔案中的指示。</span><span class="sxs-lookup"><span data-stu-id="31dae-766">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="31dae-767">隨著工作集大小會增加，也會增加記憶體需求。</span><span class="sxs-lookup"><span data-stu-id="31dae-767">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="31dae-768">處理序有最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-768">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="31dae-769">每次處理序資源建立時，系統會保留等於工作集大小的處理序的最小記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="31dae-769">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="31dae-770">虛擬記憶體管理員會嘗試的 8kb 至少最小記憶體數量時的處理序正在使用，但永遠不會保留超過最大的大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-770">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="31dae-771">系統會設定預設工作集大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-771">The system sets the default working set sizes.</span></span> <span data-ttu-id="31dae-772">您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-772">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="31dae-773">不過，設定這些值不保證記憶體會保留或駐留。</span><span class="sxs-lookup"><span data-stu-id="31dae-773">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-774">當您增加處理程序工作集大小時，您需要從系統的其餘部分的實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-774">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="31dae-775">請確定不會要求是太大，因為這樣做可能會降低系統效能的最小值或最大的工作集大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-775">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31dae-776">工作集大小上限無效。</span><span class="sxs-lookup"><span data-stu-id="31dae-776">The maximum working set size is invalid.</span></span> <span data-ttu-id="31dae-777">必須大於或等於工作集大小下限。</span><span class="sxs-lookup"><span data-stu-id="31dae-777">It must be greater than or equal to the minimum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-778">無法從關聯的處理序資源擷取工作集資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-778">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="31dae-779">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-779">-or-</span></span> 
<span data-ttu-id="31dae-780">處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-780">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-781">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-781">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-782">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-782">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-783">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-783">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="31dae-784">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-784">-or-</span></span> 
<span data-ttu-id="31dae-785">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-785">The process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-786">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-786">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-787">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-787">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-788">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-788">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-789">取得或設定關聯的處理序所允許的工作集大小下限，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-789">Gets or sets the minimum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-790">處理序所需記憶體中工作集大小的最小值，以位元組 (Byte) 為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-790">The minimum working set size that is required in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-791">處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。</span><span class="sxs-lookup"><span data-stu-id="31dae-791">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="31dae-792">這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-792">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="31dae-793">工作集包括共用和私用的資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-793">The working set includes both shared and private data.</span></span> <span data-ttu-id="31dae-794">共用的資料包含頁面包含所有執行您的應用程式，包括頁面在您的.dll 檔案和 system.dll 檔案中的指示。</span><span class="sxs-lookup"><span data-stu-id="31dae-794">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="31dae-795">隨著工作集大小會增加，也會增加記憶體需求。</span><span class="sxs-lookup"><span data-stu-id="31dae-795">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="31dae-796">處理序有最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-796">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="31dae-797">每次處理序資源建立時，系統會保留等於工作集大小的處理序的最小記憶體數量。</span><span class="sxs-lookup"><span data-stu-id="31dae-797">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="31dae-798">虛擬記憶體管理員會嘗試的 8kb 至少最小記憶體數量時的處理序正在使用，但永遠不會保留超過最大的大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-798">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="31dae-799">系統會設定預設工作集大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-799">The system sets the default working set sizes.</span></span> <span data-ttu-id="31dae-800">您可以修改使用這些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-800">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="31dae-801">不過，設定這些值不保證記憶體會保留或駐留。</span><span class="sxs-lookup"><span data-stu-id="31dae-801">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-802">當您增加處理程序工作集大小時，您需要從系統的其餘部分的實體記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-802">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="31dae-803">請確定不會要求是太大，因為這樣做可能會降低系統效能的最小值或最大的工作集大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-803">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31dae-804">工作集大小下限無效。</span><span class="sxs-lookup"><span data-stu-id="31dae-804">The minimum working set size is invalid.</span></span> <span data-ttu-id="31dae-805">必須小於或等於工作集大小上限。</span><span class="sxs-lookup"><span data-stu-id="31dae-805">It must be less than or equal to the maximum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-806">無法從關聯的處理序資源擷取工作集資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-806">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="31dae-807">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-807">-or-</span></span> 
<span data-ttu-id="31dae-808">處理序識別碼或處理序控制代碼為零，因為尚未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-808">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-809">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-809">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-810">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-810">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-811">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-811">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="31dae-812">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-812">-or-</span></span> 
<span data-ttu-id="31dae-813">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-813">The process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-814">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-814">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-815">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-815">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-816">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-816">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-817">取得相關的處理序所載入的模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-817">Gets the modules that have been loaded by the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-818"><see cref="T:System.Diagnostics.ProcessModule" /> 類型的陣列，代表相關聯處理序所載入的模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-818">An array of type <see cref="T:System.Diagnostics.ProcessModule" /> that represents the modules that have been loaded by the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-819">處理序模組表示會載入特定的處理序的.dll 或.exe 檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-819">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="31dae-820">A<xref:System.Diagnostics.ProcessModule>執行個體可讓您檢視模組，包括模組名稱、 檔案名稱和模組記憶體詳細資料的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-820">A <xref:System.Diagnostics.ProcessModule> instance lets you view information about a module, including the module name, file name, and module memory details.</span></span>  
  
 <span data-ttu-id="31dae-821">處理程序都可以將多個模組載入記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-821">A process can load multiple modules into memory.</span></span> <span data-ttu-id="31dae-822">比方說，載入其他的.dll 檔案的.exe 檔案有多個模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-822">For example,.exe files that load additional .dll files have multiple modules.</span></span>  
  
 <span data-ttu-id="31dae-823">啟動程序之後, 這個集合是空的直到系統有載入程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-823">After starting the process, this collection is empty until the system has loaded the process.</span></span> <span data-ttu-id="31dae-824">如果處理序具有主視窗，您可以呼叫<xref:System.Diagnostics.Process.WaitForInputIdle%2A>然後再擷取此屬性可確保集合的非空白時，您取得清單。</span><span class="sxs-lookup"><span data-stu-id="31dae-824">If the process has a main window, you can call <xref:System.Diagnostics.Process.WaitForInputIdle%2A> before retrieving this property to ensure that the collection is nonempty when you get the list.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-825">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-825">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-826">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-826">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-827">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-827">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-828">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-828">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-829">您嘗試存取系統處理序或閒置處理序的 <see cref="P:System.Diagnostics.Process.Modules" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-829">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process.</span></span> <span data-ttu-id="31dae-830">這些程序並沒有模組。</span><span class="sxs-lookup"><span data-stu-id="31dae-830">These processes do not have modules.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-831">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-831">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-832">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-832">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-833">取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-833">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-834">記憶體量 (以位元組為單位)，指系統已配置給不能寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-834">The amount of memory, in bytes, the system has allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-835">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-835">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-836">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-836">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-837">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-837">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-838">取得配置給關聯處理序的未分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-838">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-839">配置給關聯處理序的系統記憶體量 (以位元組為單位)，不能寫入虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-839">The amount of system memory, in bytes, allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-840">這個屬性所傳回的值表示目前程序，以位元組為單位使用的未分頁的系統記憶體的大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-840">The value returned by this property represents the current size of nonpaged system memory used by the process, in bytes.</span></span> <span data-ttu-id="31dae-841">系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。</span><span class="sxs-lookup"><span data-stu-id="31dae-841">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="31dae-842">非分頁的記憶體配置會保留在系統記憶體，而且未分頁移出至虛擬記憶體分頁檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-842">Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</span></span>  
  
 <span data-ttu-id="31dae-843">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-843">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-844">屬性值相當於**Pool Nonpaged Bytes**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-844">The property value is equivalent to the **Pool Nonpaged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-845">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-845">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-846">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-846">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-847">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-847">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-848">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-848">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-849">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-849">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-850">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-850">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-851">引發 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-851">Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-852"><xref:System.Diagnostics.Process.OnExited%2A> 引發的 API 方法<xref:System.Diagnostics.Process.Exited>事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-852"><xref:System.Diagnostics.Process.OnExited%2A> is the API method that raises the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="31dae-853">呼叫<xref:System.Diagnostics.Process.OnExited%2A>會導致<xref:System.Diagnostics.Process.Exited>事件發生來引發事件的使用是唯一的方式和<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-853">Calling <xref:System.Diagnostics.Process.OnExited%2A> causes the <xref:System.Diagnostics.Process.Exited> event to occur and is the only way to raise the event using the <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="31dae-854"><xref:System.Diagnostics.Process.OnExited%2A> 主要使用衍生類別元件時。</span><span class="sxs-lookup"><span data-stu-id="31dae-854"><xref:System.Diagnostics.Process.OnExited%2A> is primarily used when deriving classes from the component.</span></span>  
  
 <span data-ttu-id="31dae-855">做為替代<xref:System.Diagnostics.Process.OnExited%2A>，您可以撰寫您自己的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-855">As an alternative to <xref:System.Diagnostics.Process.OnExited%2A>, you can write your own event handler.</span></span> <span data-ttu-id="31dae-856">建立您自己的事件處理常式委派和事件處理方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-856">You create your own event handler delegate and your own event-handling method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-857">如果您使用 Visual Studio 環境時，事件處理常式委派 (AddOnExited) 和事件處理方法 (Process1_Exited) 會針對您拖曳時<xref:System.Diagnostics.Process>元件拖曳至表單，然後按兩下的圖示。</span><span class="sxs-lookup"><span data-stu-id="31dae-857">If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a <xref:System.Diagnostics.Process> component onto a form and double-click the icon.</span></span> <span data-ttu-id="31dae-858">建立時要執行的程式碼<xref:System.Diagnostics.Process.Exited>Process1_Exited 程序輸入發生的事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-858">The code you create to run when the <xref:System.Diagnostics.Process.Exited> event occurs is entered into the Process1_Exited procedure.</span></span> <span data-ttu-id="31dae-859">您不需要建立<xref:System.Diagnostics.Process.OnExited%2A>成員，因為它會為您實作。</span><span class="sxs-lookup"><span data-stu-id="31dae-859">You do not need to create the <xref:System.Diagnostics.Process.OnExited%2A> member, because it is implemented for you.</span></span>  
  
 <span data-ttu-id="31dae-860">引發事件會透過委派叫用此事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-860">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="31dae-861">如需概觀，請參閱[處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="31dae-861">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-862">下列範例示範如何使用<xref:System.Diagnostics.Process.OnExited%2A>衍生類別中的方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-862">The following example shows how to use the <xref:System.Diagnostics.Process.OnExited%2A> method in a derived class.</span></span>  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-863">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-863">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-864">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-864">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-865">發生於應用程式將某行寫入至其重新導向的 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流時。</span><span class="sxs-lookup"><span data-stu-id="31dae-865">Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-866"><xref:System.Diagnostics.Process.OutputDataReceived>事件指出相關聯<xref:System.Diagnostics.Process>已撰寫程式，以新行字元，其重新導向至終止<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-866">The <xref:System.Diagnostics.Process.OutputDataReceived> event indicates that the associated <xref:System.Diagnostics.Process> has written a line, terminating with a newline character, to its redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-867">事件上啟用非同步讀取作業期間<xref:System.Diagnostics.Process.StandardOutput%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-867">The event is enabled during asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span> <span data-ttu-id="31dae-868">若要開始非同步讀取的作業，您必須重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>的資料流<xref:System.Diagnostics.Process>，新增您的事件處理常式，來<xref:System.Diagnostics.Process.OutputDataReceived>事件，並呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-868">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardOutput%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event, and call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</span></span> <span data-ttu-id="31dae-869">之後，<xref:System.Diagnostics.Process.OutputDataReceived>事件訊號處理程序會將某行寫入至重新導向每次<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，直到處理程序結束或呼叫<xref:System.Diagnostics.Process.CancelOutputRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-869">Thereafter, the <xref:System.Diagnostics.Process.OutputDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-870">正在處理的非同步輸出的應用程式應該呼叫<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以確保已排清輸出緩衝區。</span><span class="sxs-lookup"><span data-stu-id="31dae-870">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to ensure that the output buffer has been flushed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-871">下列範例說明如何執行非同步讀取的作業的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>的資料流`ipconfig`命令。</span><span class="sxs-lookup"><span data-stu-id="31dae-871">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.</span></span>  
  
 <span data-ttu-id="31dae-872">此範例會建立事件的委派`OutputHandler`事件處理常式並將它與相關聯<xref:System.Diagnostics.Process.OutputDataReceived>事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-872">The example creates an event delegate for the `OutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="31dae-873">事件處理常式收到文字行的重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，格式化文字，並將它儲存在稍後會在此範例的主控台視窗中顯示輸出字串。</span><span class="sxs-lookup"><span data-stu-id="31dae-873">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that's later shown in the example's console window.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-874">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-874">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-875">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-875">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-876">取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-876">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-877">記憶體量 (以位元組為單位)，指由關聯的處理序所配置，且可以寫入虛擬記憶體分頁檔案的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-877">The amount of memory, in bytes, allocated by the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-878">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-878">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-879">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-879">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-880">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-880">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-881">取得配置給關聯處理序的分頁記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-881">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-882">虛擬記憶體分頁檔案中，配置給關聯處理序的記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-882">The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-883">這個屬性所傳回的值表示目前程序，以位元組為單位使用之虛擬記憶體分頁檔中的記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-883">The value returned by this property represents the current size of memory in the virtual memory paging file used by the process, in bytes.</span></span> <span data-ttu-id="31dae-884">作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用，來管理每個處理序虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="31dae-884">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="31dae-885">當可分頁記憶體不在使用中時，它可以傳輸到磁碟上的虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-885">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="31dae-886">若要取得作業系統所使用的處理序記憶體的大小，請使用<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-886">To obtain the size of memory used by the operating system for the process, use the <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="31dae-887">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-887">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-888">屬性值相當於**分頁檔位元組**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-888">The property value is equivalent to the **Page File Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-889">下列程式碼範例啟動 「 記事本 」 應用程式的執行個體，然後擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-889">The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-890">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-890">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-891">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-891">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-892">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-892">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-893">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-893">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-894">取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-894">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-895">記憶體量 (以位元組為單位)，指系統已配置給可以寫入虛擬記憶體分頁檔案之關聯處理序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-895">The amount of memory, in bytes, the system has allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-896">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-896">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-897">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-897">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-898">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-898">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-899">取得配置給關聯處理序的可分頁系統記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-899">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-900">配置給關聯處理序的系統記憶體量 (以位元組為單位)，可以寫入虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-900">The amount of system memory, in bytes, allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-901">這個屬性值所傳回的值表示目前程序，以位元組為單位使用的可分頁系統記憶體的大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-901">The value returned by this property value represents the current size of pageable system memory used by the process, in bytes.</span></span> <span data-ttu-id="31dae-902">系統記憶體是作業系統中，所使用的實體記憶體，而且分成分頁和非分頁集區。</span><span class="sxs-lookup"><span data-stu-id="31dae-902">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="31dae-903">當可分頁記憶體不在使用中時，它可以傳輸到磁碟上的虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-903">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="31dae-904">若要取得處理序所使用的應用程式記憶體的大小，請使用<xref:System.Diagnostics.Process.PagedMemorySize64%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-904">To obtain the size of the application memory used by the process, use the <xref:System.Diagnostics.Process.PagedMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="31dae-905">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-905">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-906">屬性值相當於**Pool Paged Bytes**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-906">The property value is equivalent to the **Pool Paged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-907">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-907">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-908">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-908">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-909">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-909">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-910">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-910">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-911">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-911">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-912">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-912">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-913">取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-913">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-914">最大記憶體量 (以位元組為單位)，指由關聯的處理序配置給可以寫入虛擬記憶體分頁檔案的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-914">The maximum amount of memory, in bytes, allocated by the associated process that could be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-915">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-915">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-916">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-916">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-917">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-917">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-918">取得關聯處理序所使用之虛擬記憶體分頁檔的最大記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-918">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-919">虛擬記憶體分頁檔案中，從啟動以來配置給關聯處理序的最大記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-919">The maximum amount of memory, in bytes, allocated in the virtual memory paging file for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-920">這個屬性值所傳回的值代表自啟動，以位元組為單位的處理序使用之虛擬記憶體分頁檔中的記憶體大小上限。</span><span class="sxs-lookup"><span data-stu-id="31dae-920">The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started, in bytes.</span></span> <span data-ttu-id="31dae-921">作業系統會使用實體記憶體之虛擬記憶體分頁檔搭配使用，來管理每個處理序虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="31dae-921">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="31dae-922">當可分頁記憶體不在使用中時，它可以傳輸到磁碟上的虛擬記憶體分頁檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-922">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="31dae-923">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-923">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-924">屬性值相當於**分頁檔位元組尖峰**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-924">The property value is equivalent to the **Page File Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-925">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-925">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-926">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-926">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-927">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-927">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-928">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-928">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-929">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-929">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-930">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-930">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-931">取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-931">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-932">最大虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-932">The maximum amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-933">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-933">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-934">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-934">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-935">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-935">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-936">取得關聯處理序所使用最大虛擬記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-936">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-937">從啟動以來配置給關聯處理序的最大虛擬記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-937">The maximum amount of virtual memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-938">這個屬性所傳回的值代表自啟動，以位元組為單位的處理序使用的虛擬記憶體的大小上限。</span><span class="sxs-lookup"><span data-stu-id="31dae-938">The value returned by this property represents the maximum size of virtual memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="31dae-939">作業系統會對應到頁面載入的實體記憶體，或儲存在磁碟上的虛擬記憶體分頁檔案中的頁面每個處理序虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="31dae-939">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="31dae-940">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-940">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-941">屬性值相當於**虛擬位元組尖峰**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-941">The property value is equivalent to the **Virtual Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-942">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-942">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-943">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-943">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-944">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-944">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-945">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-945">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-946">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-946">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-947">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-947">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-948">取得相關處理序工作集大小的最大值 (位元組)。</span><span class="sxs-lookup"><span data-stu-id="31dae-948">Gets the peak working set size for the associated process, in bytes.</span></span></summary>
        <value><span data-ttu-id="31dae-949">最大實體記憶體數量，為相關的處理序一次所需的量 (位元組)，</span><span class="sxs-lookup"><span data-stu-id="31dae-949">The maximum amount of physical memory that the associated process has required all at once, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-950">處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。</span><span class="sxs-lookup"><span data-stu-id="31dae-950">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="31dae-951">這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-951">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="31dae-952">工作集包括共用和私用的資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-952">The working set includes both shared and private data.</span></span> <span data-ttu-id="31dae-953">共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。</span><span class="sxs-lookup"><span data-stu-id="31dae-953">The shared data includes the pages that contain all the instructions that the process executes, including process modules and the system libraries.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-954">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-954">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-955">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-955">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-956">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-956">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-957">取得關聯處理序所使用最大實體記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-957">Gets the maximum amount of physical memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-958">從啟動以來配置給關聯處理序的最大實體記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-958">The maximum amount of physical memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-959">這個屬性所傳回的值代表工作集由處理序，因為它啟動，以位元組為單位的記憶體的大小上限。</span><span class="sxs-lookup"><span data-stu-id="31dae-959">The value returned by this property represents the maximum size of working set memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="31dae-960">處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。</span><span class="sxs-lookup"><span data-stu-id="31dae-960">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="31dae-961">這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-961">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="31dae-962">工作集包括共用和私用的資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-962">The working set includes both shared and private data.</span></span> <span data-ttu-id="31dae-963">共用的資料包含頁面包含所有處理序執行，包括指示，從處理序模組和系統程式庫的指示。</span><span class="sxs-lookup"><span data-stu-id="31dae-963">The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="31dae-964">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-964">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-965">屬性值相當於**工作集尖峰**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-965">The property value is equivalent to the **Working Set Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-966">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-966">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-967">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-967">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-968">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-968">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-969">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-969">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-970">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-970">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-971">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-971">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-972">取得或設定值，指出作業系統是否應該在主視窗有焦點 (Focus) 時，暫時提高相關的處理序優先權。</span><span class="sxs-lookup"><span data-stu-id="31dae-972">Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</span></span></summary>
        <value><span data-ttu-id="31dae-973">當處理序離開等候狀態時，如果應動態提高處理序優先權，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-973"><see langword="true" /> if dynamic boosting of the process priority should take place for a process when it is taken out of the wait state; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="31dae-974">預設值為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-974">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-975">當執行緒的優先權類別具有動態優先順序列舉值的其中一個處理序中執行時 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)，系統暫時增加執行緒的優先順序，當它被帶離等候狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-975">When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), the system temporarily boosts the thread's priority when it is taken out of a wait state.</span></span> <span data-ttu-id="31dae-976">這個動作可防止其他處理序中斷目前執行緒的處理。</span><span class="sxs-lookup"><span data-stu-id="31dae-976">This action prevents other processes from interrupting the processing of the current thread.</span></span> <span data-ttu-id="31dae-977"><xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定會影響所有現有的執行緒和任何後續的程序所建立的執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-977">The <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> setting affects all the existing threads and any threads subsequently created by the process.</span></span> <span data-ttu-id="31dae-978">若要還原的正常行為，請設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>屬性設`false`。</span><span class="sxs-lookup"><span data-stu-id="31dae-978">To restore normal behavior, set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-979">提升提高優先權可能會耗盡必要作業系統和網路功能，導致問題的其他作業系統工作的資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-979">Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-980">無法從關聯的處理序資源擷取優先權提升資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-980">Priority boost information could not be retrieved from the associated process resource.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-981">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-981">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span>  
  
<span data-ttu-id="31dae-982">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-982">-or-</span></span> 
<span data-ttu-id="31dae-983">處理序識別碼或處理序控制代碼為零。</span><span class="sxs-lookup"><span data-stu-id="31dae-983">The process identifier or process handle is zero.</span></span> <span data-ttu-id="31dae-984">(尚未啟動處理序)。</span><span class="sxs-lookup"><span data-stu-id="31dae-984">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-985">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-985">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-986">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-986">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-987">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-987">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-988">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-988">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-989">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-989">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-990">取得或設定相關處理序的整體優先權分類。</span><span class="sxs-lookup"><span data-stu-id="31dae-990">Gets or sets the overall priority category for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-991">相關聯處理序的優先權分類，處理序的 <see cref="P:System.Diagnostics.Process.BasePriority" /> 由此計算出來。</span><span class="sxs-lookup"><span data-stu-id="31dae-991">The priority category for the associated process, from which the <see cref="P:System.Diagnostics.Process.BasePriority" /> of the process is calculated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-992">處理序優先權類別涵蓋了各種執行緒優先順序層級。</span><span class="sxs-lookup"><span data-stu-id="31dae-992">A process priority class encompasses a range of thread priority levels.</span></span> <span data-ttu-id="31dae-993">具有不同的優先權，相對於處理程序的優先權等級執行之處理序中執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-993">Threads with different priorities that are running in the process run relative to the priority class of the process.</span></span> <span data-ttu-id="31dae-994">Win32 與每個類別的七個基底的優先順序層級使用四個優先權類別。</span><span class="sxs-lookup"><span data-stu-id="31dae-994">Win32 uses four priority classes with seven base priority levels per class.</span></span> <span data-ttu-id="31dae-995">這些程序的優先順序類別會擷取<xref:System.Diagnostics.ProcessPriorityClass>列舉型別，可讓您設定為處理序優先權<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。</span><span class="sxs-lookup"><span data-stu-id="31dae-995">These process priority classes are captured in the <xref:System.Diagnostics.ProcessPriorityClass> enumeration, which lets you set the process priority to <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>.</span></span> <span data-ttu-id="31dae-996">根據 24 小時制或其他的增加，基底的優先權層級可以變更作業系統，當處理程序需要領先其他人存取放到處理器的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-996">Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor.</span></span> <span data-ttu-id="31dae-997">此外，您可以設定<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>暫時提高已脫離等候狀態的執行緒的優先權層級。</span><span class="sxs-lookup"><span data-stu-id="31dae-997">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> to temporarily boost the priority level of threads that have been taken out of the wait state.</span></span> <span data-ttu-id="31dae-998">處理程序會回到等候狀態時，會重設的優先順序。</span><span class="sxs-lookup"><span data-stu-id="31dae-998">The priority is reset when the process returns to the wait state.</span></span>  
  
 <span data-ttu-id="31dae-999"><xref:System.Diagnostics.Process.BasePriority%2A>屬性可讓您檢視開始指派給處理程序的優先順序。</span><span class="sxs-lookup"><span data-stu-id="31dae-999">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority that is assigned to a process.</span></span> <span data-ttu-id="31dae-1000">不過，因為它是唯讀的您無法使用<xref:System.Diagnostics.Process.BasePriority%2A>屬性來設定處理序的優先順序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1000">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> property to set the priority of a process.</span></span> <span data-ttu-id="31dae-1001">若要變更的優先順序，使用<xref:System.Diagnostics.Process.PriorityClass%2A>屬性，取得或設定處理程序的整體優先權分類。</span><span class="sxs-lookup"><span data-stu-id="31dae-1001">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property, which gets or sets the overall priority category for the process.</span></span>  
  
 <span data-ttu-id="31dae-1002">無法使用系統監視器來檢視的優先權等級。</span><span class="sxs-lookup"><span data-stu-id="31dae-1002">The priority class cannot be viewed using System Monitor.</span></span> <span data-ttu-id="31dae-1003">下表顯示之間的關聯性<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>值。</span><span class="sxs-lookup"><span data-stu-id="31dae-1003">The following table shows the relationship between the <xref:System.Diagnostics.Process.BasePriority%2A> and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="31dae-1004">BasePriority</span><span class="sxs-lookup"><span data-stu-id="31dae-1004">BasePriority</span></span>|<span data-ttu-id="31dae-1005">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="31dae-1005">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="31dae-1006">4</span><span class="sxs-lookup"><span data-stu-id="31dae-1006">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="31dae-1007">8</span><span class="sxs-lookup"><span data-stu-id="31dae-1007">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="31dae-1008">13</span><span class="sxs-lookup"><span data-stu-id="31dae-1008">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="31dae-1009">24</span><span class="sxs-lookup"><span data-stu-id="31dae-1009">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1010">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1010">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1011">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1011">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1012">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1012">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1013">無法設定處理序優先順序的資訊，或從相關聯的處理序資源擷取。</span><span class="sxs-lookup"><span data-stu-id="31dae-1013">Process priority information could not be set or retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="31dae-1014">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1014">-or-</span></span> 
<span data-ttu-id="31dae-1015">處理序識別碼或處理序控制代碼為零。</span><span class="sxs-lookup"><span data-stu-id="31dae-1015">The process identifier or process handle is zero.</span></span> <span data-ttu-id="31dae-1016">(尚未啟動處理序)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1016">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1017">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1017">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1018">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1018">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1019">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1019">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1020">使用 Windows 98 或 Windows Millennium Edition (Windows Me) 時，<see cref="P:System.Diagnostics.Process.PriorityClass" /> 已設定為 <see langword="AboveNormal" /> 或 <see langword="BelowNormal" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1020">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me).</span></span> <span data-ttu-id="31dae-1021">這些平台不支援優先權類別的這些值。</span><span class="sxs-lookup"><span data-stu-id="31dae-1021">These platforms do not support those values for the priority class.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="31dae-1022">無法設定優先權類別，因為它不使用如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列舉類型中所定義的有效值。</span><span class="sxs-lookup"><span data-stu-id="31dae-1022">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1023">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1023">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1024">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1024">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1025">取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1025">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-1026">相關的處理序配置的位元組數目，不能與其他處理序共用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1026">The number of bytes allocated by the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1027">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1027">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1028">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1028">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1029">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1029">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1030">取得配置給關聯處理序的私用記憶體量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1030">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-1031">配置給關聯處理序的記憶體量 (以位元組為單位)，不能與其他處理序共用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1031">The amount of memory, in bytes, allocated for the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1032">這個屬性所傳回的值表示目前程序，以位元組為單位，不能與其他處理序共用所使用的記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-1032">The value returned by this property represents the current size of memory used by the process, in bytes, that cannot be shared with other processes.</span></span>  
  
 <span data-ttu-id="31dae-1033">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-1033">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-1034">屬性值相當於**私用位元組**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-1034">The property value is equivalent to the **Private Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1035">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1035">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-1036">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1036">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1037">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-1037">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1038">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1038">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1039">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1039">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1040">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1040">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1041">取得這個處理序使用處理器的授權時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1041">Gets the privileged processor time for this process.</span></span></summary>
        <value><span data-ttu-id="31dae-1042"><see cref="T:System.TimeSpan" />，表示處理序在作業系統核心內執行程式碼所花費的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1042">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the process has spent running code inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="31dae-1043">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1043">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1044">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1044">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1045">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1045">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1046">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1046">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1047">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1047">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1048">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1048">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1049">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1049">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1050">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1050">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1051">取得處理序的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1051">Gets the name of the process.</span></span></summary>
        <value><span data-ttu-id="31dae-1052">名稱，系統用來向使用者識別處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1052">The name that the system uses to identify the process to the user.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1053"><xref:System.Diagnostics.Process.ProcessName%2A>屬性會保留的可執行檔名稱，例如 Outlook、 不包含副檔名為.exe 或路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1053">The <xref:System.Diagnostics.Process.ProcessName%2A> property holds an executable file name, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="31dae-1054">它可協助取得和管理相同的可執行檔相關聯的所有處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1054">It is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1055">在 [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]作業系統，<xref:System.Diagnostics.Process.ProcessName%2A>屬性可能會被截斷為 15 個字元，如果無法取得處理序模組資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-1055">On [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] operating systems, the <xref:System.Diagnostics.Process.ProcessName%2A> property may be truncated to 15 characters if the process module information cannot be obtained.</span></span>  
  
 <span data-ttu-id="31dae-1056">您可以呼叫<xref:System.Diagnostics.Process.GetProcessesByName%2A>，傳遞的可執行檔名稱，來擷取陣列，其中包含每個指定的電腦上執行的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1056">You can call <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer.</span></span> <span data-ttu-id="31dae-1057">您可以使用這個陣列，例如，若要關閉的可執行檔的所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1057">You can use this array, for example, to shut down all the running instances of the executable file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1058">處理序沒有識別項，或沒有處理序與 <see cref="T:System.Diagnostics.Process" /> 相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1058">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.</span></span>  
  
<span data-ttu-id="31dae-1059">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1059">-or-</span></span> 
<span data-ttu-id="31dae-1060">關聯處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1060">The associated process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1061">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1061">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1062">處理序不在這部電腦上。</span><span class="sxs-lookup"><span data-stu-id="31dae-1062">The process is not on this computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1063">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1063">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1064">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1064">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1065">取得或設定處理器，這個處理序中的執行緒可以在其上排程執行。</span><span class="sxs-lookup"><span data-stu-id="31dae-1065">Gets or sets the processors on which the threads in this process can be scheduled to run.</span></span></summary>
        <value><span data-ttu-id="31dae-1066">位元遮罩，表示相關的處理序中的執行緒可以在其上執行的處理器。</span><span class="sxs-lookup"><span data-stu-id="31dae-1066">A bitmask representing the processors that the threads in the associated process can run on.</span></span> <span data-ttu-id="31dae-1067">預設值取決於電腦上的處理器數目。</span><span class="sxs-lookup"><span data-stu-id="31dae-1067">The default depends on the number of processors on the computer.</span></span> <span data-ttu-id="31dae-1068">預設值為 2 <sup>n</sup> -1，其中 n 是處理器數目。</span><span class="sxs-lookup"><span data-stu-id="31dae-1068">The default value is 2 <sup>n</sup> -1, where n is the number of processors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1069">在 Windows 2000 和更新版本中，處理程序中的執行緒可以移轉處理器，以重新載入處理器快取每個移轉。</span><span class="sxs-lookup"><span data-stu-id="31dae-1069">In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="31dae-1070">在繁重的系統負載下指定哪一個處理器應該執行特定的執行緒可以改善效能降低的次數會重新載入處理器快取。</span><span class="sxs-lookup"><span data-stu-id="31dae-1070">Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded.</span></span> <span data-ttu-id="31dae-1071">處理器和執行緒之間的關聯稱為處理器相似性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1071">The association between a processor and a thread is called the processor affinity.</span></span>  
  
 <span data-ttu-id="31dae-1072">位元表示每個處理器。</span><span class="sxs-lookup"><span data-stu-id="31dae-1072">Each processor is represented as a bit.</span></span> <span data-ttu-id="31dae-1073">位元 0 是第一個處理器，位元 1 是第二個，處理器等等。</span><span class="sxs-lookup"><span data-stu-id="31dae-1073">Bit 0 is processor one, bit 1 is processor two, and so forth.</span></span> <span data-ttu-id="31dae-1074">如果您將設定位元為 1 的值，對應的處理器會選取進行執行緒指派。</span><span class="sxs-lookup"><span data-stu-id="31dae-1074">If you set a bit to the value 1, the corresponding processor is selected for thread assignment.</span></span> <span data-ttu-id="31dae-1075">當您將設定<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值為零，作業系統的排程演算法設定執行緒的相似性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1075">When you set the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value to zero, the operating system's scheduling algorithms set the thread's affinity.</span></span> <span data-ttu-id="31dae-1076">當<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值設定為任何非零值，值會解譯為指定適合選取之處理器的位元遮罩。</span><span class="sxs-lookup"><span data-stu-id="31dae-1076">When the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</span></span>  
  
 <span data-ttu-id="31dae-1077">下表顯示選取的<xref:System.Diagnostics.Process.ProcessorAffinity%2A>八個處理器的系統值。</span><span class="sxs-lookup"><span data-stu-id="31dae-1077">The following table shows a selection of <xref:System.Diagnostics.Process.ProcessorAffinity%2A> values for an eight-processor system.</span></span>  
  
|<span data-ttu-id="31dae-1078">位元遮罩</span><span class="sxs-lookup"><span data-stu-id="31dae-1078">Bitmask</span></span>|<span data-ttu-id="31dae-1079">二進位值</span><span class="sxs-lookup"><span data-stu-id="31dae-1079">Binary value</span></span>|<span data-ttu-id="31dae-1080">符合資格的處理器</span><span class="sxs-lookup"><span data-stu-id="31dae-1080">Eligible processors</span></span>|  
|-------------|------------------|-------------------------|  
|<span data-ttu-id="31dae-1081">0x0001</span><span class="sxs-lookup"><span data-stu-id="31dae-1081">0x0001</span></span>|<span data-ttu-id="31dae-1082">00000000 00000001</span><span class="sxs-lookup"><span data-stu-id="31dae-1082">00000000 00000001</span></span>|<span data-ttu-id="31dae-1083">1</span><span class="sxs-lookup"><span data-stu-id="31dae-1083">1</span></span>|  
|<span data-ttu-id="31dae-1084">0x0003</span><span class="sxs-lookup"><span data-stu-id="31dae-1084">0x0003</span></span>|<span data-ttu-id="31dae-1085">00000000 00000011</span><span class="sxs-lookup"><span data-stu-id="31dae-1085">00000000 00000011</span></span>|<span data-ttu-id="31dae-1086">1 和 2</span><span class="sxs-lookup"><span data-stu-id="31dae-1086">1 and 2</span></span>|  
|<span data-ttu-id="31dae-1087">0x0007</span><span class="sxs-lookup"><span data-stu-id="31dae-1087">0x0007</span></span>|<span data-ttu-id="31dae-1088">00000000 00000111</span><span class="sxs-lookup"><span data-stu-id="31dae-1088">00000000 00000111</span></span>|<span data-ttu-id="31dae-1089">1、 2 和 3</span><span class="sxs-lookup"><span data-stu-id="31dae-1089">1, 2 and 3</span></span>|  
|<span data-ttu-id="31dae-1090">0x0009</span><span class="sxs-lookup"><span data-stu-id="31dae-1090">0x0009</span></span>|<span data-ttu-id="31dae-1091">00000000 00001001</span><span class="sxs-lookup"><span data-stu-id="31dae-1091">00000000 00001001</span></span>|<span data-ttu-id="31dae-1092">1 到 4</span><span class="sxs-lookup"><span data-stu-id="31dae-1092">1 and 4</span></span>|  
|<span data-ttu-id="31dae-1093">0x007F</span><span class="sxs-lookup"><span data-stu-id="31dae-1093">0x007F</span></span>|<span data-ttu-id="31dae-1094">00000000 01111111</span><span class="sxs-lookup"><span data-stu-id="31dae-1094">00000000 01111111</span></span>|<span data-ttu-id="31dae-1095">1、 2、 3、 4、 5、 6 和 7</span><span class="sxs-lookup"><span data-stu-id="31dae-1095">1, 2, 3, 4, 5, 6 and 7</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1096"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 資訊無法設定或從相關聯的處理序資源擷取。</span><span class="sxs-lookup"><span data-stu-id="31dae-1096"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="31dae-1097">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1097">-or-</span></span> 
<span data-ttu-id="31dae-1098">處理序識別碼或處理序控制代碼為零。</span><span class="sxs-lookup"><span data-stu-id="31dae-1098">The process identifier or process handle is zero.</span></span> <span data-ttu-id="31dae-1099">(尚未啟動處理序)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1099">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1100">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1100">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1101">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1101">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1102">處理序 <see cref="P:System.Diagnostics.Process.Id" /> 無法使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1102">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.</span></span>  
  
<span data-ttu-id="31dae-1103">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1103">-or-</span></span> 
<span data-ttu-id="31dae-1104">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1104">The process has exited.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1105">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1105">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1106">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1106">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-1107">捨棄快取於處理序元件內之相關處理序的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-1107">Discards any information about the associated process that has been cached inside the process component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1108">之後<xref:System.Diagnostics.Process.Refresh%2A>呼叫時，第一個要求的每一個屬性的相關資訊會導致處理序元件，從相關聯的處理序中取得新的值。</span><span class="sxs-lookup"><span data-stu-id="31dae-1108">After <xref:System.Diagnostics.Process.Refresh%2A> is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</span></span>  
  
 <span data-ttu-id="31dae-1109">當<xref:System.Diagnostics.Process>元件是與處理序資源，屬性值相關聯<xref:System.Diagnostics.Process>立即填入根據相關聯的處理序的狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-1109">When a <xref:System.Diagnostics.Process> component is associated with a process resource, the property values of the <xref:System.Diagnostics.Process> are immediately populated according to the status of the associated process.</span></span> <span data-ttu-id="31dae-1110">如果後續變更相關聯的處理序的相關資訊，這些變更不會反映在<xref:System.Diagnostics.Process>元件的快取的值。</span><span class="sxs-lookup"><span data-stu-id="31dae-1110">If the information about the associated process subsequently changes, those changes are not reflected in the <xref:System.Diagnostics.Process> component's cached values.</span></span> <span data-ttu-id="31dae-1111"><xref:System.Diagnostics.Process>元件會將快照集的處理序資源位於與其相關聯的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1111">The <xref:System.Diagnostics.Process> component is a snapshot of the process resource at the time they are associated.</span></span> <span data-ttu-id="31dae-1112">若要檢視相關聯的處理序的目前值，請呼叫<xref:System.Diagnostics.Process.Refresh%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1112">To view the current values for the associated process, call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1113">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1113">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1114">然後，它會擷取相關聯的處理序的實體記憶體使用量在 10 秒，最多達 2 秒的間隔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1114">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="31dae-1115">此範例會偵測處理序結束之前經過 10 秒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1115">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="31dae-1116">如果它仍在執行 10 秒後，範例就會關閉程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1116">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1117">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1117">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1118">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1118">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1119">取得值，指出處理序的使用者介面是否正在回應。</span><span class="sxs-lookup"><span data-stu-id="31dae-1119">Gets a value indicating whether the user interface of the process is responding.</span></span></summary>
        <value><span data-ttu-id="31dae-1120">如果相關聯處理序的使用者介面正在回應系統，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1120"><see langword="true" /> if the user interface of the associated process is responding to the system; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1121">如果處理程序具有使用者介面，<xref:System.Diagnostics.Process.Responding%2A>屬性連絡使用者介面，以判斷處理序是否正在回應使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="31dae-1121">If a process has a user interface, the <xref:System.Diagnostics.Process.Responding%2A> property contacts the user interface to determine whether the process is responding to user input.</span></span> <span data-ttu-id="31dae-1122">如果介面沒有回應，立即<xref:System.Diagnostics.Process.Responding%2A>屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1122">If the interface does not respond immediately, the <xref:System.Diagnostics.Process.Responding%2A> property returns `false`.</span></span> <span data-ttu-id="31dae-1123">使用這個屬性來判斷相關聯的處理序的介面是否已停止回應。</span><span class="sxs-lookup"><span data-stu-id="31dae-1123">Use this property to determine whether the interface of the associated process has stopped responding.</span></span>  
  
 <span data-ttu-id="31dae-1124">如果處理程序並沒有<xref:System.Diagnostics.Process.MainWindowHandle%2A>，這個屬性會傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1124">If the process does not have a <xref:System.Diagnostics.Process.MainWindowHandle%2A>, this property returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1125">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1125">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1126">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1126">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1127">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1127">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1128">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1128">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1129">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1129">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1130">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.Responding" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1130">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1131">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1131">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1132">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1132">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1133">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1133">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1134">取得這個處理序的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1134">Gets the native handle to this process.</span></span></summary>
        <value><span data-ttu-id="31dae-1135">這個處理序的原生控制代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1135">The native handle to this process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1136">控制代碼才可使用呼叫元件已啟動的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1136">The handle is only available if the calling component started the process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1137">取得相關處理序的終端機服務工作階段識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-1137">Gets the Terminal Services session identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-1138">相關處理序的終端機服務工作階段識別項。</span><span class="sxs-lookup"><span data-stu-id="31dae-1138">The Terminal Services session identifier for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1139"><xref:System.Diagnostics.Process.SessionId%2A>屬性識別目前執行中應用程式的工作階段。</span><span class="sxs-lookup"><span data-stu-id="31dae-1139">The <xref:System.Diagnostics.Process.SessionId%2A> property identifies the session in which the application is currently running.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="31dae-1140">沒有與此處理序相關聯的工作階段。</span><span class="sxs-lookup"><span data-stu-id="31dae-1140">There is no session associated with this process.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1141">沒有與這個工作階段識別項相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1141">There is no process associated with this session identifier.</span></span>  
  
<span data-ttu-id="31dae-1142">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1142">-or-</span></span> 
<span data-ttu-id="31dae-1143">相關的處理序不在此機器上。</span><span class="sxs-lookup"><span data-stu-id="31dae-1143">The associated process is not on this machine.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1144">Windows 98 不支援 <see cref="P:System.Diagnostics.Process.SessionId" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1144">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1145">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1145">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1146">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1146">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1147">取得用來讀取應用程式錯誤輸出的資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1147">Gets a stream used to read the error output of the application.</span></span></summary>
        <value><span data-ttu-id="31dae-1148"><see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1148">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard error stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1149">當<xref:System.Diagnostics.Process>將文字寫入至其標準錯誤資料流中，文字通常會顯示在主控台上。</span><span class="sxs-lookup"><span data-stu-id="31dae-1149">When a <xref:System.Diagnostics.Process> writes text to its standard error stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="31dae-1150">藉由重新導向<xref:System.Diagnostics.Process.StandardError%2A>資料流，您可以操作或隱藏的錯誤輸出的處理程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1150">By redirecting the <xref:System.Diagnostics.Process.StandardError%2A> stream, you can manipulate or suppress the error output of a process.</span></span> <span data-ttu-id="31dae-1151">例如，您可以篩選文字、 格式，或將輸出寫入到主控台和指定的記錄檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1151">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1152">若要使用<xref:System.Diagnostics.Process.StandardError%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>要`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>到`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1152">To use <xref:System.Diagnostics.Process.StandardError%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="31dae-1153">否則，讀取<xref:System.Diagnostics.Process.StandardError%2A>資料流則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1153">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="31dae-1154">重新導向<xref:System.Diagnostics.Process.StandardError%2A>可以讀取資料流，同步或非同步。</span><span class="sxs-lookup"><span data-stu-id="31dae-1154">The redirected <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="31dae-1155">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的錯誤輸出資料流同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1155">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="31dae-1156">這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardError%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1156">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="31dae-1157">相反地，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1157">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="31dae-1158">這個方法可讓資料流輸出指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1158">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="31dae-1159">同步讀取作業採用之間讀取呼叫端相依性<xref:System.Diagnostics.Process.StandardError%2A>資料流和子處理該資料流寫入。</span><span class="sxs-lookup"><span data-stu-id="31dae-1159">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="31dae-1160">這些相依性可能會導致死結狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1160">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="31dae-1161">呼叫端會從子處理序的重新導向資料流讀取，時，取決於子系。</span><span class="sxs-lookup"><span data-stu-id="31dae-1161">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="31dae-1162">呼叫者會等候讀取作業，直到寫入資料流中的子系，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1162">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="31dae-1163">子處理序寫入資料不足，無法填滿其重新導向的資料流，時，相依於父代。</span><span class="sxs-lookup"><span data-stu-id="31dae-1163">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="31dae-1164">子處理序會等候下一個寫入作業，直到父從完整的資料流讀取，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1164">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="31dae-1165">當呼叫端和子處理序等待彼此完成作業時，且無法繼續時，就會導致死結狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-1165">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="31dae-1166">您可以評估子處理序與呼叫端之間的相依性，以避免死結。</span><span class="sxs-lookup"><span data-stu-id="31dae-1166">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="31dae-1167">例如，下列 C# 程式碼會示範如何讀取重新導向資料流，並等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1167">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 <span data-ttu-id="31dae-1168">藉由呼叫程式碼範例可避免的鎖死的情況`p.StandardError.ReadToEnd`之前`p.WaitForExit`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1168">The code example avoids a deadlock condition by calling `p.StandardError.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="31dae-1169">如果父系處理程序的呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿的重新導向的資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1169">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardError.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="31dae-1170">父處理序會無限期等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1170">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="31dae-1171">子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1171">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-1172">當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。</span><span class="sxs-lookup"><span data-stu-id="31dae-1172">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="31dae-1173">下列 C# 程式碼，例如，會執行兩個資料流上的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1173">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="31dae-1174">在程式碼範例執行非同步讀取作業，在避免發生死結狀況<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1174">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-1175">如果父系處理程序的呼叫會產生鎖死的情況`p.StandardOutput.ReadToEnd`後面接著`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿其錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1175">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="31dae-1176">父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1176">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-1177">子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1177">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-1178">您可以使用非同步讀取的作業，以避免這些相依性，以及其潛在的死結。</span><span class="sxs-lookup"><span data-stu-id="31dae-1178">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="31dae-1179">或者，您可以藉由建立兩個執行緒，並讀取每個個別的執行緒上的資料流的輸出，避免發生死結狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1179">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1180">您不能混用重新導向的資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1180">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="31dae-1181">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1181">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="31dae-1182">例如，請勿遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>資料流，或反之亦然。</span><span class="sxs-lookup"><span data-stu-id="31dae-1182">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="31dae-1183">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1183">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="31dae-1184">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1184">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1185">下列範例會使用`net use`命令搭配使用者提供的引數，以對應的網路資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1185">The following example uses the `net use` command together with a user supplied argument to map a network resource.</span></span> <span data-ttu-id="31dae-1186">然後讀取，net 命令標準錯誤資料流，並寫入至主控台。</span><span class="sxs-lookup"><span data-stu-id="31dae-1186">It then reads the standard error stream of the net command and writes it to console.</span></span>  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1187">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1187">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
<span data-ttu-id="31dae-1188">\-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1188">\- or -</span></span> 
<span data-ttu-id="31dae-1189">已開啟 <see cref="P:System.Diagnostics.Process.StandardError" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 的非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1189">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1190">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1190">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1191">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1191">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1192">取得用來寫入應用程式輸入的資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1192">Gets a stream used to write the input of the application.</span></span></summary>
        <value><span data-ttu-id="31dae-1193"><see cref="T:System.IO.StreamWriter" />，可用來寫入應用程式的標準輸入資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1193">A <see cref="T:System.IO.StreamWriter" /> that can be used to write the standard input stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1194">A<xref:System.Diagnostics.Process>可以讀取其標準輸入資料流，一般是鍵盤輸入的文字。</span><span class="sxs-lookup"><span data-stu-id="31dae-1194">A <xref:System.Diagnostics.Process> can read input text from its standard input stream, typically the keyboard.</span></span> <span data-ttu-id="31dae-1195">藉由重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流，您可以透過程式設計方式指定輸入。</span><span class="sxs-lookup"><span data-stu-id="31dae-1195">By redirecting the <xref:System.Diagnostics.Process.StandardInput%2A> stream, you can programmatically specify the input.</span></span> <span data-ttu-id="31dae-1196">比方說，而不是使用鍵盤輸入，您可以提供從指定的檔案內容的文字或另一個應用程式的輸出。</span><span class="sxs-lookup"><span data-stu-id="31dae-1196">For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1197">若要使用<xref:System.Diagnostics.Process.StandardInput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>要`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>到`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1197">To use <xref:System.Diagnostics.Process.StandardInput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="31dae-1198">否則，寫入<xref:System.Diagnostics.Process.StandardInput%2A>資料流則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1198">Otherwise, writing to the <xref:System.Diagnostics.Process.StandardInput%2A> stream throws an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1199">下列範例說明如何將重新導向<xref:System.Diagnostics.Process.StandardInput%2A>程序的資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1199">The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process.</span></span> <span data-ttu-id="31dae-1200">此範例會啟動`sort`命令搭配重新導向的輸入。</span><span class="sxs-lookup"><span data-stu-id="31dae-1200">The example starts the `sort` command with redirected input.</span></span> <span data-ttu-id="31dae-1201">接著會提示使用者輸入文字，並將其傳遞至`sort`處理序，透過重新導向<xref:System.Diagnostics.Process.StandardInput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1201">It then prompts the user for text, and passes that to the `sort` process by means of the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream.</span></span> <span data-ttu-id="31dae-1202">`sort`結果會顯示在主控台上的使用者。</span><span class="sxs-lookup"><span data-stu-id="31dae-1202">The `sort` results are displayed to the user on the console.</span></span>  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1203">尚未定義 <see cref="P:System.Diagnostics.Process.StandardInput" /> 資料流，因為 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 已設定為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1203">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1204">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1204">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1205">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1205">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1206">取得用來讀取應用程式文字輸出的資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1206">Gets a stream used to read the textual output of the application.</span></span></summary>
        <value><span data-ttu-id="31dae-1207"><see cref="T:System.IO.StreamReader" />，可用來讀取應用程式的標準輸出資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1207">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard output stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1208">當<xref:System.Diagnostics.Process>將文字寫入至其標準的資料流，文字通常會顯示在主控台上。</span><span class="sxs-lookup"><span data-stu-id="31dae-1208">When a <xref:System.Diagnostics.Process> writes text to its standard stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="31dae-1209">藉由重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，您可以操作或隱藏程序的輸出。</span><span class="sxs-lookup"><span data-stu-id="31dae-1209">By redirecting the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, you can manipulate or suppress the output of a process.</span></span> <span data-ttu-id="31dae-1210">例如，您可以篩選文字、 格式，或將輸出寫入到主控台和指定的記錄檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1210">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1211">若要使用<xref:System.Diagnostics.Process.StandardOutput%2A>，您必須設定<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>要`false`，而且您必須將<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>到`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1211">To use <xref:System.Diagnostics.Process.StandardOutput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="31dae-1212">否則，讀取<xref:System.Diagnostics.Process.StandardOutput%2A>資料流則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1212">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="31dae-1213">重新導向<xref:System.Diagnostics.Process.StandardOutput%2A>可以讀取資料流，同步或非同步。</span><span class="sxs-lookup"><span data-stu-id="31dae-1213">The redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="31dae-1214">這類方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>執行程序的輸出資料流同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1214">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="31dae-1215">這些同步讀取作業未完成直到相關聯<xref:System.Diagnostics.Process>寫入其<xref:System.Diagnostics.Process.StandardOutput%2A>串流處理，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1215">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="31dae-1216">相反地，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>開始非同步讀取作業上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1216">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-1217">這個方法可讓資料流輸出指定的事件處理常式，並立即傳回給呼叫者，可以執行其他工作，而資料流輸出會導向至事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1217">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="31dae-1218">同步讀取作業採用之間讀取呼叫端相依性<xref:System.Diagnostics.Process.StandardOutput%2A>資料流和子處理該資料流寫入。</span><span class="sxs-lookup"><span data-stu-id="31dae-1218">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="31dae-1219">這些相依性可能會導致死結狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1219">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="31dae-1220">呼叫端會從子處理序的重新導向資料流讀取，時，取決於子系。</span><span class="sxs-lookup"><span data-stu-id="31dae-1220">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="31dae-1221">呼叫者會等候讀取作業，直到寫入資料流中的子系，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1221">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="31dae-1222">子處理序寫入資料不足，無法填滿其重新導向的資料流，時，相依於父代。</span><span class="sxs-lookup"><span data-stu-id="31dae-1222">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="31dae-1223">子處理序會等候下一個寫入作業，直到父從完整的資料流讀取，或關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1223">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="31dae-1224">當呼叫端和子處理序等待彼此完成作業時，且無法繼續時，就會導致死結狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-1224">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="31dae-1225">您可以評估子處理序與呼叫端之間的相依性，以避免死結。</span><span class="sxs-lookup"><span data-stu-id="31dae-1225">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="31dae-1226">例如，下列 C# 程式碼會示範如何讀取重新導向資料流，並等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1226">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="31dae-1227">藉由呼叫程式碼範例可避免的鎖死的情況`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1227">The code example avoids a deadlock condition by calling `p.StandardOutput.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="31dae-1228">如果父系處理程序的呼叫，死結狀況可能會造成`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子處理序寫入足夠的文字，以填滿的重新導向的資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1228">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardOutput.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="31dae-1229">父處理序會無限期等候子處理序結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1229">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="31dae-1230">子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1230">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-1231">當您從標準輸出和標準錯誤資料流讀取所有文字時，沒有類似的問題。</span><span class="sxs-lookup"><span data-stu-id="31dae-1231">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="31dae-1232">下列 C# 程式碼，例如，會執行兩個資料流上的讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1232">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="31dae-1233">在程式碼範例執行非同步讀取作業，在避免發生死結狀況<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1233">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-1234">如果父系處理程序的呼叫會產生鎖死的情況`p.StandardOutput.ReadToEnd`後面接著`p.StandardError.ReadToEnd`和子處理序寫入足夠的文字，以填滿其錯誤資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1234">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="31dae-1235">父處理序會無限期地等候子處理序關閉其<xref:System.Diagnostics.Process.StandardOutput%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1235">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="31dae-1236">子處理序會無限期地等候從完整讀取的父代<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1236">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="31dae-1237">您可以使用非同步讀取的作業，以避免這些相依性，以及其潛在的死結。</span><span class="sxs-lookup"><span data-stu-id="31dae-1237">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="31dae-1238">或者，您可以藉由建立兩個執行緒，並讀取每個個別的執行緒上的資料流的輸出，避免發生死結狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1238">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1239">您不能混用重新導向的資料流的非同步和同步讀取的作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1239">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="31dae-1240">一次重新導向資料流的<xref:System.Diagnostics.Process>開啟在非同步或同步模式中，所有進一步的讀取該資料流的作業必須是相同的模式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1240">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="31dae-1241">例如，請勿遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>藉由呼叫<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>資料流，或反之亦然。</span><span class="sxs-lookup"><span data-stu-id="31dae-1241">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="31dae-1242">不過，您可以讀取在不同模式中的兩個不同資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1242">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="31dae-1243">例如，您可以呼叫<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然後呼叫<xref:System.IO.StreamReader.ReadLine%2A>如<xref:System.Diagnostics.Process.StandardError%2A>資料流。</span><span class="sxs-lookup"><span data-stu-id="31dae-1243">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1244">下列範例執行 ipconfig.exe 命令，並將其標準輸出重新導向至範例的 [主控台] 視窗。</span><span class="sxs-lookup"><span data-stu-id="31dae-1244">The following example runs the ipconfig.exe command and redirects its standard output to the example's console window.</span></span>  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1245">尚未針對重新導向定義 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流；請確定已將 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 設為 <see langword="true" />，且將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1245">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
<span data-ttu-id="31dae-1246">\-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1246">\- or -</span></span> 
<span data-ttu-id="31dae-1247">已開啟 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 資料流，用於搭配 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 的非同步讀取作業。</span><span class="sxs-lookup"><span data-stu-id="31dae-1247">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1248">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1248">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1249">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1249">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31dae-1250">啟動處理序資源，並將其與 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1250">Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-1251">啟動 (或重複使用) 這個 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性指定的處理序資源，並將其與元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1251">Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</span></span></summary>
        <returns><span data-ttu-id="31dae-1252">如果啟動處理序資源，則為 <see langword="true" />；如果沒有啟動任何新的處理序資源 (例如，如果重複使用現有的處理序)，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1252"><see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1253">使用此多載來啟動處理序資源，並將它與目前的關聯<xref:System.Diagnostics.Process>元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1253">Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="31dae-1254">傳回值`true`指出已啟動新的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1254">The return value `true` indicates that a new process resource was started.</span></span> <span data-ttu-id="31dae-1255">如果所指定的處理序資源<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性已在電腦上執行，沒有啟動任何額外的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1255">If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started.</span></span> <span data-ttu-id="31dae-1256">相反地，執行處理序資源會重複使用和`false`會傳回。</span><span class="sxs-lookup"><span data-stu-id="31dae-1256">Instead, the running process resource is reused and `false` is returned.</span></span>  
  
 <span data-ttu-id="31dae-1257">您可以藉由指定從中您原先安裝應用程式的位置 （例如，Web 位址） 來啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1257">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="31dae-1258">藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1258">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1259">如果您使用 Visual Studio 中的這個多載<xref:System.Diagnostics.Process.Start%2A>方法就是拖曳後，您將您的程式碼插入<xref:System.Diagnostics.Process>元件拖曳至設計工具。</span><span class="sxs-lookup"><span data-stu-id="31dae-1259">If you are using Visual Studio, this overload of the <xref:System.Diagnostics.Process.Start%2A> method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer.</span></span> <span data-ttu-id="31dae-1260">使用`Properties`視窗中，展開`StartInfo`類別目錄和寫入至適當的值`FileName`屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1260">Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property.</span></span> <span data-ttu-id="31dae-1261">您的變更會出現在表單的`InitializeComponent`程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1261">Your changes will appear in the form's `InitializeComponent` procedure.</span></span>  
  
 <span data-ttu-id="31dae-1262">這個多載<xref:System.Diagnostics.Process.Start%2A>不是`static`方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1262">This overload of <xref:System.Diagnostics.Process.Start%2A> is not a `static` method.</span></span> <span data-ttu-id="31dae-1263">您必須呼叫它的執行個體從<xref:System.Diagnostics.Process>類別。</span><span class="sxs-lookup"><span data-stu-id="31dae-1263">You must call it from an instance of the <xref:System.Diagnostics.Process> class.</span></span> <span data-ttu-id="31dae-1264">然後再呼叫<xref:System.Diagnostics.Process.Start%2A>，您必須先指定<xref:System.Diagnostics.Process.StartInfo%2A>屬性資訊<xref:System.Diagnostics.Process>執行個體，因為該資訊來判斷啟動的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1264">Before calling <xref:System.Diagnostics.Process.Start%2A>, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.</span></span>  
  
 <span data-ttu-id="31dae-1265">其他多載<xref:System.Diagnostics.Process.Start%2A>方法會`static`成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-1265">The other overloads of the <xref:System.Diagnostics.Process.Start%2A> method are `static` members.</span></span> <span data-ttu-id="31dae-1266">您不需要建立的執行個體<xref:System.Diagnostics.Process>元件才能呼叫方法的多載。</span><span class="sxs-lookup"><span data-stu-id="31dae-1266">You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method.</span></span> <span data-ttu-id="31dae-1267">相反地，您可以呼叫<xref:System.Diagnostics.Process.Start%2A>for<xref:System.Diagnostics.Process>類別本身，以及新<xref:System.Diagnostics.Process>如果處理序已啟動，則會建立元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1267">Instead, you can call <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started.</span></span> <span data-ttu-id="31dae-1268">或者，`null`會傳回處理程序已重複使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1268">Or, `null` is returned if a process was reused.</span></span> <span data-ttu-id="31dae-1269">處理序資源會自動與新的關聯<xref:System.Diagnostics.Process>所傳回的元件<xref:System.Diagnostics.Process.Start%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1269">The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the <xref:System.Diagnostics.Process.Start%2A> method.</span></span>  
  
 <span data-ttu-id="31dae-1270"><xref:System.Diagnostics.Process.StartInfo%2A>成員可以用來複製的功能`Run`對話方塊中的 Windows`Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="31dae-1270">The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="31dae-1271">任何可以輸入命令列的項目可以啟動程式中設定適當的值<xref:System.Diagnostics.Process.StartInfo%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1271">Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="31dae-1272">唯一<xref:System.Diagnostics.Process.StartInfo%2A>必須設定的屬性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1272">The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="31dae-1273"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性沒有可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1273">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file.</span></span> <span data-ttu-id="31dae-1274">它可以是任何的延伸模組已安裝在系統的應用程式相關聯的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="31dae-1274">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="31dae-1275">比方說，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以有副檔名為.txt，如果您的文字檔案關聯的編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有副檔名為.doc。</span><span class="sxs-lookup"><span data-stu-id="31dae-1275">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="31dae-1276">在命令列中，您可以指定要用於特定類型的檔案所採取的動作。</span><span class="sxs-lookup"><span data-stu-id="31dae-1276">In the command line, you can specify actions to take for certain types of files.</span></span> <span data-ttu-id="31dae-1277">例如，您可以列印文件，或編輯文字檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1277">For example, you can print documents or edit text files.</span></span> <span data-ttu-id="31dae-1278">指定使用這些動作<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1278">Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="31dae-1279">對於其他類型的檔案中，您可以指定命令列引數時開始從檔案`Run` 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="31dae-1279">For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box.</span></span> <span data-ttu-id="31dae-1280">比方說，您可以傳遞 URL 作為引數如果您指定做為您的瀏覽器<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1280">For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</span></span> <span data-ttu-id="31dae-1281">中可以指定這些引數<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-1281">These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.</span></span>  
  
 <span data-ttu-id="31dae-1282">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1282">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="31dae-1283">否則，系統將無法找到路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1283">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="31dae-1284">例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="31dae-1284">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1285">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1285">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="31dae-1286">如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。</span><span class="sxs-lookup"><span data-stu-id="31dae-1286">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="31dae-1287">處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1287">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="31dae-1288">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1288">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="31dae-1289">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1289">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-1290">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1290">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="31dae-1291">這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="31dae-1291">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="31dae-1292">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1292">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="31dae-1293">Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1293">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="31dae-1294">某些方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1294">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="31dae-1295">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="31dae-1295">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="31dae-1296">不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1296">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1297">下列範例使用的執行個體<xref:System.Diagnostics.Process>類別來啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1297">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1298">在 <see cref="T:System.Diagnostics.Process" /> 元件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1298">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.</span></span>
<span data-ttu-id="31dae-1299">或者，<see cref="P:System.Diagnostics.Process.StartInfo" /> 屬性的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 成員是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1299">-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1300">開啟關聯檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1300">There was an error in opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31dae-1301">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="31dae-1301">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1302">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1302">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1303">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1303">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1304">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1304">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo"><span data-ttu-id="31dae-1305"><see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用來啟動處理序的資訊，包括檔名和任何命令列引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1305">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</span></span></param>
        <summary><span data-ttu-id="31dae-1306">啟動含有處理序啟動資訊 (例如，要啟動之處理序的檔名) 的參數所指定的處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1306">Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="31dae-1307">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1307">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="31dae-1308">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="31dae-1308">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="31dae-1309">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1309">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="31dae-1310">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1310">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1311">使用此多載來啟動處理序資源，藉由指定<xref:System.Diagnostics.ProcessStartInfo>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1311">Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span> <span data-ttu-id="31dae-1312">多載會將資源與新<xref:System.Diagnostics.Process>物件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1312">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1313">如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。</span><span class="sxs-lookup"><span data-stu-id="31dae-1313">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="31dae-1314">這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1314">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1315">使用這個多載<xref:System.Diagnostics.ProcessStartInfo>參數是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定其<xref:System.Diagnostics.Process.StartInfo%2A>內容，然後呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1315">Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="31dae-1316">使用<xref:System.Diagnostics.ProcessStartInfo>執行個體如下參數可讓您呼叫<xref:System.Diagnostics.Process.Start%2A>控制最傳入啟動程序呼叫。</span><span class="sxs-lookup"><span data-stu-id="31dae-1316">Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process.</span></span> <span data-ttu-id="31dae-1317">如果您需要將只能在檔案名稱或檔案名稱和引數傳遞，不需要建立新<xref:System.Diagnostics.ProcessStartInfo>執行個體，雖然這是一個選項。</span><span class="sxs-lookup"><span data-stu-id="31dae-1317">If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option.</span></span> <span data-ttu-id="31dae-1318">唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>必須設定的屬性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1318">The only <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="31dae-1319"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1319">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="31dae-1320">它可以是任何的延伸模組已安裝在系統的應用程式相關聯的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="31dae-1320">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="31dae-1321">比方說，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性可以有副檔名為.txt，如果您的文字檔案關聯的編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有副檔名為.doc。</span><span class="sxs-lookup"><span data-stu-id="31dae-1321">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="31dae-1322">您可以藉由指定從中您原先安裝應用程式的位置 （例如，Web 位址） 來啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1322">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="31dae-1323">藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1323">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="31dae-1324">如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>並<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>的屬性<xref:System.Diagnostics.Process.StartInfo%2A>執行個體設定，未受管理`CreateProcessWithLogonW`呼叫函式，這會啟動程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1324">If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>.</span></span> <span data-ttu-id="31dae-1325">如果<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>屬性是`null`，則<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>屬性必須以 UPN 格式*使用者*@*DNS_domain_name*。</span><span class="sxs-lookup"><span data-stu-id="31dae-1325">If the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> property is `null`, the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> property must be in UPN format, *user*@*DNS_domain_name*.</span></span>   
  
 <span data-ttu-id="31dae-1326">不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-1326">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="31dae-1327">使用當您已建立多載<xref:System.Diagnostics.Process>執行個體，指定的開始資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1327">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1328">使用其中一種`static`當您想要建立新的多載<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1328">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="31dae-1329">這個多載並沒有參數的多載可讓您藉由使用指定的處理序資源的啟動資訊<xref:System.Diagnostics.ProcessStartInfo>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1329">Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span>  
  
 <span data-ttu-id="31dae-1330">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1330">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="31dae-1331">否則，系統將無法找到路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1331">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="31dae-1332">例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="31dae-1332">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1333">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1333">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="31dae-1334">如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。</span><span class="sxs-lookup"><span data-stu-id="31dae-1334">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="31dae-1335">處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1335">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="31dae-1336">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1336">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="31dae-1337">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1337">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-1338">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1338">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="31dae-1339">這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="31dae-1339">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="31dae-1340">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>已`true`上`startInfo`參數，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1340">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="31dae-1341">Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1341">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="31dae-1342">某些方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1342">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="31dae-1343">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="31dae-1343">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="31dae-1344">不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1344">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1345">下列範例首先會繁衍的 Internet Explorer 執行個體，並會顯示在瀏覽器中的 [我的最愛] 資料夾的內容。</span><span class="sxs-lookup"><span data-stu-id="31dae-1345">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="31dae-1346">然後會啟動 Internet Explorer 的某些其他執行個體，並會顯示一些特定的網頁或網站。</span><span class="sxs-lookup"><span data-stu-id="31dae-1346">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="31dae-1347">最後它會啟動 Internet Explorer 與正在同時瀏覽至特定站台的最小化視窗。</span><span class="sxs-lookup"><span data-stu-id="31dae-1347">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 <span data-ttu-id="31dae-1348">這個方法的其他用途的其他範例，請參閱個別屬性的<xref:System.Diagnostics.ProcessStartInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="31dae-1348">For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1349">在 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性沒有指定任何檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1349">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.</span></span>  
  
<span data-ttu-id="31dae-1350">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1350">-or-</span></span> 
<span data-ttu-id="31dae-1351"><paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 屬性也是 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1351">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.</span></span>  
  
<span data-ttu-id="31dae-1352">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1352">-or-</span></span> 
<span data-ttu-id="31dae-1353"><paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 屬性是 <see langword="true" />，而 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 屬性不是 <see langword="null" /> 或空白，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 屬性不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1353">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31dae-1354"><paramref name="startInfo" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1354">The <paramref name="startInfo" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31dae-1355">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="31dae-1355">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="31dae-1356">找不到 <paramref name="startInfo" /> 參數的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 屬性中所指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-1356">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1357">開啟關聯檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1357">An error occurred when opening the associated file.</span></span>  
  
<span data-ttu-id="31dae-1358">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1358">-or-</span></span> 
<span data-ttu-id="31dae-1359">引數長度和處理序完整路徑長度的總和超過 2080。</span><span class="sxs-lookup"><span data-stu-id="31dae-1359">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="31dae-1360">與這個例外狀況相關聯的錯誤訊息可以是下列其中之一：「傳到系統呼叫的資料區域太小。」</span><span class="sxs-lookup"><span data-stu-id="31dae-1360">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="31dae-1361">或「拒絕存取」。</span><span class="sxs-lookup"><span data-stu-id="31dae-1361">or "Access is denied."</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1362">此方法在沒有殼層支援的作業系統上不受支援，例如 Nano 伺服器 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1362">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1363">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1363">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1364">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1364">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="31dae-1365">要在處理序中執行之文件或應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1365">The name of a document or application file to run in the process.</span></span></param>
        <summary><span data-ttu-id="31dae-1366">藉由指定文件或應用程式檔案的名稱啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1366">Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="31dae-1367">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1367">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="31dae-1368">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="31dae-1368">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="31dae-1369">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1369">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="31dae-1370">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1370">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1371">使用這個多載來啟動處理序資源指定檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1371">Use this overload to start a process resource by specifying its file name.</span></span> <span data-ttu-id="31dae-1372">多載會將資源與新<xref:System.Diagnostics.Process>物件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1372">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1373">如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。</span><span class="sxs-lookup"><span data-stu-id="31dae-1373">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="31dae-1374">這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1374">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1375">多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>隸屬<xref:System.Diagnostics.Process.StartInfo%2A>屬性，然後呼叫<xref:System.Diagnostics.Process.Start%2A>如<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1375">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="31dae-1376">您可以啟動 ClickOnce 應用程式設定`fileName`參數，以在原本安裝的應用程式的位置 （例如，Web 位址）。</span><span class="sxs-lookup"><span data-stu-id="31dae-1376">You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="31dae-1377">藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1377">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="31dae-1378">藉由指定其檔案名稱啟動處理序是類似於輸入中的資訊`Run`對話方塊中的 Windows`Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="31dae-1378">Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="31dae-1379">因此，檔案名稱不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1379">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="31dae-1380">它可以是任何的副檔名已經相關聯的系統上安裝的應用程式的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="31dae-1380">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="31dae-1381">比方說如果文字檔聯編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有.doc 的檔案名稱可以有副檔名為.txt。</span><span class="sxs-lookup"><span data-stu-id="31dae-1381">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="31dae-1382">同樣地，在相同方式來`Run` 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1382">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="31dae-1383">例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1383">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="31dae-1384">這個多載不允許處理序的命令列引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1384">This overload does not allow command-line arguments for the process.</span></span> <span data-ttu-id="31dae-1385">如果您需要指定處理序的一或多個命令列引數，使用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>或<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>多載。</span><span class="sxs-lookup"><span data-stu-id="31dae-1385">If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overloads.</span></span>  
  
 <span data-ttu-id="31dae-1386">不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-1386">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="31dae-1387">使用當您已建立多載<xref:System.Diagnostics.Process>執行個體，指定的開始資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1387">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1388">使用其中一種`static`當您想要建立新的多載<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1388">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="31dae-1389">這個多載並沒有參數的多載可讓您指定要啟動的處理序資源的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1389">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.</span></span>  
  
 <span data-ttu-id="31dae-1390">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1390">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="31dae-1391">否則，系統將無法找到路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1391">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="31dae-1392">例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="31dae-1392">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1393">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1393">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="31dae-1394">如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。</span><span class="sxs-lookup"><span data-stu-id="31dae-1394">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="31dae-1395">處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1395">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="31dae-1396">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1396">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="31dae-1397">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1397">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-1398">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1398">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="31dae-1399">這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="31dae-1399">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="31dae-1400">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1400">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="31dae-1401">Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1401">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="31dae-1402">某些方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1402">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="31dae-1403">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="31dae-1403">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="31dae-1404">不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1404">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1405">下列範例首先會繁衍的 Internet Explorer 執行個體，並會顯示在瀏覽器中的 [我的最愛] 資料夾的內容。</span><span class="sxs-lookup"><span data-stu-id="31dae-1405">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="31dae-1406">然後會啟動 Internet Explorer 的某些其他執行個體，並會顯示一些特定的網頁或網站。</span><span class="sxs-lookup"><span data-stu-id="31dae-1406">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="31dae-1407">最後它會啟動 Internet Explorer 與正在同時瀏覽至特定站台的最小化視窗。</span><span class="sxs-lookup"><span data-stu-id="31dae-1407">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1408">開啟關聯的檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1408">An error occurred when opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31dae-1409">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="31dae-1409">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="31dae-1410">PATH 環境變數具有含引號的字串。</span><span class="sxs-lookup"><span data-stu-id="31dae-1410">The PATH environment variable has a string containing quotes.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1411">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1411">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1412">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1412">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="31dae-1413">要在處理序中執行之應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1413">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="31dae-1414">啟動處理程序時要傳遞的命令列引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1414">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="31dae-1415">藉由指定應用程式的名稱和一組命令列引數來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1415">Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="31dae-1416">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1416">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="31dae-1417">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="31dae-1417">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="31dae-1418">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1418">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="31dae-1419">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1419">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1420">若要啟動處理序資源，藉由指定其檔案名稱和命令列引數中使用此多載。</span><span class="sxs-lookup"><span data-stu-id="31dae-1420">Use this overload to start a process resource by specifying its file name and command-line arguments.</span></span> <span data-ttu-id="31dae-1421">多載會將資源與新<xref:System.Diagnostics.Process>物件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1421">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1422">如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。</span><span class="sxs-lookup"><span data-stu-id="31dae-1422">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="31dae-1423">這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1423">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1424">多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>並<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>的成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性，以及呼叫<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1424">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="31dae-1425">藉由指定其檔案名稱和引數啟動程序是類似於輸入的檔案名稱和中的命令列引數`Run`對話方塊中的 Windows`Start`功能表。</span><span class="sxs-lookup"><span data-stu-id="31dae-1425">Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="31dae-1426">因此，檔案名稱不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1426">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="31dae-1427">它可以是任何的副檔名已經相關聯的系統上安裝的應用程式的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="31dae-1427">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="31dae-1428">比方說如果文字檔聯編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有.doc 的檔案名稱可以有副檔名為.txt。</span><span class="sxs-lookup"><span data-stu-id="31dae-1428">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="31dae-1429">同樣地，在相同方式來`Run` 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1429">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="31dae-1430">例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1430">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="31dae-1431">如果`fileName`參數表示可執行檔`arguments`參數可能代表採取動作，例如文字檔案中的檔案`Notepad.exe myfile.txt`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1431">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span> <span data-ttu-id="31dae-1432">如果`fileName`參數代表命令 (.cmd) 檔`arguments`參數必須包含 「`/c`「 或 」`/k`"引數來指定是否在命令視窗結束或完成後仍會保持。</span><span class="sxs-lookup"><span data-stu-id="31dae-1432">If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a "`/c`" or "`/k`" argument to specify whether the command window exits or remains after completion.</span></span>  
  
 <span data-ttu-id="31dae-1433">不同於其他多載的多載<xref:System.Diagnostics.Process.Start%2A>不具有任何參數不是`static`成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-1433">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="31dae-1434">使用當您已建立多載<xref:System.Diagnostics.Process>執行個體，指定的開始資訊 （包括檔案名稱），而且想要啟動處理序資源，並將它與現有關聯<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1434">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1435">使用其中一種`static`當您想要建立新的多載<xref:System.Diagnostics.Process>元件，而不是啟動現有元件的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1435">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="31dae-1436">這個多載並沒有參數的多載可讓您指定要傳遞的命令列引數與啟動的處理序資源的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1436">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.</span></span>  
  
 <span data-ttu-id="31dae-1437">如果您有宣告在系統中使用引號括住路徑變數，您必須在啟動該位置中找到任何處理序時完整限定該路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1437">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="31dae-1438">否則，系統將無法找到路徑。</span><span class="sxs-lookup"><span data-stu-id="31dae-1438">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="31dae-1439">例如，如果`c:\mypath`不在您的路徑，而且您新增使用引號： `path = %path%;"c:\mypath"`，您必須完整限定在任何處理序`c:\mypath`時啟動它。</span><span class="sxs-lookup"><span data-stu-id="31dae-1439">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1440">ASP.NET 工作者處理序，在 Web 伺服器上的內容中執行 ASP.NET Web 網頁和伺服器控制項的程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1440">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="31dae-1441">如果您使用<xref:System.Diagnostics.Process.Start%2A>ASP.NET 網頁或伺服器控制項中的方法，新的處理序 Web 伺服器上執行具有限制權限。</span><span class="sxs-lookup"><span data-stu-id="31dae-1441">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="31dae-1442">處理程序不會啟動與用戶端瀏覽器中，相同的內容中，而且沒有存取權的使用者桌面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1442">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="31dae-1443">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1443">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="31dae-1444">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1444">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-1445">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...</span><span class="sxs-lookup"><span data-stu-id="31dae-1445">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
 <span data-ttu-id="31dae-1446">這裡的附註中的 managed 執行緒的 apartment 狀態是必要的。</span><span class="sxs-lookup"><span data-stu-id="31dae-1446">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="31dae-1447">當<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`處理序元件<xref:System.Diagnostics.Process.StartInfo%2A>屬性，請確定您已在您的應用程式上設定執行緒模型，藉由將屬性`[STAThread]`上`main()`方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1447">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="31dae-1448">Managed 的執行緒在可以的否則為`unknown`狀態，或放入`MTA`狀態，後者的 je v konfliktu<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1448">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="31dae-1449">某些方法需要的 apartment 狀態不是`unknown`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1449">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="31dae-1450">如果狀態未明確設定，當應用程式遇到這種方法，則預設為`MTA`，而且設定之後，apartment 狀態無法變更。</span><span class="sxs-lookup"><span data-stu-id="31dae-1450">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="31dae-1451">不過，`MTA`造成作業系統殼層來管理執行緒時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1451">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1452">下列範例首先會繁衍的 Internet Explorer 執行個體，並會顯示在瀏覽器中的 [我的最愛] 資料夾的內容。</span><span class="sxs-lookup"><span data-stu-id="31dae-1452">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="31dae-1453">然後會啟動 Internet Explorer 的某些其他執行個體，並會顯示一些特定的網頁或網站。</span><span class="sxs-lookup"><span data-stu-id="31dae-1453">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="31dae-1454">最後它會啟動 Internet Explorer 與正在同時瀏覽至特定站台的最小化視窗。</span><span class="sxs-lookup"><span data-stu-id="31dae-1454">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1455"><paramref name="fileName" /> 或 <paramref name="arguments" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1455">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1456">開啟關聯的檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1456">An error occurred when opening the associated file.</span></span>  
  
<span data-ttu-id="31dae-1457">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1457">-or-</span></span> 
<span data-ttu-id="31dae-1458">引數長度和處理序完整路徑長度的總和超過 2080。</span><span class="sxs-lookup"><span data-stu-id="31dae-1458">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="31dae-1459">與這個例外狀況相關聯的錯誤訊息可以是下列其中之一：「傳到系統呼叫的資料區域太小。」</span><span class="sxs-lookup"><span data-stu-id="31dae-1459">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="31dae-1460">或「拒絕存取」。</span><span class="sxs-lookup"><span data-stu-id="31dae-1460">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31dae-1461">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="31dae-1461">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="31dae-1462">PATH 環境變數具有含引號的字串。</span><span class="sxs-lookup"><span data-stu-id="31dae-1462">The PATH environment variable has a string containing quotes.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1463">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1463">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1464">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1464">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="31dae-1465">要在處理序中執行之應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1465">The name of an application file to run in the process.</span></span></param>
        <param name="userName"><span data-ttu-id="31dae-1466">要在啟動處理序時使用的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1466">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="31dae-1467"><see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1467">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="31dae-1468">要在啟動處理序時使用的網域。</span><span class="sxs-lookup"><span data-stu-id="31dae-1468">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="31dae-1469">藉由指定應用程式的名稱、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1469">Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="31dae-1470">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1470">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="31dae-1471">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="31dae-1471">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="31dae-1472">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1472">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="31dae-1473">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1473">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1474">您可以使用此多載，藉由指定其檔案名稱、 使用者名稱、 密碼和網域中建立新的處理序和其主要的執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1474">Use this overload to create a new process and its primary thread by specifying its file name, user name, password, and domain.</span></span> <span data-ttu-id="31dae-1475">新的處理序再執行指定的可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。</span><span class="sxs-lookup"><span data-stu-id="31dae-1475">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1476">當可執行檔位於遠端的磁碟機中時，您必須使用統一資源識別元 (URI) 未連結的磁碟機代號來識別網路共用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1476">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1477">如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。</span><span class="sxs-lookup"><span data-stu-id="31dae-1477">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="31dae-1478">這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1478">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1479">多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，並<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，並呼叫<xref:System.Diagnostics.Process.Start%2A>的<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1479">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="31dae-1480">同樣地，在相同方式來**執行** 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1480">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="31dae-1481">例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1481">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="31dae-1482">如果`fileName`參數表示可執行檔`arguments`參數可能代表採取動作，例如文字檔案中的檔案`Notepad.exe myfile.txt`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1482">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1483">檔案名稱必須代表的可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1483">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="31dae-1484">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1484">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="31dae-1485">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1485">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-1486">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...</span><span class="sxs-lookup"><span data-stu-id="31dae-1486">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1487">下列程式碼範例將示範如何使用此多載，來啟動可執行檔，並也會示範擲回<xref:System.ComponentModel.Win32Exception>時嘗試啟動不可執行的檔案相關聯的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1487">The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1488">未指定檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1488">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1489">開啟關聯檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1489">There was an error in opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31dae-1490">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="31dae-1490">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1491">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1491">Method not supported on Linux or macOS (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1492">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1492">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1493">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1493">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="31dae-1494">要在處理序中執行之應用程式檔案的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1494">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="31dae-1495">啟動處理程序時要傳遞的命令列引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1495">Command-line arguments to pass when starting the process.</span></span></param>
        <param name="userName"><span data-ttu-id="31dae-1496">要在啟動處理序時使用的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1496">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="31dae-1497"><see cref="T:System.Security.SecureString" />，包含啟動處理序時要使用的密碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1497">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="31dae-1498">要在啟動處理序時使用的網域。</span><span class="sxs-lookup"><span data-stu-id="31dae-1498">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="31dae-1499">藉由指定應用程式的名稱、一組命令列引數、使用者名稱、密碼和網域來啟動處理序資源，並將該資源與新的 <see cref="T:System.Diagnostics.Process" /> 元件相關聯。</span><span class="sxs-lookup"><span data-stu-id="31dae-1499">Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="31dae-1500">與處理程序資源關聯的新 <see cref="T:System.Diagnostics.Process" />，或者是 <see langword="null" /> (若未啟動任何處理程序資源)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1500">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="31dae-1501">請注意，隨著已在執行中之相同處理程序啟動的新處理程序將獨立於其他處理程序之外。</span><span class="sxs-lookup"><span data-stu-id="31dae-1501">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="31dae-1502">此外，啟動可能會傳回非空值處理程序，且其 <see cref="P:System.Diagnostics.Process.HasExited" /> 屬性會設定為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1502">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="31dae-1503">在此案例中，已啟動的處理程序可能已啟用本身的現有執行個體並結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1503">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1504">您可以使用此多載，藉由指定其檔案名稱、 命令列引數、 使用者名稱、 密碼和網域中建立新的處理序和其主要的執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1504">Use this overload to create a new process and its primary thread by specifying its file name, command-line arguments, user name, password, and domain.</span></span> <span data-ttu-id="31dae-1505">新的處理序再執行指定的可執行檔中指定的認證 （使用者、 網域及密碼） 的安全性內容。</span><span class="sxs-lookup"><span data-stu-id="31dae-1505">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1506">當可執行檔位於遠端的磁碟機中時，您必須使用統一資源識別元 (URI) 未連結的磁碟機代號來識別網路共用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1506">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1507">如果要啟動可執行檔的位址 URL，此程序未啟動和`null`會傳回。</span><span class="sxs-lookup"><span data-stu-id="31dae-1507">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="31dae-1508">這個多載可讓您不需要先建立一個新啟動的處理序<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1508">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="31dae-1509">多載是明確的步驟，建立新的替代<xref:System.Diagnostics.Process>執行個體，設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>屬性<xref:System.Diagnostics.Process.StartInfo%2A>屬性，然後呼叫<xref:System.Diagnostics.Process.Start%2A>針對<xref:System.Diagnostics.Process>執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1509">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="31dae-1510">同樣地，在相同方式來**執行** 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性的`fileName`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1510">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="31dae-1511">例如，您可以設定`fileName`"Notepad.exe"或"Notepad"的參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1511">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="31dae-1512">如果`fileName`參數表示可執行檔`arguments`參數可能代表採取動作，例如文字檔案中的檔案`Notepad.exe myfile.txt`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1512">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1513">檔案名稱必須代表的可執行檔<xref:System.Diagnostics.Process.Start%2A>的多載`userName`， `password`，和`domain`參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1513">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="31dae-1514">每當您使用<xref:System.Diagnostics.Process.Start%2A>啟動處理序，您可能需要將它關閉，或可能會遺失的系統資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1514">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="31dae-1515">關閉使用的處理程序<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1515">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="31dae-1516">您可以檢查處理程序是否已經使用關閉其<xref:System.Diagnostics.Process.HasExited%2A>屬性...</span><span class="sxs-lookup"><span data-stu-id="31dae-1516">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property..</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1517">未指定檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1517">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1518">開啟關聯的檔案時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1518">An error occurred when opening the associated file.</span></span>  
  
<span data-ttu-id="31dae-1519">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1519">-or-</span></span> 
<span data-ttu-id="31dae-1520">引數長度和關聯檔案完整路徑長度的總和超過 2080。</span><span class="sxs-lookup"><span data-stu-id="31dae-1520">The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080.</span></span> <span data-ttu-id="31dae-1521">與這個例外狀況關聯的錯誤訊息可以是下列其中之一：「傳遞到系統呼叫的資料區太小」，</span><span class="sxs-lookup"><span data-stu-id="31dae-1521">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="31dae-1522">或「拒絕存取」。</span><span class="sxs-lookup"><span data-stu-id="31dae-1522">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31dae-1523">處理序物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="31dae-1523">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1524">此方法在 Linux 或 macOS 上不受支援 (僅限 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1524">Method not supported on Linux or macOS (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1525">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1525">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1526">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1526">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1527">取得或設定要傳遞給 <see cref="T:System.Diagnostics.Process" /> 之 <see cref="M:System.Diagnostics.Process.Start" /> 方法的屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1527">Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</span></span></summary>
        <value><span data-ttu-id="31dae-1528"><see cref="T:System.Diagnostics.ProcessStartInfo" />，代表用來啟動處理序的資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-1528">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that represents the data with which to start the process.</span></span> <span data-ttu-id="31dae-1529">這些引數包括用來啟動處理序的可執行檔或文件的名稱。</span><span class="sxs-lookup"><span data-stu-id="31dae-1529">These arguments include the name of the executable file or document used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1530"><xref:System.Diagnostics.Process.StartInfo%2A> 表示要用來啟動處理程序的參數組。</span><span class="sxs-lookup"><span data-stu-id="31dae-1530"><xref:System.Diagnostics.Process.StartInfo%2A> represents the set of parameters to use to start a process.</span></span> <span data-ttu-id="31dae-1531">當<xref:System.Diagnostics.Process.Start%2A>呼叫時，<xref:System.Diagnostics.Process.StartInfo%2A>用來指定要啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1531">When <xref:System.Diagnostics.Process.Start%2A> is called, the <xref:System.Diagnostics.Process.StartInfo%2A> is used to specify the process to start.</span></span> <span data-ttu-id="31dae-1532">只有必要的時候<xref:System.Diagnostics.Process.StartInfo%2A>若要設定的成員是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1532">The only necessary <xref:System.Diagnostics.Process.StartInfo%2A> member to set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="31dae-1533">藉由指定啟動處理序<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性是類似於輸入中的資訊**執行**Windows 對話方塊**啟動**功能表。</span><span class="sxs-lookup"><span data-stu-id="31dae-1533">Starting a process by specifying the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property is similar to typing the information in the **Run** dialog box of the Windows **Start** menu.</span></span> <span data-ttu-id="31dae-1534">因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要代表可執行檔。</span><span class="sxs-lookup"><span data-stu-id="31dae-1534">Therefore, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="31dae-1535">它可以是任何的副檔名已經相關聯的系統上安裝的應用程式的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="31dae-1535">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="31dae-1536">例如<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>可以有副檔名為.txt，如果您文字的檔案關聯的編輯器，例如 [記事本]，或如果您有使用文字處理工具，例如 Microsoft Word associated.doc 檔案，它可以有.doc。</span><span class="sxs-lookup"><span data-stu-id="31dae-1536">For example the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="31dae-1537">同樣地，在相同方式來**執行** 對話方塊中可接受包含或不含副檔名為.exe 的可執行檔名稱，副檔名為.exe 是選擇性在<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-1537">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="31dae-1538">例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>"Notepad.exe"或"Notepad"的屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1538">For example, you can set the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="31dae-1539">您可以啟動 ClickOnce 應用程式設定<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>在原本安裝的應用程式的位置 （例如，Web 位址） 的屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1539">You can start a ClickOnce application by setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="31dae-1540">藉由指定已安裝硬碟機上，不要啟動 ClickOnce 應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1540">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="31dae-1541">如果檔案名稱包含非執行檔的檔案，例如.doc 檔案，您可以包含指定要對檔案執行的動作動詞命令。</span><span class="sxs-lookup"><span data-stu-id="31dae-1541">If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file.</span></span> <span data-ttu-id="31dae-1542">例如，您可以設定<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>"Print"，結尾為.doc 副檔名的檔案。</span><span class="sxs-lookup"><span data-stu-id="31dae-1542">For example, you could set the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> to "Print" for a file ending in the .doc extension.</span></span> <span data-ttu-id="31dae-1543">在指定的檔名<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>屬性不需要有副檔名，如果您手動輸入的值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1543">The file name specified in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to have an extension if you manually enter a value for the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> property.</span></span> <span data-ttu-id="31dae-1544">不過，如果您使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>屬性來判斷何種動詞可供使用，您必須包含副檔名。</span><span class="sxs-lookup"><span data-stu-id="31dae-1544">However, if you use the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property to determine what verbs are available, you must include the extension.</span></span>  
  
 <span data-ttu-id="31dae-1545">您可以變更中指定的參數<xref:System.Diagnostics.Process.StartInfo%2A>屬性，讓您呼叫為止<xref:System.Diagnostics.Process.Start%2A>程序的方法。</span><span class="sxs-lookup"><span data-stu-id="31dae-1545">You can change the parameters specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property up to the time that you call the <xref:System.Diagnostics.Process.Start%2A> method on the process.</span></span> <span data-ttu-id="31dae-1546">啟動程序之後，變更<xref:System.Diagnostics.Process.StartInfo%2A>值不會影響或重新啟動相關的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1546">After you start the process, changing the <xref:System.Diagnostics.Process.StartInfo%2A> values does not affect or restart the associated process.</span></span> <span data-ttu-id="31dae-1547">如果您呼叫<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>方法<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>並<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>屬性集，如果未受管理`CreateProcessWithLogonW`呼叫函式，這會啟動程序在新視窗即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>屬性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>屬性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1547">If you call the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> method with the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.</span></span>  
  
 <span data-ttu-id="31dae-1548">如果您未使用<xref:System.Diagnostics.Process.Start%2A>方法來啟動處理程序，<xref:System.Diagnostics.Process.StartInfo%2A>屬性不會反映使用啟動程序的參數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1548">If you did not use the <xref:System.Diagnostics.Process.Start%2A> method to start a process, the <xref:System.Diagnostics.Process.StartInfo%2A> property does not reflect the parameters used to start the process.</span></span> <span data-ttu-id="31dae-1549">例如，如果您使用<xref:System.Diagnostics.Process.GetProcesses%2A>以取得陣列的電腦上，執行的處理序<xref:System.Diagnostics.Process.StartInfo%2A>每個屬性<xref:System.Diagnostics.Process>不包含原始的檔案名稱或用來啟動處理程序的引數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1549">For example, if you use <xref:System.Diagnostics.Process.GetProcesses%2A> to get an array of processes running on the computer, the <xref:System.Diagnostics.Process.StartInfo%2A> property of each <xref:System.Diagnostics.Process> does not contain the original file name or arguments used to start the process.</span></span>  
  
 <span data-ttu-id="31dae-1550">檔案名稱啟動處理程序時，會填入 （唯讀） 檔案<xref:System.Diagnostics.Process.MainModule%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1550">When the process is started, the file name is the file that populates the (read-only) <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="31dae-1551">如果您想要擷取可執行檔所關聯的處理序啟動程序之後，請使用<xref:System.Diagnostics.Process.MainModule%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1551">If you want to retrieve the executable file that is associated with the process after the process has started, use the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="31dae-1552">如果您想要設定的可執行檔<xref:System.Diagnostics.Process>執行個體的相關聯的處理序尚未啟動，請使用<xref:System.Diagnostics.Process.StartInfo%2A>屬性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成員。</span><span class="sxs-lookup"><span data-stu-id="31dae-1552">If you want to set the executable file of a <xref:System.Diagnostics.Process> instance for which an associated process has not been started, use the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="31dae-1553">因為成員<xref:System.Diagnostics.Process.StartInfo%2A>屬性會傳遞至引數<xref:System.Diagnostics.Process.Start%2A>方法的程序中，然後再變更<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>不會重設屬性相關聯的處理序啟動之後<xref:System.Diagnostics.Process.MainModule%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1553">Because the members of the <xref:System.Diagnostics.Process.StartInfo%2A> property are arguments that are passed to the <xref:System.Diagnostics.Process.Start%2A> method of a process, changing the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property after the associated process has started will not reset the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="31dae-1554">這些屬性是只能用來初始化相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1554">These properties are used only to initialize the associated process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1555">下列範例會填入<xref:System.Diagnostics.Process.StartInfo%2A>與要執行的檔案，它執行動作，以及是否應該顯示使用者介面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1555">The following example populates a <xref:System.Diagnostics.Process.StartInfo%2A> with the file to execute, the action performed on it and whether it should displays a user interface.</span></span> <span data-ttu-id="31dae-1556">如需其他範例，請參閱參考頁面屬性的<xref:System.Diagnostics.ProcessStartInfo>類別。</span><span class="sxs-lookup"><span data-stu-id="31dae-1556">For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31dae-1557">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1557">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1558">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1558">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1559">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1559">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1560">取得相關的處理序啟動的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1560">Gets the time that the associated process was started.</span></span></summary>
        <value><span data-ttu-id="31dae-1561">物件，指出處理序何時啟動。</span><span class="sxs-lookup"><span data-stu-id="31dae-1561">An object  that indicates when the process started.</span></span> <span data-ttu-id="31dae-1562">如果處理序並未執行，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1562">An exception is thrown if the process is not running.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1563">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1563">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1564">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.StartTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1564">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1565">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1565">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1566">處理序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1566">The process has exited.</span></span>  
  
<span data-ttu-id="31dae-1567">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1567">-or-</span></span> 
<span data-ttu-id="31dae-1568">尚未啟動處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1568">The process has not been started.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1569">呼叫 Windows 函式時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1569">An error occurred in the call to the Windows function.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1570">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1570">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1571">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1571">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1572">取得或設定物件，用以封送處理因處理序結束事件而發出的事件處理常式呼叫。</span><span class="sxs-lookup"><span data-stu-id="31dae-1572">Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</span></span></summary>
        <value><span data-ttu-id="31dae-1573"><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用以封送處理因處理序上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而發出的事件處理常式呼叫。</span><span class="sxs-lookup"><span data-stu-id="31dae-1573">The <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> used to marshal event handler calls that are issued as a result of an <see cref="E:System.Diagnostics.Process.Exited" /> event on the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1574">當<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>已`null`，處理方法<xref:System.Diagnostics.Process.Exited>系統執行緒集區的執行緒上呼叫事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1574">When <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> is `null`, methods that handle the <xref:System.Diagnostics.Process.Exited> event are called on a thread from the system thread pool.</span></span> <span data-ttu-id="31dae-1575">如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1575">For more information about system thread pools, see <xref:System.Threading.ThreadPool>.</span></span>  
  
 <span data-ttu-id="31dae-1576">當<xref:System.Diagnostics.Process.Exited>事件由 visual 的 Windows Form 元件，例如<xref:System.Windows.Forms.Button>，透過系統執行緒集區中存取元件可能無法運作，或可能會導致例外狀況。</span><span class="sxs-lookup"><span data-stu-id="31dae-1576">When the <xref:System.Diagnostics.Process.Exited> event is handled by a visual Windows Forms component, such as a <xref:System.Windows.Forms.Button>, accessing the component through the system thread pool might not work, or might result in an exception.</span></span> <span data-ttu-id="31dae-1577">藉由設定避免這<xref:System.Diagnostics.Process.SynchronizingObject%2A>至 Windows Form 元件，因而導致處理方法<xref:System.Diagnostics.Process.Exited>元件建立所在的相同執行緒上呼叫的事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1577">Avoid this by setting <xref:System.Diagnostics.Process.SynchronizingObject%2A> to a Windows Forms component, which causes the methods handling the <xref:System.Diagnostics.Process.Exited> event to be called on the same thread on which the component was created.</span></span>  
  
 <span data-ttu-id="31dae-1578">如果<xref:System.Diagnostics.Process>使用於內部[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.Diagnostics.Process.SynchronizingObject%2A>會自動設為包含的控制項<xref:System.Diagnostics.Process>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1578">If the <xref:System.Diagnostics.Process> is used inside [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in a Windows Forms designer, <xref:System.Diagnostics.Process.SynchronizingObject%2A> is automatically set to the control that contains the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="31dae-1579">比方說，如果您放置<xref:System.Diagnostics.Process>設計工具上`Form1`(繼承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性<xref:System.Diagnostics.Process>設定為執行個體`Form1`:</span><span class="sxs-lookup"><span data-stu-id="31dae-1579">For example, if you place a <xref:System.Diagnostics.Process> on a designer for `Form1` (which inherits from <xref:System.Windows.Forms.Form>) the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property of <xref:System.Diagnostics.Process> is set to the instance of `Form1`:</span></span>  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 <span data-ttu-id="31dae-1580">一般而言，這個屬性設定時元件會放置在控制項或表單中，因為這些元件會繫結至特定執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1580">Typically, this property is set when the component is placed inside a control or form, because those components are bound to a specific thread.</span></span>  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1581">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1581">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1582">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1582">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1583">取得正在相關的處理序中執行的執行緒集。</span><span class="sxs-lookup"><span data-stu-id="31dae-1583">Gets the set of threads that are running in the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-1584"><see cref="T:System.Diagnostics.ProcessThread" /> 類型的陣列，代表目前正在相關聯處理序中執行的作業系統執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1584">An array of type <see cref="T:System.Diagnostics.ProcessThread" /> representing the operating system threads currently running in the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1585">執行緒處理序中執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1585">A thread executes code in a process.</span></span> <span data-ttu-id="31dae-1586">每個處理序會啟動具有單一執行緒，其主要執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1586">Each process is started with a single thread, its primary thread.</span></span> <span data-ttu-id="31dae-1587">任何執行緒可以建立額外的執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1587">Any thread can create additional threads.</span></span> <span data-ttu-id="31dae-1588">在處理序中的執行緒共用處理序位址空間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1588">Threads within a process share the address space of the process.</span></span>  
  
 <span data-ttu-id="31dae-1589">使用<xref:System.Diagnostics.ProcessThread>，取得目前的處理序相關聯的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="31dae-1589">Use <xref:System.Diagnostics.ProcessThread> to get all the threads associated with the current process.</span></span> <span data-ttu-id="31dae-1590">主要執行緒不一定是在陣列中的索引為零。</span><span class="sxs-lookup"><span data-stu-id="31dae-1590">The primary thread is not necessarily at index zero in the array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="31dae-1591">處理序沒有 <see cref="P:System.Diagnostics.Process.Id" />，或沒有與 <see cref="T:System.Diagnostics.Process" /> 執行個體關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1591">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
<span data-ttu-id="31dae-1592">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1592">-or-</span></span> 
<span data-ttu-id="31dae-1593">關聯處理序已結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1593">The associated process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1594">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；將 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 設定為 <see langword="false" /> 可存取 Windows 98 和 Windows Me 上的這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1594">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1595">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1595">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1596">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1596">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-1597">將處理序的名稱格式化為字串，如果適用，將它和父代 (Parent) 元件類型結合。</span><span class="sxs-lookup"><span data-stu-id="31dae-1597">Formats the process's name as a string, combined with the parent component type, if applicable.</span></span></summary>
        <returns><span data-ttu-id="31dae-1598"><see cref="P:System.Diagnostics.Process.ProcessName" />，與基底元件的 <see cref="M:System.Object.ToString" /> 傳回值搭配相結合。</span><span class="sxs-lookup"><span data-stu-id="31dae-1598">The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="31dae-1599">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1599">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1600">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1600">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1601">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1601">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1602">Windows 98 不支援 <see cref="M:System.Diagnostics.Process.ToString" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1602"><see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1603">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1603">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1604">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1604">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1605">取得這個處理序的總處理器時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1605">Gets the total processor time for this process.</span></span></summary>
        <value><span data-ttu-id="31dae-1606"><see cref="T:System.TimeSpan" />，表示相關聯處理序花在使用 CPU 的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1606">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent utilizing the CPU.</span></span> <span data-ttu-id="31dae-1607">這個值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的總和。</span><span class="sxs-lookup"><span data-stu-id="31dae-1607">This value is the sum of the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> and the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="31dae-1608">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1608">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1609">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1609">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1610">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1610">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1611">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1611">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1612">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1612">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1613">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1613">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1614">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1614">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1615">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1615">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1616">取得這個處理序的使用者處理器時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1616">Gets the user processor time for this process.</span></span></summary>
        <value><span data-ttu-id="31dae-1617"><see cref="T:System.TimeSpan" />，表示相關聯處理序花在處理序的應用程式部分內 (而不是在作業系統核心內) 執行程式碼的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1617">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent running code inside the application portion of the process (not inside the operating system core).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="31dae-1618">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1618">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1619">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1619">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1620">在處理序結束時，此範例會偵測並顯示處理程序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1620">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1621">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1621">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="31dae-1622">您正在嘗試存取於遠端電腦上執行之處理序的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1622">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1623">這個屬性僅供在本機電腦執行的處理序使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1623">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1624">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1624">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1625">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1625">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1626">取得處理序的虛擬記憶體的大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1626">Gets the size of the process's virtual memory, in bytes.</span></span></summary>
        <value><span data-ttu-id="31dae-1627">虛擬記憶體量 (以位元組為單位)，指關聯的處理序所要求的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1627">The amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1628">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1628">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1629">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1629">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1630">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1630">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1631">取得配置給關聯處理序的虛擬記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-1631">Gets the amount of the virtual memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-1632">配置給關聯處理序的虛擬記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-1632">The amount of virtual memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1633">這個屬性所傳回的值表示目前程序，以位元組為單位使用的虛擬記憶體的大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-1633">The value returned by this property represents the current size of virtual memory used by the process, in bytes.</span></span> <span data-ttu-id="31dae-1634">作業系統會對應到頁面載入的實體記憶體，或儲存在磁碟上的虛擬記憶體分頁檔案中的頁面每個處理序虛擬位址空間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1634">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="31dae-1635">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-1635">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-1636">屬性值相當於**Virtual Bytes**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-1636">The property value is equivalent to the **Virtual Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1637">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1637">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-1638">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1638">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1639">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-1639">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1640">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1640">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1641">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1641">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1642">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1642">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31dae-1643">設定要等待相關的處理序結束的時間，並且阻止目前的執行緒執行，直到等候時間耗盡或者處理序已經結束為止。</span><span class="sxs-lookup"><span data-stu-id="31dae-1643">Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited.</span></span> <span data-ttu-id="31dae-1644">為避免封鎖目前的執行緒，請使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1644">To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span>  
  
<span data-ttu-id="31dae-1645">對於程式碼範例，請參閱 <see cref="P:System.Diagnostics.Process.StandardError" /> 與 <see cref="P:System.Diagnostics.Process.ExitCode" /> 屬性參考頁面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1645">For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-1646">指示 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1646">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1647"><xref:System.Diagnostics.Process.WaitForExit> 可讓目前的執行緒等候相關聯的處理序終止為止。</span><span class="sxs-lookup"><span data-stu-id="31dae-1647"><xref:System.Diagnostics.Process.WaitForExit> makes the current thread wait until the associated process terminates.</span></span>  <span data-ttu-id="31dae-1648">所有其他方法會呼叫程序之後，應該要進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="31dae-1648">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="31dae-1649">為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1649">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="31dae-1650">這個方法會指示<xref:System.Diagnostics.Process>元件等候無限量的時間到結束的處理程序和事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1650">This method instructs the <xref:System.Diagnostics.Process> component to wait an infinite amount of time for the process and event handlers to exit.</span></span> <span data-ttu-id="31dae-1651">這會造成停止回應的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1651">This can cause an application to stop responding.</span></span> <span data-ttu-id="31dae-1652">例如，如果您呼叫<xref:System.Diagnostics.Process.CloseMainWindow%2A>具有使用者介面程序中，要求作業系統終止相關聯的處理序可能不會處理如果處理程序撰寫永遠不會輸入其訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="31dae-1652">For example, if you call <xref:System.Diagnostics.Process.CloseMainWindow%2A> for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1653">中[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和更早的版本<xref:System.Diagnostics.Process.WaitForExit>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），不無限期。</span><span class="sxs-lookup"><span data-stu-id="31dae-1653">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, the <xref:System.Diagnostics.Process.WaitForExit> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span> <span data-ttu-id="31dae-1654">此外，舊版未等待事件處理常式，如果結束完整<xref:System.Int32.MaxValue>已到達時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1654">Also, previous versions did not wait for the event handlers to exit if the full <xref:System.Int32.MaxValue> time was reached.</span></span>  
  
 <span data-ttu-id="31dae-1655">這個多載可確保，所有處理都完成之後，包括重新導向標準輸出的非同步事件的處理。</span><span class="sxs-lookup"><span data-stu-id="31dae-1655">This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output.</span></span> <span data-ttu-id="31dae-1656">您應該使用這個多載之後呼叫<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>多載時非同步事件處理常式已重新導向標準輸出。</span><span class="sxs-lookup"><span data-stu-id="31dae-1656">You should use this overload after a call to the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload when standard output has been redirected to asynchronous event handlers.</span></span>  
  
 <span data-ttu-id="31dae-1657">時相關聯的處理序結束時 （也就是它遭到關閉作業系統正常或不正常終止） 時，系統會儲存程序的系統管理資訊，並傳回給已呼叫元件<xref:System.Diagnostics.Process.WaitForExit>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1657">When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit>.</span></span> <span data-ttu-id="31dae-1658"><xref:System.Diagnostics.Process>元件可以存取的資訊，包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>結束程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1658">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="31dae-1659">因為相關聯的處理序已結束，<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1659">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="31dae-1660">相反地，控制代碼可用來存取的處理序資源相關的作業系統的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-1660">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="31dae-1661">系統所知的控點來結束處理程序尚未發行所<xref:System.Diagnostics.Process>元件，因此它會保留<xref:System.Diagnostics.Process.ExitTime%2A>並<xref:System.Diagnostics.Process.Handle%2A>資訊中記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1661">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="31dae-1662">基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>for<xref:System.Diagnostics.Process>執行個體，呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序終止為止，您不再需要任何系統管理相關資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-1662">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="31dae-1663"><xref:System.Diagnostics.Process.Close%2A> 釋放配置給結束的處理序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1663"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1664">請參閱 < 備註 > 一節的<xref:System.Diagnostics.Process.StandardError%2A>屬性參考頁面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1664">See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1665">無法存取等候設定。</span><span class="sxs-lookup"><span data-stu-id="31dae-1665">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="31dae-1666">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。</span><span class="sxs-lookup"><span data-stu-id="31dae-1666">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
<span data-ttu-id="31dae-1667">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1667">-or-</span></span> 
<span data-ttu-id="31dae-1668">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1668">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
<span data-ttu-id="31dae-1669">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1669">-or-</span></span> 
<span data-ttu-id="31dae-1670">您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.WaitForExit" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1670">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1671">這個方法僅適用於在本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1671">This method is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1672">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1672">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1673">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1673">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="31dae-1674">等候相關的處理序結束的時間量，以毫秒計算。</span><span class="sxs-lookup"><span data-stu-id="31dae-1674">The amount of time, in milliseconds, to wait for the associated process to exit.</span></span> <span data-ttu-id="31dae-1675">最大值是 32 位元整數的最大可能值，對作業系統來說，這表示無限。</span><span class="sxs-lookup"><span data-stu-id="31dae-1675">The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</span></span></param>
        <summary><span data-ttu-id="31dae-1676">指示 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序結束的指定毫秒數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1676">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</span></span></summary>
        <returns><span data-ttu-id="31dae-1677">如果相關聯處理序已結束，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1677"><see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1678"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 可讓目前的執行緒等候相關聯的處理序終止為止。</span><span class="sxs-lookup"><span data-stu-id="31dae-1678"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> makes the current thread wait until the associated process terminates.</span></span> <span data-ttu-id="31dae-1679">所有其他方法會呼叫程序之後，應該要進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="31dae-1679">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="31dae-1680">為避免封鎖目前的執行緒，請使用 <xref:System.Diagnostics.Process.Exited> 事件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1680">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="31dae-1681">這個方法會指示<xref:System.Diagnostics.Process>元件等候一段有限的處理序結束的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1681">This method instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to exit.</span></span> <span data-ttu-id="31dae-1682">如果相關聯的處理序未結束的間隔結束時終止要求遭到拒絕，因為`false`會傳回到呼叫的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1682">If the associated process does not exit by the end of the interval because the request to terminate is denied, `false` is returned to the calling procedure.</span></span> <span data-ttu-id="31dae-1683">您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>for `milliseconds`，並<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>行為與相同<xref:System.Diagnostics.Process.WaitForExit>多載。</span><span class="sxs-lookup"><span data-stu-id="31dae-1683">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for `milliseconds`, and <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> will behave the same as the <xref:System.Diagnostics.Process.WaitForExit> overload.</span></span> <span data-ttu-id="31dae-1684">如果您將 0 （零） 傳遞給方法，它會傳回`true`只有當 proces byl již ukončen; 否則會立即傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1684">If you pass 0 (zero) to the method, it returns `true` only if the process has already exited; otherwise, it immediately returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31dae-1685">在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和更早版本，如果`milliseconds`為-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>多載等候<xref:System.Int32.MaxValue>毫秒 （大約 24 天），不無限期。</span><span class="sxs-lookup"><span data-stu-id="31dae-1685">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, if `milliseconds` was -1, the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span>  
  
 <span data-ttu-id="31dae-1686">當非同步事件處理常式已重新導向標準輸出時，它有可能，輸出處理尚未完成此方法傳回時。</span><span class="sxs-lookup"><span data-stu-id="31dae-1686">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns.</span></span> <span data-ttu-id="31dae-1687">若要確保非同步事件處理已完成，請呼叫<xref:System.Diagnostics.Process.WaitForExit>多載會採用任何參數，在收到之後`true`從這個多載。</span><span class="sxs-lookup"><span data-stu-id="31dae-1687">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter after receiving a `true` from this overload.</span></span> <span data-ttu-id="31dae-1688">為協助確保<xref:System.Diagnostics.Process.Exited>Windows Forms 應用程式中正確地處理事件，請將<xref:System.Diagnostics.Process.SynchronizingObject%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1688">To help ensure that the <xref:System.Diagnostics.Process.Exited> event is handled correctly in Windows Forms applications, set the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
 <span data-ttu-id="31dae-1689">相關聯的處理序結束時 （關閉作業系統正常或不正常終止），系統會儲存程序的系統管理資訊，並傳回給已呼叫元件<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1689">When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>.</span></span> <span data-ttu-id="31dae-1690"><xref:System.Diagnostics.Process>元件可以存取的資訊，包括<xref:System.Diagnostics.Process.ExitTime%2A>，使用<xref:System.Diagnostics.Process.Handle%2A>結束程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1690">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="31dae-1691">因為相關聯的處理序已結束，<xref:System.Diagnostics.Process.Handle%2A>元件的屬性不會再指向現有的處理序資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1691">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="31dae-1692">相反地，控制代碼可用來存取的處理序資源相關的作業系統的資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-1692">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="31dae-1693">系統所知的控點來結束處理程序尚未發行所<xref:System.Diagnostics.Process>元件，因此它會保留<xref:System.Diagnostics.Process.ExitTime%2A>並<xref:System.Diagnostics.Process.Handle%2A>資訊中記憶體中，直到<xref:System.Diagnostics.Process>元件特別釋出資源。</span><span class="sxs-lookup"><span data-stu-id="31dae-1693">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="31dae-1694">基於這個理由，每當您呼叫<xref:System.Diagnostics.Process.Start%2A>for<xref:System.Diagnostics.Process>執行個體，呼叫<xref:System.Diagnostics.Process.Close%2A>當相關聯的處理序終止為止，您不再需要任何系統管理相關資訊。</span><span class="sxs-lookup"><span data-stu-id="31dae-1694">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="31dae-1695"><xref:System.Diagnostics.Process.Close%2A> 釋放配置給結束的處理序的記憶體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1695"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1696">程式碼範例，請參閱<xref:System.Diagnostics.Process.ExitCode%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1696">See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="31dae-1697">無法存取等候設定。</span><span class="sxs-lookup"><span data-stu-id="31dae-1697">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="31dae-1698">尚未設定任何處理序 <see cref="P:System.Diagnostics.Process.Id" />，而且可從中判斷 <see cref="P:System.Diagnostics.Process.Id" /> 屬性的 <see cref="P:System.Diagnostics.Process.Handle" /> 不存在。</span><span class="sxs-lookup"><span data-stu-id="31dae-1698">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
<span data-ttu-id="31dae-1699">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1699">-or-</span></span> 
<span data-ttu-id="31dae-1700">沒有與這個 <see cref="T:System.Diagnostics.Process" /> 物件關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1700">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
<span data-ttu-id="31dae-1701">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1701">-or-</span></span> 
<span data-ttu-id="31dae-1702">您正在嘗試呼叫於遠端電腦上執行之處理序的 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1702">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="31dae-1703">這個方法僅適用於在本機電腦執行的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1703">This method is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="31dae-1704"><paramref name="milliseconds" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="31dae-1704"><paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1705">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1705">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1706">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1706">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31dae-1707">讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-1707">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="31dae-1708">讓 <see cref="T:System.Diagnostics.Process" /> 元件無限期等候相關聯處理序進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-1708">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state.</span></span> <span data-ttu-id="31dae-1709">這個多載只適用於具有使用者介面和訊息迴圈的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1709">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns><span data-ttu-id="31dae-1710">如果相關聯處理序已經達到閒置狀態，則為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1710"><see langword="true" /> if the associated process has reached an idle state.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1711">使用<xref:System.Diagnostics.Process.WaitForInputIdle>強制您的應用程式等候，直到訊息迴圈已閒置狀態恢復處理。</span><span class="sxs-lookup"><span data-stu-id="31dae-1711">Use <xref:System.Diagnostics.Process.WaitForInputIdle> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="31dae-1712">當具有使用者介面的程序正在執行時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。</span><span class="sxs-lookup"><span data-stu-id="31dae-1712">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="31dae-1713">此程序則會傳回至訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="31dae-1713">The process then returns to the message loop.</span></span> <span data-ttu-id="31dae-1714">處理程序即處於閒置狀態，當它正在等候訊息迴圈內的訊息。</span><span class="sxs-lookup"><span data-stu-id="31dae-1714">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="31dae-1715">此狀態時很有用，例如，您的應用程式必須等候完成建立其主視窗，才能在應用程式傳送與該視窗啟動的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1715">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="31dae-1716">如果沒有訊息迴圈，處理程序。<xref:System.Diagnostics.Process.WaitForInputIdle>會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1716">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="31dae-1717"><xref:System.Diagnostics.Process.WaitForInputIdle>多載會指示<xref:System.Diagnostics.Process>無限期地等待處理序變成閒置訊息迴圈中的元件。</span><span class="sxs-lookup"><span data-stu-id="31dae-1717">The <xref:System.Diagnostics.Process.WaitForInputIdle> overload instructs the <xref:System.Diagnostics.Process> component to wait indefinitely for the process to become idle in the message loop.</span></span> <span data-ttu-id="31dae-1718">此指令，可能會造成停止回應的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1718">This instruction can cause an application to stop responding.</span></span> <span data-ttu-id="31dae-1719">例如，如果處理程序撰寫為永遠其訊息迴圈立即結束，如程式碼片段所示`while(true)`。</span><span class="sxs-lookup"><span data-stu-id="31dae-1719">For example, if the process is written to always exit its message loop immediately, as in the code fragment `while(true)`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1720">處理序沒有圖形化介面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1720">The process does not have a graphical interface.</span></span>  
  
<span data-ttu-id="31dae-1721">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1721">-or-</span></span> 
<span data-ttu-id="31dae-1722">發生未知的錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1722">An unknown error occurred.</span></span> <span data-ttu-id="31dae-1723">處理序無法進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-1723">The process failed to enter an idle state.</span></span>  
  
<span data-ttu-id="31dae-1724">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1724">-or-</span></span> 
<span data-ttu-id="31dae-1725">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1725">The process has already exited.</span></span>  
  
<span data-ttu-id="31dae-1726">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1726">-or-</span></span> 
<span data-ttu-id="31dae-1727">沒有和這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1727">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1728">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1728">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1729">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1729">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="31dae-1730">1 到 <see cref="F:System.Int32.MaxValue" /> 的值，指定等候相關聯處理序變成閒置的時間 (毫秒)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1730">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle.</span></span> <span data-ttu-id="31dae-1731">值為 0 時，指定立即傳回，而值為 -1 時則指定無限期等候。</span><span class="sxs-lookup"><span data-stu-id="31dae-1731">A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="31dae-1732">讓 <see cref="T:System.Diagnostics.Process" /> 元件等候相關聯處理序進入閒置狀態的指定毫秒數。</span><span class="sxs-lookup"><span data-stu-id="31dae-1732">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state.</span></span> <span data-ttu-id="31dae-1733">這個多載只適用於具有使用者介面和訊息迴圈的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1733">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns><span data-ttu-id="31dae-1734">如果相關聯處理序已經達到閒置狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="31dae-1734"><see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1735">使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>強制您的應用程式等候，直到訊息迴圈已閒置狀態恢復處理。</span><span class="sxs-lookup"><span data-stu-id="31dae-1735">Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="31dae-1736">當具有使用者介面的程序正在執行時，其訊息迴圈會執行每次 Windows 訊息傳送至處理序的作業系統。</span><span class="sxs-lookup"><span data-stu-id="31dae-1736">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="31dae-1737">此程序則會傳回至訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="31dae-1737">The process then returns to the message loop.</span></span> <span data-ttu-id="31dae-1738">處理程序即處於閒置狀態，當它正在等候訊息迴圈內的訊息。</span><span class="sxs-lookup"><span data-stu-id="31dae-1738">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="31dae-1739">此狀態時很有用，例如，您的應用程式必須等候完成建立其主視窗，才能在應用程式傳送與該視窗啟動的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1739">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="31dae-1740">如果沒有訊息迴圈，處理程序。<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="31dae-1740">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="31dae-1741"><xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>多載會指示<xref:System.Diagnostics.Process>元件等候一段有限的處理序變成閒置訊息迴圈中的時間。</span><span class="sxs-lookup"><span data-stu-id="31dae-1741">The <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> overload instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to become idle in the message loop.</span></span> <span data-ttu-id="31dae-1742">相關聯的處理序已不變成閒置狀態時的時間間隔結束迴圈仍在處理訊息，因為`false`會傳回到呼叫的程序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1742">If the associated process has not become idle by the end of the interval because the loop is still processing messages, `false` is returned to the calling procedure.</span></span>  
  
 <span data-ttu-id="31dae-1743">如需有關如何處理事件的詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1743">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31dae-1744">處理序沒有圖形化介面。</span><span class="sxs-lookup"><span data-stu-id="31dae-1744">The process does not have a graphical interface.</span></span>  
  
<span data-ttu-id="31dae-1745">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1745">-or-</span></span> 
<span data-ttu-id="31dae-1746">發生未知的錯誤。</span><span class="sxs-lookup"><span data-stu-id="31dae-1746">An unknown error occurred.</span></span> <span data-ttu-id="31dae-1747">處理序無法進入閒置狀態。</span><span class="sxs-lookup"><span data-stu-id="31dae-1747">The process failed to enter an idle state.</span></span>  
  
<span data-ttu-id="31dae-1748">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1748">-or-</span></span> 
<span data-ttu-id="31dae-1749">處理程序已經結束。</span><span class="sxs-lookup"><span data-stu-id="31dae-1749">The process has already exited.</span></span>  
  
<span data-ttu-id="31dae-1750">-或-</span><span class="sxs-lookup"><span data-stu-id="31dae-1750">-or-</span></span> 
<span data-ttu-id="31dae-1751">沒有和這個 <see cref="T:System.Diagnostics.Process" /> 物件相關聯的處理序。</span><span class="sxs-lookup"><span data-stu-id="31dae-1751">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1752">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1752">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1753">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1753">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1754">取得相關處理序的實體記憶體使用量 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="31dae-1754">Gets the associated process's physical memory usage, in bytes.</span></span></summary>
        <value><span data-ttu-id="31dae-1755">相關的處理序正在使用的實體記憶體的總量。</span><span class="sxs-lookup"><span data-stu-id="31dae-1755">The total amount of physical memory the associated process is using, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1756">這個屬性所傳回的值表示目前的工作集由處理序，以位元組為單位的記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-1756">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="31dae-1757">處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。</span><span class="sxs-lookup"><span data-stu-id="31dae-1757">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="31dae-1758">這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1758">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="31dae-1759">工作集包括共用和私用的資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-1759">The working set includes both shared and private data.</span></span> <span data-ttu-id="31dae-1760">共用的資料包含頁面包含所有處理序執行，包括處理序模組和系統程式庫的指示。</span><span class="sxs-lookup"><span data-stu-id="31dae-1760">The shared data includes the pages that contain all the instructions that the process executes, including the process modules and the system libraries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1761">下列範例會啟動 「 記事本 」 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1761">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="31dae-1762">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1762">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1763">在處理序結束時，此範例會偵測並顯示該處理序的結束代碼。</span><span class="sxs-lookup"><span data-stu-id="31dae-1763">The example detects when the process exits, and displays the process' exit code.</span></span>  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1764">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1764">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1765">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1765">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1766">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1766">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="31dae-1767">取得配置給關聯處理序的實體記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-1767">Gets the amount of physical memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="31dae-1768">配置給關聯處理序的實體記憶體量，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="31dae-1768">The amount of physical memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31dae-1769">這個屬性所傳回的值表示目前的工作集由處理序，以位元組為單位的記憶體大小。</span><span class="sxs-lookup"><span data-stu-id="31dae-1769">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="31dae-1770">處理程序的工作集是實體 RAM 記憶體中的目前可見的程序的記憶體分頁集。</span><span class="sxs-lookup"><span data-stu-id="31dae-1770">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="31dae-1771">這些頁面是常駐的而且可供使用，而不觸發分頁錯誤的應用程式。</span><span class="sxs-lookup"><span data-stu-id="31dae-1771">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="31dae-1772">工作集包括共用和私用的資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-1772">The working set includes both shared and private data.</span></span> <span data-ttu-id="31dae-1773">共用的資料包含頁面包含所有處理序執行，包括指示處理序模組和系統程式庫中的指示。</span><span class="sxs-lookup"><span data-stu-id="31dae-1773">The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="31dae-1774">這個屬性可用來監視處理器 32 位元或 64 位元處理器的電腦上的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="31dae-1774">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="31dae-1775">屬性值相當於**工作組**處理程序的效能計數器。</span><span class="sxs-lookup"><span data-stu-id="31dae-1775">The property value is equivalent to the **Working Set** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31dae-1776">下列程式碼範例會啟動 「 記事本 」 應用程式的執行個體。</span><span class="sxs-lookup"><span data-stu-id="31dae-1776">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="31dae-1777">此範例會擷取並顯示相關聯的處理序的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1777">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="31dae-1778">在處理序結束時，此範例會偵測並顯示其結束程式碼和尖峰記憶體統計資料。</span><span class="sxs-lookup"><span data-stu-id="31dae-1778">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="31dae-1779">平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支援這個屬性。</span><span class="sxs-lookup"><span data-stu-id="31dae-1779">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="31dae-1780">針對完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="31dae-1780">for full trust for the immediate caller.</span></span> <span data-ttu-id="31dae-1781">這個成員無法供部分信任的程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="31dae-1781">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>