<Type Name="EntityKey" FullName="System.Data.EntityKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3cbfb230bbd505bee5b98342478f53b76fa51c60" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37668949" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityKey : IEquatable&lt;System.Data.EntityKey&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityKey extends System.Object implements class System.IEquatable`1&lt;class System.Data.EntityKey&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Data.EntityKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityKey&#xA;Implements IEquatable(Of EntityKey)" />
  <TypeSignature Language="C++ CLI" Value="public ref class EntityKey sealed : IEquatable&lt;System::Data::EntityKey ^&gt;" />
  <TypeSignature Language="F#" Value="type EntityKey = class&#xA;    interface IEquatable&lt;EntityKey&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Data.EntityKey&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{ConcatKeyValue()}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.DataContract(IsReference=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides a durable reference to an object that is an instance of an entity type.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityKey> 物件是不可變動的。也就是說，建構這些物件之後，就無法修改它們。  
  
 如需詳細資訊，請參閱 <<c0> [ 使用實體索引鍵](http://msdn.microsoft.com/library/fe3f4206-d277-43a1-a72f-4e86fdf12b9f)。  
  
   
  
## Examples  
 這些範例根據[AdventureWorks Sales Model](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832)。 範例會示範如何建立和使用<xref:System.Data.EntityKey>。  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of KeyValuePair(Of String, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A <see cref="T:System.String" /> that is the entity set name qualified by the entity container name.</param>
        <param name="entityKeyValues">A generic <see cref="T:System.Collections.Generic.KeyValuePair" /> collection.  Each key/value pair has a property name as the key and the value of that property as the value. There should be one pair for each property that is part of the <see cref="T:System.Data.EntityKey" />. The order of the key/value pairs is not important, but each key property should be included. The property names are simple names that are not qualified with an entity type name or the schema name.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and a generic <see cref="T:System.Collections.Generic.KeyValuePair" /> collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例根據[AdventureWorks Sales Model](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832)。 此範例會示範如何建立和使用<xref:System.Data.EntityKey>。  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.EntityKeyMember&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Data.EntityKeyMember})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of EntityKeyMember))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Data::EntityKeyMember ^&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Data.EntityKeyMember&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A <see cref="T:System.String" /> that is the entity set name qualified by the entity container name.</param>
        <param name="entityKeyValues">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of <see cref="T:System.Data.EntityKeyMember" /> objects with which to initialize the key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and an <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of <see cref="T:System.Data.EntityKeyMember" /> objects.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, string keyName, object keyValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, string keyName, object keyValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, keyName As String, keyValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::String ^ keyName, System::Object ^ keyValue);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * string * obj -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, keyName, keyValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="keyValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A <see cref="T:System.String" /> that is the entity set name qualified by the entity container name.</param>
        <param name="keyName">A <see cref="T:System.String" /> that is the name of the key.</param>
        <param name="keyValue">An <see cref="T:System.Object" /> that is the key value.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.EntityKey" /> class with an entity set name and specific entity key pair.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 這個範例根據[AdventureWorks Sales Model](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832)。 此範例會示範如何建立和使用<xref:System.Data.EntityKey>。  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityContainerName">
      <MemberSignature Language="C#" Value="public string EntityContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntityContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntityContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityContainerName : string with get, set" Usage="System.Data.EntityKey.EntityContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the entity container.</summary>
        <value>
          <see cref="T:System.String" /> 值，它是 <see cref="T:System.Data.EntityKey" /> 所屬之實體的實體容器名稱。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityKeyValues">
      <MemberSignature Language="C#" Value="public System.Data.EntityKeyMember[] EntityKeyValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.EntityKeyMember[] EntityKeyValues" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityKeyValues" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityKeyValues As EntityKeyMember()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ EntityKeyValues { cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ get(); void set(cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityKeyValues : System.Data.EntityKeyMember[] with get, set" Usage="System.Data.EntityKey.EntityKeyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.EntityKeyMember[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the key values associated with this <see cref="T:System.Data.EntityKey" />.</summary>
        <value>這個 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 之索引鍵值的 <see cref="T:System.Data.EntityKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityKey> 類別 (Class) 包含構成針對這個實體類型所指定之邏輯索引鍵的值複本。  
  
 每個 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 的成員都在 <xref:System.Collections.Generic.KeyValuePair%602> 中具有屬性名稱和值，其中索引鍵是屬性名稱，而值是物件之該屬性的實際值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityNotValidKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey EntityNotValidKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey EntityNotValidKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.EntityNotValidKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EntityNotValidKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ EntityNotValidKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable EntityNotValidKey : System.Data.EntityKey" Usage="System.Data.EntityKey.EntityNotValidKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A simple <see cref="T:System.Data.EntityKey" /> identifying an entity that resulted from a failed [TREAT](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) operation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 取得無效實體的方式有許多種。 最常見的案例是，當[!INCLUDE[esql](~/includes/esql-md.md)]查詢會使用[視為](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md)運算子來解譯成特定的型別中，多型類型的執行個體和有問題的執行個體不符。 ([視為](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md)類似於 C#`as`運算子)。 在此情況中，查詢會傳回無效的實體，而且產生之實體的實體索引鍵會設定為 <xref:System.Data.EntityKey.EntityNotValidKey>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntitySetName">
      <MemberSignature Language="C#" Value="public string EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntitySetName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntitySetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntitySetName : string with get, set" Usage="System.Data.EntityKey.EntitySetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the entity set.</summary>
        <value>
          <see cref="T:System.String" /> 值，它是 <see cref="T:System.Data.EntityKey" /> 所屬之實體的實體集名稱。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Data.EntityKey other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Data.EntityKey other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Data::EntityKey ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Data.EntityKey -&gt; bool" Usage="entityKey.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="other">An <see cref="T:System.Data.EntityKey" /> object to compare with this instance.</param>
        <summary>Returns a value that indicates whether this instance is equal to a specified <see cref="T:System.Data.EntityKey" />.</summary>
        <returns>
          <see langword="true" /> if this instance and <paramref name="other" /> have equal values; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 暫存索引鍵與永久索引鍵具有不同的比較語意：  
  
-   暫存索引鍵會使用參考相等。 也就是說，完全相同之暫存 <xref:System.Data.EntityKey> 執行個體的兩個參考會相等，但是沒有其他 <xref:System.Data.EntityKey> 執行個體會相等。  
  
-   永久索引鍵會根據包含的索引鍵屬性值和 <xref:System.Data.Metadata.Edm.EntitySet> 來判斷是否相等。 也就是說，如果實體集相同，而且索引鍵值相等，您可能會有兩個相等的個別 <xref:System.Data.EntityKey> 執行個體。  
  
 此外，暫存索引鍵沒有任何 <xref:System.Data.Metadata.Edm.EntitySet> 或索引鍵值，但是永久索引鍵有。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="entityKey.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">An <see cref="T:System.Object" /> to compare with this instance.</param>
        <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if this instance and <paramref name="obj" /> have equal values; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 暫存索引鍵與永久索引鍵具有不同的比較語意：  
  
-   暫存索引鍵會使用參考相等。 也就是說，完全相同之暫存 <xref:System.Data.EntityKey> 執行個體的兩個參考會相等，但是沒有其他 <xref:System.Data.EntityKey> 執行個體會相等。  
  
-   永久索引鍵會根據包含的索引鍵屬性值和 <xref:System.Data.Metadata.Edm.EntitySet> 來判斷是否相等。 也就是說，如果 <xref:System.Data.EntityKey> 物件相同，而且索引鍵值相等，您可能會有兩個相等的個別 <xref:System.Data.Metadata.Edm.EntitySet> 執行個體。  
  
 此外，暫存索引鍵沒有任何 <xref:System.Data.Metadata.Edm.EntitySet> 或索引鍵值，但是永久索引鍵有。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntitySet">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.EntitySet GetEntitySet (System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.EntitySet GetEntitySet(class System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetEntitySet(System.Data.Metadata.Edm.MetadataWorkspace)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::EntitySet ^ GetEntitySet(System::Data::Metadata::Edm::MetadataWorkspace ^ metadataWorkspace);" />
      <MemberSignature Language="F#" Value="member this.GetEntitySet : System.Data.Metadata.Edm.MetadataWorkspace -&gt; System.Data.Metadata.Edm.EntitySet" Usage="entityKey.GetEntitySet metadataWorkspace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.EntitySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataWorkspace" Type="System.Data.Metadata.Edm.MetadataWorkspace" />
      </Parameters>
      <Docs>
        <param name="metadataWorkspace">The metadata workspace that contains the entity.</param>
        <summary>Gets the entity set for this entity key from the given metadata workspace.</summary>
        <returns>The <see cref="T:System.Data.Metadata.Edm.EntitySet" /> for the entity key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 系統會根據索引鍵的實體容器名稱和實體集名稱，存取此實體集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The entity set could not be located in the specified metadata workspace.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="entityKey.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serves as a hash function for the current <see cref="T:System.Data.EntityKey" /> object. <see cref="M:System.Data.EntityKey.GetHashCode" /> is suitable for hashing algorithms and data structures such as a hash table.</summary>
        <returns>A hash code for the current <see cref="T:System.Data.EntityKey" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.EntityKey.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.EntityKey" /> is temporary.</summary>
        <value>
          <see langword="true" /> 如果<see cref="T:System.Data.EntityKey" />暫存; 否則即為<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立新實體時，[!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] 會定義暫時索引鍵，並將 <xref:System.Data.EntityKey.IsTemporary%2A> 屬性設定為 `true`。 當您呼叫<xref:System.Data.Objects.ObjectContext.SaveChanges%2A>方法中，[!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)]指派永久的索引鍵，並設定<xref:System.Data.EntityKey.IsTemporary%2A>屬性設`false`。  
  
> [!NOTE]
>  暫存索引鍵是此架構自動建構的。使用者無法直接建構暫存索引鍵。  
  
 暫存索引鍵與永久索引鍵具有不同的比較語意：  
  
-   暫存索引鍵會使用參考相等。 也就是說，完全相同之暫存 <xref:System.Data.EntityKey> 執行個體的兩個參考會相等，但是沒有其他 <xref:System.Data.EntityKey> 執行個體會相等。  
  
-   永久索引鍵會根據包含的索引鍵屬性值和 <xref:System.Data.Metadata.Edm.EntitySet> 來判斷是否相等。 也就是說，如果實體集相同，而且索引鍵值相等，您可能會有兩個相等的個別 <xref:System.Data.EntityKey> 執行個體。  
  
 此外，暫存索引鍵沒有任何 <xref:System.Data.Metadata.Edm.EntitySet> 或索引鍵值，但是永久索引鍵有。  
  
 針對實體的 <xref:System.Data.Objects.ObjectStateEntry.AcceptChanges%2A> 呼叫 <xref:System.Data.Objects.ObjectStateEntry> 方法，而且此實體從 <xref:System.Data.EntityState.Added> 狀態轉換成 <xref:System.Data.EntityState.Unchanged> 狀態時，[!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] 就會自動計算實體的新永久索引鍵並且同步處理所有暫存索引鍵參考。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoEntitySetKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey NoEntitySetKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey NoEntitySetKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.NoEntitySetKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoEntitySetKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ NoEntitySetKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoEntitySetKey : System.Data.EntityKey" Usage="System.Data.EntityKey.NoEntitySetKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A singleton <see cref="T:System.Data.EntityKey" /> by which a read-only entity is identified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 唯讀的實體會識別在每種用途中有效的實體，但是當它沒有與實際實體集相關聯的情況除外。 在建構並傳回指定於查詢文字內部之實體執行個體 (相對於從資料庫資料表中擷取的實體) 的 [!INCLUDE[esql](~/includes/esql-md.md)] 查詢結果中，可能會發生這種情況。 沒有實體集的實體要等到與某個實體集相關聯時，才能保存至資料庫。 因此，不論指定的實際合併選項為何，物件具體化程式都會將這種實體視為指定了 <xref:System.Data.Objects.MergeOption.NoTracking> 合併選項。 雖然系統將建立實體物件，但是無法解析其識別 (Identity)，而且它不會在具體化程序中加入至狀態管理員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialized">
      <MemberSignature Language="C#" Value="public void OnDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Describes the source and destination of a given serialized stream and provides an additional caller-defined context.</param>
        <summary>Helper method that is used to deserialize an <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化 <xref:System.Data.EntityKey.OnDeserialized%2A> 時，物件服務會使用 <xref:System.Data.EntityKey>。 如需詳細資訊，請參閱 <<c0> [ 序列化的物件](http://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserializing">
      <MemberSignature Language="C#" Value="public void OnDeserializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.</param>
        <summary>Helper method that is used to deserialize an <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化 <xref:System.Data.EntityKey.OnDeserializing%2A> 時，物件服務會使用 <xref:System.Data.EntityKey>。 如需詳細資訊，請參閱 <<c0> [ 序列化的物件](http://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Equality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="key1 = key2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <param name="key2">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <summary>Compares two <see cref="T:System.Data.EntityKey" /> objects.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="key1" /> and <paramref name="key2" /> values are equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 暫存索引鍵與永久索引鍵具有不同的比較語意：  
  
-   暫存索引鍵會使用參考相等。 也就是說，完全相同之暫存 <xref:System.Data.EntityKey> 執行個體的兩個參考會相等，但是沒有其他 <xref:System.Data.EntityKey> 執行個體會相等。  
  
-   永久索引鍵會根據包含的索引鍵屬性值和 <xref:System.Data.Metadata.Edm.EntitySet> 來判斷是否相等。 也就是說，如果實體集相同，而且索引鍵值相等，您可能會有兩個相等的個別 <xref:System.Data.EntityKey> 執行個體。  
  
 此外，暫存索引鍵沒有任何 <xref:System.Data.Metadata.Edm.EntitySet> 或索引鍵值，但是永久索引鍵有。  
  
 對等的方法，為這位操作員<xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType> </format> </remarks> </Docs> 
     </Member> 
     <Member MemberName="op_Inequality"> <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Data.EntityKey key1, System.Data.EntityKey key2);" /> <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" /> <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" /> <MemberType>方法</MemberType> <AssemblyInfo> <AssemblyName>System.Data.Entity</AssemblyName> <AssemblyVersion>4.0.0.0</AssemblyVersion> </AssemblyInfo> <ReturnValue> <ReturnType>System.Boolean</ReturnType> </ReturnValue><Parameters> <Parameter Name="key1" Type="System.Data.EntityKey" /> <Parameter Name="key2" Type="System.Data.EntityKey" /> </Parameters> <Docs> <param name="key1">A<see cref="T:System.Data.EntityKey" />比較。</param>
        <param name="key2">A<see cref="T:System.Data.EntityKey" />比較。</param>
        <summary>比較兩個<see cref="T:System.Data.EntityKey" />物件。</summary>
        <returns> <see langword="true" /> 如果<paramref name="key1" />並<paramref name="key2" />值不相等，否則<see langword="false" />。</returns>
        <remarks> <format type="text/markdown"><![CDATA[  
  
## Remarks  
 暫存索引鍵與永久索引鍵具有不同的比較語意：  
  
-   暫存索引鍵會使用參考相等。 也就是說，完全相同之暫存 <xref:System.Data.EntityKey> 執行個體的兩個參考會相等，但是沒有其他 <xref:System.Data.EntityKey> 執行個體會相等。  
  
-   永久索引鍵會根據包含的索引鍵屬性值和 <xref:System.Data.Metadata.Edm.EntitySet> 來判斷是否相等。 也就是說，如果實體集相同，而且索引鍵值相等，您可能會有兩個相等的個別 <xref:System.Data.EntityKey> 執行個體。  
  
 此外，暫存索引鍵沒有任何 <xref:System.Data.Metadata.Edm.EntitySet> 或索引鍵值，但是一般索引鍵有。  
  
 這個運算子的對等方法是<xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType>。]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="System.Data.EntityKey.op_Inequality (key1, key2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <param name="key2">A <see cref="T:System.Data.EntityKey" /> to compare.</param>
        <summary>Compares two <see cref="T:System.Data.EntityKey" /> objects.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="key1" /> and <paramref name="key2" /> values are not equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 暫存索引鍵與永久索引鍵具有不同的比較語意：  
  
-   暫存索引鍵會使用參考相等。 也就是說，完全相同之暫存 <xref:System.Data.EntityKey> 執行個體的兩個參考會相等，但是沒有其他 <xref:System.Data.EntityKey> 執行個體會相等。  
  
-   永久索引鍵會根據包含的索引鍵屬性值和 <xref:System.Data.Metadata.Edm.EntitySet> 來判斷是否相等。 也就是說，如果實體集相同，而且索引鍵值相等，您可能會有兩個相等的個別 <xref:System.Data.EntityKey> 執行個體。  
  
 此外，暫存索引鍵沒有任何 <xref:System.Data.Metadata.Edm.EntitySet> 或索引鍵值，但是一般索引鍵有。]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>