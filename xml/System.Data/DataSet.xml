<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5722a0fd981990611404db2615089cc410571a77" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53568716" /></Metadata><TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表資料的記憶體中快取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet>，這就是資料來源擷取資料的記憶體中快取是 ADO.NET 架構的主要元件。 <xref:System.Data.DataSet>組成的集合<xref:System.Data.DataTable>物件，您可以相互關聯與<xref:System.Data.DataRelation>物件。 您也可以強制執行中的資料完整性<xref:System.Data.DataSet>利用<xref:System.Data.UniqueConstraint>和<xref:System.Data.ForeignKeyConstraint>物件。 如需有關使用的詳細資訊<xref:System.Data.DataSet>物件，請參閱[Dataset、 Datatable 和 Dataview](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)。  
  
 然而<xref:System.Data.DataTable>物件包含的資料，<xref:System.Data.DataRelationCollection>可讓您透過瀏覽階層的資料表。 中所包含的資料表<xref:System.Data.DataTableCollection>經由<xref:System.Data.DataSet.Tables%2A>屬性。 當存取<xref:System.Data.DataTable>物件，請注意，這些有條件地區分大小寫。 例如，如果一個<xref:System.Data.DataTable>名為"mydatatable"和另一個名為"Mydatatable 」，用來搜尋的其中一個資料表的字串會視為區分大小寫。 不過，如果"mydatatable 」 存在，而且 「 Mydatatable"並不會搜尋字串會視為為不區分大小寫。 如需使用詳細資訊<xref:System.Data.DataTable>物件，請參閱[建立 DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)。  
  
 A<xref:System.Data.DataSet>可以讀取和寫入資料和結構描述為 XML 文件。 資料和結構描述然後會透過 HTTP 傳輸並啟用 XML 的任何平台上的任何應用程式，使用。 您可以使用的 XML 結構描述儲存結構描述<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，，和結構描述和資料可以儲存使用<xref:System.Data.DataSet.WriteXml%2A>方法。 若要讀取 XML 文件包含結構描述和資料，使用<xref:System.Data.DataSet.ReadXml%2A>方法。  
  
 在典型的多層式實作，可建立及重新整理步驟<xref:System.Data.DataSet>，而且會更新原始資料的：  
  
1.  建置並填滿每<xref:System.Data.DataTable>中<xref:System.Data.DataSet>從資料來源使用的資料與<xref:System.Data.Common.DataAdapter>。  
  
2.  變更中個別的資料<xref:System.Data.DataTable>藉由新增、 更新或刪除的物件<xref:System.Data.DataRow>物件。  
  
3.  叫用<xref:System.Data.DataSet.GetChanges%2A>方法用來建立第二個<xref:System.Data.DataSet>該功能的資料變更。  
  
4.  呼叫<xref:System.Data.Common.DataAdapter.Update%2A>方法<xref:System.Data.Common.DataAdapter>，將第二個<xref:System.Data.DataSet>做為引數。  
  
5.  叫用<xref:System.Data.DataSet.Merge%2A>方法來合併的變更，從第二個<xref:System.Data.DataSet>到第一個。  
  
6.  叫用<xref:System.Data.DataSet.AcceptChanges%2A>上<xref:System.Data.DataSet>。 或者，叫用<xref:System.Data.DataSet.RejectChanges%2A>取消所做的變更。  
  
> [!NOTE]
>  <xref:System.Data.DataSet>並<xref:System.Data.DataTable>物件會繼承自<xref:System.ComponentModel.MarshalByValueComponent>，並支援<xref:System.Runtime.Serialization.ISerializable>針對遠端執行功能的介面。 這些是唯一可以進行遠端通訊的 ADO.NET 物件。  
  
> [!NOTE]
>  類別繼承自<xref:System.Data.DataSet>不會完成記憶體回收行程，因為完成項已隱藏在<xref:System.Data.DataSet>。 在衍生的類別可以呼叫<xref:System.GC.ReRegisterForFinalize%2A>其建構函式，以允許記憶體回收行程完成類別中的方法。  
  
   
  
## Examples  
 下列範例包含數種方法結合，建立並填入<xref:System.Data.DataSet>從**Northwind**資料庫。  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此類型是安全多執行緒的讀取作業。 您必須同步處理任何寫入作業。</threadsafe>
    <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Data.DataSet" /> 類別的新執行個體。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Data.DataSet" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個實作<xref:System.Data.DataSet>建構函式不接受任何參數，並建立一個預設名稱，"NewDataSet，"新的執行個體。  
  
 名稱<xref:System.Data.DataSet>，才能確保的 XML 表示法<xref:System.Data.DataSet>一律會有文件的項目，也就是最高層級的項目在結構描述定義中的名稱。  
  
   
  
## Examples  
 下列範例會建立新<xref:System.Data.DataSet>，並加入兩個<xref:System.Data.DataTable>給它的物件。  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName"><see cref="T:System.Data.DataSet" /> 的名稱。</param>
        <summary>使用指定名稱，初始化 <see cref="T:System.Data.DataSet" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名稱<xref:System.Data.DataSet>，才能確保的 XML 表示法<xref:System.Data.DataSet>一律會有文件的項目，也就是最高的層級項目在結構描述定義中的名稱。  
  
   
  
## Examples  
 下列範例會建立新<xref:System.Data.DataSet>，以哪欳<xref:System.Data.DataTable>物件會加入。  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">序列化或還原序列化物件所需的資料。</param>
        <param name="context">指定的序列化資料流的來源和目的端。</param>
        <summary>初始化具有指定序列化資訊和內容之 <see cref="T:System.Data.DataSet" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 物件。</param>
        <param name="ConstructSchema">布林值。</param>
        <summary>初始化 <see cref="T:System.Data.DataSet" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>認可從載入這個 <see cref="T:System.Data.DataSet" /> 物件或前一次呼叫 <see cref="M:System.Data.DataSet.AcceptChanges" /> 以來，對該物件做的所有變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 同時<xref:System.Data.DataRow>並<xref:System.Data.DataTable>類別都有<xref:System.Data.DataSet.AcceptChanges%2A>方法。 呼叫<xref:System.Data.DataTable.AcceptChanges%2A>位於<xref:System.Data.DataTable>層級的原因<xref:System.Data.DataRow.AcceptChanges%2A>方法，每個<xref:System.Data.DataRow>呼叫。 同樣地，叫用<xref:System.Data.DataSet.AcceptChanges%2A>上<xref:System.Data.DataSet>會導致<xref:System.Data.DataTable.AcceptChanges%2A>上的每個資料表呼叫<xref:System.Data.DataSet>。 如此一來，在中，您必須在可以叫用方法的多個層級。 呼叫<xref:System.Data.DataSet.AcceptChanges%2A>的<xref:System.Data.DataSet>可讓您叫用所有從屬物件 （例如，資料表和資料列） 與某個呼叫方法。  
  
 當您呼叫`AcceptChanges`上`DataSet`，任何<xref:System.Data.DataRow>仍處於編輯模式的物件已成功結束其編輯。 <xref:System.Data.DataRow.RowState%2A>每個屬性<xref:System.Data.DataRow>也會變更;`Added`並`Modified`資料列會變成`Unchanged`，和`Deleted`移除的資料列。  
  
 如果`DataSet`包含<xref:System.Data.ForeignKeyConstraint>物件，叫用`AcceptChanges`方法也會導致<xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A>強制執行。  
  
> [!NOTE]
>  `AcceptChanges` 並`RejectChanges`只會套用到`DataRow`相關的變更 （也就是 Add、 Remove、 刪除和修改）。 它們並不適用於結構描述或結構的變更。  
>   
>  呼叫 AcceptChanges 不會複寫這些變更回資料來源如果使用 DataAdapter 填入資料集。 在此情況下，呼叫<xref:System.Data.Common.DataAdapter.Update%2A>改。 請參閱[使用 Dataadapter 更新資料來源](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md)如需詳細資訊。  
  
   
  
## Examples  
 下列範例會將<xref:System.Data.DataRow>要<xref:System.Data.DataTable>在<xref:System.Data.DataSet>。 <xref:System.Data.DataSet.AcceptChanges%2A>上，然後呼叫方法<xref:System.Data.DataSet>，哪一個串聯，聯集全部<xref:System.Data.DataTable>它所包含的物件。  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始對表單或另一個元件所使用的 <see cref="T:System.Data.DataSet" /> 進行初始化作業。 初始化發生於執行階段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 設計環境會使用這個方法，開始對表單或另一個元件所使用的元件初始化。 <xref:System.Data.DataSet.EndInit%2A>方法結束初始化。 使用<xref:System.Data.DataSet.BeginInit%2A>和<xref:System.Data.DataSet.EndInit%2A>方法，防止控制項被完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出在 <see cref="T:System.Data.DataTable" /> 物件中的字串比較是否為區分大小寫。</summary>
        <value><see langword="true" /> 如果字串比較會區分大小寫;否則， <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.CaseSensitive%2A>屬性會影響如何執行排序、 搜尋和篩選作業在每個<xref:System.Data.DataTable>中所包含的物件<xref:System.Data.DataSet>時使用<xref:System.Data.DataTable.Select%2A>方法。  
  
 根據預設，設定<xref:System.Data.DataSet.CaseSensitive%2A>屬性<xref:System.Data.DataSet>也會設定<xref:System.Data.DataTable.CaseSensitive%2A>的每個相關聯的屬性<xref:System.Data.DataTable>相同的值。  
  
   
  
## Examples  
 下列範例會切換<xref:System.Data.DataSet.CaseSensitive%2A>屬性。  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除所有資料表中的資料列，以清除任何資料的 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Data.DataSet>繫結至<xref:System.Xml.XmlDataDocument>，則呼叫<xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType>或是<xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType>引發<xref:System.NotSupportedException>。 若要避免這種情況下，會周遊一次移除一個每個資料列的每個資料表。  
  
   
  
## Examples  
 下列範例會清除<xref:System.Data.DataSet>的所有資料表中的所有資料列。  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>複製 <see cref="T:System.Data.DataSet" /> 的結構，包括所有 <see cref="T:System.Data.DataTable" /> 結構描述、關聯和條件約束。 不要複製任何資料。</summary>
        <returns>具有與目前的 <see cref="T:System.Data.DataSet" /> 相同結構描述之新 <see cref="T:System.Data.DataSet" />，但是沒有資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果這些類別已形成子類別，複製也會屬於相同的子類別。  
  
   
  
## Examples  
 下列範例會建立的複本<xref:System.Data.DataSet>物件的結構描述。  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>複製這個 <see cref="T:System.Data.DataSet" /> 的結構和資料。</summary>
        <returns>新的 <see cref="T:System.Data.DataSet" />，具有與這個 <see cref="T:System.Data.DataSet" /> 相同的結構 (資料表結構描述、關聯和條件約束) 和資料。  
  
 <block subset="none" type="note"><para>  
 如果這些類別已形成子類別，則複本也會屬於相同的子類別。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會使用<xref:System.Data.DataSet.Copy%2A>方法用來建立一份原始<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回 <see cref="T:System.Data.DataTableReader" />，每個 <see cref="T:System.Data.DataTable" /> 有一個結果集，順序與資料表出現在 <see cref="P:System.Data.DataSet.Tables" /> 集合中的順序相同。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了確保結果集內傳回的順序<xref:System.Data.DataTableReader>的話<xref:System.Data.DataTable>內<xref:System.Data.DataSet>是空的它將會以表示空的結果集內傳回`DataTableReader`。  
  
   
  
## Examples  
 此範例中，主控台應用程式，會建立三個<xref:System.Data.DataTable>執行個體，並將每個都加入<xref:System.Data.DataSet>。 此範例會呼叫<xref:System.Data.DataSet.CreateDataReader%2A>方法，並顯示傳回之內容<xref:System.Data.DataTableReader>。 請注意，設定結果的順序`DataTableReader`依以下順序控制`DataTable`做為參數傳遞的執行個體。  
  
> [!NOTE]
>  此範例示範如何使用其中一個多載版本`CreateDataReader`。 如需可能會提供其他範例，請參閱個別的多載的主題。  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 此範例會將下列程式碼顯示在主控台視窗中：  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Data.DataTableReader" />，每個 <see cref="T:System.Data.DataTable" /> 有一個結果集，順序與資料表出現在 <see cref="P:System.Data.DataSet.Tables" /> 集合中的順序相同。</summary>
        <returns><see cref="T:System.Data.DataTableReader" />，包含一個或多個結果集，對應於包含在來源 <see cref="T:System.Data.DataTable" /> 之中的 <see cref="T:System.Data.DataSet" /> 執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了確保結果集內傳回的順序<xref:System.Data.DataTableReader>的話<xref:System.Data.DataTable>內<xref:System.Data.DataSet>是空的它以空的結果集內傳回`DataTableReader`。  
  
   
  
## Examples  
 下列範例會建立三個<xref:System.Data.DataTable>執行個體，並將每個都加入<xref:System.Data.DataSet>。 範例接著會傳遞將填滿`DataSet`要呼叫的程序<xref:System.Data.DataSet.CreateDataReader%2A>方法，然後繼續進行逐一查看所有結果集內包含<xref:System.Data.DataTableReader>。 此範例會在主控台視窗中顯示結果。  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">DataTable 的陣列提供要在 <see cref="T:System.Data.DataTableReader" /> 中傳回的結果集順序。</param>
        <summary>傳回 <see cref="T:System.Data.DataTableReader" />，每一個 <see cref="T:System.Data.DataTable" /> 有一個結果集。</summary>
        <returns><see cref="T:System.Data.DataTableReader" />，包含一個或多個結果集，對應於包含在來源 <see cref="T:System.Data.DataTable" /> 之中的 <see cref="T:System.Data.DataSet" /> 執行個體。 傳回的結果集的順序是 <paramref name="dataTables" /> 參數所指定的順序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 為了確保結果的順序設定內傳回<xref:System.Data.DataTableReader>的話<xref:System.Data.DataTable>內<xref:System.Data.DataSet>是空的它以空的結果集內傳回`DataTableReader`。 因為此多載的版本可讓您提供一份`DataTable`做為參數的執行個體，您可以指定結果集內傳回的出現的順序`DataTableReader`。  
  
   
  
## Examples  
 此範例中，主控台應用程式，會建立三個<xref:System.Data.DataTable>執行個體，並將每個都加入<xref:System.Data.DataSet>。 此範例會呼叫<xref:System.Data.DataSet.CreateDataReader%2A>方法，並顯示傳回之內容<xref:System.Data.DataTableReader>。 請注意，設定結果的順序`DataTableReader`依以下順序控制`DataTable`做為參數傳遞的執行個體。 此範例會在主控台視窗中顯示結果。  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDataSetNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前 <see cref="T:System.Data.DataSet" /> 的名稱。</summary>
        <value><see cref="T:System.Data.DataSet" /> 的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立新<xref:System.Data.DataSet>與指定<xref:System.Data.DataSet.DataSetName%2A>。  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Data.DataSet" /> (它允許使用自訂的 <see cref="T:System.Data.DataViewManager" /> 進行篩選、搜尋和巡覽) 所包含的資料之自訂檢視。</summary>
        <value><see cref="T:System.Data.DataViewManager" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataViewManager>所傳回<xref:System.Data.DataSet.DefaultViewManager%2A>屬性可讓您建立自訂的設定，每個<xref:System.Data.DataTable>在<xref:System.Data.DataSet>。  
  
 當您取得<xref:System.Data.DataView>從<xref:System.Data.DataTable>，排序順序中，篩選並<xref:System.Data.DataViewRowState>根據中的設定會設定<xref:System.Data.DataSet.DefaultViewManager%2A>屬性。  
  
   
  
## Examples  
 下列範例會取得預設值<xref:System.Data.DataViewManager>for <xref:System.Data.DataSet>，並將<xref:System.Data.DataTable>至<xref:System.Data.DataTableCollection>。  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>判斷 <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> 的 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化的型別時，就可以呼叫這個方法<xref:System.Data.DataSet>來判斷其<xref:System.Data.DataSet.SchemaSerializationMode%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /> 執行個體，是在 <see cref="T:System.Data.DataSet" /> 的還原序列化期間傳遞的。</param>
        <summary>判斷 <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> 的 <see cref="T:System.Data.DataSet" />。</summary>
        <returns><see cref="T:System.Data.SchemaSerializationMode" /> 列舉，指出結構描述資訊是否已從承載中省略。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化的型別時，就可以呼叫這個方法<xref:System.Data.DataSet>來判斷其<xref:System.Data.DataSet.SchemaSerializationMode%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />，在遠端還原序列化案例中，以 <see langword="DataSet" /> 的保護建構函式 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> 叫用。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" />，在遠端還原序列化案例中，以 <see langword="DataSet" /> 的保護建構函式 <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> 叫用。</param>
        <summary>判斷 <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> 的 <see cref="T:System.Data.DataSet" />。</summary>
        <returns><see cref="T:System.Data.SchemaSerializationMode" /> 列舉，指出結構描述資訊是否已從承載中省略。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原序列化的型別時，就可以呼叫這個方法<xref:System.Data.DataSet>來判斷其<xref:System.Data.DataSet.SchemaSerializationMode%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束對表單或另一個元件所使用的 <see cref="T:System.Data.DataSet" /> 進行初始化作業。 初始化發生於執行階段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 設計環境會使用這個方法，結束對表單或另一個元件所使用的元件初始化。 <xref:System.Data.DataSet.BeginInit%2A>方法會啟動初始化。 使用<xref:System.Data.DataSet.BeginInit%2A>和<xref:System.Data.DataSet.EndInit%2A>方法，防止控制項被完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetEnforceConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出在嘗試任何更新作業時，是否遵循條件約束 (Constraint) 規則。</summary>
        <value><see langword="true" /> 如果會強制執行規則;否則， <see langword="false" />。 預設為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在設定條件約束<xref:System.Data.DataTable>層級 (<xref:System.Data.DataTable.Constraints%2A>屬性)。 如需建立條件約束的詳細資訊，請參閱 < [DataTable 條件約束](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Data.DataSet>一個資料表，一個資料行、 五個資料列，再<xref:System.Data.UniqueConstraint>。 <xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`和每個資料列的值都會設為相同的值。 當<xref:System.Data.DataSet.EnforceConstraints%2A>屬性重設為`true`、<xref:System.Data.ConstraintException>產生。  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">一個或多個條件約束無法強制遵循。</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與 <see langword="DataSet" /> 相關聯的自訂使用者資訊集合。</summary>
        <value>具有所有自訂使用者資訊的 <see cref="T:System.Data.PropertyCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ExtendedProperties%2A>屬性可讓您儲存自訂的資訊與`DataSet`。 例如，您可能會儲存資料應該重新整理的時間。  
  
 擴充的屬性必須是型別<xref:System.String>如果您想保存時<xref:System.Data.DataSet>撰寫為 XML。  
  
   
  
## Examples  
 下列範例會將自訂屬性來<xref:System.Data.PropertyCollection>所傳回<xref:System.Data.DataColumn.ExtendedProperties%2A>屬性。 第二個範例會擷取自訂屬性。  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得 <see cref="T:System.Data.DataSet" /> (包含從前一次載入它或呼叫 <see cref="M:System.Data.DataSet.AcceptChanges" /> 以來所做的所有變更) 的複本。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Data.DataSet" /> (包含從載入它或前一次呼叫 <see cref="M:System.Data.DataSet.AcceptChanges" /> 以來所做的所有變更) 的複本。</summary>
        <returns>這個 <see cref="T:System.Data.DataSet" /> 所產生變更的複本，可在其上執行動作，並且稍後使用 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /> 合併回來。 如果找不到已變更的資料列，則方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建立新<xref:System.Data.DataSet>，其中包含一份原始中的所有資料列<xref:System.Data.DataSet>具有暫止的變更。 關聯性條件約束可能會導致其他未變更的資料列加入至新<xref:System.Data.DataSet>如果未變更的資料列包含主索引鍵對應至已變更的資料列中的外部索引鍵。 此方法會傳回`null`有任何資料列中原始<xref:System.Data.DataSet>具有暫止的變更。  
  
   
  
## Examples  
 下列範例會建立簡單<xref:System.Data.DataSet>一個資料表、 兩個資料行，與 10 個資料列。 兩個值會變更，並加入一個資料列。 使用建立的已變更的資料子集<xref:System.Data.DataSet.GetChanges%2A>方法。 之後重新調整錯誤，變更結構描述的子集，加入新的資料行。 當<xref:System.Data.DataSet.Merge%2A>方法呼叫`missingSchemaAction`設為`MissingSchemaAction.Add`，新的資料行加入原始<xref:System.Data.DataSet>物件的結構描述。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">其中一個 <see cref="T:System.Data.DataRowState" /> 值。</param>
        <summary>取得 <see cref="T:System.Data.DataSet" /> (包含從前一次載入它或呼叫 <see cref="M:System.Data.DataSet.AcceptChanges" /> 以來所做的所有變更) 的複本 (由 <see cref="T:System.Data.DataRowState" /> 篩選)。</summary>
        <returns>篩選過的 <see cref="T:System.Data.DataSet" /> 複本，可以在其上執行動作，然後在使用 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /> 時合併回來。 如果找不到所需的 <see cref="T:System.Data.DataRowState" /> 的資料列，則方法會傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.GetChanges%2A>方法用來產生第二個<xref:System.Data.DataSet>導入原始的物件，其中包含的變更。 使用`rowStates`引數來指定新的物件應該包含的變更類型。  
  
 傳回此複本設計來合併回到此原始<xref:System.Data.DataSet>。 關聯性條件約束可能會造成標記的父資料列`Unchanged`納入。 如果所需的任何資料列<xref:System.Data.DataRowState>找不到，<xref:System.Data.DataSet.GetChanges%2A>方法會傳回`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Data.DataSet.GetChanges%2A>方法用來建立第二個<xref:System.Data.DataSet>物件，然後用來更新資料來源。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">指定的結構描述集。</param>
        <summary>取得資料集之 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 的複本。</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchemaSet" /> 的複本。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" />，保留與 <see cref="T:System.Data.DataSet" /> 關聯的序列化資料。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" />，含有與 <see cref="T:System.Data.DataSet" /> 關聯的序列資料流的來源和目的端。</param>
        <summary>以序列化 <see cref="T:System.Data.DataSet" /> 所需的資料，填入序列化資訊物件。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 參數為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回可序列化的 <see cref="T:System.Xml.Schema.XmlSchema" /> 執行個體。</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchema" /> 執行個體。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 執行個體。</param>
        <param name="context">資料流內容。</param>
        <summary>從二進位或 XML 資料流還原序列化資料表資料。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回儲存於 <see cref="T:System.Data.DataSet" /> 的資料之 XML 表示。</summary>
        <returns>字串，儲存於 <see cref="T:System.Data.DataSet" /> 的資料表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫此方法等於呼叫<xref:System.Data.DataSet.WriteXml%2A>具有<xref:System.Data.XmlWriteMode>設定為<xref:System.Data.XmlWriteMode.IgnoreSchema>。  
  
 <xref:System.Data.DataSet.GetXml%2A> 傳回字串形式的 XML，並因此需要更多的額外負荷比<xref:System.Data.DataSet.WriteXml%2A>來寫入 XML 檔案。  
  
 如果您要建置<xref:System.Data.DataSet>使用結構描述推斷和序列化使用 XML 或 Web 服務，資料行順序可能會改變。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Data.DataSet>和<xref:System.Data.DataTable>、 新增範例資料，並以 XML 格式顯示資料。  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 此範例示範如何將資料寫入至 XML 檔案中，從資料集和資料讀入資料集，從 XML。 此範例會建立具有兩個資料表的一個資料集，使用兩種方式可將資料集匯出至 XML 檔案 （WriteXml 和 GetXml），並使用兩種方式 （ReadXml 和 InferXmlSchema），從 XML 檔案匯入資料集。  
  
 在編譯和執行範例之前，您需要在 範例目錄中建立四個 XML 檔案。 首先，建立 ElementsWithAttributes.xml:  
  
```xml  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 接下來，建立 ElementsWithChildElementsxml.xml:  
  
```xml  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 現在建立 ElementsWithOnlyAttributes.xml:  
  
```xml
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 然後，最後，建立 RepeatingElements.xml:  
  
```xml
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 現在您可以編譯並執行下列原始程式碼。  [如何儲存區資料的資料集的 XML 檔案](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3)有此範例的 Visual Basic 和 C# 專案。  
  
```csharp
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>為儲存於 <see cref="T:System.Data.DataSet" /> 的資料之 XML 表示，傳回 XML 結構描述。</summary>
        <returns>字串，為儲存於 <see cref="T:System.Data.DataSet" /> 的資料之 XML 表示的 XML 結構描述。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫此方法等於呼叫<xref:System.Data.DataSet.WriteXmlSchema%2A>，不過，只有主要的結構描述寫入。  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> 傳回字串形式的 XML，並因此需要更多的額外負荷比<xref:System.Data.DataSet.WriteXmlSchema%2A>來寫入 XML 檔案。  
  
 如果您要建置<xref:System.Data.DataSet>使用結構描述推斷和序列化使用 XML 或 Web 服務，資料行順序可能會改變。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Data.DataSet>和<xref:System.Data.DataTable>，然後顯示 XML 格式的結構描述。  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得值，表示 <see cref="T:System.Data.DataSet" /> 是否包含變更，包括加入、刪除或修改的資料列。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得值，表示 <see cref="T:System.Data.DataSet" /> 是否包含變更，包括加入、刪除或修改的資料列。</summary>
        <returns>若 <see cref="T:System.Data.DataSet" /> 包含變更，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會使用<xref:System.Data.DataSet.GetChanges%2A>方法用來建立第二個<xref:System.Data.DataSet>然後用來更新資料來源的物件。  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">其中一個 <see cref="T:System.Data.DataRowState" /> 值。</param>
        <summary>取得值，指出 <see cref="T:System.Data.DataSet" /> 是否包含變更，包括加入、刪除或修改的資料列 (由 <see cref="T:System.Data.DataRowState" /> 篩選)。</summary>
        <returns>若 <see cref="T:System.Data.DataSet" /> 包含變更，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檢查<xref:System.Data.DataSet.HasChanges%2A>的屬性`DataSet`叫用之前<xref:System.Data.DataSet.GetChanges%2A>方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Data.DataSet.GetChanges%2A>方法用來建立第二個<xref:System.Data.DataSet>物件，然後用來更新資料來源。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出這個 <see cref="T:System.Data.DataTable" /> 內的 <see cref="T:System.Data.DataSet" /> 物件中是否有任何一個有錯誤。</summary>
        <value><see langword="true" /> 如果任何資料表包含錯誤;否則， <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個<xref:System.Data.DataTable>中<xref:System.Data.DataSet>還有<xref:System.Data.DataTable.HasErrors%2A>屬性。 使用`HasErrors`的屬性`DataSet`第一個，來判斷如果任何 tato tabulka obsahuje chyby，再檢查個別<xref:System.Data.DataTable>物件。 如果`DataTable`發生錯誤，<xref:System.Data.DataTable.GetErrors%2A>方法傳回的陣列<xref:System.Data.DataRow>包含錯誤的物件。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Data.DataSet.HasErrors%2A>屬性來判斷是否<xref:System.Data.DataSet>物件包含錯誤。 如果是的話，每個錯誤<xref:System.Data.DataRow>在每個<xref:System.Data.DataTable>列印。  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 XML 結構描述套用至 <see cref="T:System.Data.DataSet" /> .</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">要從其中讀取結構描述的來源 <see langword="Stream" />。</param>
        <param name="nsArray">要從結構描述 (Schema) 推斷中排除之命名空間統一資源識別元 (URI) 字串的陣列。</param>
        <summary>從指定的 <see cref="T:System.IO.Stream" />，將 XML 結構描述套用至 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">要從其中讀取結構描述的來源 <see langword="TextReader" />。</param>
        <param name="nsArray">要從結構描述 (Schema) 推斷中排除之命名空間統一資源識別元 (URI) 字串的陣列。</param>
        <summary>從指定的 <see cref="T:System.IO.TextReader" />，將 XML 結構描述套用至 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">要從中讀取結構描述的來源檔案名稱 (包含路徑)。</param>
        <param name="nsArray">要從結構描述 (Schema) 推斷中排除之命名空間統一資源識別元 (URI) 字串的陣列。</param>
        <summary>從指定的檔案，將 XML 結構描述套用至 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> 並不是設定為 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 關聯的列舉型別：<see cref="T:System.Security.Permissions.FileIOPermissionAccess" />。</permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">要從其中讀取結構描述的來源 <see langword="XMLReader" />。</param>
        <param name="nsArray">要從結構描述 (Schema) 推斷中排除之命名空間統一資源識別元 (URI) 字串的陣列。</param>
        <summary>從指定的 <see cref="T:System.Xml.XmlReader" />，將 XML 結構描述套用至 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生於 <see cref="T:System.Data.DataSet" /> 初始化之後。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱<xref:System.Data.DataSet.IsInitialized%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從二進位或 XML 資料流還原序列化資料集的所有資料表資料。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> 物件。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> 物件。</param>
        <summary>檢查 <see langword="DataSet" /> 之序列化表示的格式。</summary>
        <returns>如果指定的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 表示以二進位格式序列化的 <see langword="true" />，則為 <see langword="DataSet" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成員支援 .NET Framework 基礎結構，並不能直接使用於您的程式碼中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Data.DataSet" /> 是否已初始化。</summary>
        <value><see langword="true" /> 表示元件已完成初始化，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的狀態<xref:System.Data.DataSet>時它由所建構，例如 Visual Studio。 <xref:System.Data.DataSet.BeginInit%2A>方法將它設定為`false`並<xref:System.Data.DataSet.EndInit%2A>方法將它設定為`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用所提供的 <see cref="T:System.Data.DataSet" />，用資料來源的值填滿 <see cref="T:System.Data.IDataReader" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>方法提供一種技術來填滿單一<xref:System.Data.DataTable>從擷取的資料<xref:System.Data.IDataReader>執行個體。 這個方法會提供相同的功能，但可讓您從多個結果集載入`IDataReader`成多個資料表內`DataSet`。  
  
 如果 `DataSet` 已經包含資料列，從資料來源傳入的資料會與現有的資料列合併。  
  
 `Load`方法可用於數個常見的案例，從指定的資料來源取得資料，並將它加入至目前的資料容器所有為中心 (在此情況下， `DataSet`)。 下列案例說明標準用法`DataSet`、 描述其更新，並合併行為。  
  
 A`DataSet`會同步處理，或更新具有單一主要資料來源。 `DataSet`追蹤變更，允許與主要資料來源的同步處理。 颾魤 ㄛ`DataSet`可以接受一或多個次要資料來源的增量資料。 `DataSet`不負任何責任，若要允許與次要資料來源的同步處理追蹤變更。  
  
 根據這些兩個的假設性的資料來源，使用者很可能需要下列其中一個下列行為：  
  
-   初始化`DataSet`從主要資料來源。 在此案例中，使用者想要初始化空`DataSet`以主要資料來源的值。 會修改一或多個 DataTable 的內容。 稍後，使用者想要將變更傳播回主要資料來源。  
  
-   保留變更，並重新同步處理主要資料來源。 在此案例中，使用者想要採取`DataSet`填入先前案例中，並執行增量同步處理與主要資料來源，保留在中所做的修改`DataSet`。  
  
-   累加的資料摘要，從次要資料來源。 在此案例中，使用者想要合併從一或多個次要資料來源的變更並傳播這些變更回復到主要資料來源。  
  
 `Load`方法會進行所有這些情況下可能。 這個方法可讓您指定的載入選項參數，指出如何已經在資料列<xref:System.Data.DataTable>結合所載入的資料列。 下表描述所提供的三種載入選項<xref:System.Data.LoadOption>列舉型別。 在每個案例中，描述當內送資料中的資料列的主索引鍵符合現有的資料列的主索引鍵表示的行為。  
  
|載入選項|描述|  
|-----------------|-----------------|  
|`PreserveChanges` (預設值)|使用內送資料列的值更新資料列的原始版本。|  
|`OverwriteChanges`|傳入的資料列的值更新資料列的目前和原始版本。|  
|`Upsert`|使用內送資料列的值來更新資料列的目前版本。|  
  
 一般情況下，`PreserveChanges`並`OverwriteChanges`選項適用的案例中，使用者必須同步處理`DataSet`和其與主要資料來源的變更。 `Upsert`選項有助於從一或多個次要資料來源的彙總變更。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" />，提供一個或多個結果集。</param>
        <param name="loadOption">來自 <see cref="T:System.Data.LoadOption" /> 列舉的值，表示已經在 <see cref="T:System.Data.DataTable" /> 之內 <see cref="T:System.Data.DataSet" /> 執行個體中的資料列如何與共用相同主索引鍵的傳入資料列結合。</param>
        <param name="tables"><see cref="T:System.Data.DataTable" /> 執行個體的陣列，<see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> 方法從中擷取名稱和命名空間資訊。 這些資料表的每一個都必須為這個 <see cref="T:System.Data.DataTableCollection" /> 所包含 <see cref="T:System.Data.DataSet" /> 的成員。</param>
        <summary>使用所提供的 <see cref="T:System.Data.DataSet" />，以資料來源的值，填入 <see cref="T:System.Data.IDataReader" />，使用 <see cref="T:System.Data.DataTable" /> 執行個體的陣列，以提供結構描述和命名空間資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>方法提供一種技術來填滿單一<xref:System.Data.DataTable>從擷取的資料<xref:System.Data.IDataReader>執行個體。 這個方法會提供相同的功能，但可讓您從多個結果集載入<xref:System.Data.IDataReader>成多個資料表內<xref:System.Data.DataSet>。  
  
> [!NOTE]
>  載入作業會失敗<xref:System.InvalidOperationException>如果有任何來源資料行，在傳入`reader`是計算資料行。  
  
 `loadOption`參數可讓您指定要匯入的資料與現有資料互動，及可以是任何一個值的方式<xref:System.Data.LoadOption>列舉型別。 請參閱文件<xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A>如需有關使用此參數的方法。  
  
 `tables`參數可讓您指定的陣列<xref:System.Data.DataTable>執行個體，表示對應至每一個結果集從讀取器的 載入資料表的順序。 <xref:System.Data.DataSet.Load%2A>方法會填滿每個提供<xref:System.Data.DataTable>包含來自單一結果集，從來源資料讀取器的執行個體。 每個結果集之後,<xref:System.Data.DataSet.Load%2A>方法移至下一個設定的讀取器中，直到有沒有更多的結果集的結果。  
  
 這個方法的名稱解析配置等同於，後面接著<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>類別。  
  
   
  
## Examples  
 下列範例會建立新<xref:System.Data.DataSet>，加入兩個<xref:System.Data.DataTable>執行個體<xref:System.Data.DataSet>，然後填滿<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.Load%2A>方法，擷取資料，從<xref:System.Data.DataTableReader>包含兩個結果集。 最後，這個範例會顯示在主控台視窗中資料表的內容。  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" />，提供一個或多個結果集。</param>
        <param name="loadOption">來自 <see cref="T:System.Data.LoadOption" /> 列舉的值，表示已經在 <see cref="T:System.Data.DataTable" /> 之內 <see langword="DataSet" /> 執行個體中的資料列如何與共用相同主索引鍵的傳入資料列結合。</param>
        <param name="tables">字串的陣列，<see langword="Load" /> 方法從中擷取資料表名稱資訊。</param>
        <summary>使用所提供的 <see cref="T:System.Data.DataSet" />，以資料來源的值填入 <see cref="T:System.Data.IDataReader" />，使用字串的陣列來提供 <see langword="DataSet" /> 之內的資料表名稱。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>方法提供一種技術來填滿單一<xref:System.Data.DataTable>從擷取的資料<xref:System.Data.IDataReader>執行個體。 這個方法會提供相同的功能，但可讓您從多個結果集載入`IDataReader`成多個資料表內`DataSet`。  
  
> [!NOTE]
>  載入作業會失敗<xref:System.InvalidOperationException>如果有任何來源資料行，在傳入`reader`是計算資料行。  
  
 `loadOption`參數可讓您指定要匯入的資料與現有資料互動，及可以是任何一個值的方式<xref:System.Data.LoadOption>列舉型別。 請參閱文件<xref:System.Data.DataTable.Load%2A>如需有關使用此參數的方法。  
  
 `tables`參數可讓您指定資料表名稱，表示對應至每一個結果集從讀取器的 載入的資料表順序的陣列。 `Load`方法會嘗試尋找的資料表內`DataSet`陣列中的資料表名稱，在順序中找到符合的名稱。 如果找到相符的資料表，則該資料表會載入目前的結果集的內容。 如果找到相符的資料表，資料表名稱的陣列中提供的名稱建立資料表，並從結果集中會推斷新的資料表結構描述。 每個結果集之後,`Load`方法移至下一個設定的讀取器中，直到有沒有更多的結果集的結果。  
  
 與相關聯的預設命名空間`DataSet`，如果任何項目，是新建立的每個相關聯`DataTable`。 這個方法的名稱解析配置等同於，後面接著<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>類別。  
  
   
  
## Examples  
 下列主控台應用程式範例首先會建立資料表，並將資料載入至讀取器從<xref:System.Data.DataSet>，並使用`Load`方法。 範例接著會新增至資料表<xref:System.Data.DataSet>，並嘗試使用的資料填入資料表<xref:System.Data.DataTableReader>。 在此範例中，因為參數傳遞給`Load`方法表示資料表名稱不存在，`Load`方法會建立新的資料表，以符合做為參數傳遞的名稱。 將資料載入之後，這個範例會顯示在主控台視窗及其所有資料表的內容。  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" />，提供一個或多個結果集。</param>
        <param name="loadOption">來自 <see cref="T:System.Data.LoadOption" /> 列舉的值，表示已經在 <see cref="T:System.Data.DataTable" /> 之內 <see cref="T:System.Data.DataSet" /> 執行個體中的資料列如何與共用相同主索引鍵的傳入資料列結合。</param>
        <param name="errorHandler">載入資料時發生錯誤，要呼叫的 <see cref="T:System.Data.FillErrorEventHandler" /> 委派。</param>
        <param name="tables"><see cref="T:System.Data.DataTable" /> 執行個體的陣列，<see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> 方法從中擷取名稱和命名空間資訊。</param>
        <summary>使用所提供的 <see cref="T:System.Data.DataSet" />，以資料來源的值，填入 <see cref="T:System.Data.IDataReader" />，使用 <see cref="T:System.Data.DataTable" /> 執行個體的陣列，以提供結構描述和命名空間資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>方法提供一種技術來填滿單一<xref:System.Data.DataTable>從擷取的資料<xref:System.Data.IDataReader>執行個體。 這個方法會提供相同的功能，但可讓您從多個結果集載入<xref:System.Data.IDataReader>成多個資料表內<xref:System.Data.DataSet>。  
  
> [!NOTE]
>  載入作業會失敗<xref:System.InvalidOperationException>如果有任何來源資料行，在傳入`reader`是計算資料行。  
  
 `loadOption`參數可讓您指定要匯入的資料與現有資料互動，及可以是任何一個值的方式<xref:System.Data.LoadOption>列舉型別。 請參閱文件<xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A>如需有關使用此參數的方法。  
  
 `errorHandler`參數是<xref:System.Data.FillErrorEventHandler>指的在載入資料時，發生錯誤時所呼叫的程序的委派。 <xref:System.Data.FillErrorEventArgs>傳遞至程序的參數提供屬性，可讓您擷取資訊所發生的錯誤，目前的資料列的資料，而<xref:System.Data.DataTable>被填入。 使用此委派的機制，而不是更簡單的 try/catch 區塊，可讓您判斷錯誤處理狀況，並繼續處理，如果您想。 <xref:System.Data.FillErrorEventArgs>參數提供<xref:System.Data.FillErrorEventArgs.Continue%2A>屬性： 將此屬性設定為`true`表示處理錯誤和想来繼續處理，將屬性設定為`false`來代表您想要停止處理。 請注意，將屬性設定為`false`造成觸發要擲回例外狀況的問題程式碼。  
  
 `tables`參數可讓您指定的陣列<xref:System.Data.DataTable>執行個體，表示對應至每一個結果集從讀取器的 載入資料表的順序。 <xref:System.Data.DataSet.Load%2A>方法會填滿每個提供<xref:System.Data.DataTable>包含來自單一結果集，從來源資料讀取器的執行個體。 每個結果集之後,<xref:System.Data.DataSet.Load%2A>方法移至下一個設定的讀取器中，直到有沒有更多的結果集的結果。  
  
 這個方法的名稱解析配置等同於，後面接著<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>類別。  
  
   
  
## Examples  
 下列範例會加入至資料表<xref:System.Data.DataSet>，然後嘗試使用<xref:System.Data.DataSet.Load%2A>方法來載入資料<xref:System.Data.DataTableReader>，其中包含不相容的結構描述。 而不是捕捉此錯誤，此範例會使用<xref:System.Data.FillErrorEventHandler>調查和處理錯誤的委派。 輸出會顯示在主控台視窗。  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用來在資料表中比較字串的地區設定 (Locale) 資訊。</summary>
        <value><see cref="T:System.Globalization.CultureInfo" />，包含使用者電腦地區設定的資料。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Locale%2A>屬性指定的地區設定的排序會套用。  
  
 根據預設，設定<xref:System.Data.DataSet.Locale%2A>for<xref:System.Data.DataSet>也會設定<xref:System.Data.DataSet.Locale%2A>每個<xref:System.Data.DataTable>中的物件`DataSet`相同的值。  
  
> [!NOTE]
>  資料行中包含的運算式，<xref:System.StringComparison.InvariantCulture>用。 <xref:System.StringComparison.CurrentCulture>會被忽略。  
  
   
  
## Examples  
 下列範例會取得<xref:System.Globalization.CultureInfo>for <xref:System.Data.DataSet> ，並列印<xref:System.Globalization.CultureInfo.DisplayName%2A>和<xref:System.Globalization.CultureInfo.EnglishName%2A>屬性。  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定的 <see cref="T:System.Data.DataSet" />、<see cref="T:System.Data.DataTable" /> 或 <see cref="T:System.Data.DataRow" /> 物件的陣列合併到目前的 <see langword="DataSet" /> 或 <see langword="DataTable" /> 中。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows"><see langword="DataRow" /> 物件的陣列，將合併至 <see langword="DataSet" />。</param>
        <summary>將 <see cref="T:System.Data.DataRow" /> 物件的陣列合併到目前的 <see cref="T:System.Data.DataSet" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有<xref:System.Data.DataSet>。 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。  
  
 <xref:System.Data.DataSet.Merge%2A>結尾的一系列包含驗證變更、 錯誤，重新調整、 更新資料來源的變更，以及最後重新整理現有的程序通常會呼叫方法<xref:System.Data.DataSet>。  
  
 用戶端應用程式中，它會有單一按鈕，讓使用者可以按一下，收集變更的資料，並驗證它再將它傳送回中介層元件。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>第一次叫用方法。 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>並<xref:System.Data.DataRow>物件的已變更，導致原始的子集<xref:System.Data.DataSet>。 這個子集通常比較小，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或它可以傳回的任何變更，已對它從資料來源子集。 （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。  
  
 當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已變更。 比方說，在企業對企業案例中，新的資料行可能有已加入 XML 結構描述由自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (新增<xref:System.Data.DataColumn>物件)，在目標中遺漏，結構描述項目可以藉由設定新增到目標`missingSchemaAction`引數`MissingSchemaAction.Add`。 在此情況下，合併<xref:System.Data.DataSet>包含加入的結構描述和資料。  
  
 合併的結構描述之後, 便會合併資料。  
  
 合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`與進行比對具有相同的主索引鍵值的目標資料列。 來源的資料列<xref:System.Data.DataRowState>的值`Added`就會對應到新的來源資料列的相同主索引鍵值的新目標資料列。  
  
 合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，和所有資料列，而不會標示為錯誤。 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see langword="DataSet" />，其資料及結構描述將被合併。</param>
        <summary>將指定的 <see cref="T:System.Data.DataSet" /> 及其結構描述合併到目前的 <see langword="DataSet" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有<xref:System.Data.DataSet>。 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。  
  
 <xref:System.Data.DataSet.Merge%2A>結尾的一系列包含驗證變更、 錯誤，重新調整、 更新資料來源的變更，以及最後重新整理現有的程序通常會呼叫方法<xref:System.Data.DataSet>。  
  
 用戶端應用程式中，它會有單一按鈕，讓使用者可以按一下，收集變更的資料，並驗證它再將它傳送回中介層元件。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>第一次叫用方法。 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>並<xref:System.Data.DataRow>物件的已變更，導致原始的子集<xref:System.Data.DataSet>。 這個子集是通常較小，並因此更有效率地傳回給中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或它可以傳回的任何變更，已對它從資料來源子集。 （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。  
  
 當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已變更。 比方說，在企業對企業案例中，新的資料行可能有已加入 XML 結構描述由自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (新增<xref:System.Data.DataColumn>物件)，在目標中遺漏，結構描述項目可以藉由設定新增到目標`missingSchemaAction`引數`MissingSchemaAction.Add`。 在此情況下，合併<xref:System.Data.DataSet>包含加入的結構描述和資料。  
  
 合併的結構描述之後, 便會合併資料。  
  
 合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`與進行比對具有相同的主索引鍵值的目標資料列。 來源的資料列`DataRowState`的值`Added`就會對應到新的來源資料列的相同主索引鍵值的新目標資料列。  
  
 合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，和所有資料列，而不會標示為錯誤。 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設`true`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Data.DataSet.GetChanges%2A>，更新，並<xref:System.Data.DataSet.Merge%2A>上的方法<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">一個或多個條件約束無法啟用。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table"><see cref="T:System.Data.DataTable" />，其資料及結構描述將被合併。</param>
        <summary>將指定的 <see cref="T:System.Data.DataTable" /> 及其結構描述合併到目前的 <see cref="T:System.Data.DataSet" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有<xref:System.Data.DataSet>。 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。  
  
 <xref:System.Data.DataSet.Merge%2A>結尾的一系列包含驗證變更、 錯誤，重新調整、 更新資料來源的變更，以及最後重新整理現有的程序通常會呼叫方法<xref:System.Data.DataSet>。  
  
 用戶端應用程式中，它會有單一按鈕，讓使用者可以按一下，收集變更的資料，並驗證它再將它傳送回中介層元件。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>第一次叫用方法。 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>並<xref:System.Data.DataRow>物件的已變更，導致原始的子集<xref:System.Data.DataSet>。 這個子集是通常較小，並因此更有效率地傳回給中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或它可以傳回的任何變更，已對它從資料來源子集。 （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。  
  
 當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已變更。 比方說，在企業對企業案例中，新的資料行可能有已加入 XML 結構描述由自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (新增<xref:System.Data.DataColumn>物件)，在目標中遺漏，結構描述項目可以藉由設定新增到目標`missingSchemaAction`引數`MissingSchemaAction.Add`。 在此情況下，合併<xref:System.Data.DataSet>包含加入的結構描述和資料。  
  
 合併的結構描述之後, 便會合併資料。  
  
 合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`與進行比對具有相同的主索引鍵值的目標資料列。 來源的資料列`DataRowState`的值`Added`就會對應到新的來源資料列的相同主索引鍵值的新目標資料列。  
  
 合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，和所有資料列，而不會標示為錯誤。 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設`true`。  
  
   
  
## Examples  
 下列範例會建立簡單<xref:System.Data.DataSet>一個資料表、 兩個資料行，與 10 個資料列。 第二個<xref:System.Data.DataTable>也就是建立與第一個。 兩個資料列會加入第二個資料表，然後合併到<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="table" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see langword="DataSet" />，其資料及結構描述將被合併。</param>
        <param name="preserveChanges">若要保留目前 <see langword="DataSet" /> 中的變更，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>將指定的 <see cref="T:System.Data.DataSet" /> 及其結構描述合併到目前的 <see langword="DataSet" /> 中，根據給定參數保留或忽略這個 <see langword="DataSet" /> 中的任何變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有<xref:System.Data.DataSet>。 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。  
  
 <xref:System.Data.DataSet.Merge%2A>結尾的一系列包含驗證變更、 錯誤，重新調整、 更新資料來源的變更，以及最後重新整理現有的程序通常會呼叫方法<xref:System.Data.DataSet>。  
  
 用戶端應用程式中，它會有單一按鈕，讓使用者可以按一下，收集變更的資料，並驗證它再將它傳送回中介層元件。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>第一次叫用方法。 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>並<xref:System.Data.DataRow>物件的已變更，導致原始的子集<xref:System.Data.DataSet>。 這個子集是通常較小，並因此更有效率地傳回給中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或它可以傳回的任何變更，已對它從資料來源子集。 （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。  
  
 當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已變更。 比方說，在企業對企業案例中，新的資料行可能有已加入 XML 結構描述由自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (新增<xref:System.Data.DataColumn>物件)，在目標中遺漏，結構描述項目可以藉由設定新增到目標`missingSchemaAction`引數`MissingSchemaAction.Add`。 在此情況下，合併<xref:System.Data.DataSet>包含加入的結構描述和資料。  
  
 合併的結構描述之後, 便會合併資料。  
  
 合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`與進行比對具有相同的主索引鍵值的目標資料列。 來源的資料列`DataRowState`的值`Added`就會對應到新的來源資料列的相同主索引鍵值的新目標資料列。  
  
 合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，和所有資料列，而不會標示為錯誤。 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設`true`。  
  
   
  
## Examples  
 下列範例會建立簡單<xref:System.Data.DataSet>一個資料表、 兩個資料行，與 10 個資料列。 新增十個資料列後, 兩個值會變更，並加入一個資料列。 使用建立的已變更的資料子集<xref:System.Data.DataSet.GetChanges%2A>方法。 之後，重新調整錯誤，子集資料合併至原始<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows"><see cref="T:System.Data.DataRow" /> 物件的陣列，將合併至 <see langword="DataSet" />。</param>
        <param name="preserveChanges">若要保留 <see langword="DataSet" /> 中的變更，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="missingSchemaAction">其中一個 <see cref="T:System.Data.MissingSchemaAction" /> 值。</param>
        <summary>將 <see cref="T:System.Data.DataRow" /> 物件的陣列合併到目前的 <see cref="T:System.Data.DataSet" /> 中，根據給定參數保留或忽略 <see langword="DataSet" /> 中的變更，並處理不相容的結構描述。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有<xref:System.Data.DataSet>。 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。  
  
 <xref:System.Data.DataSet.Merge%2A>結尾的一系列包含驗證變更、 錯誤，重新調整、 更新資料來源的變更，以及最後重新整理現有的程序通常會呼叫方法<xref:System.Data.DataSet>。  
  
 用戶端應用程式中，它會有單一按鈕，讓使用者可以按一下，收集變更的資料，並驗證它再將它傳送回中介層元件。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>第一次叫用方法。 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>並<xref:System.Data.DataRow>物件的已變更，導致原始的子集<xref:System.Data.DataSet>。 這個子集是通常較小，並因此更有效率地傳回給中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或它可以傳回的任何變更，已對它從資料來源子集。 （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。  
  
 為了方便說明<xref:System.Data.DataSet.Merge%2A>方法中，我們使用 「 目標 」 來表示目前<xref:System.Data.DataSet>，並以命名第二個 （參數） 的 「 來源 」 <xref:System.Data.DataSet>。 目標<xref:System.Data.DataSet>會如此命名是因為它是在其動作 （合併），就會發生的物件。 第二個<xref:System.Data.DataSet>稱為 「 來源 」，因為它所包含的資訊不會變更，但改為合併到目前<xref:System.Data.DataSet>。  
  
 當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已變更。 比方說，在企業對企業案例中，新的資料行可能有已加入 XML 結構描述由自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (新增<xref:System.Data.DataColumn>物件)，在目標中遺漏，結構描述項目可以藉由設定新增到目標`missingSchemaAction`引數`MissingSchemaAction.Add`。 在此情況下，合併<xref:System.Data.DataSet>包含加入的結構描述和資料。  
  
 合併的結構描述之後, 便會合併資料。  
  
 合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`與進行比對具有相同的主索引鍵值的目標資料列。 來源的資料列`DataRowState`的值`Added`就會對應到新的來源資料列的相同主索引鍵值的新目標資料列。  
  
 合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，和所有資料列，而不會標示為錯誤。 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet"><see langword="DataSet" />，其資料及結構描述將被合併。</param>
        <param name="preserveChanges">若要保留目前 <see langword="DataSet" /> 中的變更，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="missingSchemaAction">其中一個 <see cref="T:System.Data.MissingSchemaAction" /> 值。</param>
        <summary>將指定的 <see cref="T:System.Data.DataSet" /> 及其結構描述與目前的 <see langword="DataSet" /> 合併，根據給定參數保留或忽略目前 <see langword="DataSet" /> 中的變更，並處理不相容的結構描述。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有<xref:System.Data.DataSet>。 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。  
  
 <xref:System.Data.DataSet.Merge%2A>結尾的一系列包含驗證變更、 錯誤，重新調整、 更新資料來源的變更，以及最後重新整理現有的程序通常會呼叫方法<xref:System.Data.DataSet>。  
  
 用戶端應用程式中，它會有單一按鈕，讓使用者可以按一下，收集變更的資料，並驗證它再將它傳送回中介層元件。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>第一次叫用方法。 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>並<xref:System.Data.DataRow>物件的已變更，導致原始的子集<xref:System.Data.DataSet>。 這個子集是通常較小，並因此更有效率地傳回給中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或它可以傳回的任何變更，已對它從資料來源子集。 （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。  
  
 為了方便說明<xref:System.Data.DataSet.Merge%2A>方法中，我們使用 「 目標 」 來表示目前<xref:System.Data.DataSet>，並以命名第二個 （參數） 的 「 來源 」 <xref:System.Data.DataSet>。 目標<xref:System.Data.DataSet>會如此命名是因為它是在其動作 （合併），就會發生的物件。 第二個<xref:System.Data.DataSet>稱為 「 來源 」，因為它所包含的資訊不會變更，但改為合併到目前<xref:System.Data.DataSet>。  
  
 當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已變更。 比方說，在企業對企業案例中，新的資料行可能有已加入 XML 結構描述由自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (新增<xref:System.Data.DataColumn>物件)，在目標中遺漏，結構描述項目可以藉由設定新增到目標`missingSchemaAction`引數`MissingSchemaAction.Add`。 在此情況下，合併<xref:System.Data.DataSet>包含加入的結構描述和資料。  
  
 合併的結構描述之後, 便會合併資料。  
  
 合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`與進行比對具有相同的主索引鍵值的目標資料列。 來源的資料列`DataRowState`的值`Added`就會對應到新的來源資料列的相同主索引鍵值的新目標資料列。  
  
 合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，和所有資料列，而不會標示為錯誤。 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設`true`。  
  
   
  
## Examples  
 下列範例會建立簡單<xref:System.Data.DataSet>一個資料表、 兩個資料行，與 10 個資料列。 兩個值會變更，並加入一個資料列。 使用建立的已變更的資料子集<xref:System.Data.DataSet.GetChanges%2A>方法。 之後重新調整錯誤，變更結構描述的子集，加入新的資料行。 當<xref:System.Data.DataSet.Merge%2A>方法呼叫`missingSchemaAction`設為`MissingSchemaAction.Add`，新的資料行加入原始<xref:System.Data.DataSet>物件的結構描述。  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table"><see langword="DataTable" />，其資料及結構描述將被合併。</param>
        <param name="preserveChanges">其中一個 <see cref="T:System.Data.MissingSchemaAction" /> 值。</param>
        <param name="missingSchemaAction">若要保留 <see langword="DataSet" /> 中的變更，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>將指定的 <see cref="T:System.Data.DataTable" /> 及其結構描述合併到目前的 <see langword="DataSet" />，根據給定引數保留或忽略 <see langword="DataSet" /> 中的變更，並處理不相容的結構描述。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有<xref:System.Data.DataSet>。 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。  
  
 <xref:System.Data.DataSet.Merge%2A>結尾的一系列包含驗證變更、 錯誤，重新調整、 更新資料來源的變更，以及最後重新整理現有的程序通常會呼叫方法<xref:System.Data.DataSet>。  
  
 Middle 用戶端應用程式，它是具有單一按鈕，使用者可以按一下，收集變更的資料，並驗證它再將它傳送回中介層元件。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>第一次叫用方法。 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>並<xref:System.Data.DataRow>物件的已變更，導致原始的子集<xref:System.Data.DataSet>。 這個子集是通常較小，並因此更有效率地傳回給中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或它可以傳回的任何變更，已對它從資料來源子集。 （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。  
  
 當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已變更。 比方說，在企業對企業案例中，新的資料行可能有已加入 XML 結構描述由自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (新增<xref:System.Data.DataColumn>物件)，在目標中遺漏，結構描述項目可以藉由設定新增到目標`missingSchemaAction`引數`MissingSchemaAction.Add`。 在此情況下，合併<xref:System.Data.DataSet>包含加入的結構描述和資料。  
  
 合併的結構描述之後, 便會合併資料。  
  
 合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`與進行比對具有相同的主索引鍵值的目標資料列。 來源的資料列`DataRowState`的值`Added`就會對應到新的來源資料列的相同主索引鍵值的新目標資料列。  
  
 合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，和所有資料列，而不會標示為錯誤。 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設`true`。  
  
   
  
## Examples  
 下列範例會建立簡單<xref:System.Data.DataSet>一個資料表、 兩個資料行，與 10 個資料列。 第二個<xref:System.Data.DataTable>也就是建立幾乎完全相同的第一個不同之處在於新`DataColumn`加入至資料表。 兩個資料列會加入第二個資料表，然後合併到<xref:System.Data.DataSet>具有`preserveChanges`引數設定為`false`，而`missingSchemaAction`引數設定為`MissingSchemaAction.Add`。  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> 為 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetMergeFailedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當目標和來源 <see cref="T:System.Data.DataRow" /> 有相同的主索引鍵值，且 <see cref="P:System.Data.DataSet.EnforceConstraints" /> 設定為 True 時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需如何處理事件的詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Data.DataSet.MergeFailed>事件。  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Data.DataSet" /> 的命名空間。</summary>
        <value><see cref="T:System.Data.DataSet" /> 的命名空間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Namespace%2A>讀取和寫入 XML 文件時，會使用屬性<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>， <xref:System.Data.DataSet.WriteXml%2A>， <xref:System.Data.DataSet.ReadXmlSchema%2A>，或<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 文件的命名空間用來限定範圍的 XML 屬性和項目時讀取到<xref:System.Data.DataSet>。 例如，如果<xref:System.Data.DataSet>包含結構描述已讀取的文件與命名空間"myCompany，"和嘗試具有不同的命名空間的文件中只能讀取資料，任何未對應到現有的結構描述的資料會被忽略。  
  
   
  
## Examples  
 下列範例會設定<xref:System.Data.DataSet.Prefix%2A>再呼叫<xref:System.Data.DataSet.ReadXml%2A>方法。  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">命名空間已經有資料。</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent"><see cref="T:System.ComponentModel.PropertyChangedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引發事件會透過委派叫用此事件處理常式。 如需概觀，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當覆寫<see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />衍生類別時，請務必呼叫基底類別<see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />方法。</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">正在移除的 <see cref="T:System.Data.DataRelation" />。</param>
        <summary>發生於從 <see cref="T:System.Data.DataRelation" /> 移除 <see cref="T:System.Data.DataTable" /> 時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要限制資料表中移除的子類別應該覆寫此方法  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">正在移除的 <see cref="T:System.Data.DataTable" />。</param>
        <summary>發生於從 <see cref="T:System.Data.DataTable" /> 移除 <see cref="T:System.Data.DataSet" /> 時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 移除限制資料表的子類別可以覆寫此方法。  
  
   
  
## Examples  
 下列範例示範衍生自類別<xref:System.Data.DataSet>與<xref:System.Data.DataSet.OnRemoveTable%2A>覆寫的方法。  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetPrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定建立 <see cref="T:System.Data.DataSet" /> 命名空間別名的 XML 前置詞。</summary>
        <value><see cref="T:System.Data.DataSet" /> 命名空間的 XML 前置詞。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Prefix%2A>屬性來識別所屬的命名空間的項目時，可在整個 XML 文件<xref:System.Data.DataSet>物件 (由所設定<xref:System.Data.DataSet.Namespace%2A>屬性)。  
  
   
  
## Examples  
 下列範例會設定<xref:System.Data.DataSet.Prefix%2A>再呼叫<xref:System.Data.DataSet.ReadXml%2A>方法。  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">將要變更的屬性名稱。</param>
        <summary>傳送一個指定的 <see cref="T:System.Data.DataSet" /> 屬性即將變更的告知。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 XML 結構描述和資料讀入 <see cref="T:System.Data.DataSet" />。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">衍生自 <see cref="T:System.IO.Stream" /> 的物件。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" />，將 XML 結構描述和資料讀入 <see cref="T:System.IO.Stream" />。</summary>
        <returns><see cref="T:System.Data.XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述，如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 下列範例會先建立一個簡單<xref:System.Data.DataSet>與其中一個<xref:System.Data.DataTable>，兩個資料行，以及十個資料列。 <xref:System.Data.DataSet>結構描述和資料會寫入磁碟，然後叫用<xref:System.Data.DataSet.WriteXml%2A>方法。 第二個<xref:System.Data.DataSet>建立和<xref:System.Data.DataSet.ReadXml%2A>方法用來填入結構描述和資料。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">要從中讀取結構描述和資料的 <see langword="TextReader" />。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" />，將 XML 結構描述和資料讀入 <see cref="T:System.IO.TextReader" />。</summary>
        <returns><see cref="T:System.Data.XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 繼承自類別<xref:System.IO.TextReader>類別包含<xref:System.IO.StreamReader>和<xref:System.IO.StringReader>類別。  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 下列範例會先建立一個簡單<xref:System.Data.DataSet>與其中一個<xref:System.Data.DataTable>，兩個資料行，以及十個資料列。 <xref:System.Data.DataSet>結構描述和資料會寫入磁碟，然後叫用<xref:System.Data.DataSet.WriteXml%2A>方法。 第二個<xref:System.Data.DataSet>建立和<xref:System.Data.DataSet.ReadXml%2A>方法用來填入結構描述和資料。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要讀取的檔案名稱 (包括路徑)。</param>
        <summary>使用指定的檔案，將 XML 結構描述和資料讀入 <see cref="T:System.Data.DataSet" />。</summary>
        <returns><see langword="XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 下列範例會先建立一個簡單<xref:System.Data.DataSet>與其中一個<xref:System.Data.DataTable>，兩個資料行，以及十個資料列。 <xref:System.Data.DataSet>結構描述和資料會寫入磁碟，然後叫用<xref:System.Data.DataSet.WriteXml%2A>方法。 第二個<xref:System.Data.DataSet>建立和<xref:System.Data.DataSet.ReadXml%2A>方法用來填入結構描述和資料。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> 並不是設定為 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">要讀取的來源 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" />，將 XML 結構描述和資料讀入 <see cref="T:System.Xml.XmlReader" />。</summary>
        <returns><see langword="XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> 繼承自 <xref:System.Xml.XmlReader>。  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 下列範例會先建立一個簡單<xref:System.Data.DataSet>與其中一個<xref:System.Data.DataTable>，兩個資料行，以及十個資料列。 <xref:System.Data.DataSet>結構描述和資料會寫入磁碟，然後叫用<xref:System.Data.DataSet.WriteXml%2A>方法。 第二個<xref:System.Data.DataSet>建立和<xref:System.Data.DataSet.ReadXml%2A>方法用來填入結構描述和資料。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">要讀取的來源 <see cref="T:System.IO.Stream" />。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlReadMode" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.IO.Stream" />，將 XML 結構描述和資料讀入 <see cref="T:System.Data.XmlReadMode" />。</summary>
        <returns><see langword="XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  當您使用<xref:System.Data.DataSet.ReadXml%2A>和您設定<xref:System.Data.XmlReadMode>要`Diffgram`，內容的目標`DataSet`，原始`DataSet`可能因為 diffgram 是產生和處理方式不同。 如需有關 diffgram 的詳細資訊，請參閱 < [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md)。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">要讀取的來源 <see cref="T:System.IO.TextReader" />。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlReadMode" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.IO.TextReader" />，將 XML 結構描述和資料讀入 <see cref="T:System.Data.XmlReadMode" />。</summary>
        <returns><see langword="XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">要讀取的檔案名稱 (包括路徑)。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlReadMode" /> 值。</param>
        <summary>使用指定的檔案和 <see cref="T:System.Data.DataSet" />，將 XML 結構描述和資料讀入 <see cref="T:System.Data.XmlReadMode" />。</summary>
        <returns><see langword="XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> 並不是設定為 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">要讀取的來源 <see cref="T:System.Xml.XmlReader" />。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlReadMode" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.Xml.XmlReader" />，將 XML 結構描述和資料讀入 <see cref="T:System.Data.XmlReadMode" />。</summary>
        <returns><see langword="XmlReadMode" />，用來讀取資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述讀入<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法會讀取結構描述。 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。 要寫入 XML 資料，或結構描述和資料`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定的內嵌結構描述，則內嵌結構描述用來擴充現有的關聯式結構載入資料前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。  
  
 如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法推斷透過延伸架構才能公開的所有資料，則會引發例外狀況。  
  
> [!NOTE]
>  `DataSet`不會將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法 XML 字元，例如 ("_") 中序列化的 XML 逸出。 `DataSet`本身只會在 XML 項目名稱中不合法的 XML 字元的逸出，因此只能取用相同。 在 XML 項目名稱的合法字元會逸出，當處理時忽略此元素。  
  
 如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`，可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>搭配包含非限定命名空間元素的 XML。 若要讀取未限定的項目，設定`elementFormDefault`等於"qualified"中的 XML 結構描述如下列範例所示。  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 XML 結構描述讀入 <see cref="T:System.Data.DataSet" />。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">要讀取的來源 <see cref="T:System.IO.Stream" />。</param>
        <summary>從指定的 <see cref="T:System.IO.Stream" />，將 XML 結構描述讀入 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法用來建立的結構描述<xref:System.Data.DataSet>。 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入 XML 文件中的結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
> [!NOTE]
>  如果 msdata:DataType 和 xs: type 類型不相符，可能會發生資料損毀。 將會擲不回任何例外狀況。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>通常會再叫用會叫用方法<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>。  
  
 衍生自類別<xref:System.IO.Stream>類別包含<xref:System.IO.BufferedStream>， <xref:System.IO.FileStream>， <xref:System.IO.MemoryStream>，和<xref:System.Net.Sockets.NetworkStream>。  
  
> [!NOTE]
>  如果結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXmlSchema%2A>。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileStream>物件來讀取 XML 結構描述，並叫用<xref:System.Data.DataSet.ReadXmlSchema%2A>與物件的方法。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">要讀取的來源 <see cref="T:System.IO.TextReader" />。</param>
        <summary>從指定的 <see cref="T:System.IO.TextReader" />，將 XML 結構描述讀入 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法用來建立的結構描述<xref:System.Data.DataSet>。 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入 XML 文件中的結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
> [!NOTE]
>  如果 msdata:DataType 和 xs: type 類型不相符，可能會發生資料損毀。 將會擲不回任何例外狀況。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>通常會再叫用會叫用方法<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>。  
  
 繼承自類別<xref:System.IO.TextReader>類別包含<xref:System.IO.StreamReader>和<xref:System.IO.StringReader>類別。  
  
> [!NOTE]
>  如果結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXmlSchema%2A>。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.StreamReader>物件來讀取結構描述，並叫用<xref:System.Data.DataSet.ReadXmlSchema%2A>與物件的方法。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要讀取的來源檔案名稱 (包括路徑)。</param>
        <summary>從指定的檔案，將 XML 結構描述讀入 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法用來建立的結構描述<xref:System.Data.DataSet>。 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入 XML 文件中的結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
> [!NOTE]
>  如果 msdata:DataType 和 xs: type 類型不相符，可能會發生資料損毀。 將會擲不回任何例外狀況。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>通常會再叫用會叫用方法<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>。  
  
> [!NOTE]
>  如果的結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXmlSchema%2A>。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> 並不是設定為 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">要讀取的來源 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>從指定的 <see cref="T:System.Xml.XmlReader" />，將 XML 結構描述讀入 <see cref="T:System.Data.DataSet" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法用來建立的結構描述<xref:System.Data.DataSet>。 結構描述包含資料表、 關聯和條件約束的定義。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
> [!NOTE]
>  如果 msdata:DataType 和 xs: type 類型不相符，可能會發生資料損毀。 將會擲不回任何例外狀況。  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A>通常會再叫用會叫用方法<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>。  
  
 <xref:System.Xml.XmlReader?displayProperty=nameWithType>類別是抽象的。 類別繼承自`XmlReader`是<xref:System.Xml.XmlTextReader?displayProperty=nameWithType>類別。  
  
> [!NOTE]
>  如果結構描述您<xref:System.Data.DataSet>包含項目名稱相同，但相同的命名空間中的不同類型的例外狀況時擲回您嘗試讀取結構描述讀入<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXmlSchema%2A>。 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。  
  
   
  
## Examples  
 下列範例會建立新<xref:System.Data.DataSet>和<xref:System.IO.FileStream?displayProperty=nameWithType>物件。 <xref:System.IO.FileStream>的檔案路徑和檔案名稱，建立的物件用來建立<xref:System.Xml.XmlTextReader?displayProperty=nameWithType>做為引數傳遞<xref:System.Data.DataSet.ReadXmlSchema%2A>方法。  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">指定的 XML 讀取器。</param>
        <summary>忽略屬性並傳回空白資料集。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>復原從建立 <see cref="T:System.Data.DataSet" /> 物件或前一次呼叫 <see cref="M:System.Data.DataSet.AcceptChanges" /> 以來，對該物件做的所有變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 叫用<xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType>來呼叫<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType>所有方法<xref:System.Data.DataTable>所包含的物件<xref:System.Data.DataSet>。  
  
 <xref:System.Data.DataRow> 所包含的物件<xref:System.Data.DataSet>可以每個都設為編輯模式叫用<xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType>方法。 叫用後<xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType>方法，可以拒絕的變更，藉由呼叫<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType>上<xref:System.Data.DataTable>要<xref:System.Data.DataRow>所屬的物件。  
  
 當<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType>呼叫方法，仍處於編輯模式的任何資料列會取消其編輯。 新的資料列被移除。 修改和刪除資料列回到其原始狀態 (`DataRowState.Unchanged`)。  
  
 AcceptChanges 和 RejectChanges 只適用於<xref:System.Data.DataRow>相關的變更 (亦即`Add`， `Remove`， `Delete`，和`Modify`)。 它們並不適用於結構描述或結構的變更。  
  
   
  
## Examples  
 下列範例示範衍生自<xref:System.Data.DataSet>類別。 <xref:System.Data.DataSet.RejectChanges%2A>事件從函式中呼叫。  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得關聯的集合，這些關聯會連結資料表，並允許從父資料表巡覽至子資料表。</summary>
        <value>包含 <see cref="T:System.Data.DataRelationCollection" /> 物件集合的 <see cref="T:System.Data.DataRelation" />。 如果沒有任何 <see cref="T:System.Data.DataRelation" /> 物件存在，則會傳回空的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會列印到所有的子資料表的資料行名稱<xref:System.Data.DataSet.Relations%2A>屬性。  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定遠端作業中使用之 <see cref="T:System.Data.SerializationFormat" /> 的 <see cref="T:System.Data.DataSet" />。</summary>
        <value><see cref="T:System.Data.SerializationFormat" /> 物件。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除所有資料表，並從 <see cref="T:System.Data.DataSet" /> 中移除所有關聯、外部條件約束和資料表。 子類別應該覆寫 <see cref="M:System.Data.DataSet.Reset" /> 以還原 <see cref="T:System.Data.DataSet" /> 到它的原始狀態。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Data.SchemaSerializationMode" /> 的 <see cref="T:System.Data.DataSet" />。</summary>
        <value><see cref="T:System.Data.SchemaSerializationMode" /> 的 <see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Data.DataSet>序列化其結構描述和執行個體的資料預設會在 Web 服務和遠端處理案例。 設定<xref:System.Data.DataSet.SchemaSerializationMode%2A>具型別的屬性`DataSet`到<xref:System.Data.SchemaSerializationMode.ExcludeSchema>會導致序列化裝載要排除的結構描述資訊。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 支援僅適用於具型別`DataSet`。 針對不具型別的`DataSet`這個屬性只能設定為<xref:System.Data.SchemaSerializationMode.IncludeSchema>。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 只應在其中具類型的基礎結構描述資訊的情況下`DataTables`，`DataRelations`和`Constraints`未遭修改。 如果修改已發生且完整的結構描述資訊應該序列化與<xref:System.Data.SchemaSerializationMode.IncludeSchema>。  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> 支援 2.0 版的.NET framework 或更新版本。  
  
 當<xref:System.Data.SchemaSerializationMode.ExcludeSchema>設定，只有最上層的層級執行階段屬性存在於上<xref:System.Data.DataSet>會序列化。 此外，它們會序列化才發生不同的預設值。 沒有任何`Tables`，`Relations`或`Constraints`會序列化。 包含序列化的執行階段屬性<xref:System.Data.DataSet.DataSetName%2A>， <xref:System.Data.DataSet.Namespace%2A>， <xref:System.Data.DataSet.Prefix%2A>， <xref:System.Data.DataSet.Locale%2A>， <xref:System.Data.DataSet.EnforceConstraints%2A>，和<xref:System.Data.DataSet.CaseSensitive%2A>。 這些屬性會序列化以確定會保留整體的執行階段資料的完整性。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得值，表示是否應該保存 <see cref="P:System.Data.DataSet.Relations" /> 屬性。</summary>
        <returns>如果屬性值已經從其預設值變更，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您通常使用這個方法，如果您要建立的設計工具<xref:System.Data.DataSet>，或建立您自己的控制項併入<xref:System.Data.DataSet>。  
  
   
  
## Examples  
 下列範例示範衍生自<xref:System.Data.DataSet>類別。 <xref:System.Data.DataSet.Reset%2A>和<xref:System.Data.DataSet.ShouldSerializeRelations%2A>方法會從叫用在衍生類別中的函式內。  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得值，表示是否應該保存 <see cref="P:System.Data.DataSet.Tables" /> 屬性。</summary>
        <returns>如果屬性值已經從其預設值變更，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您通常使用這個方法，您可能想要建立的設計工具時，才<xref:System.Data.DataSet>，或建立您自己的控制項併入<xref:System.Data.DataSet>。  
  
   
  
## Examples  
 下列範例示範衍生自<xref:System.Data.DataSet>類別。 <xref:System.Data.DataSet.ShouldSerializeTables%2A>衍生類別中的函式中呼叫方法。  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Data.DataSet" /> 的 <see cref="T:System.ComponentModel.ISite" />。</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> 的 <see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站台繫結<xref:System.ComponentModel.Component>至<xref:System.ComponentModel.Container>和啟用它們，之間的通訊，以及提供讓要管理其元件的容器。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IListSource.ContainsListCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />。</summary>
        <value>如需這個成員的說明，請參閱 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.DataSet> 執行個體轉換成 <xref:System.ComponentModel.IListSource> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IListSource.GetList</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.ComponentModel.IListSource.GetList" />。</summary>
        <returns>如需這個成員的說明，請參閱 <see cref="M:System.ComponentModel.IListSource.GetList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.DataSet> 執行個體轉換成 <xref:System.ComponentModel.IListSource> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">要以資料填入的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">這個序列化的目的端 (請參閱 <see cref="T:System.Runtime.Serialization.StreamingContext" />)。</param>
        <summary>以序列化 <see cref="T:System.Data.DataSet" /> 所需的資料，填入序列化資訊物件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />。</summary>
        <returns>如需這個成員的說明，請參閱 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.DataSet> 執行個體轉換成 <xref:System.Xml.Serialization.IXmlSerializable> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" />。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.DataSet> 執行個體轉換成 <xref:System.Xml.Serialization.IXmlSerializable> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Data.DataSet> 執行個體轉換成 <xref:System.Xml.Serialization.IXmlSerializable> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetTablesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得包含在 <see cref="T:System.Data.DataSet" /> 中的資料表的集合。</summary>
        <value><see cref="T:System.Data.DataTableCollection" />，這個 <see cref="T:System.Data.DataSet" /> 所包含的集合。 如果沒有任何 <see cref="T:System.Data.DataTable" /> 物件存在，則會傳回空的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要將資料表加入至集合中，使用<xref:System.Data.DataTableCollection.Add%2A>方法的<xref:System.Data.DataTableCollection>。 若要移除資料表，請使用<xref:System.Data.DataTableCollection.Remove%2A>方法。  
  
   
  
## Examples  
 下列範例會傳回<xref:System.Data.DataSet>物件的<xref:System.Data.DataTableCollection>，並列印每個資料表中的資料列與資料行。  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從 <see cref="T:System.Data.DataSet" /> 寫入 XML 資料，並選擇性寫入結構描述。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">用來寫入檔案的 <see cref="T:System.IO.Stream" /> 物件。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" />，寫入 <see cref="T:System.IO.Stream" /> 的目前資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileStream?displayProperty=nameWithType>物件。 物件會接著搭配<xref:System.Data.DataSet.WriteXml%2A>方法來寫入 XML 文件。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用來寫入的 <see cref="T:System.IO.TextWriter" /> 物件。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" />，寫入 <see cref="T:System.IO.TextWriter" /> 的目前資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要寫入的目的檔案名稱 (包括路徑)。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 的目前資料寫入指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> 並不是設定為 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">要用來寫入的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 的目前資料寫入指定的 <see cref="T:System.Xml.XmlWriter" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">用來寫入檔案的 <see cref="T:System.IO.Stream" /> 物件。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlWriteMode" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.IO.Stream" />，寫入 <see cref="T:System.Data.XmlWriteMode" /> 的目前資料，並選擇性寫入結構描述。 若要寫入結構描述，請設定 <paramref name="mode" /> 參數的值為 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，設定`mode`參數來`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">用來寫入文件的 <see cref="T:System.IO.TextWriter" /> 物件。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlWriteMode" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.IO.TextWriter" />，寫入 <see cref="T:System.Data.XmlWriteMode" /> 的目前資料，並選擇性寫入結構描述。 若要寫入結構描述，請設定 <paramref name="mode" /> 參數的值為 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，設定`mode`參數來`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 下列範例會先建立一個簡單<xref:System.Data.DataSet>與其中一個<xref:System.Data.DataTable>，兩個資料行，以及十個資料列。 <xref:System.Data.DataSet>結構描述和資料會寫入磁碟，然後叫用<xref:System.Data.DataSet.WriteXml%2A>方法。 第二個<xref:System.Data.DataSet>建立和<xref:System.Data.DataSet.ReadXml%2A>方法用來填入結構描述和資料。  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">要寫入的目的檔案名稱 (包括路徑)。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlWriteMode" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" />，寫入 <see cref="T:System.Data.XmlWriteMode" /> 的目前資料 (並選擇性寫入結構描述) 至指定的檔案。 若要寫入結構描述，請設定 <paramref name="mode" /> 參數的值為 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，設定`mode`參數來`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Data.DataSet.WriteXml%2A>方法來寫入 XML 文件。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> 並不是設定為 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">要用來寫入的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="mode">其中一個 <see cref="T:System.Data.XmlWriteMode" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Data.DataSet" /> 和 <see cref="T:System.Xml.XmlWriter" />，寫入 <see cref="T:System.Data.XmlWriteMode" /> 的目前資料，並選擇性寫入結構描述。 若要寫入結構描述，請設定 <paramref name="mode" /> 參數的值為 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml`方法來撰寫資料，或同時提供資料和結構描述<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會將寫入的結構描述。 若要寫入資料和結構描述，設定`mode`參數來`WriteSchema`。  
  
 請注意，這也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。 若要讀取 XML 資料，或結構描述和資料讀入`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的資料行型別將會擲回`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>並不會實作<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileStream?displayProperty=nameWithType>用來建立新的物件<xref:System.Xml.XmlTextWriter>。 <xref:System.Xml.XmlTextWriter>物件搭配<xref:System.Data.DataSet.WriteXml%2A>方法來寫入 XML 文件。  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>寫入 <see cref="T:System.Data.DataSet" /> 結構做為 XML 結構描述。</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">用來寫入檔案的 <see cref="T:System.IO.Stream" /> 物件。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構做為 XML 結構描述寫入指定的 <see cref="T:System.IO.Stream" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法來寫入的結構描述<xref:System.Data.DataSet>XML 文件。 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入 XML 文件中的結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
 若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。  
  
 衍生自類別<xref:System.IO.Stream>類別包含<xref:System.IO.BufferedStream>， <xref:System.IO.FileStream>， <xref:System.IO.MemoryStream>，和<xref:System.Net.Sockets.NetworkStream>。  
  
   
  
## Examples  
 下列範例會建立新<xref:System.IO.FileStream>傳遞給物件<xref:System.Data.DataSet.WriteXmlSchema%2A>寫入磁碟中的結構描述的方法。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用來寫入的 <see cref="T:System.IO.TextWriter" /> 物件。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構做為 XML 結構描述寫入指定的 <see cref="T:System.IO.TextWriter" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法來寫入的結構描述<xref:System.Data.DataSet>XML 文件。 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入 XML 文件中的結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
 若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。  
  
 類別衍生自<xref:System.IO.TextWriter?displayProperty=nameWithType>類別包含<xref:System.Web.HttpWriter?displayProperty=nameWithType>， <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>， <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>， <xref:System.IO.StreamWriter?displayProperty=nameWithType>，和<xref:System.IO.StringWriter?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Text.StringBuilder?displayProperty=nameWithType>的物件用來建立新<xref:System.IO.StringWriter?displayProperty=nameWithType>。 <xref:System.IO.StringWriter>傳遞至<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，並產生的字串會列印到主控台視窗。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要寫入的目的檔案名稱 (包括路徑)。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構做為 XML 結構描述寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法來寫入的結構描述<xref:System.Data.DataSet>XML 文件。 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入 XML 文件中的結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
 若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" /> 並不是設定為 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">要寫入的目標 <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構做為 XML 結構描述寫入 <see cref="T:System.Xml.XmlWriter" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法來寫入的結構描述<xref:System.Data.DataSet>XML 文件。 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入 XML 文件中的結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。  
  
 XML 結構描述是使用 XSD 標準來撰寫。  
  
 若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。  
  
 一個類別繼承自<xref:System.Xml.XmlWriter?displayProperty=nameWithType>類別是<xref:System.Xml.XmlTextWriter>類別。  
  
   
  
## Examples  
 下列範例會建立新<xref:System.IO.FileStream?displayProperty=nameWithType>物件使用指定的路徑。 <xref:System.IO.FileStream>物件用來建立<xref:System.Xml.XmlTextWriter>物件。 <xref:System.Data.DataSet.WriteXmlSchema%2A>再叫用方法<xref:System.Xml.XmlTextWriter>寫入磁碟中的結構描述的物件。  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">在 ADO.NET 中使用資料集</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">要寫入的目標 <see cref="T:System.IO.Stream" /> 物件。</param>
        <param name="multipleTargetConverter">用於將 <see cref="T:System.Type" /> 轉換成字串的委派。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構做為 XML 結構描述寫入指定的 <see cref="T:System.IO.Stream" /> 物件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">要寫入的目標 <see cref="T:System.IO.TextWriter" /> 物件。</param>
        <param name="multipleTargetConverter">用於將 <see cref="T:System.Type" /> 轉換成字串的委派。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構當做 XML 結構描述寫入至指定的 <see cref="T:System.IO.TextWriter" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">要寫入的檔案名稱。</param>
        <param name="multipleTargetConverter">用於將 <see cref="T:System.Type" /> 轉換成字串的委派。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構做為 XML 結構描述寫入檔案。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">要寫入的目標 <see cref="T:System.Xml.XmlWriter" /> 物件。</param>
        <param name="multipleTargetConverter">用於將 <see cref="T:System.Type" /> 轉換成字串的委派。</param>
        <summary>將 <see cref="T:System.Data.DataSet" /> 結構當做 XML 結構描述寫入至指定的 <see cref="T:System.Xml.XmlWriter" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>