<Type Name="InstancePersistenceContext" FullName="System.Runtime.DurableInstancing.InstancePersistenceContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="da9726ebb98607c42e4b0426b7992de2ce345954" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480282" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class InstancePersistenceContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit InstancePersistenceContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.DurableInstancing.InstancePersistenceContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class InstancePersistenceContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class InstancePersistenceContext sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>代表持續性命令執行時的執行狀態資訊。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個類別的執行個體會傳遞給持續性提供者實作的 TryCommand 方法。 持續性提供者會使用這個類別來檢查此執行個體的記憶體中檢視，以及指出外部存放區上可能會影響檢視或其他記憶體中內容之作業的結果。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AssociatedInstanceKey">
      <MemberSignature Language="C#" Value="public void AssociatedInstanceKey (Guid key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssociatedInstanceKey(valuetype System.Guid key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.AssociatedInstanceKey(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssociatedInstanceKey (key As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssociatedInstanceKey(Guid key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="key">已經相關聯之索引鍵的執行個體索引鍵識別碼。 不得為 Guid.Empty。</param>
        <summary>表示持續性提供者已經成功地將索引鍵與執行個體存放區中的目前執行個體產生關聯。 此索引鍵的識別碼會指定為參數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行個體索引鍵必須是無關聯的。 目前的執行個體控制代碼必須繫結至執行個體以及該執行個體的鎖定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginBindReclaimedLock">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginBindReclaimedLock (long instanceVersion, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginBindReclaimedLock(int64 instanceVersion, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BeginBindReclaimedLock(System.Int64,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginBindReclaimedLock (instanceVersion As Long, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginBindReclaimedLock(long instanceVersion, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">在執行個體上保留的鎖定版本，但如果持續性提供者沒有實作鎖定版本，則為零。</param>
        <param name="timeout">非同步作業的逾時期限。</param>
        <param name="callback">作業完成時要呼叫的方法。</param>
        <param name="state">與非同步作業相關聯的狀態資訊。</param>
        <summary>開始非同步作業，將執行個體上的現有鎖定繫結至目前執行個體控制代碼。 現有的鎖定版本會當做參數傳遞。</summary>
        <returns>非同步作業的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘗試取得鎖定時，持續性提供者可能會決定目前的執行個體已經鎖定在目前的存放區中。 如果其鎖定權杖符合目前控制代碼的鎖定權杖，則持續性提供者就可以透過檢查鎖定的版本並將它傳遞給 BeginBindReclaimedLock，嘗試回收鎖定。 在成功回收鎖定之前，持續性提供者不得對執行個體進行變更。 如果沒有其他控制代碼繫結至鎖定，則 BeginBindReclaimedLock 作業就會成功，而且目前的控制代碼會變成繫結至鎖定。 否則，BeginBindReclaimedLock 或 EndBindReclaimedLock 會擲回 InstanceHandleConflictException。 如果其他控制代碼的命令正在進行，在等候這些命令的結果來決定是否能夠回收鎖定時，此作業可能無法完成。  
  
 目前的執行個體控制代碼必須繫結至執行個體和鎖定擁有者。 此執行個體不得為完成。 與鎖定擁有者相關聯的鎖定權杖會用來識別鎖定的擁有者。  
  
 一旦鎖定繫結至控制代碼之後，它就會在控制代碼的存留期內維持繫結狀態。 此時，無法變更鎖定權杖或執行個體版本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginExecute">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginExecute (System.Runtime.DurableInstancing.InstancePersistenceCommand command, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginExecute(class System.Runtime.DurableInstancing.InstancePersistenceCommand command, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BeginExecute(System.Runtime.DurableInstancing.InstancePersistenceCommand,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginExecute (command As InstancePersistenceCommand, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginExecute(System::Runtime::DurableInstancing::InstancePersistenceCommand ^ command, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Runtime.DurableInstancing.InstancePersistenceCommand" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">要執行的持續性命令。</param>
        <param name="timeout">作業的逾時值。</param>
        <param name="callback">委派，這個委派會接收要求作業完成之非同步接收的通知。</param>
        <param name="state">狀態資訊。</param>
        <summary>開始以非同步方式執行持續性命令。</summary>
        <returns>非同步作業的狀態。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 持續性提供者可以使用這個方法，將子命令當做命令的一部分執行。 此子命令將使用 BeginTryCommand 來執行，與傳遞給 InstanceStore.BeginExecute 的命令很相似。 雖然命令可以巢狀化，不過一個命令一次只能執行一個子命令。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindAcquiredLock">
      <MemberSignature Language="C#" Value="public void BindAcquiredLock (long instanceVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindAcquiredLock(int64 instanceVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindAcquiredLock(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindAcquiredLock (instanceVersion As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindAcquiredLock(long instanceVersion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">在執行個體上取得的鎖定版本，但如果持續性提供者沒有實作鎖定版本，則為零。</param>
        <summary>將執行個體上新取得的鎖定繫結至目前執行個體控制代碼。 取得的鎖定版本會當做參數傳遞。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果持續性提供者會實作鎖定版本，每次在執行個體上取得鎖定時，外部存放區中的版本都必須遞增一。 第一次鎖定執行個體時，版本應該是 1。 每次取得鎖定都會讓先前的鎖定失效。 目前的執行個體控制代碼必須繫結至執行個體和鎖定擁有者。 此執行個體不得為完成。 與鎖定擁有者相關聯的鎖定權杖會用來識別鎖定的擁有者。  
  
 一旦鎖定繫結至控制代碼之後，它就會在控制代碼的存留期內維持繫結狀態。 此時，無法變更鎖定權杖或執行個體版本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindEvent">
      <MemberSignature Language="C#" Value="public void BindEvent (System.Runtime.DurableInstancing.InstancePersistenceEvent persistenceEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindEvent(class System.Runtime.DurableInstancing.InstancePersistenceEvent persistenceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindEvent(System.Runtime.DurableInstancing.InstancePersistenceEvent)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindEvent (persistenceEvent As InstancePersistenceEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindEvent(System::Runtime::DurableInstancing::InstancePersistenceEvent ^ persistenceEvent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistenceEvent" Type="System.Runtime.DurableInstancing.InstancePersistenceEvent" />
      </Parameters>
      <Docs>
        <param name="persistenceEvent">包含事件相關資訊的 <see cref="T:System.Runtime.DurableInstancing.InstancePersistenceEvent" /> 物件。</param>
        <summary>將 <see cref="T:System.Runtime.DurableInstancing.InstancePersistenceEvent" /> 繫結至執行個體控制代碼。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindInstance">
      <MemberSignature Language="C#" Value="public void BindInstance (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindInstance(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindInstance(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindInstance (instanceId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindInstance(Guid instanceId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">執行個體識別碼。 不得為 Guid.Empty。</param>
        <summary>將識別碼已指定為參數的執行個體繫結至目前的執行個體控制代碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一旦執行個體繫結至控制代碼之後，它就會在控制代碼的存留期內維持繫結狀態。 此時，其他執行個體就無法繫結程序至控制代碼。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindInstanceOwner">
      <MemberSignature Language="C#" Value="public void BindInstanceOwner (Guid instanceOwnerId, Guid lockToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindInstanceOwner(valuetype System.Guid instanceOwnerId, valuetype System.Guid lockToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindInstanceOwner(System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindInstanceOwner (instanceOwnerId As Guid, lockToken As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindInstanceOwner(Guid instanceOwnerId, Guid lockToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceOwnerId" Type="System.Guid" />
        <Parameter Name="lockToken" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceOwnerId">執行個體擁有者的識別碼。</param>
        <param name="lockToken">執行個體擁有者的鎖定權杖。 持續性提供者可能會選擇針對執行個體擁有者識別碼和擁有者的鎖定權杖使用相同的值。</param>
        <summary>將執行個體擁有者繫結至目前執行個體控制代碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一旦執行個體擁有者繫結至控制代碼之後，它就會在控制代碼的存留期內維持繫結狀態。 此時，其他執行個體擁有者就無法繫結程序至控制代碼。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindReclaimedLock">
      <MemberSignature Language="C#" Value="public void BindReclaimedLock (long instanceVersion, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BindReclaimedLock(int64 instanceVersion, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BindReclaimedLock(System.Int64,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BindReclaimedLock (instanceVersion As Long, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BindReclaimedLock(long instanceVersion, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">在執行個體上保留的鎖定版本，但如果持續性提供者沒有實作鎖定版本，則為零。</param>
        <param name="timeout">作業的逾時值。</param>
        <summary>將執行個體上的現有鎖定繫結至目前執行個體控制代碼。 現有的鎖定版本會當做參數傳遞。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘗試取得鎖定時，持續性提供者可能會決定目前的執行個體已經鎖定在目前的存放區中。 如果其鎖定權杖符合目前控制代碼的鎖定權杖，則持續性提供者就可以透過檢查鎖定的版本並將它傳遞給 BindReclaimedLock，嘗試回收鎖定。 在成功回收鎖定之前，持續性提供者不得對執行個體進行變更。 如果沒有其他控制代碼繫結程序至鎖定，則 BindReclaimedLock 就會成功，而且目前的控制代碼會變成繫結程序至鎖定。 否則，BindReclaimedLock 會擲回 InstanceHandleConflictException。 如果其他控制代碼的命令正在進行，BindReclaimedLock 可能會進入封鎖狀態而等候這些命令的結果，然後再決定是否能夠回收鎖定。  
  
 目前的執行個體控制代碼必須繫結至執行個體和鎖定擁有者。 此執行個體不得為完成。 與鎖定擁有者相關聯的鎖定權杖會用來識別鎖定的擁有者。  
  
 一旦鎖定繫結至控制代碼之後，它就會在控制代碼的存留期內維持繫結狀態。 此時，無法變更鎖定權杖或執行個體版本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedInstance">
      <MemberSignature Language="C#" Value="public void CompletedInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompletedInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.CompletedInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompletedInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompletedInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>表示持續性提供者已經成功地將執行個體存放區中的目前執行個體標示為完成。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體以及該執行個體的鎖定。 此執行個體必須進行初始化而且尚未完成  (如果執行個體資料集曾經保存到該執行個體，它就會進行初始化)。與該執行個體相關聯的所有索引鍵都必須完成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedInstanceKey">
      <MemberSignature Language="C#" Value="public void CompletedInstanceKey (Guid key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompletedInstanceKey(valuetype System.Guid key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.CompletedInstanceKey(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompletedInstanceKey (key As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompletedInstanceKey(Guid key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="key">已經完成之索引鍵的執行個體索引鍵識別碼。 不得為 Guid.Empty。</param>
        <summary>表示持續性提供者已經成功地將外部存放區中的索引鍵標示為完成。 此索引鍵的識別碼會指定為參數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體以及該執行個體的鎖定。 此執行個體索引鍵必須與目前的執行個體相關聯而且尚未完成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBindReclaimedLockException">
      <MemberSignature Language="C#" Value="public Exception CreateBindReclaimedLockException (long instanceVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception CreateBindReclaimedLockException(int64 instanceVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.CreateBindReclaimedLockException(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateBindReclaimedLockException (instanceVersion As Long) As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ CreateBindReclaimedLockException(long instanceVersion);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceVersion" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="instanceVersion">在執行個體上保留的鎖定版本，但如果持續性提供者沒有實作鎖定版本，則為零。</param>
        <summary>建立可從 TryCommand 擲回以觸發 BindReclaimedLock 行為之例外狀況的執行個體。</summary>
        <returns>例外狀況。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 範例程式碼：  
  
```  
  
protected override bool TryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout)  
{  
    throw context.CreateBindReclaimedLockException(5);  
}  
is equivalent to  
protected override bool TryCommand(InstancePersistenceContext context, InstancePersistenceCommand command, TimeSpan timeout)  
{  
    context.BindReclaimedLock(5, timeout);  
    throw new OperationCanceledException();  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBindReclaimedLock">
      <MemberSignature Language="C#" Value="public void EndBindReclaimedLock (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBindReclaimedLock(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.EndBindReclaimedLock(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBindReclaimedLock (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBindReclaimedLock(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">非同步作業的結果。</param>
        <summary>結束由 <see cref="M:System.Runtime.DurableInstancing.InstancePersistenceContext.BeginBindReclaimedLock(System.Int64,System.TimeSpan,System.AsyncCallback,System.Object)" /> 方法開始的非同步作業。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExecute">
      <MemberSignature Language="C#" Value="public void EndExecute (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndExecute(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.EndExecute(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndExecute (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndExecute(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">非同步作業的狀態。</param>
        <summary>結束非同步作業。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Runtime.DurableInstancing.InstancePersistenceCommand command, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Runtime.DurableInstancing.InstancePersistenceCommand command, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.Execute(System.Runtime.DurableInstancing.InstancePersistenceCommand,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (command As InstancePersistenceCommand, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Runtime::DurableInstancing::InstancePersistenceCommand ^ command, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Runtime.DurableInstancing.InstancePersistenceCommand" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="command">要執行的持續性命令。</param>
        <param name="timeout">作業的逾時值。</param>
        <summary>執行持續性命令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 持續性提供者可以使用這個方法，將子命令當做命令的一部分執行。 此子命令將使用 TryCommand 來執行，與傳遞給 InstanceStore.Execute 的命令很相似。 雖然命令可以巢狀化，不過一個命令一次只能執行一個子命令。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceHandle">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceHandle InstanceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceHandle InstanceHandle" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceHandle As InstanceHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceHandle ^ InstanceHandle { System::Runtime::DurableInstancing::InstanceHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行個體控制代碼。</summary>
        <value>目前執行個體控制代碼。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceVersion">
      <MemberSignature Language="C#" Value="public long InstanceVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 InstanceVersion" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long InstanceVersion { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行個體控制代碼保留在目前執行個體上的鎖定版本。</summary>
        <value>繫結至目前執行個體控制代碼的執行個體鎖定版本，但如果控制代碼沒有繫結至鎖定，則為 -1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用繫結至鎖定的控制代碼來執行需要鎖定的作業 (例如保存執行個體資料) 時，持續性提供者應該針對保留在執行個體存放區中之執行個體上的鎖定版本檢查此值。 如果鎖定版本不符，此命令應該會由於 InstanceLockLostException 而失敗。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceView">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceView InstanceView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceView InstanceView" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.InstanceView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceView As InstanceView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceView ^ InstanceView { System::Runtime::DurableInstancing::InstanceView ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得執行個體檢視物件，這個物件代表目前執行個體的記憶體中狀態。 當進行中的命令進行更新時，這個檢視就會反映更新。</summary>
        <value>執行個體檢視物件。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedInstance">
      <MemberSignature Language="C#" Value="public void LoadedInstance (System.Runtime.DurableInstancing.InstanceState state, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; instanceData, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; instanceMetadata, System.Collections.Generic.IDictionary&lt;Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt; associatedInstanceKeyMetadata, System.Collections.Generic.IDictionary&lt;Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt; completedInstanceKeyMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadedInstance(valuetype System.Runtime.DurableInstancing.InstanceState state, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; instanceData, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; instanceMetadata, class System.Collections.Generic.IDictionary`2&lt;valuetype System.Guid, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt;&gt; associatedInstanceKeyMetadata, class System.Collections.Generic.IDictionary`2&lt;valuetype System.Guid, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt;&gt; completedInstanceKeyMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.LoadedInstance(System.Runtime.DurableInstancing.InstanceState,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Collections.Generic.IDictionary{System.Guid,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue}},System.Collections.Generic.IDictionary{System.Guid,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadedInstance (state As InstanceState, instanceData As IDictionary(Of XName, InstanceValue), instanceMetadata As IDictionary(Of XName, InstanceValue), associatedInstanceKeyMetadata As IDictionary(Of Guid, IDictionary(Of XName, InstanceValue)), completedInstanceKeyMetadata As IDictionary(Of Guid, IDictionary(Of XName, InstanceValue)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadedInstance(System::Runtime::DurableInstancing::InstanceState state, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ instanceData, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ instanceMetadata, System::Collections::Generic::IDictionary&lt;Guid, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^&gt; ^ associatedInstanceKeyMetadata, System::Collections::Generic::IDictionary&lt;Guid, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^&gt; ^ completedInstanceKeyMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Runtime.DurableInstancing.InstanceState" />
        <Parameter Name="instanceData" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="instanceMetadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="associatedInstanceKeyMetadata" Type="System.Collections.Generic.IDictionary&lt;System.Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt;" />
        <Parameter Name="completedInstanceKeyMetadata" Type="System.Collections.Generic.IDictionary&lt;System.Guid,System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="state">執行個體狀態資訊。</param>
        <param name="instanceData">做為 <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件之字典的執行個體資料。</param>
        <param name="instanceMetadata">做為 <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件之集合的執行個體中繼資料。</param>
        <param name="associatedInstanceKeyMetadata">做為執行個體識別項和執行個體索引鍵中繼資料之字典的相關聯執行個體索引鍵中繼資料，該中繼資料是 <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件的字典。</param>
        <param name="completedInstanceKeyMetadata">做為執行個體識別碼和執行個體索引鍵中繼資料之字典的已完成執行個體中繼資料，這個中繼資料是 <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件的字典。</param>
        <summary>表示持續性提供者已經成功地從執行個體存放區中擷取目前的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體。 如果此執行個體控制代碼繫結程序至鎖定或已載入的執行個體標示為完成，已載入的資料就會被視為一致的，否則這項資料就會被視為不確定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LockToken">
      <MemberSignature Language="C#" Value="public Guid LockToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid LockToken" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.LockToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LockToken As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid LockToken { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得繫結至目前執行個體控制代碼之執行個體擁有者的鎖定權杖。</summary>
        <value>繫結至目前執行個體控制代碼的鎖定權杖，但如果控制代碼沒有繫結至執行個體擁有者，則為 Guid.Empty。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用繫結至鎖定的控制代碼來執行需要鎖定的作業 (例如保存執行個體資料) 時，持續性提供者應該針對保留在執行個體存放區中之執行個體上的鎖定權杖檢查此值。 如果鎖定權杖不符，此命令應該會由於 InstanceLockLostException 而失敗。  
  
 取得執行個體的新鎖定 (例如使用尚未繫結至鎖定的控制代碼來保存執行個體資料) 時，持續性提供者應該使用這個值當做鎖定權杖。 如果執行個體已經在執行個體存放區中鎖定，而且其鎖定權杖符合這個鎖定權杖，持續性提供者就可以嘗試使用 BindReclaimedLock 來回收執行個體。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistedInstance">
      <MemberSignature Language="C#" Value="public void PersistedInstance (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PersistedInstance(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.PersistedInstance(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue})" />
      <MemberSignature Language="VB.NET" Value="Public Sub PersistedInstance (data As IDictionary(Of XName, InstanceValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PersistedInstance(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
      </Parameters>
      <Docs>
        <param name="data">做為 <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件之字典的執行個體資料。</param>
        <summary>表示持續性提供者已經成功地將執行個體資料集保存到執行個體存放區。 如果執行個體尚未初始化，這就具有初始化執行個體的作用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體以及該執行個體的鎖定。 每個執行個體資料集都會完全取代先前的資料集。 執行個體資料集可能為 null，也就是空白。 保存 null 的執行個體資料集會刪除現有的執行個體資料集  (保存執行個體資料集完全不會影響執行個體中繼資料)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueriedInstanceStore">
      <MemberSignature Language="C#" Value="public void QueriedInstanceStore (System.Runtime.DurableInstancing.InstanceStoreQueryResult queryResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void QueriedInstanceStore(class System.Runtime.DurableInstancing.InstanceStoreQueryResult queryResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.QueriedInstanceStore(System.Runtime.DurableInstancing.InstanceStoreQueryResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub QueriedInstanceStore (queryResult As InstanceStoreQueryResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void QueriedInstanceStore(System::Runtime::DurableInstancing::InstanceStoreQueryResult ^ queryResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queryResult" Type="System.Runtime.DurableInstancing.InstanceStoreQueryResult" />
      </Parameters>
      <Docs>
        <param name="queryResult">針對執行個體存放區執行查詢的結果。</param>
        <summary>將傳遞做為參數的 <see cref="T:System.Runtime.DurableInstancing.InstanceStoreQueryResult" /> 加入至 <see cref="T:System.Runtime.DurableInstancing.InstanceStoreQueryResult" /> 中 <see cref="T:System.Runtime.DurableInstancing.InstanceView" /> 物件的清單。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadInstanceKeyMetadata">
      <MemberSignature Language="C#" Value="public void ReadInstanceKeyMetadata (Guid key, System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadInstanceKeyMetadata(valuetype System.Guid key, class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.ReadInstanceKeyMetadata(System.Guid,System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadInstanceKeyMetadata (key As Guid, metadata As IDictionary(Of XName, InstanceValue), complete As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadInstanceKeyMetadata(Guid key, System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ metadata, bool complete);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="complete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="key">已讀取其中繼資料之索引鍵的執行個體索引鍵識別碼。 不得為 Guid.Empty。</param>
        <param name="metadata">做為 <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件之字典的中繼資料。</param>
        <param name="complete">
          如果此中繼資料代表與執行個體索引鍵相關聯的所有中繼資料，則為 <see langword="True" />，否則為 <see langword="false" />。</param>
        <summary>表示持續性提供者已經成功地針對與執行個體存放區中目前執行個體相關聯的索引鍵，讀取某些執行個體索引鍵中繼資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體。 如果此執行個體控制代碼繫結程序至鎖定或目前的執行個體標示為完成，此中繼資料就會被視為一致的，否則這項資料就會被視為不確定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadInstanceMetadata">
      <MemberSignature Language="C#" Value="public void ReadInstanceMetadata (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadInstanceMetadata(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.ReadInstanceMetadata(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadInstanceMetadata (metadata As IDictionary(Of XName, InstanceValue), complete As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadInstanceMetadata(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ metadata, bool complete);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="complete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadata">做為 <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件之字典的中繼資料。</param>
        <param name="complete">
          如果此中繼資料代表與執行個體相關聯的所有中繼資料，則為 <see langword="True" />，否則為 <see langword="false" />。</param>
        <summary>表示持續性提供者已經成功地針對執行個體存放區中的目前執行個體，讀取某些執行個體中繼資料。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadInstanceOwnerMetadata">
      <MemberSignature Language="C#" Value="public void ReadInstanceOwnerMetadata (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadInstanceOwnerMetadata(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, class System.Runtime.DurableInstancing.InstanceValue&gt; metadata, bool complete) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.ReadInstanceOwnerMetadata(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadInstanceOwnerMetadata (metadata As IDictionary(Of XName, InstanceValue), complete As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadInstanceOwnerMetadata(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Runtime::DurableInstancing::InstanceValue ^&gt; ^ metadata, bool complete);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue&gt;" />
        <Parameter Name="complete" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadata">
          <see cref="T:System.Xml.Linq.XName" /> 和 <see cref="T:System.Runtime.DurableInstancing.InstanceValue" /> 物件的字典。</param>
        <param name="complete">指定是否設定一致性為 <see cref="F:System.Runtime.DurableInstancing.InstanceValueConsistency.InDoubt" /> 或 <see cref="F:System.Runtime.DurableInstancing.InstanceValueConsistency.Partial" /> 的值。</param>
        <summary>使用在參數內傳遞的資料，設定執行個體擁有者中繼資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體。 如果此執行個體控制代碼繫結程序至鎖定或目前的執行個體標示為完成，此中繼資料就會被視為一致的，否則這項資料就會被視為不確定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCancellationHandler">
      <MemberSignature Language="C#" Value="public void SetCancellationHandler (Action&lt;System.Runtime.DurableInstancing.InstancePersistenceContext&gt; cancellationHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCancellationHandler(class System.Action`1&lt;class System.Runtime.DurableInstancing.InstancePersistenceContext&gt; cancellationHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.SetCancellationHandler(System.Action{System.Runtime.DurableInstancing.InstancePersistenceContext})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCancellationHandler (cancellationHandler As Action(Of InstancePersistenceContext))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCancellationHandler(Action&lt;System::Runtime::DurableInstancing::InstancePersistenceContext ^&gt; ^ cancellationHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationHandler" Type="System.Action&lt;System.Runtime.DurableInstancing.InstancePersistenceContext&gt;" />
      </Parameters>
      <Docs>
        <param name="cancellationHandler">要呼叫之函式的參考。</param>
        <summary>設定要求取消作業時要呼叫的取消處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果呼叫了取消處理常式，持續性提供者就應該取消所有暫止的作業，並且從 TryCommand 擲回 OperationCanceledException，表示持續性命令在完成之前已經被中斷。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnassociatedInstanceKey">
      <MemberSignature Language="C#" Value="public void UnassociatedInstanceKey (Guid key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnassociatedInstanceKey(valuetype System.Guid key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.UnassociatedInstanceKey(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnassociatedInstanceKey (key As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnassociatedInstanceKey(Guid key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="key">已經解除關聯之索引鍵的執行個體索引鍵識別碼。 不得為 Guid.Empty。</param>
        <summary>表示持續性提供者已經成功地將索引鍵與執行個體存放區中的目前執行個體解除關聯。 此索引鍵的識別碼會指定為參數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體以及該執行個體的鎖定。 此執行個體索引鍵必須與目前的執行個體相關聯而且標示為完成。 目前的執行個體不得標示為完成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserContext">
      <MemberSignature Language="C#" Value="public object UserContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object UserContext" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.DurableInstancing.InstancePersistenceContext.UserContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ UserContext { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得附加至目前執行個體控制代碼的使用者內容資訊。</summary>
        <value>使用者內容資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此物件是從目前執行個體控制代碼之 InstanceStore.OnNewInstanceHandle 傳回的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WroteInstanceKeyMetadataValue">
      <MemberSignature Language="C#" Value="public void WroteInstanceKeyMetadataValue (Guid key, System.Xml.Linq.XName name, System.Runtime.DurableInstancing.InstanceValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WroteInstanceKeyMetadataValue(valuetype System.Guid key, class System.Xml.Linq.XName name, class System.Runtime.DurableInstancing.InstanceValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.WroteInstanceKeyMetadataValue(System.Guid,System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WroteInstanceKeyMetadataValue (key As Guid, name As XName, value As InstanceValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WroteInstanceKeyMetadataValue(Guid key, System::Xml::Linq::XName ^ name, System::Runtime::DurableInstancing::InstanceValue ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Guid" />
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Runtime.DurableInstancing.InstanceValue" />
      </Parameters>
      <Docs>
        <param name="key">索引鍵的執行個體索引鍵識別碼。 不得為 Guid.Empty。</param>
        <param name="name">中繼資料屬性的名稱。</param>
        <param name="value">中繼資料屬性的值。</param>
        <summary>表示持續性提供者已經成功地將與目前執行個體相關聯之執行個體索引鍵的中繼資料值寫入執行個體存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體以及該執行個體的鎖定。 此執行個體索引鍵必須與目前的執行個體相關聯而且不得為完成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WroteInstanceMetadataValue">
      <MemberSignature Language="C#" Value="public void WroteInstanceMetadataValue (System.Xml.Linq.XName name, System.Runtime.DurableInstancing.InstanceValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WroteInstanceMetadataValue(class System.Xml.Linq.XName name, class System.Runtime.DurableInstancing.InstanceValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.WroteInstanceMetadataValue(System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WroteInstanceMetadataValue (name As XName, value As InstanceValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WroteInstanceMetadataValue(System::Xml::Linq::XName ^ name, System::Runtime::DurableInstancing::InstanceValue ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Runtime.DurableInstancing.InstanceValue" />
      </Parameters>
      <Docs>
        <param name="name">中繼資料屬性的名稱。</param>
        <param name="value">中繼資料屬性的值。</param>
        <summary>表示持續性提供者已經成功地將目前執行個體的中繼資料值寫入外部執行個體存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體以及具有該執行個體的鎖定。 此執行個體不得為完成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WroteInstanceOwnerMetadataValue">
      <MemberSignature Language="C#" Value="public void WroteInstanceOwnerMetadataValue (System.Xml.Linq.XName name, System.Runtime.DurableInstancing.InstanceValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WroteInstanceOwnerMetadataValue(class System.Xml.Linq.XName name, class System.Runtime.DurableInstancing.InstanceValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.DurableInstancing.InstancePersistenceContext.WroteInstanceOwnerMetadataValue(System.Xml.Linq.XName,System.Runtime.DurableInstancing.InstanceValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WroteInstanceOwnerMetadataValue (name As XName, value As InstanceValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WroteInstanceOwnerMetadataValue(System::Xml::Linq::XName ^ name, System::Runtime::DurableInstancing::InstanceValue ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.DurableInstancing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Runtime.DurableInstancing.InstanceValue" />
      </Parameters>
      <Docs>
        <param name="name">中繼資料屬性的名稱。</param>
        <param name="value">中繼資料屬性的值。</param>
        <summary>表示持續性提供者已經成功地將目前執行個體擁有者的中繼資料值寫入執行個體存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前的執行個體控制代碼必須繫結至執行個體擁有者。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>