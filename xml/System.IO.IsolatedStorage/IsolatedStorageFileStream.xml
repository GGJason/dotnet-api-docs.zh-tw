<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8b5c74ce52efd9404fe42f44754ae999bbefd8fe" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52742154" /></Metadata><TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class IsolatedStorageFileStream&#xA;Inherits FileStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFileStream : System::IO::FileStream" />
  <TypeSignature Language="F#" Value="type IsolatedStorageFileStream = class&#xA;    inherit FileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>公開隔離儲存區內的檔案。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個類別來讀取、 寫入和建立隔離儲存區中的檔案。  
  
 由於此類別會擴充<xref:System.IO.FileStream>，您可以使用的執行個體<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>在大部分情況下所在<xref:System.IO.FileStream>否則可能會使用，例如建構<xref:System.IO.StreamReader>或<xref:System.IO.StreamWriter>。  
  
 此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
> [!IMPORTANT]
>  [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式無法使用隔離儲存區。 請改用 `Windows.Storage` 應用程式開發介面內含的 [!INCLUDE[wrt](~/includes/wrt-md.md)] 命名空間中的應用程式資料類別來儲存本機資料和檔案。 如需詳細資訊，請參閱 Windows 開發人員中心的 [應用程式資料](https://go.microsoft.com/fwlink/?LinkId=229175) 。  
  
   
  
## Examples  
 下列主控台應用程式，示範如何使用<xref:System.IO.IsolatedStorage.IsolatedStorageFile>和<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>將資料寫入至隔離儲存區檔案。 您可以要求使用者登入。 如果使用者是新的使用者，會記錄新聞 URL 和運動 URL 做為隔離儲存區中的個人喜好設定。 如果使用者是傳回的使用者，則會顯示使用者的目前設定。 在這個命名空間所使用的程式碼範例會在此範例應用程式的內容。 您可以使用[Storeadm.exe （隔離儲存區工具）](~/docs/framework/tools/storeadm-exe-isolated-storage-tool.md)公用程式來列出並移除這個主控台應用程式建立的隔離儲存區檔案。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#1)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體。 開啟 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 的唯一方法是使用它的一個建構函式進行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的新執行個體，這個執行個體可以存取在指定的 <paramref name="mode" /> 中 <paramref name="path" /> 所指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隔離儲存區所使用的範圍是由目前執行組件的識別，以及正在執行之應用程式定義域。 此存放區只會針對的存留期會維持開啟<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。 若要指定不同的隔離儲存區範圍，或允許保持開啟狀態存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從中開啟)，使用可接受的建構函式的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。  
  
 `mode`參數會指出是否應該建立新的檔案、 使用現有的等等。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，可能會無法解譯字元，並可能會導致擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> 中的目錄不存在。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設為 <see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> 值的位元組合。</param>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體，這個執行個體可使用所要求的 <paramref name="access" /> 類型，以指定的 <paramref name="mode" /> 存取 <paramref name="path" /> 所指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隔離儲存區所使用的範圍是由目前執行組件的識別，以及正在執行之應用程式定義域。 此存放區只會針對的存留期會維持開啟<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。 若要指定不同的隔離儲存區範圍，或允許保持開啟狀態存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從中開啟)，使用可接受的建構函式的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。  
  
 `mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設定為 <see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <param name="isf"><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />，要在其中開啟 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />。</param>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體，這個執行個體可以在 <paramref name="isf" /> 所指定之 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> 的內容中，用指定的 <paramref name="mode" />，存取 <paramref name="path" /> 所指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode`參數會指出是否應該建立新的檔案、 使用現有的等等。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個建構函式。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設定為 <see cref="F:System.IO.FileMode.Open" /></exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"><paramref name="isf" /> 沒有配額。</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> 值的位元組合。</param>
        <param name="share"><see cref="T:System.IO.FileShare" /> 值的位元組合。</param>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體，這個執行個體可以使用 <paramref name="share" /> 所指定的檔案共用模式，以指定的檔案 <paramref name="access" /> 和指定的 <paramref name="mode" />，存取以 <paramref name="path" /> 指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隔離儲存區所使用的範圍是由目前執行組件的識別，以及正在執行之應用程式定義域。 此存放區只會針對的存留期會維持開啟<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。 若要指定不同的隔離儲存區範圍，或允許保持開啟狀態存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從中開啟)，使用可接受的建構函式的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，可能會無法解譯字元，並可能會導致擲回例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個建構函式。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設定為 <see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> 值的位元組合。</param>
        <param name="isf"><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />，要在其中開啟 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />。</param>
        <summary>在 <paramref name="isf" /> 所指定的 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> 之內容中初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體，這個執行個體可以用指定的 <paramref name="mode" />，使用指定的檔案 <paramref name="access" /> 存取以 <paramref name="path" /> 所指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個建構函式。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">隔離儲存區已關閉。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設定為 <see cref="F:System.IO.FileMode.Open" />。</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"><paramref name="isf" /> 沒有配額。</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> 值的位元組合。</param>
        <param name="share"><see cref="T:System.IO.FileShare" /> 值的位元組合。</param>
        <param name="bufferSize"><see cref="T:System.IO.FileStream" /> 緩衝區大小。</param>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體，這個執行個體可以在指定的 <paramref name="mode" /> 下，存取以 <paramref name="path" /> 所指定的檔案，方式則是使用指定的檔案 <paramref name="access" />、使用 <paramref name="share" /> 所指定的檔案共用模式，以及指定的 <paramref name="buffersize" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 隔離儲存區所使用的範圍是由目前執行組件的識別，以及正在執行之應用程式定義域。 此存放區只會針對的存留期會維持開啟<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。 若要指定不同的隔離儲存區範圍，或允許保持開啟狀態存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從中開啟)，使用可接受的建構函式的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。  
  
 `mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設定為 <see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> 值的位元組合。</param>
        <param name="share"><see cref="T:System.IO.FileShare" /> 值的位元組合。</param>
        <param name="isf"><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />，要在其中開啟 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />。</param>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體，這個執行個體可以在 <paramref name="isf" /> 所指定之 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> 的內容中，用指定的 <paramref name="mode" />，存取以 <paramref name="path" /> 所指定的檔案，方式則是使用指定的檔案 <paramref name="access" />，以及使用 <paramref name="share" /> 所指定的檔案共用模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個建構函式。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設定為 <see cref="F:System.IO.FileMode.Open" /></exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"><paramref name="isf" /> 沒有配額。</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, bufferSize, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">隔離儲存區中的檔案的相對路徑。</param>
        <param name="mode">其中一個 <see cref="T:System.IO.FileMode" /> 值。</param>
        <param name="access"><see cref="T:System.IO.FileAccess" /> 值的位元組合。</param>
        <param name="share"><see cref="T:System.IO.FileShare" /> 值的位元組合。</param>
        <param name="bufferSize"><see cref="T:System.IO.FileStream" /> 緩衝區大小。</param>
        <param name="isf"><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />，要在其中開啟 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />。</param>
        <summary>初始化 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 類別的新執行個體，這個執行個體可以在 <paramref name="isf" /> 所指定之 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> 的內容中，用指定的 <paramref name="mode" />，存取以 <paramref name="path" /> 所指定的檔案，方式則是使用指定的檔案 <paramref name="access" />、使用 <paramref name="share" /> 所指定的檔案共用模式，以及使用指定的 <paramref name="buffersize" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用這個建構函式。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#12)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#12)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 格式不正確。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到任何檔案，且 <paramref name="mode" /> 設定為 <see cref="F:System.IO.FileMode.Open" /></exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"><paramref name="isf" /> 沒有配額。</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">隔離儲存區存取</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="isolatedStorageFileStream.BeginRead (buffer, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">要讀取資料的緩衝區。</param>
        <param name="offset">在 <paramref name="buffer" /> 中要開始讀取的位元組位移。</param>
        <param name="numBytes">要讀取的最大位元組數。</param>
        <param name="userCallback">在完成非同步讀取作業時呼叫的方法。 這是選擇性參數。</param>
        <param name="stateObject">非同步讀取的狀態。</param>
        <summary>開始非同步讀取。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 物件，表示可能還在暫止中的非同步讀取。 這個 <see cref="T:System.IAsyncResult" /> 必須傳遞給這個資料流的 <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" /> 方法，以判斷有多少位元組被讀取。 若要做到這點，可以使用與呼叫 <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 相同的程式碼，或者在傳遞至 <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 的回呼中做到。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您發出非同步的讀取或寫入 I/O 作業完成時，不，會更新資料流中目前的位置。  
  
 您必須呼叫<xref:System.IO.Stream.EndRead%2A>以此方式<xref:System.IAsyncResult>找出多少位元組被讀取。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">在超過檔案結尾處嘗試了非同步讀取。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="isolatedStorageFileStream.BeginWrite (buffer, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">寫入資料的緩衝區。</param>
        <param name="offset"><paramref name="buffer" /> 中的位元組位移，即開始寫入的位置。</param>
        <param name="numBytes">寫入的最大位元組數。</param>
        <param name="userCallback">在完成非同步寫入作業時呼叫的方法。 這是選擇性參數。</param>
        <param name="stateObject">非同步寫入的狀態。</param>
        <summary>開始非同步寫入。</summary>
        <returns><see cref="T:System.IAsyncResult" />，表示可能還在暫止中的非同步寫入。 這個 <see cref="T:System.IAsyncResult" /> 必須傳遞給資料流的 <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" /> 方法，以確保寫入完成，然後適當地釋放資源。 若要做到這點，可以使用與呼叫 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 相同的程式碼，或者在傳遞至 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 的回呼中做到。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件是可寫入，在資料流結尾寫入展開的資料流。  
  
 當您發出非同步的讀取或寫入 I/O 作業完成時，不，會更新資料流中目前的位置。  
  
 您必須呼叫<xref:System.IO.Stream.EndWrite%2A>與<xref:System.IAsyncResult>物件，這個方法會傳回以找出多少個位元組所撰寫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">在超過檔案結尾處嘗試了非同步寫入。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得布林值，指出是否可讀取檔案。</summary>
        <value>如果可讀取 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性來判斷是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>可以讀取物件。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead%2A>屬性，以查看是否可讀取資料流呼叫之前，先檢查<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>或<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>方法。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得布林值，指出是否支援搜尋作業。</summary>
        <value>如果 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件支援搜尋作業，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性來判斷是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件支援搜尋作業。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得布林值，指出您是否可以寫入檔案。</summary>
        <value>如果可以寫入 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性來判斷是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件只能被寫入。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite%2A>屬性，以查看是否可讀取資料流呼叫之前，先檢查<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A>或<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>方法。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#13)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#13)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="isolatedStorageFileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放與 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件建立關聯的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

任何資料之前寫入緩衝區之前複製到檔案的檔案資料流已關閉，如此就不需要呼叫<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A>叫用關閉之前。

下列呼叫關閉時，檔案資料流上的任何作業可能會引發例外狀況。 之後`Close`已呼叫一次，它不執行任何動作如果再次呼叫。 <xref:System.Object.Finalize>方法在讓檔案資料流已關閉記憶體回收行程結束物件之前，會叫用關閉。

<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 物件需要<xref:System.IO.IsolatedStorage.IsolatedStorageFile>決定存取之檔案的儲存體內容物件。 開啟未傳遞之資料流<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件時，預設值<xref:System.IO.IsolatedStorage.IsolatedStorageFile>是正在執行的組件建立物件，並將其關閉在呼叫期間後關閉。

> [!NOTE]
> `Close`方法呼叫<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A>，並將處置設定為 true，以釋放其資源，然後呼叫<xref:System.GC.SuppressFinalize%2A>隱藏最終化，這個物件的記憶體回收行程。

## Examples

下列程式碼範例示範的 Close 方法。

```csharp
IsolatedStorageFileStream source =
     new IsolatedStorageFileStream(this.userName,FileMode.Open,isoFile);
 // This stream is the one that data will be read from
 Console.WriteLine("Source can be read?" + (source.CanRead?"true":"false"));
 IsolatedStorageFileStream target =
     new IsolatedStorageFileStream("Archive\\ " + this.userName,FileMode.OpenOrCreate,isoFile);
 // This stream is the one that data will be written to
 Console.WriteLine("Target is writable?" + (target.CanWrite?"true":"false"));
 // Do work...
 // After you have read and written to the streams, close them
 source.Close();
 target.Close();
```

```vb
Dim source As New IsolatedStorageFileStream(UserName,FileMode.Open,isoFile)
 ' This stream is the one that data will be read from
 If source.CanRead Then
     Console.WriteLine("Source can read ? true")
 Else
     Console.WriteLine("Source can read ? false")
 End If
 Dim target As New IsolatedStorageFileStream("Archive\\ " & UserName, _
                                             FileMode.OpenOrCreate, _
                                             isoFile)
 ' This stream is the one that data will be written to
 If target.CanWrite Then
     Console.WriteLine("Target is writable? true")
 Else
     Console.WriteLine("Target is writable? false")
 End If
 ' After you have read and written to the streams, close them
 source.Close()
 target.Close()
```

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="isolatedStorageFileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />，表示釋放 Managed 和 Unmanaged 資源，<see langword="false" />，表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用<xref:System.IDisposable.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.IDisposable.Dispose%2A> 叫用受保護<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A>方法使用`disposing`參數設為 true。 <xref:System.Object.Finalize%2A> 叫用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A>與`disposing`設為 false。  
  
 當`disposing`參數為 true 時，這個方法由任何 managed 物件持有的資源全部釋出這個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>參考。 這個方法會叫用每個參考物件的 <xref:System.IDisposable.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IDisposable.Dispose" /> 可以被其他物件呼叫多次。 覆寫 <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" /> 時，請小心不要參考到先前已在對 <see cref="M:System.IDisposable.Dispose" /> 的早期呼叫中被處置 (Dispose) 的物件。 如需有關如何實作<see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />，請參閱 &lt;&lt;c2&gt; [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
如需詳細資訊<see cref="M:System.IDisposable.Dispose" />並<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="isolatedStorageFileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">暫止的非同步要求。</param>
        <summary>結束擱置的非同步讀取要求。</summary>
        <returns>自資料流讀取的位元組數，在零和您所要求的位元組數目之間。 資料流只會在資料流的結尾處傳回零。 否則，它們會阻擋，直到至少有一個位元組為止。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> 必須正好一次上呼叫每個<xref:System.IAsyncResult>物件從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>，然後呼叫<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A>是唯一的辦法知道多少位元組被讀取從<xref:System.IO.Stream>。 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> 將會封鎖直到 I/O 作業完成為止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="isolatedStorageFileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">要結束的暫止的非同步 I/O 要求。</param>
        <summary>結束非同步寫入。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>。  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> 將會封鎖直到 I/O 作業完成為止。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="isolatedStorageFileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因為緩衝區可用來讀取或寫入，但是兩者不能同時<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A>執行兩個函式。 首先，任何之前寫入緩衝區的資料複製到檔案，並清除緩衝區。 第二個，如果<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>是`true`資料先前已從檔案複製到讀取的緩衝區，檔案中目前的位置也會減少在緩衝區中未讀取的位元組數目。 然後清除緩衝區。  
  
 使用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29>方法多載時您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="isolatedStorageFileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><see langword="true" /> 表示排清所有中繼檔案緩衝區；否則為 <see langword="false" />。</param>
        <summary>清除此資料流的緩衝區，讓所有緩衝資料全部寫入檔案，同時也清除所有的中繼檔案緩衝區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle - once available")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use IsolatedStorageFileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件封裝之檔案的檔案控制代碼。 在 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件上並不允許存取這個屬性，否則會擲回 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageException" />。</summary>
        <value>目前 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件封裝之檔案的檔案控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱<xref:System.IO.FileStream.Handle%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle%2A>屬性。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#4)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#4)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"><see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" /> 屬性一律會產生這個例外狀況。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供存取 unmanaged 程式碼的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得布林值，指出 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件是以非同步或同步方式開啟。</summary>
        <value>如果 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件支援非同步存取，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>無法建立物件不同的是<xref:System.IO.FileStream>。 不過， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>，和<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A>具有一些效能的負面影響的同步執行個體上支援的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync%2A>屬性，以確認<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>是同步的。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的長度。</summary>
        <value><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的長度，以位元組為單位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> 表示目前檔案中的位元組數目。 它不會受到隔離儲存區配額。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A>屬性。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="override this.Lock : int64 * int64 -&gt; unit" Usage="isolatedStorageFileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">要鎖定之範圍的開始位置。 這個參數的值必須等於或大於 0 (零)。</param>
        <param name="length">要鎖定的位元組數目。</param>
        <summary>防止其他處理程序讀取或寫入資料流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鎖定某個範圍的檔案資料流可讓該範圍的檔案資料流的鎖定處理程序的獨佔存取權的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> 或 <paramref name="length" /> 為負。</exception>
        <exception cref="T:System.ObjectDisposedException">檔案已關閉。</exception>
        <exception cref="T:System.IO.IOException">處理序無法存取檔案，因為其他處理序鎖定了該檔案的一部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件目前的位置。</summary>
        <value>這個 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的目前位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性的運作方式的時機<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>屬性是`true`。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position%2A>將資料寫入檔案的屬性。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">不能將位置設定為負數。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="isolatedStorageFileStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要讀取的緩衝區。</param>
        <param name="offset">開始寫入緩衝區的位移。</param>
        <param name="count">要讀取的最大位元組數。</param>
        <summary>將位元組從目前緩衝的 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件複製到陣列。</summary>
        <returns>讀取到 <paramref name="buffer" /> 中的位元組總數。 如果目前無法提供那麼多的位元組數目，則這個數目可能小於所要求的位元組數，或如果已經到達資料流結尾，則為零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `buffer`參數可以是執行個體<xref:System.Buffer>類別或其中一個下列類型的陣列： <xref:System.Byte>， <xref:System.SByte>， <xref:System.Char>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.UInt16>， <xref:System.UInt32><xref:System.UInt64>， <xref:System.Single>，或<xref:System.Double>。 `offset`參數提供的位元組位移處開始寫入 （索引緩衝區中），緩衝區中和`count`參數會提供將會從此資料流讀取的位元組數目上限。 如果已到達資料流結尾，傳回的值會是位元組讀取，則為零的實際數目。 讀取的作業成功時，讀取的位元組數目進階資料流的目前位置。 如果發生例外狀況，資料流的目前位置不變。  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>方法視為`buffer`做為區塊的位元組，不論其實際型別參數。 同樣地，`offset`和`count`參數一律會以位元組為單位指定。 針對`buffer`這位元組陣列以外的參數，表示項目索引必須先乘以項目大小，以位元組為單位來形成的正確值`offset`或`count`。  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>方法會傳回零，只有當資料流結尾為止。 在其他情況下，<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>一律從資料流讀取至少一個位元組，再傳回。 如果沒有資料可從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件時呼叫<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>，此方法將會封鎖直到至少一個位元組的資料可以傳回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="isolatedStorageFileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從隔離儲存區中 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件讀取一個位元組。</summary>
        <returns>從隔離儲存區檔案讀取的 8 位元不帶正負號的整數值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte%2A>方法可用來讀取資料，從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 物件，這個物件代表目前的 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件封裝之檔案的作業系統檔案控制代碼。</summary>
        <value><see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 物件，這個物件代表目前的 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件封裝的檔案之作業系統檔案控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle%2A>屬性不支援，而且一律會產生<xref:System.IO.IsolatedStorage.IsolatedStorageException>例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"><see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" /> 屬性一律會產生這個例外狀況。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供存取 unmanaged 程式碼的能力。 相關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="isolatedStorageFileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的新位置。</param>
        <param name="origin">其中一個 <see cref="T:System.IO.SeekOrigin" /> 值。</param>
        <summary>將這個 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的目前位置設定為指定的值。</summary>
        <returns><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件中的新位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件支援定位超過資料流的長度，其他人將會在此情況下擲回例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="origin" /> 必須是 <see cref="T:System.IO.SeekOrigin" /> 值其中之一。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="isolatedStorageFileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的新長度。</param>
        <summary>將這個 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的長度設定為指定的 <paramref name="value" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定`value`目前的長度小於<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件、 資料流遭截斷。 如果指定`value`大於目前的長度資料流，擴充的資料流。 如果資料流已展開，舊和新的長度之間的資料流的內容為未定義。 若要使用這種方法，<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件必須支援寫入和搜尋。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> 為負數。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="override this.Unlock : int64 * int64 -&gt; unit" Usage="isolatedStorageFileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">要取消鎖定之範圍的開始位置。 這個參數的值必須等於或大於 0 (零)。</param>
        <param name="length">要解除鎖定的位元組數目。</param>
        <summary>允許其他處理程序存取先前鎖定之檔案的全部或一部分。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> 或 <paramref name="length" /> 為負。</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="isolatedStorageFileStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要寫入的緩衝區。</param>
        <param name="offset">要從其起始的緩衝區位元組位移。</param>
        <param name="count">寫入的最大位元組數。</param>
        <summary>使用讀取自位元組陣列的資料，將位元組區塊寫入 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `offset`參數會提供中的位元組位移`buffer`要開始讀取，而`count`參數會提供這將寫入的位元組數目<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。 如果寫入作業成功時，目前位置<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件會前移寫入的位元組數目。 如果發生例外狀況，目前位置<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件不會變更。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">寫入嘗試超過 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的配額。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="isolatedStorageFileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要寫入隔離儲存區檔案的位元組值。</param>
        <summary>將單一位元組寫入 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte%2A>方法可用來讀取資料，從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。 此範例的完整內容，請參閱<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>概觀。  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">寫入嘗試超過 <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> 物件的配額。</exception>
      </Docs>
    </Member>
  </Members>
</Type>