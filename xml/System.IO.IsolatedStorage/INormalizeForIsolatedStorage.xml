<Type Name="INormalizeForIsolatedStorage" FullName="System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="abeda777d7c6a428f5ca16088dd5287f7de36087" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39957728" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INormalizeForIsolatedStorage" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" />
  <TypeSignature Language="VB.NET" Value="Public Interface INormalizeForIsolatedStorage" />
  <TypeSignature Language="C++ CLI" Value="public interface class INormalizeForIsolatedStorage" />
  <TypeSignature Language="F#" Value="type INormalizeForIsolatedStorage = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="4aa5f-101">啟用隔離存放區、應用程式定義域和組件 (Assembly) 辨識項之間的比較。</span>
      <span class="sxs-lookup">
        <span data-stu-id="4aa5f-101">Enables comparisons between an isolated store and an application domain and assembly's evidence.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aa5f-102">隔離儲存區會使用以識別它，並提供它唯一的檔案儲存位置的組件的相關辨識項。</span><span class="sxs-lookup"><span data-stu-id="4aa5f-102">Isolated storage uses evidence about an assembly in order to identify it and provide it with a unique file storage location.</span></span> <span data-ttu-id="4aa5f-103">當組件要求的存放區時，它的辨識項 （如主講的主控件在載入） 處理，而且相較於用來建立現有的存放區的辨識項。</span><span class="sxs-lookup"><span data-stu-id="4aa5f-103">When an assembly requests a store, its evidence (as presented by the host that loaded it) is processed and compared with the evidence used to create the existing stores.</span></span> <span data-ttu-id="4aa5f-104">這會決定如果您需要建立新的存放區，或如果已經存在有問題之組件。</span><span class="sxs-lookup"><span data-stu-id="4aa5f-104">This determines if you need to create a new store or if one already exists for the assembly in question.</span></span> <span data-ttu-id="4aa5f-105">所使用的比較 」 技巧，因為的辨識項的功能相同的片段可能會導致一個 true 比較如果序列化的表單並不相同。</span><span class="sxs-lookup"><span data-stu-id="4aa5f-105">Due to the comparison technique used, pieces of evidence that are functionally equivalent might not result in a true comparison if the serialized forms are not identical.</span></span> <span data-ttu-id="4aa5f-106">在實作自訂的辨識項，請考慮是否這是您的辨識項類別的情況，如果是這樣，實作<xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage>。</span><span class="sxs-lookup"><span data-stu-id="4aa5f-106">When implementing custom evidence, consider whether this is the case for your evidence class and, if so, implement <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage>.</span></span> <span data-ttu-id="4aa5f-107">實作此介面的證據<xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A>方法呼叫和比較依據該方法所傳回之物件的正常化複本。</span><span class="sxs-lookup"><span data-stu-id="4aa5f-107">For evidence that implements this interface, the <xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A> method is called and comparisons are based on the normalized copy of the object returned by that method.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="4aa5f-108">
        <para>當您實作自訂的辨識項，而且需要以判斷是否為存放區已經存在，請實作這個介面。序列化的物件不應該用於在某些情況下，例如，區分大小寫的字串比較。比方說，www.MSN.com 等於 WWW.msn.com，而且會傳回<see langword="true" />相比。若要建立<see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" />物件，您需要實作<see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" />方法。</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="4aa5f-108">
          <para>Implement this interface when you are implementing custom evidence and need to determine if a store already exists. Serialized objects should not be used for comparisons in some instances, such as that of case sensitive strings. For example, www.MSN.com is equal to WWW.msn.com and will return a <see langword="true" /> when compared. To create an <see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /> object, you need to implement the <see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /> method.</para>
        </span>
      </span>
    </block>
    <block subset="none" type="usage">
      <span data-ttu-id="4aa5f-109">
        <para>呼叫這個介面來標準化的執行個體，才能進行比較的組件辨識項與目前現有之間隔離存放區的方法。</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="4aa5f-109">
          <para>Call the methods of this interface to normalize the instance before making comparisons between an assembly's evidence and currently existing isolated stores.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public object Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Normalize();" />
      <MemberSignature Language="F#" Value="abstract member Normalize : unit -&gt; obj" Usage="iNormalizeForIsolatedStorage.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4aa5f-110">當在衍生類別中被覆寫時，傳回呼叫物件的正常化複本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4aa5f-110">When overridden in a derived class, returns a normalized copy of the object on which it is called.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4aa5f-111">正常化物件，表示呼叫這個方法所在的執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4aa5f-111">A normalized object that represents the instance on which this method was called.</span>
          </span>
          <span data-ttu-id="4aa5f-112">這個執行個體可以是字串、資料流或任何可序列化的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4aa5f-112">This instance can be a string, stream, or any serializable object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="4aa5f-113">
            <para>時覆寫這個方法所傳回的物件是資料流，它會假設為可序列化，並會直接與用來建立現有的存放區的辨識項的序列化形式相比較。如果傳回的物件是字串，就會被視為隔離存放區的名稱，而相較於現有的存放區名稱。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="4aa5f-113">
              <para>When you override this method and the object returned is a stream, it is assumed to be serialized and is compared directly to the serialized form of the evidence used to create existing stores. If the object returned is a string, it is considered the name of an isolated store and compared to the names of the existing stores.</para>
            </span>
          </span>
        </block>
        <block subset="none" type="usage">
          <span data-ttu-id="4aa5f-114">
            <para>如果您正在撰寫衍生自隔離儲存區的類別，而且您需要檢查是否隔離儲存區已存在目前組件中，通常會呼叫這個方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="4aa5f-114">
              <para>You typically call this method if you are writing a class derived from isolated storage and you need to check to see if isolated storage already exists for the current assembly.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>