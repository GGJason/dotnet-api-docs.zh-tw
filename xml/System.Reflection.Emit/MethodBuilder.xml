<Type Name="MethodBuilder" FullName="System.Reflection.Emit.MethodBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c93c1a358d5c177a5835b41cbeaeae252a6af730" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit MethodBuilder extends System.Reflection.MethodInfo implements class System.Runtime.InteropServices._MethodBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.MethodBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodBuilder&#xA;Inherits MethodInfo&#xA;Implements _MethodBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBuilder sealed : System::Reflection::MethodInfo, System::Runtime::InteropServices::_MethodBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="8b46b-101">定義及表示動態類別上的方法 (或建構函式)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="8b46b-101">Defines and represents a method (or constructor) on a dynamic class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-102"><xref:System.Reflection.Emit.MethodBuilder>類別用來完整描述 Microsoft intermediate language (MSIL)，包括名稱、 屬性、 簽章和方法主體的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-102">The <xref:System.Reflection.Emit.MethodBuilder> class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body.</span></span> <span data-ttu-id="8b46b-103">它用於搭配<xref:System.Reflection.Emit.TypeBuilder>類別以建立在執行階段類別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-103">It is used in conjunction with the <xref:System.Reflection.Emit.TypeBuilder> class to create classes at runtime.</span></span>  
  
## <a name="global-methods-and-methods-as-type-members"></a><span data-ttu-id="8b46b-104">通用的方法和類型成員的方法</span><span class="sxs-lookup"><span data-stu-id="8b46b-104">Global methods and methods as type members</span></span>  
 <span data-ttu-id="8b46b-105">您可以使用反映發出定義全域方法，以及定義為型別成員的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-105">You can use reflection emit to define global methods and to define methods as type members.</span></span> <span data-ttu-id="8b46b-106">定義方法的 Api 傳回<xref:System.Reflection.Emit.MethodBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="8b46b-106">The APIs that define methods return <xref:System.Reflection.Emit.MethodBuilder> objects.</span></span>  
  
### <a name="global-methods"></a><span data-ttu-id="8b46b-107">全域方法</span><span class="sxs-lookup"><span data-stu-id="8b46b-107">Global methods</span></span>  
 <span data-ttu-id="8b46b-108">使用定義的全域方法<xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType>方法，這個方法會傳回**MethodBuilder**物件。</span><span class="sxs-lookup"><span data-stu-id="8b46b-108">A global method is defined by using the <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A?displayProperty=nameWithType> method, which returns a **MethodBuilder** object.</span></span>  
  
 <span data-ttu-id="8b46b-109">全域方法必須為靜態。</span><span class="sxs-lookup"><span data-stu-id="8b46b-109">Global methods must be static.</span></span> <span data-ttu-id="8b46b-110">如果動態模組包含全域方法，<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType>保存的動態模組或包含的動態組件，因為 common language runtime 延後修復的動態模組，直到所有的全域函式之前，必須呼叫方法尚未定義。</span><span class="sxs-lookup"><span data-stu-id="8b46b-110">If a dynamic module contains global methods, the <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A?displayProperty=nameWithType> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.</span></span>  
  
 <span data-ttu-id="8b46b-111">定義通用的原生方法使用<xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-111">A global native method is defined by using the <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8b46b-112">平台叫用 (PInvoke) 抽象或虛擬方法不能宣告。</span><span class="sxs-lookup"><span data-stu-id="8b46b-112">Platform invoke (PInvoke) methods must not be declared abstract or virtual.</span></span> <span data-ttu-id="8b46b-113">執行階段集<xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType>屬性平台叫用方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-113">The runtime sets the <xref:System.Reflection.MethodAttributes.PinvokeImpl?displayProperty=nameWithType> attribute for a platform invoke method.</span></span>  
  
### <a name="methods-as-members-of-types"></a><span data-ttu-id="8b46b-114">方法的型別成員</span><span class="sxs-lookup"><span data-stu-id="8b46b-114">Methods as members of types</span></span>  
 <span data-ttu-id="8b46b-115">方法定義為型別成員使用<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType>方法，這個方法會傳回<xref:System.Reflection.Emit.MethodBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="8b46b-115">A method is defined as a type member by using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.MethodBuilder> object.</span></span>  
  
 <span data-ttu-id="8b46b-116"><xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A>方法用來設定參數，或傳回值的名稱和參數的屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-116">The <xref:System.Reflection.Emit.MethodBuilder.DefineParameter%2A> method is used to set the name and parameter attributes of a parameter, or of the return value.</span></span> <span data-ttu-id="8b46b-117"><xref:System.Reflection.Emit.ParameterBuilder>的參數或傳回值，代表這個方法所傳回的物件。</span><span class="sxs-lookup"><span data-stu-id="8b46b-117">The <xref:System.Reflection.Emit.ParameterBuilder> object returned by this method represents a parameter or the return value.</span></span> <span data-ttu-id="8b46b-118"><xref:System.Reflection.Emit.ParameterBuilder>物件可以用於封送處理的設定、 設定常數的值，並套用自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-118">The <xref:System.Reflection.Emit.ParameterBuilder> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="8b46b-119">屬性</span><span class="sxs-lookup"><span data-stu-id="8b46b-119">Attributes</span></span>  
 <span data-ttu-id="8b46b-120">成員<xref:System.Reflection.MethodAttributes>列舉型別定義的動態方法的精確字元：</span><span class="sxs-lookup"><span data-stu-id="8b46b-120">Members of the <xref:System.Reflection.MethodAttributes> enumeration define the precise character of a dynamic method:</span></span>  
  
-   <span data-ttu-id="8b46b-121">使用指定的靜態方法<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-121">Static methods are specified using the <xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="8b46b-122">最後兩個方法 （不能覆寫的方法） 會使用指定<xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-122">Final methods (methods that cannot be overridden) are specified using the <xref:System.Reflection.MethodAttributes.Final?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="8b46b-123">使用指定的虛擬方法<xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-123">Virtual methods are specified using the <xref:System.Reflection.MethodAttributes.Virtual?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="8b46b-124">使用指定抽象方法<xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-124">Abstract methods are specified using the <xref:System.Reflection.MethodAttributes.Abstract?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="8b46b-125">有數個屬性會決定方法的可視性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-125">Several attributes determine method visibility.</span></span> <span data-ttu-id="8b46b-126">請參閱描述<xref:System.Reflection.MethodAttributes>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-126">See the description of the <xref:System.Reflection.MethodAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="8b46b-127">實作多載的運算子之方法必須設定<xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-127">Methods that implement overloaded operators must set the <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="8b46b-128">完成項必須設定<xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-128">Finalizers must set the <xref:System.Reflection.MethodAttributes.SpecialName?displayProperty=nameWithType> attribute.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="8b46b-129">已知問題</span><span class="sxs-lookup"><span data-stu-id="8b46b-129">Known Issues</span></span>  
  
-   <span data-ttu-id="8b46b-130">雖然<xref:System.Reflection.Emit.MethodBuilder>衍生自<xref:System.Reflection.MethodInfo>，部分中所定義的抽象方法<xref:System.Reflection.MethodInfo>類別並未完整實作中<xref:System.Reflection.Emit.MethodBuilder>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-130">Although <xref:System.Reflection.Emit.MethodBuilder> is derived from <xref:System.Reflection.MethodInfo>, some of the abstract methods defined in the <xref:System.Reflection.MethodInfo> class are not fully implemented in <xref:System.Reflection.Emit.MethodBuilder>.</span></span> <span data-ttu-id="8b46b-131">這些<xref:System.Reflection.Emit.MethodBuilder>方法會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-131">These <xref:System.Reflection.Emit.MethodBuilder> methods throw the <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="8b46b-132">例如<xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType>未完全實作的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-132">For example the <xref:System.Reflection.Emit.MethodBuilder.Invoke%2A?displayProperty=nameWithType> method is not fully implemented.</span></span> <span data-ttu-id="8b46b-133">您可以藉由擷取封入類型使用這些方法上反映<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-133">You can reflect on these methods by retrieving the enclosing type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> methods.</span></span>  
  
-   <span data-ttu-id="8b46b-134">從.NET Framework 2.0 版支援的自訂修飾詞。</span><span class="sxs-lookup"><span data-stu-id="8b46b-134">Custom modifiers are supported starting with the .NET Framework version 2.0.</span></span> <span data-ttu-id="8b46b-135">它們不支援在舊版本。</span><span class="sxs-lookup"><span data-stu-id="8b46b-135">They are not supported in earlier versions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-136">下列範例會使用<xref:System.Reflection.Emit.MethodBuilder>類別來建立動態類型中的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-136">The following example uses the <xref:System.Reflection.Emit.MethodBuilder> class to create a method within a dynamic type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">
          <span data-ttu-id="8b46b-137">要採取的安全性動作 (要求、判斷提示等)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-137">The security action to be taken (Demand, Assert, and so on).</span>
          </span>
        </param>
        <param name="pset">
          <span data-ttu-id="8b46b-138">此動作適用的權限集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-138">The set of permissions the action applies to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-139">加入這個方法的宣告式安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-139">Adds declarative security to this method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-140"><xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> 也可以呼叫多次，每次呼叫指定的安全性動作 (例如`Demand`， `Assert`，和`Deny`) 和一組要套用動作的權限。</span><span class="sxs-lookup"><span data-stu-id="8b46b-140"><xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> can be called several times, with each call specifying a security action (such as `Demand`, `Assert`, and `Deny`) and a set of permissions that the action applies to.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b46b-141">在.NET framework 1.0、 1.1 和 2.0 中，使用套用至方法的宣告式安全性屬性<xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A>方法會儲存在舊的 XML 中繼資料格式。</span><span class="sxs-lookup"><span data-stu-id="8b46b-141">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the <xref:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity%2A> method are stored in the old XML metadata format.</span></span> <span data-ttu-id="8b46b-142">請參閱發出宣告式安全性屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-142">See Emitting Declarative Security Attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-143">下列程式碼範例說明的內容使用`AddDeclarativeSecurity`要求的方法呼叫端具有不受限制的權限。</span><span class="sxs-lookup"><span data-stu-id="8b46b-143">The code sample below illustrates the contextual use of `AddDeclarativeSecurity` to require the caller of a method to have unrestricted permissions.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b46b-144">
            <paramref name="action" /> 無效 (<see langword="RequestMinimum" />、<see langword="RequestOptional" /> 和 <see langword="RequestRefuse" /> 無效)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-144">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-145">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-145">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="8b46b-146">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-146">-or-</span>
          </span>
          <span data-ttu-id="8b46b-147">權限集 <paramref name="pset" /> 包含稍早 <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" /> 所加入的動作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-147">The permission set <paramref name="pset" /> contains an action that was added earlier by <see cref="M:System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />.</span>
          </span>
          <span data-ttu-id="8b46b-148">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-148">-or-</span>
          </span>
          <span data-ttu-id="8b46b-149">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-149">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b46b-150">
            <paramref name="pset" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-150">
              <paramref name="pset" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-151">擷取此方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-151">Retrieves the attributes for this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-152">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-152">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-153">擷取此方法的 <see langword="MethodAttributes" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-153">Retrieves the <see langword="MethodAttributes" /> for this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-154">傳回方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-154">Returns the calling convention of the method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-155">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-155">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-156">方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-156">The calling convention of the method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-157">現在支援這種類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-157">Not supported for this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-158">不支援。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-158">Not supported.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-159">A<xref:System.Reflection.Emit.MethodBuilder>永遠代表泛型方法定義，並因此不能叫用。</span><span class="sxs-lookup"><span data-stu-id="8b46b-159">A <xref:System.Reflection.Emit.MethodBuilder> always represents a generic method definition, and thus cannot be invoked.</span></span>  
  
 <span data-ttu-id="8b46b-160">如需詳細資訊，請參閱 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 與 <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-160">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b46b-161">在泛型類型上的資訊，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-161">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-162">基底類別不支援叫用的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-162">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="CreateMethodBody">
      <MemberSignature Language="C#" Value="public void CreateMethodBody (byte[] il, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateMethodBody(unsigned int8[] il, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMethodBody (il As Byte(), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMethodBody(cli::array &lt;System::Byte&gt; ^ il, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="il">
          <span data-ttu-id="8b46b-163">包含有效 MSIL 指示的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-163">An array containing valid MSIL instructions.</span>
          </span>
          <span data-ttu-id="8b46b-164">如果這個參數是 <see langword="null" />，便會清除該方法的主體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-164">If this parameter is <see langword="null" />, the method's body is cleared.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="8b46b-165">MSIL 陣列中的有效位元組數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-165">The number of valid bytes in the MSIL array.</span>
          </span>
          <span data-ttu-id="8b46b-166">如果 MSIL 是 <see langword="null" />，就會忽略這個值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-166">This value is ignored if MSIL is <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-167">建立方法的主體，方法是使用 Microsoft Intermediate Language (MSIL) 指示所提供的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-167">Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-168">這個方法會建立該方法的主體從`il`、 陣列，其中包含為作業碼的 MSIL 指令。</span><span class="sxs-lookup"><span data-stu-id="8b46b-168">This method creates the method's body from `il`, an array containing MSIL instructions as opcodes.</span></span> <span data-ttu-id="8b46b-169">依計數，會提供有效 MSIL 的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="8b46b-169">The number of bytes of valid MSIL is given by count.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b46b-170">這是目前不完全支援。</span><span class="sxs-lookup"><span data-stu-id="8b46b-170">This is currently not fully supported.</span></span> <span data-ttu-id="8b46b-171">使用者無法提供語彙基元的修復動作和例外狀況處理常式的位置。</span><span class="sxs-lookup"><span data-stu-id="8b46b-171">The user cannot supply the location of token fix ups and exception handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-172">在下面將提供範例中，將兩個整數的簡單方法透過 opcode 使用產生`CreateMethodBody`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-172">In the example provided below, a simple method that adds two integers is generated via opcode using `CreateMethodBody`.</span></span>  
  
 [!code-cpp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CPP/source.cpp#1)]
 [!code-csharp[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/CS/source.cs#1)]
 [!code-vb[System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Refelction.Emit.MethodBuilder.CreateMethodBody Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b46b-173">
            <paramref name="count" /> 不在提供的 MSIL 指示陣列中的索引範圍內，且 <paramref name="il" /> 不是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-173">The <paramref name="count" /> is not within the range of indexes of the supplied MSIL instruction array and <paramref name="il" /> is not <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-174">先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-174">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="8b46b-175">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-175">-or-</span>
          </span>
          <span data-ttu-id="8b46b-176">這個方法之前是在 <see langword="MethodBuilder" /> 物件上，以非 <see langword="null" /> 的 <paramref name="il" /> 引數所呼叫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-176">This method was called previously on this <see langword="MethodBuilder" /> with an <paramref name="il" /> argument that was not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="8b46b-177">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-177">-or-</span>
          </span>
          <span data-ttu-id="8b46b-178">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-178">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-179">傳回宣告這個方法的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-179">Returns the type that declares this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-180">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-180">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-181">宣告這個方法的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-181">The type that declares this method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8b46b-182">下列程式碼說明如何使用`Type`屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-182">The following code illustrates the use of the `Type` property.</span></span>  
  
 [!code-cpp[MethodBuilderClass_TypeSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CPP/methodbuilderclass.cpp#1)]
 [!code-csharp[MethodBuilderClass_TypeSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilderClass_TypeSample/CS/methodbuilderclass.cs#1)]
 [!code-vb[MethodBuilderClass_TypeSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilderClass_TypeSample/VB/methodbuilderclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">
          <span data-ttu-id="8b46b-183">由字串組成的陣列，代表泛型類型參數的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-183">An array of strings that represent the names of the generic type parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-184">設定目前方法的泛型類型參數數目、指定其名稱，並傳回可用來定義其條件約束的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 物件陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-184">Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define their constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-185">由 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 物件組成的陣列，代表泛型方法的類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-185">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects representing the type parameters of the generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-186">呼叫<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>泛型的方法會將目前的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-186">Calling the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method makes the current method generic.</span></span> <span data-ttu-id="8b46b-187">沒有任何方式能夠復原這項變更。</span><span class="sxs-lookup"><span data-stu-id="8b46b-187">There is no way to undo this change.</span></span> <span data-ttu-id="8b46b-188">第二次呼叫這個方法會導致<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-188">Calling this method a second time causes an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="8b46b-189">泛型方法的型別參數可以稍後擷取使用<xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-189">The type parameters of the generic method can be retrieved later by using the <xref:System.Reflection.Emit.MethodBuilder.GetGenericArguments%2A> method.</span></span>  
  
 <span data-ttu-id="8b46b-190">依照慣例，型別參數名稱會是單一的大寫字母。</span><span class="sxs-lookup"><span data-stu-id="8b46b-190">By convention, a type parameter name is a single uppercase letter.</span></span>  
  
 <span data-ttu-id="8b46b-191">如需詳細資訊，請參閱 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 與 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-191">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b46b-192">在泛型類型上的資訊，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-192">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-193">下列程式碼範例會建立動態類型`DemoType`，其中包含動態泛型方法`DemoMethod`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-193">The following code example creates a dynamic type, `DemoType`, which contains the dynamic generic method `DemoMethod`.</span></span> <span data-ttu-id="8b46b-194">這個方法有兩個泛型型別參數，其中做為參數，和另一個則為傳回型別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-194">This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.</span></span>  
  
 <span data-ttu-id="8b46b-195">執行程式碼時，動態組件會儲存為 DemoGenericMethod1.dll，以及可以使用檢查[Ildasm.exe （IL 反組譯工具）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)。</span><span class="sxs-lookup"><span data-stu-id="8b46b-195">When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b46b-196">這個程式碼範例會產生簡單的方法主體，只會傳回 null 參考。</span><span class="sxs-lookup"><span data-stu-id="8b46b-196">This code example generates a simple method body that merely returns a null reference.</span></span> <span data-ttu-id="8b46b-197">具有多個完整開發的方法主體的建立及使用泛型類型的程式碼範例，請參閱[如何： 定義泛型方法使用反映發出](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="8b46b-197">For a code example with a more fully developed method body that creates and uses generic types, see [How to: Define a Generic Method with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[GenericMethodBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#1)]
 [!code-csharp[GenericMethodBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#1)]
 [!code-vb[GenericMethodBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-198">已定義這個方法的泛型類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-198">Generic type parameters have already been defined for this method.</span>
          </span>
          <span data-ttu-id="8b46b-199">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-199">-or-</span>
          </span>
          <span data-ttu-id="8b46b-200">這個方法已經完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-200">The method has been completed already.</span>
          </span>
          <span data-ttu-id="8b46b-201">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-201">-or-</span>
          </span>
          <span data-ttu-id="8b46b-202">已對目前的執行個體呼叫 <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-202">The <see cref="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" /> method has been called for the current method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b46b-203">
            <paramref name="names" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-203">
              <paramref name="names" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="8b46b-204">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-204">-or-</span>
          </span>
          <span data-ttu-id="8b46b-205">
            <paramref name="names" /> 的項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-205">An element of <paramref name="names" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8b46b-206">
            <paramref name="names" /> 是空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-206">
              <paramref name="names" /> is an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.DefineMethod" />
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string strParamName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, strParamName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ strParamName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="strParamName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">
          <span data-ttu-id="8b46b-207">在參數清單中參數的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-207">The position of the parameter in the parameter list.</span>
          </span>
          <span data-ttu-id="8b46b-208">第一個參數的參數索引從數字 1 開始，數字 0 表示方法的傳回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-208">Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="8b46b-209">參數的參數屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-209">The parameter attributes of the parameter.</span>
          </span>
        </param>
        <param name="strParamName">
          <span data-ttu-id="8b46b-210">參數名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-210">The name of the parameter.</span>
          </span>
          <span data-ttu-id="8b46b-211">名稱可以是 null 字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-211">The name can be the null string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-212">設定參數屬性和這個方法或這個方法傳回值的參數名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-212">Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method.</span>
          </span>
          <span data-ttu-id="8b46b-213">傳回可用於套用自訂屬性的 ParameterBuilder。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-213">Returns a ParameterBuilder that can be used to apply custom attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-214">傳回 <see langword="ParameterBuilder" /> 物件，其表示這個方法的參數或這個方法的傳回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-214">Returns a <see langword="ParameterBuilder" /> object that represents a parameter of this method or the return value of this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-215"><xref:System.Reflection.Emit.ParameterBuilder>可以用這個方法所傳回的物件，來設定參數的預設值，或套用自訂屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-215">The <xref:System.Reflection.Emit.ParameterBuilder> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.</span></span>  
  
 <span data-ttu-id="8b46b-216">參數編號從 1 開始，因此`position`為 1，第一個參數。</span><span class="sxs-lookup"><span data-stu-id="8b46b-216">Parameter numbering begins with 1, so `position` is 1 for the first parameter.</span></span> <span data-ttu-id="8b46b-217">如果`position`是零，則這個方法會影響傳回的值。</span><span class="sxs-lookup"><span data-stu-id="8b46b-217">If `position` is zero, this method affects the return value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b46b-218">在.NET framework 1.0 和 1.1 版中，會擲回例外狀況`position`是零，因此這個方法無法用來修改這些版本中的傳回值的屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-218">In the .NET Framework versions 1.0 and 1.1, an exception is thrown if `position` is zero, so this method cannot be used to modify attributes of the return value in those versions.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b46b-219">這個方法沒有參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-219">The method has no parameters.</span>
          </span>
          <span data-ttu-id="8b46b-220">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-220">-or-</span>
          </span>
          <span data-ttu-id="8b46b-221">
            <paramref name="position" /> 小於零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-221">
              <paramref name="position" /> is less than zero.</span>
          </span>
          <span data-ttu-id="8b46b-222">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-222">-or-</span>
          </span>
          <span data-ttu-id="8b46b-223">
            <paramref name="position" /> 大於方法參數的數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-223">
              <paramref name="position" /> is greater than the number of the method's parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-224">先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-224">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="8b46b-225">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-225">-or-</span>
          </span>
          <span data-ttu-id="8b46b-226">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-226">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="8b46b-227">與這個 <see langword="MethodBuilder" /> 執行個體相互比較的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-227">The object to compare with this <see langword="MethodBuilder" /> instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-228">判斷指定的物件是否等於這個執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-228">Determines whether the given object is equal to this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-229">如果 <see langword="MethodBuilder" /> 是 <paramref name="obj" /> 的執行個體，並且與這個物件相等，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-229">
              <see langword="true" /> if <paramref name="obj" /> is an instance of <see langword="MethodBuilder" /> and is equal to this object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-230">具有相同的名稱、 屬性和簽章取決於相等。</span><span class="sxs-lookup"><span data-stu-id="8b46b-230">Equality is determined by having the same name, attributes, and signature.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-231">傳回方法的基底實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-231">Return the base implementation for a method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-232">這個方法的基底實作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-232">The base implementation of this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-233">這一律會傳回目前`MethodBuilder`物件。</span><span class="sxs-lookup"><span data-stu-id="8b46b-233">This always returns the current `MethodBuilder` object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-234">傳回為這個方法定義的自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-234">Returns the custom attributes defined for this method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="8b46b-235">指定是否要搜尋這個成員的繼承鏈結以尋找自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-235">Specifies whether to search this member's inheritance chain to find the custom attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-236">傳回為這個方法定義的所有自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-236">Returns all the custom attributes defined for this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-237">傳回代表這個方法的所有自訂屬性的物件陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-237">Returns an array of objects representing all the custom attributes of this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-238">目前不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-238">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="8b46b-239">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 擷取方法並在傳回的 <see cref="T:System.Reflection.MethodInfo" /> 上呼叫 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-239">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="8b46b-240">自訂屬性類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-240">The custom attribute type.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="8b46b-241">指定是否要搜尋這個成員的繼承鏈結以尋找自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-241">Specifies whether to search this member's inheritance chain to find the custom attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-242">傳回指定類型所識別的自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-242">Returns the custom attributes identified by the given type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-243">傳回物件陣列，表示這個方法中屬於 <paramref name="attributeType" /> 型別的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-243">Returns an array of objects representing the attributes of this method that are of type <paramref name="attributeType" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-244">目前不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-244">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="8b46b-245">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 擷取方法並在傳回的 <see cref="T:System.Reflection.MethodInfo" /> 上呼叫 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-245">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-246">如果它是泛型，則傳回 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 物件的陣列，代表此方法的類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-246">Returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that represent the type parameters of the method, if it is generic.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-247">
            <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 物件的陣列，代表此類型參數，或者如果此方法不是泛型，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-247">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects representing the type parameters, if the method is generic, or <see langword="null" /> if the method is not generic.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-248">泛型方法的型別參數也會傳回<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>用來定義它們的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-248">The type parameters of a generic method also are returned by the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method that is used to define them.</span></span>  
  
 <span data-ttu-id="8b46b-249">如需詳細資訊，請參閱 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 與 <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-249">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b46b-250">在泛型類型上的資訊，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-250">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-251">傳回這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-251">Returns this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-252">目前的 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-252">The current instance of <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-253">A<xref:System.Reflection.Emit.MethodBuilder>無法用來直接發出建構的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-253">A <xref:System.Reflection.Emit.MethodBuilder> cannot be used to emit a constructed generic method directly.</span></span> <span data-ttu-id="8b46b-254">發出的方法是泛型方法定義。</span><span class="sxs-lookup"><span data-stu-id="8b46b-254">The emitted method is a generic method definition.</span></span>  
  
 <span data-ttu-id="8b46b-255">如需詳細資訊，請參閱 <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> 與 <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-255">For more information, see <xref:System.Reflection.MethodBase.IsGenericMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8b46b-256">在泛型類型上的資訊，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-256">For information on generic types, see <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-257">目前的方法不是泛型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-257">The current method is not generic.</span>
          </span>
          <span data-ttu-id="8b46b-258">亦即，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-258">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-259">取得這個方法的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-259">Gets the hash code for this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-260">這個方法的雜湊碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-260">The hash code for this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-261">傳回這個方法的 <see langword="ILGenerator" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-261">Returns an <see langword="ILGenerator" /> for this method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-262">針對這個方法傳回具有 64 位元組之預設 Microsoft Intermediate Language (MSIL) 資料流大小的 <see langword="ILGenerator" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-262">Returns an <see langword="ILGenerator" /> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-263">傳回這個方法的 <see langword="ILGenerator" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-263">Returns an <see langword="ILGenerator" /> object for this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8b46b-264">下列程式碼範例示範的相關用法`GetILGenerator`方法，建立及發出動態組件來計算兩個點在 3D 空間中的內積。</span><span class="sxs-lookup"><span data-stu-id="8b46b-264">The code sample below demonstrates the contextual usage of the `GetILGenerator` method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-265">因為其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 旗標，所以此方法不該有主體；例如因為它有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-265">The method should not have a body because of its <see cref="T:System.Reflection.MethodAttributes" /> or <see cref="T:System.Reflection.MethodImplAttributes" /> flags, for example because it has the <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flag.</span>
          </span>
          <span data-ttu-id="8b46b-266">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-266">-or-</span>
          </span>
          <span data-ttu-id="8b46b-267">此方法是泛型方法，但不是泛型方法定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-267">The method is a generic method, but not a generic method definition.</span>
          </span>
          <span data-ttu-id="8b46b-268">亦即，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性是 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性是 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-268">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (size As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">
          <span data-ttu-id="8b46b-269">MSIL 資料流的大小，以位元組為單位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-269">The size of the MSIL stream, in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-270">傳回具有指定之 Microsoft Intermediate Language (MSIL) 資料流大小的這個方法的 <see langword="ILGenerator" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-270">Returns an <see langword="ILGenerator" /> for this method with the specified Microsoft intermediate language (MSIL) stream size.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-271">傳回這個方法的 <see langword="ILGenerator" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-271">Returns an <see langword="ILGenerator" /> object for this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8b46b-272">下列程式碼範例示範的相關用法`GetILGenerator`方法，建立及發出動態組件來計算兩個點在 3D 空間中的內積。</span><span class="sxs-lookup"><span data-stu-id="8b46b-272">The code sample below demonstrates the contextual usage of the `GetILGenerator` method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-273">因為其 <see cref="T:System.Reflection.MethodAttributes" /> 或 <see cref="T:System.Reflection.MethodImplAttributes" /> 旗標，所以此方法不該有主體；例如因為它有 <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> 旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-273">The method should not have a body because of its <see cref="T:System.Reflection.MethodAttributes" /> or <see cref="T:System.Reflection.MethodImplAttributes" /> flags, for example because it has the <see cref="F:System.Reflection.MethodAttributes.PinvokeImpl" /> flag.</span>
          </span>
          <span data-ttu-id="8b46b-274">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-274">-or-</span>
          </span>
          <span data-ttu-id="8b46b-275">此方法是泛型方法，但不是泛型方法定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-275">The method is a generic method, but not a generic method definition.</span>
          </span>
          <span data-ttu-id="8b46b-276">亦即，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性是 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性是 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-276">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-277">傳回方法的實作旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-277">Returns the implementation flags for the method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-278">傳回方法的實作旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-278">Returns the implementation flags for the method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module GetModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Module GetModule() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetModule" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModule () As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Module ^ GetModule();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-279">傳回包含這個方法之模組的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-279">Returns a reference to the module that contains this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-280">傳回包含這個方法之模組的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-280">Returns a reference to the module that contains this method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8b46b-281">下列範例程式碼說明如何使用`GetModule`方法來擷取動態產生模組的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="8b46b-281">The sample code below illustrates the usage of the `GetModule` method to retrieve information about a dynamically-generated module.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CPP/source3.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/CS/source3.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetModule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetModule/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-282">傳回這個方法的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-282">Returns the parameters of this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-283">
            <see langword="ParameterInfo" /> 物件的陣列，代表此方法的參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-283">An array of <see langword="ParameterInfo" /> objects that represent the parameters of the method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8b46b-284">下列程式碼範例示範如何使用`GetParameters`探索參數傳遞至動態產生的方法上的資訊。</span><span class="sxs-lookup"><span data-stu-id="8b46b-284">The code sample below illustrates the use of `GetParameters` to discover information on the parameters passed to a dynamically-generated method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CPP/source4.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/CS/source4.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.GetParameters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.GetParameters Example/VB/source4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-285">目前不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-285">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="8b46b-286">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 擷取方法並在傳回的 <see cref="T:System.Reflection.MethodInfo" /> 上呼叫 <see langword="GetParameters" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-286">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see langword="GetParameters" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetToken ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetToken() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.GetToken" />
      <MemberSignature Language="VB.NET" Value="Public Function GetToken () As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetToken();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-287">傳回 <see langword="MethodToken" />，表示這個方法的語彙基元 (Token)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-287">Returns the <see langword="MethodToken" /> that represents the token for this method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-288">傳回這個方法的 <see langword="MethodToken" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-288">Returns the <see langword="MethodToken" /> of this method.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-289">取得或設定布林值，指定在這個方法中的區域變數是否以零起始。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-289">Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized.</span>
          </span>
          <span data-ttu-id="8b46b-290">此屬性的預設值為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-290">The default value of this property is <see langword="true" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-291">如果在這個方法中的區域變數應該以零起始，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-291">
              <see langword="true" /> if the local variables in this method should be zero initialized; otherwise <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-292">如果這個屬性設定為`true`，發出的 MSIL 包括可用的本機變數的初始化。</span><span class="sxs-lookup"><span data-stu-id="8b46b-292">If this property is set to `true`, the emitted MSIL includes initialization of local variables.</span></span> <span data-ttu-id="8b46b-293">如果設定為`false`、 未初始化的區域變數和產生的程式碼，將無法驗證。</span><span class="sxs-lookup"><span data-stu-id="8b46b-293">If it is set to `false`, local variables are not initialized and the generated code is unverifiable.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-294">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-294">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="8b46b-295">(Get 或 Set。)</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-295">(Get or set.)</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="8b46b-296">要在其上叫用指定方法的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-296">The object on which to invoke the specified method.</span>
          </span>
          <span data-ttu-id="8b46b-297">如果是靜態方法，則會忽略這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-297">If the method is static, this parameter is ignored.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="8b46b-298">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 中的位元旗標：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-298">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="8b46b-299">此物件能用來啟用繫結、引數的強制型轉、成員的引動過程，以及透過反映來擷取 MemberInfo 物件等功能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-299">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection.</span>
          </span>
          <span data-ttu-id="8b46b-300">如果繫結器為 <see langword="null" />，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-300">If binder is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="8b46b-301">如需詳細資訊，請參閱 <see cref="T:System.Reflection.Binder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-301">For more details, see <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="8b46b-302">引數清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-302">An argument list.</span>
          </span>
          <span data-ttu-id="8b46b-303">這是引數陣列，其數目、順序和類型與要叫用的方法參數相同。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-303">This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked.</span>
          </span>
          <span data-ttu-id="8b46b-304">如果沒有參數，則這應該為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-304">If there are no parameters this should be <see langword="null" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="8b46b-305">
            <see cref="T:System.Globalization.CultureInfo" /> 的執行個體，用於管理類型的強制型轉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-305">An instance of <see cref="T:System.Globalization.CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="8b46b-306">如果這是 null，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-306">If this is null, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="8b46b-307">(請注意，例如要將表示 1000 的 <see cref="T:System.String" /> 轉換成 <see cref="T:System.Double" /> 值時，這是必要的，因為 1000 在不同文化特性中有不同的表示方式)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-307">(Note that this is necessary to, for example, convert a <see cref="T:System.String" /> that represents 1000 to a <see cref="T:System.Double" /> value, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-308">動態叫用這個執行個體在指定物件上反映的方法，沿著指定參數，在指定繫結器的條件約束下傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-308">Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-309">傳回包含已叫用方法之傳回值的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-309">Returns an object containing the return value of the invoked method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-310">如果這個方法是靜態，`obj`參數已忽略。</span><span class="sxs-lookup"><span data-stu-id="8b46b-310">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="8b46b-311">對於非靜態方法，`obj`應該類別繼承，或是宣告方法，必須是相同的類型與這個類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="8b46b-311">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="8b46b-312">如果方法沒有參數，值`parameters`應該`null`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-312">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="8b46b-313">否則數字、 類型和參數陣列中項目的順序應該與數字、 類型和這個執行個體所反映的方法參數順序相同。</span><span class="sxs-lookup"><span data-stu-id="8b46b-313">Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b46b-314">完全信任的程式碼會忽略存取限制。</span><span class="sxs-lookup"><span data-stu-id="8b46b-314">Access restrictions are ignored for fully-trusted code.</span></span> <span data-ttu-id="8b46b-315">也就是說，私用建構函式、 方法、 欄位和屬性可以存取，而且只要完全信任程式碼使用反映來叫用。</span><span class="sxs-lookup"><span data-stu-id="8b46b-315">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-316">目前不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-316">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="8b46b-317">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 擷取方法並在傳回的 <see cref="T:System.Reflection.MethodInfo" /> 上呼叫 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-317">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="8b46b-318">自訂屬性類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-318">The custom attribute type.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="8b46b-319">指定是否要搜尋這個成員的繼承鏈結以尋找自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-319">Specifies whether to search this member's inheritance chain to find the custom attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-320">檢查是否已定義指定的自訂屬性類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-320">Checks if the specified custom attribute type is defined.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-321">如果指定的自訂屬性型別已定義，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-321">
              <see langword="true" /> if the specified custom attribute type is defined; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-322">目前不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-322">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="8b46b-323">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 擷取方法並在傳回的 <see cref="T:System.Reflection.MethodInfo" /> 上呼叫 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-323">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-324">取得可指出此方法是否為泛型方法的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-324">Gets a value indicating whether the method is a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-325">如果方法是泛型，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-325">
              <see langword="true" /> if the method is generic; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-326">方法是泛型，如果類型參數。</span><span class="sxs-lookup"><span data-stu-id="8b46b-326">A method is generic if it has type parameters.</span></span> <span data-ttu-id="8b46b-327">您可以讓方法一般呼叫<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法，將型別參數。</span><span class="sxs-lookup"><span data-stu-id="8b46b-327">You can make a method generic by calling the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to add type parameters.</span></span> <span data-ttu-id="8b46b-328">這項變更無法回復。</span><span class="sxs-lookup"><span data-stu-id="8b46b-328">This change cannot be reversed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-329">下列程式碼範例會顯示方法的狀態。</span><span class="sxs-lookup"><span data-stu-id="8b46b-329">The following code example displays the status of a method.</span></span> <span data-ttu-id="8b46b-330">這段程式碼是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-330">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-331">取得值，指出目前的 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 物件是否代表泛型方法的定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-331">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.MethodBuilder" /> object represents the definition of a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-332">如果目前的 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 物件代表泛型方法的定義，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-332">
              <see langword="true" /> if the current <see cref="T:System.Reflection.Emit.MethodBuilder" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-333">A<xref:System.Reflection.Emit.MethodBuilder>只可用來建立泛型方法定義中; 它不能直接建立建構的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-333">A <xref:System.Reflection.Emit.MethodBuilder> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly.</span></span> <span data-ttu-id="8b46b-334">不過，子類別的<xref:System.Reflection.Emit.MethodBuilder>可能代表建構的泛型方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-334">However, a subclass of <xref:System.Reflection.Emit.MethodBuilder> might represent a constructed generic method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-335">下列程式碼範例會顯示方法的狀態。</span><span class="sxs-lookup"><span data-stu-id="8b46b-335">The following code example displays the status of a method.</span></span> <span data-ttu-id="8b46b-336">這段程式碼是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-336">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#7](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#7)]
 [!code-csharp[GenericMethodBuilder#7](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#7)]
 [!code-vb[GenericMethodBuilder#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-337">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-337">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-338">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-338">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-339">若要判斷是否為安全性關鍵的動態組件中的方法，完成的型別呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>，呼叫<xref:System.Type.GetMethod%2A>上已完成的型別和 get 方法<xref:System.Reflection.MethodBase.IsSecurityCritical%2A>上產生屬性<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-339">To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-340">在所有情況下。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-340">In all cases.</span>
          </span>
          <span data-ttu-id="8b46b-341">動態組件不支援這個屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-341">This property is not supported in dynamic assemblies.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-342">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-342">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-343">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-343">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-344">若要判斷在動態組件中的方法是否為安全性安全關鍵，完成的型別呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>，呼叫<xref:System.Type.GetMethod%2A>上已完成的型別和 get 方法<xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>上產生屬性<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-344">To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-345">在所有情況下。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-345">In all cases.</span>
          </span>
          <span data-ttu-id="8b46b-346">動態組件不支援這個屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-346">This property is not supported in dynamic assemblies.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-347">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-347">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-348">在所有情況下都擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-348">Throws a <see cref="T:System.NotSupportedException" /> in all cases.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-349">若要判斷在動態組件中的方法是否為安全性透明，完成的型別呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>，呼叫<xref:System.Type.GetMethod%2A>上已完成的型別和 get 方法<xref:System.Reflection.MethodBase.IsSecurityTransparent%2A>上產生屬性<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-349">To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>, call the <xref:System.Type.GetMethod%2A> method on the completed type, and get the <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> property on the resulting <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-350">在所有情況下。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-350">In all cases.</span>
          </span>
          <span data-ttu-id="8b46b-351">動態組件不支援這個屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-351">This property is not supported in dynamic assemblies.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="8b46b-352">由 <see cref="T:System.Type" /> 物件組成的陣列，代表泛型方法的類型引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-352">An array of <see cref="T:System.Type" /> objects that represent the type arguments for the generic method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-353">傳回使用指定的泛型類型引數，從目前的泛型方法定義建構的泛型方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-353">Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-354">
            <see cref="T:System.Reflection.MethodInfo" />，代表使用指定的泛型類型引數，從目前的泛型方法定義建構的泛型方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-354">A <see cref="T:System.Reflection.MethodInfo" /> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-355">當您要發出動態程式碼時，您可能需要發出呼叫的方法，從所代表的泛型方法定義建構<xref:System.Reflection.Emit.MethodBuilder>，才能完成封入類型。</span><span class="sxs-lookup"><span data-stu-id="8b46b-355">When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <xref:System.Reflection.Emit.MethodBuilder>, before the enclosing type has been completed.</span></span> <span data-ttu-id="8b46b-356">您可以使用<xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>方法來建立<xref:System.Reflection.MethodInfo>這類建構的方法，和使用<xref:System.Reflection.MethodInfo>發出的呼叫中。</span><span class="sxs-lookup"><span data-stu-id="8b46b-356">You can use the <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method to create a <xref:System.Reflection.MethodInfo> for such a constructed method, and use the <xref:System.Reflection.MethodInfo> in the emitted call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-357">下列程式碼範例會建立從完整的泛型方法定義中不完整的型別建構的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-357">The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.</span></span>  
  
 <span data-ttu-id="8b46b-358">這個範例會建立與單一類型的暫時性組件和模組、 將方法加入`M`，並會將方法加上使用類型參數 T 的泛型<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-358">The example creates a transient assembly and module with a single type, adds a method `M`, and makes the method generic by adding a type parameter T using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span> <span data-ttu-id="8b46b-359">型別參數用做為方法的參數類型以及其傳回型別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-359">The type parameter is used as the type of the method's parameter, and also as its return type.</span></span> <span data-ttu-id="8b46b-360">泛型方法定義未指定主體，並不會完成封入類型。</span><span class="sxs-lookup"><span data-stu-id="8b46b-360">The generic method definition is not given a body, and the enclosing type is not completed.</span></span> <span data-ttu-id="8b46b-361"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>方法用來進行的建構的方法`M<String>`(`M(Of String)`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="8b46b-361">The <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method is then used to make the constructed method `M<String>` (`M(Of String)` in Visual Basic).</span></span> <span data-ttu-id="8b46b-362">範例程式碼有任何輸出，因為子類別的<xref:System.Reflection.MethodInfo>傳回<xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>方法不允許透過其參數的反映。</span><span class="sxs-lookup"><span data-stu-id="8b46b-362">The example code has no output, because the subclass of <xref:System.Reflection.MethodInfo> returned by the <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> method does not allow reflection over its parameters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8b46b-363">另一個程式碼範例使用<xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>，請參閱<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-363">For another code example that uses <xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A>, see <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>.</span></span> <span data-ttu-id="8b46b-364"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> 也廣泛時發出程式碼使用泛型型別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-364"><xref:System.Reflection.Emit.MethodBuilder.MakeGenericMethod%2A> is also used extensively when emitting code that uses generic types.</span></span> <span data-ttu-id="8b46b-365">請參閱[如何： 定義泛型方法使用反映發出](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="8b46b-365">See [How to: Define a Generic Method with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-method-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cpp/source.cpp#1)]
 [!code-csharp[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/cs/source.cs#1)]
 [!code-vb[MethodBuilder.MakeGenericMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBuilder.MakeGenericMethod/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-366">擷取方法的內部控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-366">Retrieves the internal handle for the method.</span>
          </span>
          <span data-ttu-id="8b46b-367">使用此控制代碼來存取基礎中繼資料控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-367">Use this handle to access the underlying metadata handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-368">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-368">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-369">此方法的內部控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-369">The internal handle for the method.</span>
          </span>
          <span data-ttu-id="8b46b-370">使用這個控制代碼來存取基礎中繼資料控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-370">Use this handle to access the underlying metadata handle.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8b46b-371">目前不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-371">This method is not currently supported.</span>
          </span>
          <span data-ttu-id="8b46b-372">使用 <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> 擷取方法並在傳回的 <see cref="T:System.Reflection.MethodInfo" /> 上呼叫 <see cref="P:System.Reflection.MethodBase.MethodHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-372">Retrieve the method using <see cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" /> and call <see cref="P:System.Reflection.MethodBase.MethodHandle" /> on the returned <see cref="T:System.Reflection.MethodInfo" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-373">取得所要定義之目前方法中的模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-373">Gets the module in which the current method is being defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-374">
            <see cref="T:System.Reflection.Module" />，在其中定義目前 <see cref="T:System.Reflection.MemberInfo" /> 所表示的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-374">The <see cref="T:System.Reflection.Module" /> in which the member represented by the current <see cref="T:System.Reflection.MemberInfo" /> is being defined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-375">為了方便起見，已提供這個屬性。</span><span class="sxs-lookup"><span data-stu-id="8b46b-375">This property is provided as a convenience.</span></span> <span data-ttu-id="8b46b-376">它相當於使用<xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A>屬性來取得的類型中所宣告的方法，並再呼叫<xref:System.Type.Module%2A>屬性產生<xref:System.Type>物件。</span><span class="sxs-lookup"><span data-stu-id="8b46b-376">It is equivalent to using the <xref:System.Reflection.Emit.MethodBuilder.DeclaringType%2A> property to get the type in which the method is being declared, and then calling the <xref:System.Type.Module%2A> property of the resulting <xref:System.Type> object.</span></span>  
  
 <span data-ttu-id="8b46b-377">這個屬性也是相當於呼叫<xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-377">This property is also equivalent to calling <xref:System.Reflection.Emit.MethodBuilder.GetModule%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-378">擷取這個方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-378">Retrieves the name of this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-379">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-379">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-380">擷取含有這個方法之簡單名稱的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-380">Retrieves a string containing the simple name of this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-381">取得用於反映中以取得方法的類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-381">Retrieves the class that was used in reflection to obtain this object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-382">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-382">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-383">用來取得這個方法的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-383">The type used to obtain this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-384">取得 <see cref="T:System.Reflection.ParameterInfo" /> 物件，這個物件包含方法之傳回類型的相關資訊，例如傳回類型是否具有自訂修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-384">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-385">
            <see cref="T:System.Reflection.ParameterInfo" /> 物件，包含傳回類型的相關資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-385">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-386">編譯器設計人員可以使用<xref:System.Reflection.ParameterInfo>來探索是否自訂這個屬性所傳回的物件修飾詞，例如<xref:Microsoft.VisualC.IsConstModifier>，已套用至傳回型別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-386">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-387">尚未建立宣告類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-387">The declaring type has not been created.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-388">取得這個 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 所表示之方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-388">Gets the return type of the method represented by this <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-389">該方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-389">The return type of the method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="8b46b-390">從.NET Framework 2.0 和.NET Compact Framework 2.0，這個成員繼承自基底類別， <xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-390">Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="8b46b-391">請參閱 <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-391">See <xref:System.Reflection.MethodInfo.ReturnType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-392">傳回方法之傳回型別的自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-392">Returns the custom attributes of the method's return type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-393">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-393">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-394">方法之傳回型別的自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-394">The custom attributes of the method's return type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-395">這個方法一律會傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-395">This method always returns `null`.</span></span> <span data-ttu-id="8b46b-396">取得<xref:System.Reflection.MethodInfo>之後包含<xref:System.Type>已建立並叫用<xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A>上<xref:System.Reflection.MethodInfo>。</span><span class="sxs-lookup"><span data-stu-id="8b46b-396">Get the <xref:System.Reflection.MethodInfo> after the containing <xref:System.Type> has been created and invoked <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> on the <xref:System.Reflection.MethodInfo>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-397">設定自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-397">Sets a custom attribute.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">
          <span data-ttu-id="8b46b-398">要描述自訂屬性之協助程式的類別執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-398">An instance of a helper class to describe the custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-399">使用自訂屬性產生器來設定自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-399">Sets a custom attribute using a custom attribute builder.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-400"><xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法可以互動<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法搭配使用的兩種方法時。</span><span class="sxs-lookup"><span data-stu-id="8b46b-400">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method can interact with the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method when the two methods are used in combination.</span></span> <span data-ttu-id="8b46b-401">請參閱 < 備註 > 一節的<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法，如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="8b46b-401">See the Remarks section of the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method for details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b46b-402">
            <paramref name="customBuilder" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-402">
              <paramref name="customBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-403">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-403">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">
          <span data-ttu-id="8b46b-404">自訂屬性的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-404">The constructor for the custom attribute.</span>
          </span>
        </param>
        <param name="binaryAttribute">
          <span data-ttu-id="8b46b-405">代表屬性的位元組 Blob。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-405">A byte blob representing the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-406">使用指定的自訂屬性 Blob 來設定自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-406">Sets a custom attribute using a specified custom attribute blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-407">如需詳細資訊，如何格式化`binaryAttribute`，請參閱 Common Language Infrastructure (CLI) 文件，尤其是 < 磁碟分割 II： 中繼資料定義和語意 >。</span><span class="sxs-lookup"><span data-stu-id="8b46b-407">For details on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="8b46b-408">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="8b46b-408">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="8b46b-409"><xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法可以互動<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法搭配使用的兩種方法時。</span><span class="sxs-lookup"><span data-stu-id="8b46b-409">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method can interact with the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method when the two methods are used in combination.</span></span> <span data-ttu-id="8b46b-410">請參閱 < 備註 > 一節的<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法，如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="8b46b-410">See the Remarks section of the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method for details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b46b-411">
            <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-411">
              <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-412">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-412">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetImplementationFlags">
      <MemberSignature Language="C#" Value="public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetImplementationFlags(valuetype System.Reflection.MethodImplAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetImplementationFlags(System.Reflection.MethodImplAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetImplementationFlags (attributes As MethodImplAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetImplementationFlags(System::Reflection::MethodImplAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodImplAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="8b46b-413">要設定的實作旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-413">The implementation flags to set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-414">設定此方法的實作旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-414">Sets the implementation flags for this method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-415">當您使用<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法搭配<xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法中，注意潛在的互動。</span><span class="sxs-lookup"><span data-stu-id="8b46b-415">When you use the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method in combination with the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method, be aware of potential interactions.</span></span> <span data-ttu-id="8b46b-416">例如，使用<xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法，將<xref:System.Runtime.InteropServices.DllImportAttribute>也屬性集<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="8b46b-416">For example, using the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method to add the <xref:System.Runtime.InteropServices.DllImportAttribute> attribute also sets the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="8b46b-417">如果您後續呼叫<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法，<xref:System.Reflection.MethodImplAttributes.PreserveSig>會覆寫旗標。</span><span class="sxs-lookup"><span data-stu-id="8b46b-417">If you subsequently call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method, the <xref:System.Reflection.MethodImplAttributes.PreserveSig> flag is overwritten.</span></span> <span data-ttu-id="8b46b-418">有兩種方式可避免此狀況：</span><span class="sxs-lookup"><span data-stu-id="8b46b-418">There are two ways to avoid this:</span></span>  
  
-   <span data-ttu-id="8b46b-419">呼叫<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法呼叫之前<xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-419">Call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method before you call the <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method.</span></span> <span data-ttu-id="8b46b-420"><xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A>方法一律會接受現有的方法實作旗標。</span><span class="sxs-lookup"><span data-stu-id="8b46b-420">The <xref:System.Reflection.Emit.MethodBuilder.SetCustomAttribute%2A> method always respects existing method implementation flags.</span></span>  
  
-   <span data-ttu-id="8b46b-421">當您設定的實作旗標時，呼叫<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A>方法來擷取現有的旗標，請使用位元或，新增您的旗標，然後再呼叫<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-421">When you set implementation flags, call the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-422">下列程式碼範例說明的內容使用`SetImplementationFlags`來描述在方法主體的 MSIL 實作的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-422">The code sample below illustrates the contextual use of the `SetImplementationFlags` method to describe the implementation of MSIL in a method body.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetImplementationFlags Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-423">先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-423">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="8b46b-424">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-424">-or-</span>
          </span>
          <span data-ttu-id="8b46b-425">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-425">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMarshal">
      <MemberSignature Language="C#" Value="public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarshal(class System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMarshal(System.Reflection.Emit.UnmanagedMarshal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarshal(System::Reflection::Emit::UnmanagedMarshal ^ unmanagedMarshal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("An alternate API is available: Emit the MarshalAs custom attribute instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedMarshal" Type="System.Reflection.Emit.UnmanagedMarshal" />
      </Parameters>
      <Docs>
        <param name="unmanagedMarshal">
          <span data-ttu-id="8b46b-426">這個方法之傳回型別的封送處理資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-426">Marshaling information for the return type of this method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-427">設定這個方法之傳回型別的封送處理資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-427">Sets marshaling information for the return type of this method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8b46b-428">下列程式碼範例說明的相關用法`SetMarshal`方法來封送處理為不同類型的方法呼叫的結果。</span><span class="sxs-lookup"><span data-stu-id="8b46b-428">The code sample below illustrates the contextual usage of the `SetMarshal` method to marshal the results of a method call as a different type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetMarshal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetMarshal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-429">先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-429">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="8b46b-430">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-430">-or-</span>
          </span>
          <span data-ttu-id="8b46b-431">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-431">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMethodBody">
      <MemberSignature Language="C#" Value="public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMethodBody(unsigned int8[] il, int32 maxStack, unsigned int8[] localSignature, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, class System.Collections.Generic.IEnumerable`1&lt;int32&gt; tokenFixups) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetMethodBody(System.Byte[],System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Reflection.Emit.ExceptionHandler},System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMethodBody (il As Byte(), maxStack As Integer, localSignature As Byte(), exceptionHandlers As IEnumerable(Of ExceptionHandler), tokenFixups As IEnumerable(Of Integer))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMethodBody(cli::array &lt;System::Byte&gt; ^ il, int maxStack, cli::array &lt;System::Byte&gt; ^ localSignature, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::ExceptionHandler&gt; ^ exceptionHandlers, System::Collections::Generic::IEnumerable&lt;int&gt; ^ tokenFixups);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="il" Type="System.Byte[]" />
        <Parameter Name="maxStack" Type="System.Int32" />
        <Parameter Name="localSignature" Type="System.Byte[]" />
        <Parameter Name="exceptionHandlers" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt;" />
        <Parameter Name="tokenFixups" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="il">
          <span data-ttu-id="8b46b-432">包含有效 MSIL 指令的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-432">An array that contains valid MSIL instructions.</span>
          </span>
        </param>
        <param name="maxStack">
          <span data-ttu-id="8b46b-433">最大堆疊評估深度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-433">The maximum stack evaluation depth.</span>
          </span>
        </param>
        <param name="localSignature">
          <span data-ttu-id="8b46b-434">包含已序列化之區域變數結構的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-434">An array of bytes that contain the serialized local variable structure.</span>
          </span>
          <span data-ttu-id="8b46b-435">若方法沒有任何本機變數，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-435">Specify <see langword="null" /> if the method has no local variables.</span>
          </span>
        </param>
        <param name="exceptionHandlers">
          <span data-ttu-id="8b46b-436">包含此方法之例外狀況處理常式的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-436">A collection that contains the exception handlers for the method.</span>
          </span>
          <span data-ttu-id="8b46b-437">若方法沒有任何例外狀況處理常式，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-437">Specify <see langword="null" /> if the method has no exception handlers.</span>
          </span>
        </param>
        <param name="tokenFixups">
          <span data-ttu-id="8b46b-438">代表 <c>il</c> 中位移的值集合，其中每個都指定可能修改之權杖的開始位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-438">A collection of values that represent offsets in <c>il</c>, each of which specifies the beginning of a token that may be modified.</span>
          </span>
          <span data-ttu-id="8b46b-439">如果方法沒有要修改的語彙基元，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-439">Specify <see langword="null" /> if the method has no tokens that have to be modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-440">建立方法的主體，方法是使用 Microsoft 中繼語言 (MSIL) 指示之指定的位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-440">Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8b46b-441">
            <paramref name="il" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-441">
              <paramref name="il" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8b46b-442">
            <paramref name="maxStack" /> 為負。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-442">
              <paramref name="maxStack" /> is negative.</span>
          </span>
          <span data-ttu-id="8b46b-443">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-443">-or-</span>
          </span>
          <span data-ttu-id="8b46b-444">其中一個 <paramref name="exceptionHandlers" /> 指定位於 <paramref name="il" /> 之外的位移。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-444">One of <paramref name="exceptionHandlers" /> specifies an offset outside of <paramref name="il" />.</span>
          </span>
          <span data-ttu-id="8b46b-445">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-445">-or-</span>
          </span>
          <span data-ttu-id="8b46b-446">其中一個 <paramref name="tokenFixups" /> 指定超出 <paramref name="il" /> 陣列之外的位移。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-446">One of <paramref name="tokenFixups" /> specifies an offset that is outside the <paramref name="il" /> array.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-447">包含的型別先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-447">The containing type was previously created using the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
          <span data-ttu-id="8b46b-448">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-448">-or-</span>
          </span>
          <span data-ttu-id="8b46b-449">先前已在這個 <see cref="T:System.Reflection.Emit.MethodBuilder" /> 物件上呼叫此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-449">This method was called previously on this <see cref="T:System.Reflection.Emit.MethodBuilder" /> object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetParameters">
      <MemberSignature Language="C#" Value="public void SetParameters (params Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParameters(class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParameters (ParamArray parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParameters(... cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterTypes" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parameterTypes">
          <span data-ttu-id="8b46b-450">
            <see cref="T:System.Type" /> 物件的陣列，代參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-450">An array of <see cref="T:System.Type" /> objects representing the parameter types.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-451">設定方法的參數類型與數量。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-451">Sets the number and types of parameters for a method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-452">如果參數的類型與數量已知所定義之方法，您可以設定使用的任何多載<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType>方法可接受的參數類型陣列。</span><span class="sxs-lookup"><span data-stu-id="8b46b-452">If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method that accepts an array of parameter types.</span></span> <span data-ttu-id="8b46b-453">不過，泛型方法的參數型別由一或多個它自己的泛型類型參數，定義方法之後不能定義之前。</span><span class="sxs-lookup"><span data-stu-id="8b46b-453">However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</span></span> <span data-ttu-id="8b46b-454">若要設定的參數型別在此情況下使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-454">Use this method to set the parameter types in that case.</span></span>  
  
 <span data-ttu-id="8b46b-455">如果傳回型別有選擇性或必要自訂修飾詞，例如<xref:System.Runtime.CompilerServices.IsConst>，使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="8b46b-455">If the return type has optional or required custom modifiers, such as <xref:System.Runtime.CompilerServices.IsConst>, use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> method overload.</span></span>  
  
 <span data-ttu-id="8b46b-456">呼叫這個方法會取代任何已設定使用的參數型別<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-456">Calling this method replaces any parameter types that were set using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-457">下列程式碼範例使用<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>進行泛型方法的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-457">The following code example uses the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to make a method generic.</span></span> <span data-ttu-id="8b46b-458"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>方法用來提供方法的一個參數，將第一個泛型型別參數所指定型別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-458">The <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</span></span> <span data-ttu-id="8b46b-459"><xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>方法用來指定方法的傳回型別，第二個泛型型別參數所指定。</span><span class="sxs-lookup"><span data-stu-id="8b46b-459">The <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method is used to give the method a return type, specified by the second generic type parameter.</span></span>  
  
 <span data-ttu-id="8b46b-460">這段程式碼是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-460">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-461">目前的方法是泛型，但不是泛型方法定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-461">The current method is generic, but is not a generic method definition.</span>
          </span>
          <span data-ttu-id="8b46b-462">亦即，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性是 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性是 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-462">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="SetReturnType">
      <MemberSignature Language="C#" Value="public void SetReturnType (Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetReturnType(class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetReturnType (returnType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetReturnType(Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="returnType">
          <span data-ttu-id="8b46b-463">表示方法傳回類型的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-463">A <see cref="T:System.Type" /> object that represents the return type of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-464">設定方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-464">Sets the return type of the method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-465">若要設定泛型方法的傳回型別，其中一個方法的泛型型別參數所指定的傳回型別時使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-465">Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method.</span></span> <span data-ttu-id="8b46b-466">如果傳回型別有選擇性或必要自訂修飾詞，例如<xref:System.Runtime.CompilerServices.IsConst>，使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="8b46b-466">If the return type has optional or required custom modifiers, such as <xref:System.Runtime.CompilerServices.IsConst>, use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29> method overload.</span></span>  
  
 <span data-ttu-id="8b46b-467">呼叫這個方法會建立使用傳回型別取代<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-467">Calling this method replaces a return type established using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-468">下列程式碼範例使用<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>進行泛型方法的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-468">The following code example uses the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method to make a method generic.</span></span> <span data-ttu-id="8b46b-469"><xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>方法用來提供方法的一個參數，將第一個泛型型別參數所指定型別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-469">The <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> method is used to give the method one parameter, whose type will be specified by the first generic type parameter.</span></span> <span data-ttu-id="8b46b-470"><xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>方法用來指定方法的傳回型別，第二個泛型型別參數所指定。</span><span class="sxs-lookup"><span data-stu-id="8b46b-470">The <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> method is used to give the method a return type, specified by the second generic type parameter.</span></span>  
  
 <span data-ttu-id="8b46b-471">這段程式碼是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-471">This code is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
 [!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
 [!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-472">目前的方法是泛型，但不是泛型方法定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-472">The current method is generic, but is not a generic method definition.</span>
          </span>
          <span data-ttu-id="8b46b-473">亦即，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性是 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性是 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-473">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSignature">
      <MemberSignature Language="C#" Value="public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSignature(class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSignature (returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSignature(Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="returnType">
          <span data-ttu-id="8b46b-474">該方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-474">The return type of the method.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="8b46b-475">代表該方法傳回類型之必要自訂修飾詞的類型陣列，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-475">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="8b46b-476">如果傳回類型沒有必要的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-476">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="8b46b-477">一種類型陣列，用來為方法的傳回類型指出選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-477">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="8b46b-478">如果傳回類型沒有選擇性的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-478">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="8b46b-479">方法的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-479">The types of the parameters of the method.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="8b46b-480">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-480">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="8b46b-481">每個類型陣列都代表其對應參數必要的自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-481">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="8b46b-482">如果特定的參數沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-482">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="8b46b-483">如果這些參數都沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-483">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="8b46b-484">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-484">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="8b46b-485">每個類型陣列都代表其對應參數的選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-485">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="8b46b-486">如果特定的參數沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-486">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="8b46b-487">如果這些參數都沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-487">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-488">設定方法簽章，包含傳回類型、參數類型和傳回類型及參數類型之必要與選擇性自訂修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-488">Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-489">如果所定義之方法都已知的傳回型別和類型與數量的參數，它們可以建立使用的任何多載<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType>方法可接受的參數類型陣列。</span><span class="sxs-lookup"><span data-stu-id="8b46b-489">If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method that accepts an array of parameter types.</span></span> <span data-ttu-id="8b46b-490">不過，泛型方法的參數型別由一或多個它自己的泛型類型參數，定義方法之後不能定義之前。</span><span class="sxs-lookup"><span data-stu-id="8b46b-490">However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined.</span></span> <span data-ttu-id="8b46b-491">若要設定的參數型別在此情況下使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-491">Use this method to set the parameter types in that case.</span></span>  
  
 <span data-ttu-id="8b46b-492">如果傳回型別或參數型別都不具有選擇性或必要自訂修飾詞，例如<xref:Microsoft.VisualC.IsConstModifier>，您可以使用<xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A>和<xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-492">If neither the return type nor the parameter types have optional or required custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, you can use the <xref:System.Reflection.Emit.MethodBuilder.SetReturnType%2A> and <xref:System.Reflection.Emit.MethodBuilder.SetParameters%2A> methods.</span></span>  
  
 <span data-ttu-id="8b46b-493">呼叫這個方法會取代的參數和傳回型別，建立使用<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-493">Calling this method replaces the parameters and return type established using the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-494">下列程式碼範例包含名為具有型別參數的範例為泛型類別的原始程式碼`T`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-494">The following code example contains source code for a generic class named Sample that has a type parameter `T`.</span></span> <span data-ttu-id="8b46b-495">此類別具有名為的欄位`Field`，型別`T`，和泛型方法`GM`它自己的型別參數， `U`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-495">The class has a field named `Field`, of type `T`, and a generic method `GM` with its own type parameter, `U`.</span></span> <span data-ttu-id="8b46b-496">方法`GM`建立範例中，以取代型別參數的執行個體`U`型別參數的範例中，並將其輸入的參數中`Field`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-496">Method `GM` creates an instance of Sample, substituting its own type parameter `U` for the type parameter of Sample, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="8b46b-497">這個原始程式碼已編譯的但未使用。您可以檢視它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)，並比較類別所發出的程式碼`Example`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-497">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="8b46b-498">類別中的程式碼`Example`示範如何使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A>發出一般的程式碼中的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-498">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> method in emitting generic code.</span></span> <span data-ttu-id="8b46b-499">`Main`類別方法`Example`建立動態組件包含類別，名為`Sample`，並使用<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>方法，使它成為泛型藉由新增名為型別參數`T`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-499">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="8b46b-500">預設建構函式和名為的欄位`Field`，型別`T`，加入至類別`Sample`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-500">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="8b46b-501">方法`GM`加入，並轉換成泛型方法使用<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-501">A method `GM` is added, and turned into a generic method using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span> <span data-ttu-id="8b46b-502">型別參數`GM`名為`U`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-502">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="8b46b-503">定義型別參數之後, 的簽章`GM`加入，使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-503">Once the type parameter is defined, the signature of `GM` is added, using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A> method.</span></span> <span data-ttu-id="8b46b-504">沒有沒有傳回型別，以及任何必要或自訂修飾詞，因此這個方法的所有參數都是`null`除了`parameterTypes`，它會設定此方法唯一參數的型別，這個值設定為方法的型別參數， `U`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-504">There is no return type, and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`, which sets the type of the only parameter of the method; this is set to the method's type parameter, `U`.</span></span> <span data-ttu-id="8b46b-505">方法主體建立的建構類型的執行個體`Sample<U>`(`Sample(Of U)`在 Visual Basic 中)，會指派至方法的參數`Field`，然後列印值`Field`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-505">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="8b46b-506">定義空的型別，來保存的進入點方法`Main`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-506">A dummy type is defined, to hold the entry point method `Main`.</span></span> <span data-ttu-id="8b46b-507">本文的`Main`，靜態`GM`建構的泛型類型上叫用方法`Sample<int>`(`Sample(Of Integer)`在 Visual Basic 中)，與類型<xref:System.String>取代`U`。</span><span class="sxs-lookup"><span data-stu-id="8b46b-507">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="8b46b-508"><xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType>方法用來建立<xref:System.Reflection.MethodInfo>用於靜態`GM`方法建構的泛型型別`Sample<U>`，和<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType>方法再用來建立<xref:System.Reflection.MethodInfo>，方法呼叫中所發出。</span><span class="sxs-lookup"><span data-stu-id="8b46b-508">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A?displayProperty=nameWithType> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="8b46b-509">當執行程式碼範例時，它會將發出的組件儲存為 TypeBuilderGetFieldExample.exe 中。</span><span class="sxs-lookup"><span data-stu-id="8b46b-509">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="8b46b-510">您可以執行 TypeBuilderGetFieldExample.exe，而且您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)比較發出程式碼的程式碼與`Sample`會編譯到本身的程式碼範例的類別。</span><span class="sxs-lookup"><span data-stu-id="8b46b-510">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-511">目前的方法是泛型，但不是泛型方法定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-511">The current method is generic, but is not a generic method definition.</span>
          </span>
          <span data-ttu-id="8b46b-512">亦即，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性是 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性是 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-512">That is, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetReturnType(System.Type)" />
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.SetParameters(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="8b46b-513">符號自訂屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-513">The name of the symbolic custom attribute.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="8b46b-514">位元組 Blob，代表符號自訂屬性的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-514">The byte blob that represents the value of the symbolic custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-515">使用 Blob 設定符號自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-515">Set a symbolic custom attribute using a blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-516">不同於中繼資料的自訂屬性，這個自訂屬性是相關聯的符號寫入器。</span><span class="sxs-lookup"><span data-stu-id="8b46b-516">Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8b46b-517">下列程式碼範例說明的相關用法`SetSymCustomAttribute`方法，以設定名稱和自訂屬性的索引鍵的位元組值附加至的方法。</span><span class="sxs-lookup"><span data-stu-id="8b46b-517">The code sample below illustrates the contextual usage of the `SetSymCustomAttribute` method to set the byte values for the name and key of a custom attribute attached to a method.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CPP/source2.cpp#1)]
 [!code-csharp[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/CS/source2.cs#1)]
 [!code-vb[System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8b46b-518">先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-518">The containing type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="8b46b-519">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-519">-or-</span>
          </span>
          <span data-ttu-id="8b46b-520">包含這個方法的模組不是偵錯模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-520">The module that contains this method is not a debug module.</span>
          </span>
          <span data-ttu-id="8b46b-521">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-521">-or-</span>
          </span>
          <span data-ttu-id="8b46b-522">針對於目前的方法，<see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-522">For the current method, the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethod" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Signature">
      <MemberSignature Language="C#" Value="public string Signature { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Signature" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.MethodBuilder.Signature" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Signature As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Signature { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-523">擷取方法的簽章。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-523">Retrieves the signature of the method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8b46b-524">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-524">Read-only.</span>
          </span>
          <span data-ttu-id="8b46b-525">字串，含有這個 <see langword="MethodBase" /> 執行個體 (Instance) 所反映的方法簽章。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-525">A String containing the signature of the method reflected by this <see langword="MethodBase" /> instance.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="8b46b-526">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-526">Reserved for future use.</span>
          </span>
          <span data-ttu-id="8b46b-527">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-527">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="8b46b-528">要對應之傳入的名稱陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-528">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="8b46b-529">要對應的名稱計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-529">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8b46b-530">用於解譯名稱的地區設定內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-530">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="8b46b-531">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-531">Caller-allocated array that receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-532">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-532">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-533">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="8b46b-533">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8b46b-534">如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="8b46b-534">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8b46b-535">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-535">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="8b46b-536">要傳回的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-536">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8b46b-537">類型資訊的地區設定識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-537">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="8b46b-538">接收要求的類型資訊物件的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-538">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-539">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-539">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-540">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="8b46b-540">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8b46b-541">如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="8b46b-541">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8b46b-542">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-542">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="8b46b-543">指向接收物件提供的類型資訊介面數目的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-543">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-544">擷取物件提供的類型資訊介面數目 (0 或 1)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-544">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-545">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="8b46b-545">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8b46b-546">如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="8b46b-546">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8b46b-547">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-547">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="8b46b-548">辨識成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-548">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="8b46b-549">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-549">Reserved for future use.</span>
          </span>
          <span data-ttu-id="8b46b-550">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-550">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8b46b-551">地區設定內容，用於解譯引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-551">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="8b46b-552">描述呼叫之內容的旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-552">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="8b46b-553">結構的指標，此結構包含引數陣列、指名引數之 DispID 引數的陣列，以及陣列中項目數目的計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-553">Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="8b46b-554">指向用於儲存結果之位置的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-554">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="8b46b-555">包含例外狀況資訊的結構指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-555">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="8b46b-556">第一個有錯誤的引數索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-556">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8b46b-557">提供物件所公開的屬性和方法的存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-557">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8b46b-558">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="8b46b-558">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8b46b-559">如需有關`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="8b46b-559">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8b46b-560">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-560">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.MethodBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8b46b-561">傳回此 <see langword="MethodBuilder" /> 執行個體做為字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-561">Returns this <see langword="MethodBuilder" /> instance as a string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8b46b-562">傳回字串，包含此方法的名稱、屬性、方法簽章、例外狀況和本機簽章，後面接著目前的 Microsoft Intermediate Language (MSIL) 串流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8b46b-562">Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>