<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="3db8e-101">在執行階段定義和建立類別的新執行個體。</span>
      <span class="sxs-lookup">
        <span data-stu-id="3db8e-101">Defines and creates new instances of classes during run time.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-102"><xref:System.Reflection.Emit.TypeBuilder> 根類別用來控制建立動態執行階段中的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-102"><xref:System.Reflection.Emit.TypeBuilder> is the root class used to control the creation of dynamic classes in the runtime.</span></span> <span data-ttu-id="3db8e-103">它提供一組常式，可用來定義類別、 將方法和欄位，以及建立模組內的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-103">It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</span></span> <span data-ttu-id="3db8e-104">新<xref:System.Reflection.Emit.TypeBuilder>可以藉由呼叫建立動態模組從<xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType>方法，這個方法會傳回<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-104">A new <xref:System.Reflection.Emit.TypeBuilder> can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="3db8e-105">反映發出提供下列選項，可定義類型：</span><span class="sxs-lookup"><span data-stu-id="3db8e-105">Reflection emit provides the following options for defining types:</span></span>  
  
-   <span data-ttu-id="3db8e-106">定義類別或具有指定名稱的介面。</span><span class="sxs-lookup"><span data-stu-id="3db8e-106">Define a class or interface with the given name.</span></span>  
  
-   <span data-ttu-id="3db8e-107">定義類別或介面，具有給定名稱和屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-107">Define a class or interface with the given name and attributes.</span></span>  
  
-   <span data-ttu-id="3db8e-108">定義具有指定名稱、 屬性和基底類別的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-108">Define a class with the given name, attributes, and base class.</span></span>  
  
-   <span data-ttu-id="3db8e-109">定義具有指定名稱、 屬性、 基底類別和類別實作的介面的集合類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-109">Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</span></span>  
  
-   <span data-ttu-id="3db8e-110">定義具有指定名稱、 屬性、 基底類別和封裝大小的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-110">Define a class with the given name, attributes, base class, and packing size.</span></span>  
  
-   <span data-ttu-id="3db8e-111">為整體來定義具有指定名稱、 屬性、 基底類別和類別大小的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-111">Define a class with the given name, attributes, base class, and the class size as a whole.</span></span>  
  
-   <span data-ttu-id="3db8e-112">為整體來定義具有指定名稱、 屬性、 基底類別、 封裝大小和類別大小的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-112">Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</span></span>  
  
 <span data-ttu-id="3db8e-113">若要建立陣列類型、 指標類型或不完整的類型所代表的 byref 類型<xref:System.Reflection.Emit.TypeBuilder>物件，請使用<xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A>方法，<xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A>方法，或<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A>方法，分別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-113">To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref:System.Reflection.Emit.TypeBuilder> object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="3db8e-114">一種可用之前，<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType>必須呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-114">Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> method must be called.</span></span> <span data-ttu-id="3db8e-115">**CreateType**完成建立類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-115">**CreateType** completes the creation of the type.</span></span> <span data-ttu-id="3db8e-116">下列呼叫**CreateType**，呼叫端可以使用具現化類型<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法，並使用叫用型別的成員<xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-116">Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-117">它是叫用方法變更之後類型的實作錯誤**CreateType**已呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-117">It is an error to invoke methods that change the implementation of a type after **CreateType** has been called.</span></span> <span data-ttu-id="3db8e-118">如果呼叫端嘗試將新成員加入至類型中，例如，common language runtime 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3db8e-118">For example, the common language runtime throws an exception if the caller tries to add new members to a type.</span></span>  
  
 <span data-ttu-id="3db8e-119">類別初始設定式由使用<xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-119">A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-120">**DefineTypeInitializer**傳回<xref:System.Reflection.Emit.ConstructorBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-120">**DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.</span></span>  
  
 <span data-ttu-id="3db8e-121">透過呼叫其中一個定義巢狀型別<xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-121">Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> methods.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="3db8e-122">屬性</span><span class="sxs-lookup"><span data-stu-id="3db8e-122">Attributes</span></span>  
 <span data-ttu-id="3db8e-123"><xref:System.Reflection.Emit.TypeBuilder>類別會使用<xref:System.Reflection.TypeAttributes>列舉型別，以進一步指定要建立類型的特性：</span><span class="sxs-lookup"><span data-stu-id="3db8e-123">The <xref:System.Reflection.Emit.TypeBuilder> class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:</span></span>  
  
-   <span data-ttu-id="3db8e-124">使用指定的介面<xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType>和<xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-124">Interfaces are specified using the <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> and <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributes.</span></span>  
  
-   <span data-ttu-id="3db8e-125">使用指定實體類別 （無法擴充的類別）<xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-125">Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="3db8e-126">有數個屬性會決定型別可視性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-126">Several attributes determine type visibility.</span></span> <span data-ttu-id="3db8e-127">請參閱描述<xref:System.Reflection.TypeAttributes>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-127">See the description of the <xref:System.Reflection.TypeAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="3db8e-128">如果<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>指定，則它們會讀取中繼資料的順序中的欄位配置類別載入器。</span><span class="sxs-lookup"><span data-stu-id="3db8e-128">If <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is specified, the class loader lays out fields in the order they are read from metadata.</span></span> <span data-ttu-id="3db8e-129">類別載入器會將視為指定的封裝大小，但會忽略任何指定的欄位位移。</span><span class="sxs-lookup"><span data-stu-id="3db8e-129">The class loader considers the specified packing size but ignores any specified field offsets.</span></span> <span data-ttu-id="3db8e-130">中繼資料會保留在其欄位定義不會發出的順序。</span><span class="sxs-lookup"><span data-stu-id="3db8e-130">The metadata preserves the order in which the field definitions are emitted.</span></span> <span data-ttu-id="3db8e-131">即使是跨合併，中繼資料不會重新排列欄位定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-131">Even across a merge, the metadata will not reorder the field definitions.</span></span> <span data-ttu-id="3db8e-132">載入器將會採用指定的欄位位移才<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>指定。</span><span class="sxs-lookup"><span data-stu-id="3db8e-132">The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is specified.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="3db8e-133">已知問題</span><span class="sxs-lookup"><span data-stu-id="3db8e-133">Known Issues</span></span>  
  
-   <span data-ttu-id="3db8e-134">反映發出不會驗證是否實作介面的非抽象類別已實作介面中宣告的所有方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-134">Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</span></span> <span data-ttu-id="3db8e-135">不過，如果類別未實作介面中宣告的所有方法，執行階段不會載入類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-135">However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</span></span>  
  
-   <span data-ttu-id="3db8e-136">雖然<xref:System.Reflection.Emit.TypeBuilder>衍生自<xref:System.Type>，部分中所定義的抽象方法<xref:System.Type>類別並未完整實作中<xref:System.Reflection.Emit.TypeBuilder>類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-136">Although <xref:System.Reflection.Emit.TypeBuilder> is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the <xref:System.Reflection.Emit.TypeBuilder> class.</span></span> <span data-ttu-id="3db8e-137">這些呼叫<xref:System.Reflection.Emit.TypeBuilder>方法會擲回<xref:System.NotSupportedException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3db8e-137">Calls to these <xref:System.Reflection.Emit.TypeBuilder> methods throw a <xref:System.NotSupportedException> exception.</span></span> <span data-ttu-id="3db8e-138">您可以取得所需的功能擷取建立的類型使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>並反映所擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-138">The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and reflecting on the retrieved type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-139">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="3db8e-139">This section contains two code examples.</span></span> <span data-ttu-id="3db8e-140">第一個範例示範如何建立動態類型的欄位、 建構函式、 屬性和方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-140">The first example shows how to create a dynamic type with a field, constructor, property, and method.</span></span> <span data-ttu-id="3db8e-141">第二個範例為基礎的方法，以動態方式從使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="3db8e-141">The second example builds a method dynamically from user input.</span></span>  
  
 <span data-ttu-id="3db8e-142">**其中一個範例**</span><span class="sxs-lookup"><span data-stu-id="3db8e-142">**Example one**</span></span>  
  
 <span data-ttu-id="3db8e-143">下列程式碼範例示範如何定義使用一個模組的動態組件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-143">The following code example shows how to define a dynamic assembly with one module.</span></span> <span data-ttu-id="3db8e-144">範例組件中的模組包含一種類型， `MyDynamicType`，其中包含私用欄位、 取得和設定私用欄位的屬性、 建構函式會初始化私用欄位和將私用欄位的使用者提供數字相乘的方法值，並傳回結果。</span><span class="sxs-lookup"><span data-stu-id="3db8e-144">The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</span></span>  
  
 <span data-ttu-id="3db8e-145"><xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType>建立組件時指定欄位。</span><span class="sxs-lookup"><span data-stu-id="3db8e-145">The <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> field is specified when the assembly is created.</span></span> <span data-ttu-id="3db8e-146">立即使用組件程式碼和組件也會儲存至磁碟，以便可以檢查與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)或用於另一個程式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-146">The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) or used in another program.</span></span>  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 <span data-ttu-id="3db8e-147">**第二則範例**</span><span class="sxs-lookup"><span data-stu-id="3db8e-147">**Example two**</span></span>  
  
 <span data-ttu-id="3db8e-148">下列程式碼範例示範如何建置使用動態類型`TypeBuilder`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-148">The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">
          <span data-ttu-id="3db8e-149">採取如要求、判斷提示等安全性動作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-149">The security action to be taken such as Demand, Assert, and so on.</span>
          </span>
        </param>
        <param name="pset">
          <span data-ttu-id="3db8e-150">此動作適用的權限集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-150">The set of permissions the action applies to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-151">加入此類型的宣告式安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-151">Adds declarative security to this type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-152">`AddDeclarativeSecurity` 無法呼叫多次而指定的安全性動作 （例如要求、 判斷提示或拒絕），一組套用至動作的權限的每個呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-152">`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-153">在.NET framework 1.0、 1.1 和 2.0 中，使用此方法套用至類型的宣告式安全性屬性會儲存在舊的 XML 中繼資料格式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-153">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-154">下列範例示範如何使用`AddDeclarativeSecurity`方法，以新增的安全性要求<xref:System.Security.Permissions.SecurityPermission>與<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>旗標設為動態類型，名為`MyDynamicClass`，名為 EmittedExample.dll 組件中。</span><span class="sxs-lookup"><span data-stu-id="3db8e-154">The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll.</span></span> <span data-ttu-id="3db8e-155">這個範例會產生任何主控台輸出。在執行之後，您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)檢查 EmittedExample.dll。</span><span class="sxs-lookup"><span data-stu-id="3db8e-155">The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine EmittedExample.dll.</span></span> <span data-ttu-id="3db8e-156">在`MyDynamicClass`，開啟`.class public auto ansi`陳述式，請參閱 「 宣告式的權限。</span><span class="sxs-lookup"><span data-stu-id="3db8e-156">In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.</span></span>  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3db8e-157">
            <paramref name="action" /> 無效 (<see langword="RequestMinimum" />、<see langword="RequestOptional" /> 和 <see langword="RequestRefuse" /> 無效)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-157">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-158">已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-158">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-159">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-159">-or-</span>
          </span>
          <span data-ttu-id="3db8e-160">權限集 <paramref name="pset" /> 包含稍早 <see langword="AddDeclarativeSecurity" /> 所加入的動作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-160">The permission set <paramref name="pset" /> contains an action that was added earlier by <see langword="AddDeclarativeSecurity" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-161">
            <paramref name="pset" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-161">
              <paramref name="pset" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="3db8e-162">這個類型所實作的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-162">The interface that this type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-163">加入這個類型所實作的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-163">Adds an interface that this type implements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3db8e-164">下列程式碼範例示範如何動態建立的類型使用介面的實作`AddInterfaceImplementation`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-164">The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-165">
            <paramref name="interfaceType" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-165">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-166">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-166">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-167">擷取包含這個類型定義的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-167">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-168">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-168">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-169">擷取包含這個類型定義的動態組件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-169">Retrieves the dynamic assembly that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-170">傳回這個類型的完整名稱，該名稱是由組件的顯示名稱所限定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-170">Returns the full name of this type qualified by the display name of the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-171">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-171">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-172">這個類型的完整名稱，該名稱是由組件的顯示名稱所限定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-172">The full name of this type qualified by the display name of the assembly.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-173">傳回之字串的格式是類型的完整名稱的串連 (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) 和組件的顯示名稱 (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>)、 以逗號和空格分隔。</span><span class="sxs-lookup"><span data-stu-id="3db8e-173">The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separated by a comma and a space.</span></span>  
  
 <span data-ttu-id="3db8e-174">請參閱<xref:System.Reflection.AssemblyName>的組件的顯示名稱格式的描述。</span><span class="sxs-lookup"><span data-stu-id="3db8e-174">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="3db8e-175">版本資訊</span><span class="sxs-lookup"><span data-stu-id="3db8e-175">Version Information</span></span>  
 <span data-ttu-id="3db8e-176">在.NET framework 1.0 和 1.1 版中，這個屬性的值不包含文化特性或公開金鑰。</span><span class="sxs-lookup"><span data-stu-id="3db8e-176">In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-177">擷取這個類型的基底類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-177">Retrieves the base type of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-178">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-178">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-179">擷取這個類型的基底類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-179">Retrieves the base type of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-180">建立這個類別的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-180">Creates a <see cref="T:System.Type" /> object for the class.</span>
          </span>
          <span data-ttu-id="3db8e-181">定義類別上的欄位和方法之後，呼叫 <see langword="CreateType" /> 以載入其 <see langword="Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-181">After defining fields and methods on the class, <see langword="CreateType" /> is called in order to load its <see langword="Type" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-182">傳回這個類別的新 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-182">Returns the new <see cref="T:System.Type" /> object for this class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-183">如果此類型是巢狀的類型，<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>它稱為巢狀類型上之前，必須在封入類型上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-183">If this type is a nested type, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method must be called on the enclosing type before it is called on the nested type.</span></span>  
  
 <span data-ttu-id="3db8e-184">如果目前的型別衍生自不完整的類型，或實作不完整的介面，呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>父類型，然後再呼叫在目前類型的介面類型上的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-184">If the current type derives from an incomplete type or implements incomplete interfaces, call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the parent type and the interface types before calling it on the current type.</span></span>  
  
 <span data-ttu-id="3db8e-185">如果封入類型包含可定義為巢狀類型 （例如，欄位是列舉型別定義為巢狀型別），實值類型欄位呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上的方法會產生<xref:System.AppDomain.TypeResolve?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-185">If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="3db8e-186">這是因為載入器無法判斷封入類型的大小，直到已完成的巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-186">This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</span></span> <span data-ttu-id="3db8e-187">呼叫端應該定義的處理常式<xref:System.AppDomain.TypeResolve>藉由呼叫完成的巢狀型別定義的事件<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>上<xref:System.Reflection.Emit.TypeBuilder>物件，代表巢狀的類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-187">The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type.</span></span> <span data-ttu-id="3db8e-188">本主題的程式碼範例示範如何定義這類事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-188">The code example for this topic shows how to define such an event handler.</span></span>  
  
 <span data-ttu-id="3db8e-189">建立的類型是一次，不論如何多次<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-189">A type is created only once, no matter how many times the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span> <span data-ttu-id="3db8e-190">所有的呼叫傳回相同<xref:System.Type>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-190">All calls return the same <xref:System.Type> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-191">下列程式碼範例示範如何定義事件處理常式<xref:System.AppDomain.TypeResolve?displayProperty=nameWithType>事件時，才能呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>期間的巢狀類型上的方法<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-191">The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event, in order to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on a nested type during a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> call on the enclosing type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-192">尚未建立封入類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-192">The enclosing type has not been created.</span>
          </span>
          <span data-ttu-id="3db8e-193">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-193">-or-</span>
          </span>
          <span data-ttu-id="3db8e-194">這個類型為非抽象，而且包含抽象方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-194">This type is non-abstract and contains an abstract method.</span>
          </span>
          <span data-ttu-id="3db8e-195">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-195">-or-</span>
          </span>
          <span data-ttu-id="3db8e-196">這個類型不是抽象類別或介面，而且包含沒有方法主體的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-196">This type is not an abstract class or an interface and has a method without a method body.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-197">這個類型包含無效的 Microsoft Intermediate Language (MSIL) 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-197">The type contains invalid Microsoft intermediate language (MSIL) code.</span>
          </span>
          <span data-ttu-id="3db8e-198">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-198">-or-</span>
          </span>
          <span data-ttu-id="3db8e-199">使用 1 個位元組位移指定分支目標，但目標與分支的距離大於 127 個位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-199">The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="3db8e-200">無法載入這個類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-200">The type cannot be loaded.</span>
          </span>
          <span data-ttu-id="3db8e-201">例如，其包含的 <see langword="static" /> 方法具有呼叫慣例 <see cref="F:System.Reflection.CallingConventions.HasThis" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-201">For example, it contains a <see langword="static" /> method that has the calling convention <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-202">取得代表這個類型的 <see cref="T:System.Reflection.TypeInfo" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-202">Gets a <see cref="T:System.Reflection.TypeInfo" /> object that represents this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-203">代表這個類型的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-203">An object that represents this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-204">取得宣告目前泛型類型參數的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-204">Gets the method that declared the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-205">如果目前的類型是泛型類型參數，<see cref="T:System.Reflection.MethodBase" /> 表示宣告目前類型的方法；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-205">A <see cref="T:System.Reflection.MethodBase" /> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-206">當發出程式碼，泛型型別參數由<xref:System.Reflection.Emit.GenericTypeParameterBuilder>物件而非由<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-206">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-207">傳回宣告這個類型的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-207">Returns the type that declared this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-208">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-208">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-209">宣告這個類型的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-209">The type that declared this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-210">將新建構函式加入動態類型中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-210">Adds a new constructor to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="3db8e-211">建構函式的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-211">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-212">建構函式的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-212">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-213">建構函式的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-213">The parameter types of the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-214">將新的建構函式加入此類型，並指定屬性和簽章。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-214">Adds a new constructor to the type, with the given attributes and signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-215">定義的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-215">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-216">如果您沒有定義建構函式為動態類型，自動提供預設建構函式，而且它會呼叫基底類別的預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-216">If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</span></span>  
  
 <span data-ttu-id="3db8e-217">如果您針對您動態類型定義建構函式，未提供預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-217">If you define a constructor for your dynamic type, a default constructor is not provided.</span></span> <span data-ttu-id="3db8e-218">您有下列選項來提供預設建構函式，除了您所定義的建構函式：</span><span class="sxs-lookup"><span data-stu-id="3db8e-218">You have the following options for providing a default constructor in addition to the constructor you defined:</span></span>  
  
-   <span data-ttu-id="3db8e-219">如果您想只會呼叫基底類別的預設建構函式的預設建構函式，您可以使用<xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A>方法來建立一個 （並選擇性地限制存取）。</span><span class="sxs-lookup"><span data-stu-id="3db8e-219">If you want a default constructor that simply calls the default constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it).</span></span> <span data-ttu-id="3db8e-220">請提供此預設建構函式的實作。</span><span class="sxs-lookup"><span data-stu-id="3db8e-220">Do not provide an implementation for this default constructor.</span></span> <span data-ttu-id="3db8e-221">如果您這樣做，當您嘗試使用建構函式時，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3db8e-221">If you do, an exception is thrown when you try to use the constructor.</span></span> <span data-ttu-id="3db8e-222">沒有例外狀況時擲回<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-222">No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
-   <span data-ttu-id="3db8e-223">如果您想要的預設建構函式會不只呼叫預設建構函式的基底類別，或呼叫其他建構函式的基底類別，或沒有其他項目完全，您必須使用<xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType>方法來建立一個，並提供您自己的實作。</span><span class="sxs-lookup"><span data-stu-id="3db8e-223">If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> method to create one, and provide your own implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-224">下列程式碼範例示範如何使用`DefineConstructor`動態類型上設定的建構函式特定的簽章和屬性，並傳回對應<xref:System.Reflection.Emit.ConstructorBuilder>MSIL 母體擴展。</span><span class="sxs-lookup"><span data-stu-id="3db8e-224">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-225">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-225">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="3db8e-226">建構函式的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-226">The attributes of the constructor.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-227">建構函式的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-227">The calling convention of the constructor.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-228">建構函式的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-228">The parameter types of the constructor.</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="3db8e-229">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-229">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-230">每個類型陣列都代表其對應參數必要的自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-230">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-231">如果特定的參數沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-231">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-232">如果這些參數都沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-232">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="3db8e-233">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-233">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-234">每個類型陣列都代表其對應參數的選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-234">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-235">如果特定的參數沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-235">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-236">如果這些參數都沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-236">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-237">將新的建構函式加入此類型，並指定屬性、簽章和自訂修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-237">Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-238">定義的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-238">The defined constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-239">這個多載供設計工具的 managed 編譯器使用。</span><span class="sxs-lookup"><span data-stu-id="3db8e-239">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-240">如需有關自訂修飾詞的詳細資訊，請參閱 ECMA 第 II 中繼資料文件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-240">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="3db8e-241">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-241">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-242">
            <paramref name="requiredCustomModifiers" /> 或 <paramref name="optionalCustomModifiers" /> 的大小不等於 <paramref name="parameterTypes" /> 的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-242">The size of <paramref name="requiredCustomModifiers" /> or <paramref name="optionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-243">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-243">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-244">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-244">-or-</span>
          </span>
          <span data-ttu-id="3db8e-245">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-245">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">
          <span data-ttu-id="3db8e-246">表示要套用至建構函式之屬性的 <see langword="MethodAttributes" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-246">A <see langword="MethodAttributes" /> object representing the attributes to be applied to the constructor.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-247">定義預設建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-247">Defines the default constructor.</span>
          </span>
          <span data-ttu-id="3db8e-248">這裡定義的建構函式只會呼叫父代的預設建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-248">The constructor defined here will simply call the default constructor of the parent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-249">傳回建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-249">Returns the constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-250">因為自動定義的預設建構函式，則需要呼叫這個方法只在下列情況：</span><span class="sxs-lookup"><span data-stu-id="3db8e-250">Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</span></span>  
  
-   <span data-ttu-id="3db8e-251">您已定義其他建構函式，而且也想只會呼叫基底類別建構函式的預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-251">You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</span></span>  
  
-   <span data-ttu-id="3db8e-252">您想要設定屬性的預設建構函式項目以外<xref:System.Reflection.MethodAttributes.PrivateScope>， <xref:System.Reflection.MethodAttributes.Public>， <xref:System.Reflection.MethodAttributes.HideBySig>， <xref:System.Reflection.MethodAttributes.SpecialName>，和<xref:System.Reflection.MethodAttributes.RTSpecialName>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-252">You want to set the attributes on the default constructor to something other than <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, and <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-253">下列程式碼範例示範如何使用`DefineConstructor`動態類型上設定的建構函式特定的簽章和屬性，並傳回對應<xref:System.Reflection.Emit.ConstructorBuilder>MSIL 母體擴展。</span><span class="sxs-lookup"><span data-stu-id="3db8e-253">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-254">父類型 (基底類型) 沒有預設建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-254">The parent type (base type) does not have a default constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-255">之前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-255">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-256">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-256">-or-</span>
          </span>
          <span data-ttu-id="3db8e-257">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-257">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-258">事件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-258">The name of the event.</span>
          </span>
          <span data-ttu-id="3db8e-259">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-259">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-260">事件的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-260">The attributes of the event.</span>
          </span>
        </param>
        <param name="eventtype">
          <span data-ttu-id="3db8e-261">事件的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-261">The type of the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-262">將新事件加入此類型，並指定其名稱、屬性和事件類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-262">Adds a new event to the type, with the given name, attributes and event type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-263">定義的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-263">The defined event.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-264">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-264">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-265">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-265">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-266">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-266">-or-</span>
          </span>
          <span data-ttu-id="3db8e-267">
            <paramref name="eventtype" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-267">
              <paramref name="eventtype" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-268">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-268">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-269">將新欄位加入動態類型中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-269">Adds a new field to the dynamic type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="3db8e-270">欄位的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-270">The name of the field.</span>
          </span>
          <span data-ttu-id="3db8e-271">
            <c>fieldName</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-271">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="3db8e-272">欄位的類型</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-272">The type of the field</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-273">欄位的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-273">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-274">將新欄位加入類型，指定其名稱、屬性和欄位類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-274">Adds a new field to the type, with the given name, attributes, and field type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-275">定義的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-275">The defined field.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-276">
            <paramref name="fieldName" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-276">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-277">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-277">-or-</span>
          </span>
          <span data-ttu-id="3db8e-278">
            <paramref name="type" /> 為 System.Void。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-278">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="3db8e-279">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-279">-or-</span>
          </span>
          <span data-ttu-id="3db8e-280">為這個欄位的父類別指定了總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-280">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-281">
            <paramref name="fieldName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-281">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-282">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-282">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">
          <span data-ttu-id="3db8e-283">欄位的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-283">The name of the field.</span>
          </span>
          <span data-ttu-id="3db8e-284">
            <c>fieldName</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-284">
              <c>fieldName</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="3db8e-285">欄位的類型</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-285">The type of the field</span>
          </span>
        </param>
        <param name="requiredCustomModifiers">
          <span data-ttu-id="3db8e-286">類型陣列，代表欄位的必要自訂修飾詞，例如 <see cref="T:Microsoft.VisualC.IsConstModifier" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-286">An array of types representing the required custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="optionalCustomModifiers">
          <span data-ttu-id="3db8e-287">類型陣列，代表欄位的選擇性自訂修飾詞，例如 <see cref="T:Microsoft.VisualC.IsConstModifier" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-287">An array of types representing the optional custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-288">欄位的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-288">The attributes of the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-289">將新欄位加入此類型，並指定其名稱、屬性、欄位類型和自訂修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-289">Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-290">定義的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-290">The defined field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-291">這個多載供設計工具的 managed 編譯器使用。</span><span class="sxs-lookup"><span data-stu-id="3db8e-291">This overload is provided for designers of managed compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-292">
            <paramref name="fieldName" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-292">The length of <paramref name="fieldName" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-293">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-293">-or-</span>
          </span>
          <span data-ttu-id="3db8e-294">
            <paramref name="type" /> 為 System.Void。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-294">
              <paramref name="type" /> is System.Void.</span>
          </span>
          <span data-ttu-id="3db8e-295">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-295">-or-</span>
          </span>
          <span data-ttu-id="3db8e-296">為這個欄位的父類別指定了總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-296">A total size was specified for the parent class of this field.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-297">
            <paramref name="fieldName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-297">
              <paramref name="fieldName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-298">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-298">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">
          <span data-ttu-id="3db8e-299">泛型類型參數的名稱陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-299">An array of names for the generic type parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-300">定義目前類型的泛型類型參數，即指定其數目和名稱，並傳回可設定其條件約束的 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 物件的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-300">Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to set their constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-301">
            <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> 物件的陣列可用來定義目前類型的泛型類型參數的條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-301">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define the constraints of the generic type parameters for the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-302">呼叫這個方法建立目前的類型是泛型型別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-302">Calling this method makes the current type a generic type.</span></span> <span data-ttu-id="3db8e-303">如果在相同的型別，一次呼叫方法<xref:System.InvalidOperationException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="3db8e-303">If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-304">下列程式碼範例會建立具有兩個型別參數的泛型型別，並將它們儲存在組件 GenericEmitExample1.dll。</span><span class="sxs-lookup"><span data-stu-id="3db8e-304">The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</span></span> <span data-ttu-id="3db8e-305">您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)若要檢視產生的型別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-305">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to view the generated types.</span></span> <span data-ttu-id="3db8e-306">如需定義動態的泛型類型所需的步驟的更詳細說明，請參閱[如何： 定義泛型類型使用反映發出](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-306">For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-307">已定義這個類型的泛型類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-307">Generic type parameters have already been defined for this type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-308">
            <paramref name="names" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-308">
              <paramref name="names" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-309">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-309">-or-</span>
          </span>
          <span data-ttu-id="3db8e-310">
            <paramref name="names" /> 的項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-310">An element of <paramref name="names" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-311">
            <paramref name="names" /> 是空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-311">
              <paramref name="names" /> is an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-312">用來參考資料的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-312">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="3db8e-313">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-313">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="3db8e-314">資料的 blob。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-314">The blob of data.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-315">欄位的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-315">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-316">在可攜式執行檔 (PE) 的 .sdata 區段中定義初始化資料欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-316">Defines initialized data field in the .sdata section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-317">要參考資料的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-317">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-318">您使用這個方法建立的欄位會是`static`，即使您未包含`FieldAttributes.Static`中`attributes`參數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-318">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-319">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-319">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-320">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-320">-or-</span>
          </span>
          <span data-ttu-id="3db8e-321">資料的大小小於或等於零，或者大於或等於 0x3f0000。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-321">The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-322">
            <paramref name="name" /> 或 <paramref name="data" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-322">
              <paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-323">之前已呼叫過 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-323">
              <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> has been previously called.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-324">將方法加入類型中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-324">Adds a method to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-325">方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-325">The name of the method.</span>
          </span>
          <span data-ttu-id="3db8e-326">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-326">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-327">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-327">The attributes of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-328">將新方法加入此類型，並指定其名稱和方法屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-328">Adds a new method to the type, with the specified name and method attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-329">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> 代表新定義的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-329">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-330">當您不知道方法簽章定義的方法時，請使用這個方法多載。</span><span class="sxs-lookup"><span data-stu-id="3db8e-330">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="3db8e-331">例如，參數型別和泛型方法的傳回型別可能指定之方法的泛型型別參數，必須在之後的方法已經加入至類型定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-331">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="3db8e-332">參數和方法的傳回型別可以稍後使用來設定<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-332">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3db8e-333">這個方法多載定義的方法與<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-333">This method overload defines a method with <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3db8e-334">如果您需要定義沒有簽章，以不同呼叫慣例的方法使用<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="3db8e-334">If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-335">下列程式碼範例會定義泛型方法，名為`DemoMethod`其泛型型別參數所指定之參數類型和傳回型別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-335">The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters.</span></span> <span data-ttu-id="3db8e-336">這個方法被定義沒有簽章，使用標準呼叫慣例。</span><span class="sxs-lookup"><span data-stu-id="3db8e-336">The method is defined without a signature, using the standard calling convention.</span></span> <span data-ttu-id="3db8e-337"><xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>方法用來讓`DemoMethod`泛型的方法，並新定義的型別參數，然後用於該簽章和傳回型別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-337">The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.</span></span>  
  
 <span data-ttu-id="3db8e-338">這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-338">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-339">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-339">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-340">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-340">-or-</span>
          </span>
          <span data-ttu-id="3db8e-341">這個方法的父類型是介面，且這個方法不是虛擬 (在 Visual Basic 中為 <see langword="Overridable" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-341">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-342">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-342">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-343">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-343">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-344">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-344">-or-</span>
          </span>
          <span data-ttu-id="3db8e-345">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-345">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-346">方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-346">The name of the method.</span>
          </span>
          <span data-ttu-id="3db8e-347">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-347">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-348">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-348">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-349">方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-349">The calling convention of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-350">將新方法加入類型，並指定其名稱、方法屬性和呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-350">Adds a new method to the type, with the specified name, method attributes, and calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-351">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> 代表新定義的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-351">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-352">當您不知道方法簽章定義的方法時，請使用這個方法多載。</span><span class="sxs-lookup"><span data-stu-id="3db8e-352">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="3db8e-353">例如，參數型別和泛型方法的傳回型別可能指定之方法的泛型型別參數，必須在之後的方法已經加入至類型定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-353">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="3db8e-354">參數和方法的傳回型別可以稍後使用來設定<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-354">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-355">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-355">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-356">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-356">-or-</span>
          </span>
          <span data-ttu-id="3db8e-357">這個方法的父類型是介面，且這個方法不是虛擬 (在 Visual Basic 中為 <see langword="Overridable" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-357">The type of the parent of this method is an interface and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-358">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-358">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-359">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-359">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-360">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-360">-or-</span>
          </span>
          <span data-ttu-id="3db8e-361">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-361">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-362">方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-362">The name of the method.</span>
          </span>
          <span data-ttu-id="3db8e-363">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-363">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-364">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-364">The attributes of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-365">該方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-365">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-366">方法的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-366">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-367">將新方法加入此類型中，含指定名稱、方法屬性和方法簽章。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-367">Adds a new method to the type, with the specified name, method attributes, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-368">已定義的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-368">The defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3db8e-369">下列程式碼範例示範如何使用`DefineMethod`動態類型上設定的建構函式特定的簽章和屬性，並傳回對應<xref:System.Reflection.Emit.MethodBuilder>MSIL 母體擴展。</span><span class="sxs-lookup"><span data-stu-id="3db8e-369">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-370">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-370">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-371">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-371">-or-</span>
          </span>
          <span data-ttu-id="3db8e-372">這個方法的父類型是介面，且這個方法不是虛擬 (在 Visual Basic 中為 <see langword="Overridable" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-372">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-373">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-373">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-374">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-374">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-375">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-375">-or-</span>
          </span>
          <span data-ttu-id="3db8e-376">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-376">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-377">方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-377">The name of the method.</span>
          </span>
          <span data-ttu-id="3db8e-378">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-378">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-379">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-379">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-380">方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-380">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-381">該方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-381">The return type of the method.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-382">方法的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-382">The types of the parameters of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-383">將新方法加入此類型，含指定名稱、方法屬性、呼叫慣例和方法簽章。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-383">Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-384">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> 代表新定義的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-384">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3db8e-385">下列程式碼範例示範如何使用`DefineMethod`動態類型上設定的建構函式特定的簽章和屬性，並傳回對應<xref:System.Reflection.Emit.MethodBuilder>MSIL 母體擴展。</span><span class="sxs-lookup"><span data-stu-id="3db8e-385">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-386">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-386">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-387">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-387">-or-</span>
          </span>
          <span data-ttu-id="3db8e-388">這個方法的父類型是介面，且這個方法不是虛擬 (在 Visual Basic 中為 <see langword="Overridable" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-388">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-389">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-389">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-390">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-390">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-391">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-391">-or-</span>
          </span>
          <span data-ttu-id="3db8e-392">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-392">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-393">方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-393">The name of the method.</span>
          </span>
          <span data-ttu-id="3db8e-394">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-394">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-395">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-395">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-396">方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-396">The calling convention of the method.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-397">該方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-397">The return type of the method.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-398">代表該方法傳回類型之必要自訂修飾詞的類型陣列，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-398">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="3db8e-399">如果傳回類型沒有必要的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-399">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-400">一種類型陣列，用來為方法的傳回類型指出選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-400">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="3db8e-401">如果傳回類型沒有選擇性的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-401">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-402">方法的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-402">The types of the parameters of the method.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-403">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-403">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-404">每個類型陣列都代表其對應參數必要的自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-404">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-405">如果特定的參數沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-405">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-406">如果這些參數都沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-406">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-407">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-407">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-408">每個類型陣列都代表其對應參數的選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-408">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-409">如果特定的參數沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-409">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-410">如果這些參數都沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-410">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-411">將新方法加入此類型，含指定名稱、方法屬性、呼叫慣例、方法簽章和自訂修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-411">Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-412">
            <see cref="T:System.Reflection.Emit.MethodBuilder" /> 物件，代表新加入的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-412">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> object representing the newly added method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-413">如果您要指定自訂修飾詞，請使用此多載。</span><span class="sxs-lookup"><span data-stu-id="3db8e-413">Use this overload if you need to specify custom modifiers.</span></span> <span data-ttu-id="3db8e-414">如果您需要指定自訂修飾詞，建立方法之後, 您一樣，例如，具有泛型方法的參數類型由其泛型型別參數，您可以使用<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29>或<xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29>方法多載，來定義方法，然後使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>方法來定義參數並傳回類型的自訂修飾詞。</span><span class="sxs-lookup"><span data-stu-id="3db8e-414">If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method to define the parameter and return types with custom modifiers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-415">如需有關自訂修飾詞的詳細資訊，請參閱 ECMA 第 II 中繼資料文件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-415">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="3db8e-416">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-416">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-417">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-417">The length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-418">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-418">-or-</span>
          </span>
          <span data-ttu-id="3db8e-419">此方法的父類型是介面，且這個方法不是虛擬 (在 Visual Basic 中為 <see langword="Overridable" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-419">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span>
          </span>
          <span data-ttu-id="3db8e-420">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-420">-or-</span>
          </span>
          <span data-ttu-id="3db8e-421">
            <paramref name="parameterTypeRequiredCustomModifiers" /> 或 <paramref name="parameterTypeOptionalCustomModifiers" /> 的大小不等於 <paramref name="parameterTypes" /> 的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-421">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-422">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-422">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-423">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-423">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-424">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-424">-or-</span>
          </span>
          <span data-ttu-id="3db8e-425">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-425">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">
          <span data-ttu-id="3db8e-426">要使用的方法主體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-426">The method body to be used.</span>
          </span>
          <span data-ttu-id="3db8e-427">這應該為 <see langword="MethodBuilder" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-427">This should be a <see langword="MethodBuilder" /> object.</span>
          </span>
        </param>
        <param name="methodInfoDeclaration">
          <span data-ttu-id="3db8e-428">要使用其宣告的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-428">The method whose declaration is to be used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-429">指定實作給定方法宣告的給定方法主體，可能會使用其他名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-429">Specifies a given method body that implements a given method declaration, potentially with a different name.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-430">請勿使用這個方法來發出方法覆寫或介面實作。</span><span class="sxs-lookup"><span data-stu-id="3db8e-430">Do not use this method to emit method overrides or interface implementations.</span></span> <span data-ttu-id="3db8e-431">若要覆寫基底類別的方法或實作介面的方法，直接發出與具有相同名稱和簽章的方法為方法，以覆寫或實作，在程式碼範例所示。</span><span class="sxs-lookup"><span data-stu-id="3db8e-431">To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="3db8e-432"><xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>方法可在方法主體，方法宣告具有不同的名稱。</span><span class="sxs-lookup"><span data-stu-id="3db8e-432">The <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is used when a method body and a method declaration have different names.</span></span> <span data-ttu-id="3db8e-433">例如，類別可能會覆寫基底類別方法，並也提供不同的實作介面成員相同的名稱，在程式碼範例所示。</span><span class="sxs-lookup"><span data-stu-id="3db8e-433">For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="3db8e-434">`DefineMethodOverride` 定義`methodimpl`，其中包含的一組中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="3db8e-434">`DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens.</span></span> <span data-ttu-id="3db8e-435">一個語彙基元指標實作，而其他語彙基元指向主體所實作的宣告。</span><span class="sxs-lookup"><span data-stu-id="3db8e-435">One token points to an implementation, and the other token points to a declaration that the body implements.</span></span> <span data-ttu-id="3db8e-436">主體必須定義上，定義方法實作為型別，而且主體必須是虛擬 (`Overridable`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-436">The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic).</span></span> <span data-ttu-id="3db8e-437">宣告可定義類型、 在衍生類別中的方法或方法之類型中定義所實作的介面上的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-437">The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</span></span> <span data-ttu-id="3db8e-438">宣告是否位於僅限介面上，這被改變介面定義的位置。</span><span class="sxs-lookup"><span data-stu-id="3db8e-438">If the declaration is on an interface only, the slot defined for the interface is altered.</span></span> <span data-ttu-id="3db8e-439">如果宣告對基底類型上的方法，會覆寫方法的位置，並覆寫方法的任何複本也會被取代。</span><span class="sxs-lookup"><span data-stu-id="3db8e-439">If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</span></span> <span data-ttu-id="3db8e-440">覆寫的方法不可以宣告的實際方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-440">The overridden method cannot be the actual method that is declared.</span></span> <span data-ttu-id="3db8e-441">如果該方法是在相同的型別，則取代位置，並且覆寫已取代方法的任何複本。</span><span class="sxs-lookup"><span data-stu-id="3db8e-441">If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-442">如需 impls 方法的詳細資訊，請參閱`MethodImpl`ECMA 第 II 中繼資料文件中。</span><span class="sxs-lookup"><span data-stu-id="3db8e-442">For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="3db8e-443">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-443">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3db8e-444">之後<xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>呼叫方法時，某些功能`methodInfoBody`無法變更。</span><span class="sxs-lookup"><span data-stu-id="3db8e-444">After the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is called, some features of `methodInfoBody` cannot be changed.</span></span> <span data-ttu-id="3db8e-445">例如，您無法屬性套用至泛型類型參數的`methodInfoBody`使用<xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-445">For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="3db8e-446">如果您必須使用<xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>方法，這樣做之後的所有特性`methodInfoBody`尚未定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-446">If you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method, do so after all characteristics of `methodInfoBody` have been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-447">下列程式碼範例包含介面`I`方法`M()`，基底類別`A`介面，並在衍生的類別實作`C`會覆寫的基底類別實作`M()`以及提供個別的明確實作的`I.M()`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-447">The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.</span></span>  
  
 <span data-ttu-id="3db8e-448">`main()`方法的程式碼範例示範如何發出衍生的類別`C`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-448">The `main()` method of the code example shows how to emit the derived class `C`.</span></span> <span data-ttu-id="3db8e-449">覆寫`A.M()`只要發出方法即可完成`M()`相同的簽章。</span><span class="sxs-lookup"><span data-stu-id="3db8e-449">The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature.</span></span> <span data-ttu-id="3db8e-450">不過，若要提供的不同實作`I.M()`，您必須定義方法主體，然後使用<xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A>方法產生關聯的方法主體<xref:System.Reflection.MethodInfo>代表`I.M()`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-450">However, to provide a separate implementation of `I.M()`, you must define a method body and then use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`.</span></span> <span data-ttu-id="3db8e-451">方法主體的名稱並不重要。</span><span class="sxs-lookup"><span data-stu-id="3db8e-451">The name of the method body does not matter.</span></span>  
  
 <span data-ttu-id="3db8e-452">程式碼範例會建立發出類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="3db8e-452">The code example creates an instance of the emitted class.</span></span> <span data-ttu-id="3db8e-453">它會取得<xref:System.Reflection.MethodInfo>物件`I.M()`，並使用它來叫用發出之的類別的明確介面實作。</span><span class="sxs-lookup"><span data-stu-id="3db8e-453">It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation.</span></span> <span data-ttu-id="3db8e-454">接著取得<xref:System.Reflection.MethodInfo>物件`A.M()`，並用它來叫用該方法發出的類別覆寫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-454">It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.</span></span>  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-455">
            <paramref name="methodInfoBody" /> 不屬於這個類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-455">
              <paramref name="methodInfoBody" /> does not belong to this class.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-456">
            <paramref name="methodInfoBody" /> 或 <paramref name="methodInfoDeclaration" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-456">
              <paramref name="methodInfoBody" /> or <paramref name="methodInfoDeclaration" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-457">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-457">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-458">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-458">-or-</span>
          </span>
          <span data-ttu-id="3db8e-459">
            <paramref name="methodInfoBody" /> 的宣告型別不是由此 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 表示的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-459">The declaring type of <paramref name="methodInfoBody" /> is not the type represented by this <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-460">定義巢狀類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-460">Defines a nested type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-461">型別的簡短名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-461">The short name of the type.</span>
          </span>
          <span data-ttu-id="3db8e-462">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-462">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-463">定義巢狀類型，並指定其名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-463">Defines a nested type, given its name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-464">定義的巢狀型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-464">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-465">這個方法可以用來建立巢狀型別後還是<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-465">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="3db8e-466">巢狀的類型必須先完成您可以使用來反映<xref:System.Type.GetMembers%2A>， <xref:System.Type.GetNestedType%2A>，或<xref:System.Type.GetNestedTypes%2A>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-466">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="3db8e-467">請參閱描述<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>中巢狀型別和巢狀型別應該完成的訂單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-467">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="3db8e-468">重複的名稱不一定是建立如果`name`等同於先前定義的類型或巢狀的類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="3db8e-468">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="3db8e-469">若要重複項目，必須是完整的名稱相同，包括命名空間和所有的巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-469">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-470">
            <paramref name="name" /> 的長度為零或大於 1023。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-470">Length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="3db8e-471">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-471">-or-</span>
          </span>
          <span data-ttu-id="3db8e-472">這項作業會以目前組件中的重複 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 來建立類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-472">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-473">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-473">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-474">型別的簡短名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-474">The short name of the type.</span>
          </span>
          <span data-ttu-id="3db8e-475">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-475">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="3db8e-476">類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-476">The attributes of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-477">定義巢狀類型，並指定其名稱及屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-477">Defines a nested type, given its name and attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-478">定義的巢狀型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-478">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-479">這個方法可以用來建立巢狀型別後還是<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-479">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="3db8e-480">巢狀的類型必須先完成您可以使用來反映<xref:System.Type.GetMembers%2A>， <xref:System.Type.GetNestedType%2A>，或<xref:System.Type.GetNestedTypes%2A>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-480">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="3db8e-481">請參閱描述<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>中巢狀型別和巢狀型別應該完成的訂單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-481">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="3db8e-482">重複的名稱不一定是建立如果`name`等同於先前定義的類型或巢狀的類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="3db8e-482">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="3db8e-483">若要重複項目，必須是完整的名稱相同，包括命名空間和所有的巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-483">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-484">未指定巢狀屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-484">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="3db8e-485">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-485">-or-</span>
          </span>
          <span data-ttu-id="3db8e-486">這個類型已密封。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-486">This type is sealed.</span>
          </span>
          <span data-ttu-id="3db8e-487">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-487">-or-</span>
          </span>
          <span data-ttu-id="3db8e-488">這個型別是陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-488">This type is an array.</span>
          </span>
          <span data-ttu-id="3db8e-489">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-489">-or-</span>
          </span>
          <span data-ttu-id="3db8e-490">這個型別是介面，但巢狀型別不是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-490">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="3db8e-491">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-491">-or-</span>
          </span>
          <span data-ttu-id="3db8e-492">
            <paramref name="name" /> 的長度為零或大於 1023。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-492">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="3db8e-493">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-493">-or-</span>
          </span>
          <span data-ttu-id="3db8e-494">這項作業會以目前組件中的重複 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 來建立類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-494">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-495">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-495">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-496">型別的簡短名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-496">The short name of the type.</span>
          </span>
          <span data-ttu-id="3db8e-497">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-497">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="3db8e-498">類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-498">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="3db8e-499">巢狀型別所擴充的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-499">The type that the nested type extends.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-500">定義巢狀類型，並指定其名稱、屬性和擴充的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-500">Defines a nested type, given its name, attributes, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-501">定義的巢狀型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-501">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-502">這個方法可以用來建立巢狀型別後還是<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-502">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="3db8e-503">巢狀的類型必須先完成您可以使用來反映<xref:System.Type.GetMembers%2A>， <xref:System.Type.GetNestedType%2A>，或<xref:System.Type.GetNestedTypes%2A>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-503">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="3db8e-504">請參閱描述<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>中巢狀型別和巢狀型別應該完成的訂單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-504">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="3db8e-505">重複的名稱不一定是建立如果`name`等同於先前定義的類型或巢狀的類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="3db8e-505">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="3db8e-506">若要重複項目，必須是完整的名稱相同，包括命名空間和所有的巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-506">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-507">未指定巢狀屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-507">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="3db8e-508">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-508">-or-</span>
          </span>
          <span data-ttu-id="3db8e-509">這個類型已密封。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-509">This type is sealed.</span>
          </span>
          <span data-ttu-id="3db8e-510">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-510">-or-</span>
          </span>
          <span data-ttu-id="3db8e-511">這個型別是陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-511">This type is an array.</span>
          </span>
          <span data-ttu-id="3db8e-512">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-512">-or-</span>
          </span>
          <span data-ttu-id="3db8e-513">這個型別是介面，但巢狀型別不是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-513">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="3db8e-514">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-514">-or-</span>
          </span>
          <span data-ttu-id="3db8e-515">
            <paramref name="name" /> 的長度為零或大於 1023。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-515">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="3db8e-516">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-516">-or-</span>
          </span>
          <span data-ttu-id="3db8e-517">這項作業會以目前組件中的重複 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 來建立類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-517">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-518">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-518">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-519">型別的簡短名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-519">The short name of the type.</span>
          </span>
          <span data-ttu-id="3db8e-520">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-520">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="3db8e-521">類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-521">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="3db8e-522">巢狀型別所擴充的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-522">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="3db8e-523">型別的總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-523">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-524">定義巢狀型別，指定其名稱、屬性、型別的總大小及其擴充的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-524">Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-525">定義的巢狀型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-525">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-526">這個方法可以用來建立巢狀型別後還是<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-526">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="3db8e-527">巢狀的類型必須先完成您可以使用來反映<xref:System.Type.GetMembers%2A>， <xref:System.Type.GetNestedType%2A>，或<xref:System.Type.GetNestedTypes%2A>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-527">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="3db8e-528">請參閱描述<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>中巢狀型別和巢狀型別應該完成的訂單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-528">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="3db8e-529">重複的名稱不一定是建立如果`name`等同於先前定義的類型或巢狀的類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="3db8e-529">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="3db8e-530">若要重複項目，必須是完整的名稱相同，包括命名空間和所有的巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-530">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-531">未指定巢狀屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-531">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="3db8e-532">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-532">-or-</span>
          </span>
          <span data-ttu-id="3db8e-533">這個類型已密封。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-533">This type is sealed.</span>
          </span>
          <span data-ttu-id="3db8e-534">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-534">-or-</span>
          </span>
          <span data-ttu-id="3db8e-535">這個型別是陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-535">This type is an array.</span>
          </span>
          <span data-ttu-id="3db8e-536">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-536">-or-</span>
          </span>
          <span data-ttu-id="3db8e-537">這個型別是介面，但巢狀型別不是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-537">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="3db8e-538">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-538">-or-</span>
          </span>
          <span data-ttu-id="3db8e-539">
            <paramref name="name" /> 的長度為零或大於 1023。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-539">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="3db8e-540">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-540">-or-</span>
          </span>
          <span data-ttu-id="3db8e-541">這項作業會以目前組件中的重複 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 來建立類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-541">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-542">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-542">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-543">型別的簡短名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-543">The short name of the type.</span>
          </span>
          <span data-ttu-id="3db8e-544">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-544">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="3db8e-545">類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-545">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="3db8e-546">巢狀型別所擴充的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-546">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="3db8e-547">類型的封裝大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-547">The packing size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-548">定義巢狀類型，並指定其名稱、屬性、擴充的類型和封裝大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-548">Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-549">定義的巢狀型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-549">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-550">這個方法可以用來建立巢狀型別後還是<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-550">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="3db8e-551">巢狀的類型必須先完成您可以使用來反映<xref:System.Type.GetMembers%2A>， <xref:System.Type.GetNestedType%2A>，或<xref:System.Type.GetNestedTypes%2A>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-551">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="3db8e-552">請參閱描述<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>中巢狀型別和巢狀型別應該完成的訂單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-552">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="3db8e-553">重複的名稱不一定是建立如果`name`等同於先前定義的類型或巢狀的類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="3db8e-553">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="3db8e-554">若要重複項目，必須是完整的名稱相同，包括命名空間和所有的巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-554">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-555">未指定巢狀屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-555">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="3db8e-556">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-556">-or-</span>
          </span>
          <span data-ttu-id="3db8e-557">這個類型已密封。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-557">This type is sealed.</span>
          </span>
          <span data-ttu-id="3db8e-558">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-558">-or-</span>
          </span>
          <span data-ttu-id="3db8e-559">這個型別是陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-559">This type is an array.</span>
          </span>
          <span data-ttu-id="3db8e-560">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-560">-or-</span>
          </span>
          <span data-ttu-id="3db8e-561">這個型別是介面，但巢狀型別不是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-561">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="3db8e-562">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-562">-or-</span>
          </span>
          <span data-ttu-id="3db8e-563">
            <paramref name="name" /> 的長度為零或大於 1023。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-563">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="3db8e-564">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-564">-or-</span>
          </span>
          <span data-ttu-id="3db8e-565">這項作業會以目前組件中的重複 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 來建立類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-565">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-566">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-566">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-567">型別的簡短名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-567">The short name of the type.</span>
          </span>
          <span data-ttu-id="3db8e-568">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-568">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="3db8e-569">類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-569">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="3db8e-570">巢狀類型擴充的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-570">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="interfaces">
          <span data-ttu-id="3db8e-571">巢狀類型實作的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-571">The interfaces that the nested type implements.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-572">定義巢狀類型，並指定其名稱、屬性、擴充的類型和實作的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-572">Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-573">定義的巢狀型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-573">The defined nested type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-574">這個方法可以用來建立巢狀型別後還是<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>封入類型上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-574">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="3db8e-575">巢狀的類型必須先完成您可以使用來反映<xref:System.Type.GetMembers%2A>， <xref:System.Type.GetNestedType%2A>，或<xref:System.Type.GetNestedTypes%2A>。</span><span class="sxs-lookup"><span data-stu-id="3db8e-575">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="3db8e-576">請參閱描述<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>中巢狀型別和巢狀型別應該完成的訂單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-576">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="3db8e-577">重複的名稱不一定是建立如果`name`等同於先前定義的類型或巢狀的類型的名稱。</span><span class="sxs-lookup"><span data-stu-id="3db8e-577">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="3db8e-578">若要重複項目，必須是完整的名稱相同，包括命名空間和所有的巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-578">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-579">未指定巢狀屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-579">The nested attribute is not specified.</span>
          </span>
          <span data-ttu-id="3db8e-580">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-580">-or-</span>
          </span>
          <span data-ttu-id="3db8e-581">這個類型已密封。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-581">This type is sealed.</span>
          </span>
          <span data-ttu-id="3db8e-582">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-582">-or-</span>
          </span>
          <span data-ttu-id="3db8e-583">這個型別是陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-583">This type is an array.</span>
          </span>
          <span data-ttu-id="3db8e-584">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-584">-or-</span>
          </span>
          <span data-ttu-id="3db8e-585">這個型別是介面，但巢狀型別不是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-585">This type is an interface, but the nested type is not an interface.</span>
          </span>
          <span data-ttu-id="3db8e-586">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-586">-or-</span>
          </span>
          <span data-ttu-id="3db8e-587">
            <paramref name="name" /> 的長度為零或大於 1023。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-587">The length of <paramref name="name" /> is zero or greater than 1023.</span>
          </span>
          <span data-ttu-id="3db8e-588">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-588">-or-</span>
          </span>
          <span data-ttu-id="3db8e-589">這項作業會以目前組件中的重複 <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> 來建立類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-589">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-590">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-590">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-591">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-591">-or-</span>
          </span>
          <span data-ttu-id="3db8e-592">
            <paramref name="interfaces" /> 陣列的項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-592">An element of the <paramref name="interfaces" /> array is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-593">型別的簡短名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-593">The short name of the type.</span>
          </span>
          <span data-ttu-id="3db8e-594">
            <c>name</c> 不能包含內嵌的 Null 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-594">
              <c>name</c> cannot contain embedded null values.</span>
          </span>
        </param>
        <param name="attr">
          <span data-ttu-id="3db8e-595">類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-595">The attributes of the type.</span>
          </span>
        </param>
        <param name="parent">
          <span data-ttu-id="3db8e-596">巢狀型別所擴充的型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-596">The type that the nested type extends.</span>
          </span>
        </param>
        <param name="packSize">
          <span data-ttu-id="3db8e-597">類型的封裝大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-597">The packing size of the type.</span>
          </span>
        </param>
        <param name="typeSize">
          <span data-ttu-id="3db8e-598">型別的總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-598">The total size of the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-599">定義巢狀類型，並指定其名稱、屬性、大小和擴充的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-599">Defines a nested type, given its name, attributes, size, and the type that it extends.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-600">定義的巢狀型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-600">The defined nested type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-601">定義 <see langword="PInvoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-601">Defines a <see langword="PInvoke" /> method.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-602">
            <see langword="PInvoke" /> 方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-602">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="3db8e-603">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-603">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="3db8e-604">
            <see langword="PInvoke" /> 方法定義所在的 DLL 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-604">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-605">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-605">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-606">方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-606">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-607">方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-607">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-608">方法參數的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-608">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="3db8e-609">原生呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-609">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="3db8e-610">方法的原生字元集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-610">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-611">定義 <see langword="PInvoke" /> 方法指定名稱、方法定義所在的 DLL 名稱、方法的屬性、方法的呼叫慣例、方法的傳回類型、方法的參數類型和 <see langword="PInvoke" /> 旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-611">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-612">已定義的 <see langword="PInvoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-612">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-613">某些 DLL 匯入屬性 (請參閱描述<xref:System.Runtime.InteropServices.DllImportAttribute>) 不能指定為此方法的引數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-613">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="3db8e-614">例如，DLL 匯入屬性<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>必須之後加入`PInvoke`建立方法時，如果此方法傳回的值。</span><span class="sxs-lookup"><span data-stu-id="3db8e-614">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="3db8e-615">此範例示範如何執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="3db8e-615">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-616">下列範例示範如何使用<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A>方法來建立`PInvoke`方法，以及如何新增<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>旗標，以在建立之後的方法實作旗標<xref:System.Reflection.Emit.MethodBuilder>，使用<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>和<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-616">The following example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3db8e-617">若要取得非零的傳回值，您必須加入<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="3db8e-617">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="3db8e-618">此範例會建立為單一型別，與一個動態模組的動態組件`MyType`，其中包含`PInvoke`方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-618">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="3db8e-619">`PInvoke`方法代表 Win32`GetTickCount`函式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-619">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="3db8e-620">執行範例時，它會執行`PInvoke`方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-620">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="3db8e-621">它也會儲存為 PInvokeTest.dll 的動態組件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-621">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="3db8e-622">您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)檢查`MyType`類別和`static`(`Shared`在 Visual Basic 中)`PInvoke`它所包含的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-622">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="3db8e-623">您可以編譯 Visual Basic 或 C# 的程式，以使用靜態`MyType.GetTickCount`方法包括 DLL 的參考，當您執行 csc.exe 或 vbc.exe; 例如， `/r:PInvokeTest.dll`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-623">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-624">這個方法不是靜態的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-624">The method is not static.</span>
          </span>
          <span data-ttu-id="3db8e-625">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-625">-or-</span>
          </span>
          <span data-ttu-id="3db8e-626">父類型是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-626">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="3db8e-627">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-627">-or-</span>
          </span>
          <span data-ttu-id="3db8e-628">這是抽象方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-628">The method is abstract.</span>
          </span>
          <span data-ttu-id="3db8e-629">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-629">-or-</span>
          </span>
          <span data-ttu-id="3db8e-630">方法之前已定義過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-630">The method was previously defined.</span>
          </span>
          <span data-ttu-id="3db8e-631">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-631">-or-</span>
          </span>
          <span data-ttu-id="3db8e-632">
            <paramref name="name" /> 或 <paramref name="dllName" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-632">The length of <paramref name="name" /> or <paramref name="dllName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-633">
            <paramref name="name" /> 或 <paramref name="dllName" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-633">
              <paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-634">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-634">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-635">
            <see langword="PInvoke" /> 方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-635">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="3db8e-636">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-636">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="3db8e-637">
            <see langword="PInvoke" /> 方法定義所在的 DLL 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-637">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="3db8e-638">DLL 中的進入點名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-638">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-639">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-639">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-640">方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-640">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-641">方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-641">The method's return type.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-642">方法參數的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-642">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="3db8e-643">原生呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-643">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="3db8e-644">方法的原生字元集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-644">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-645">定義 <see langword="PInvoke" /> 方法指定名稱、方法定義所在的 DLL 名稱、進入點名稱、方法的屬性、方法的呼叫慣例、方法的傳回類型、方法的參數類型和 <see langword="PInvoke" /> 旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-645">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-646">已定義的 <see langword="PInvoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-646">The defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-647">某些 DLL 匯入屬性 (請參閱描述<xref:System.Runtime.InteropServices.DllImportAttribute>) 不能指定為此方法的引數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-647">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="3db8e-648">例如，DLL 匯入屬性<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>必須之後加入`PInvoke`建立方法時，如果此方法傳回的值。</span><span class="sxs-lookup"><span data-stu-id="3db8e-648">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="3db8e-649">此範例示範如何執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="3db8e-649">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-650">下列程式碼範例示範如何使用<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A>方法來建立`PInvoke`方法，以及如何新增<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>旗標，以在建立之後的方法實作旗標<xref:System.Reflection.Emit.MethodBuilder>，使用<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>和<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-650">The following code example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3db8e-651">若要取得非零的傳回值，您必須加入<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="3db8e-651">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="3db8e-652">此範例會建立為單一型別，與一個動態模組的動態組件`MyType`，其中包含`PInvoke`方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-652">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="3db8e-653">`PInvoke`方法代表 Win32`GetTickCount`函式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-653">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="3db8e-654">執行範例時，它會執行`PInvoke`方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-654">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="3db8e-655">它也會儲存為 PInvokeTest.dll 的動態組件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-655">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="3db8e-656">您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)檢查`MyType`類別和`static`(`Shared`在 Visual Basic 中)`PInvoke`它所包含的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-656">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="3db8e-657">您可以編譯 Visual Basic 或 C# 的程式，以使用靜態`MyType.GetTickCount`方法包括 DLL 的參考，當您執行 csc.exe 或 vbc.exe; 例如， `/r:PInvokeTest.dll`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-657">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-658">這個方法不是靜態的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-658">The method is not static.</span>
          </span>
          <span data-ttu-id="3db8e-659">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-659">-or-</span>
          </span>
          <span data-ttu-id="3db8e-660">父類型是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-660">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="3db8e-661">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-661">-or-</span>
          </span>
          <span data-ttu-id="3db8e-662">這是抽象方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-662">The method is abstract.</span>
          </span>
          <span data-ttu-id="3db8e-663">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-663">-or-</span>
          </span>
          <span data-ttu-id="3db8e-664">方法之前已定義過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-664">The method was previously defined.</span>
          </span>
          <span data-ttu-id="3db8e-665">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-665">-or-</span>
          </span>
          <span data-ttu-id="3db8e-666">
            <paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-666">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-667">
            <paramref name="name" />
            <paramref name="dllName" /> 或 <paramref name="entryName" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-667">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-668">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-668">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-669">
            <see langword="PInvoke" /> 方法的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-669">The name of the <see langword="PInvoke" /> method.</span>
          </span>
          <span data-ttu-id="3db8e-670">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-670">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="dllName">
          <span data-ttu-id="3db8e-671">
            <see langword="PInvoke" /> 方法定義所在的 DLL 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-671">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span>
          </span>
        </param>
        <param name="entryName">
          <span data-ttu-id="3db8e-672">DLL 中的進入點名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-672">The name of the entry point in the DLL.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-673">方法的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-673">The attributes of the method.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-674">方法的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-674">The method's calling convention.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-675">方法的傳回類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-675">The method's return type.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-676">一種類型陣列，用來為方法的傳回類型指出必要的自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-676">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="3db8e-677">如果傳回類型沒有必要的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-677">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-678">一種類型陣列，用來為方法的傳回類型指出選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-678">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span>
          </span>
          <span data-ttu-id="3db8e-679">如果傳回類型沒有選擇性的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-679">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-680">方法參數的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-680">The types of the method's parameters.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-681">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-681">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-682">每個類型陣列都代表其對應參數必要的自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-682">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-683">如果特定的參數沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-683">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-684">如果這些參數都沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-684">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-685">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-685">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-686">每個類型陣列都代表其對應參數的選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-686">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-687">如果特定的參數沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-687">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-688">如果這些參數都沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-688">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="nativeCallConv">
          <span data-ttu-id="3db8e-689">原生呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-689">The native calling convention.</span>
          </span>
        </param>
        <param name="nativeCharSet">
          <span data-ttu-id="3db8e-690">方法的原生字元集。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-690">The method's native character set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-691">定義 <see langword="PInvoke" /> 方法，方法是指定其名稱、方法定義所在的 DLL 名稱、進入點名稱、方法的屬性、方法的呼叫慣例、方法的傳回類型、方法的參數類型、<see langword="PInvoke" /> 旗標和這些參數與傳回類型的自訂修飾詞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-691">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <see langword="PInvoke" /> flags, and custom modifiers for the parameters and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-692">
            <see cref="T:System.Reflection.Emit.MethodBuilder" />，代表定義的 <see langword="PInvoke" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-692">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the defined <see langword="PInvoke" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-693">某些 DLL 匯入屬性 (請參閱描述<xref:System.Runtime.InteropServices.DllImportAttribute>) 不能指定為此方法的引數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-693">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="3db8e-694">例如，DLL 匯入屬性<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>必須之後加入`PInvoke`建立方法時，如果此方法傳回的值。</span><span class="sxs-lookup"><span data-stu-id="3db8e-694">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="3db8e-695">此範例示範如何執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="3db8e-695">The example shows how to do this.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-696">如需有關自訂修飾詞的詳細資訊，請參閱 ECMA 第 II 中繼資料文件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-696">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="3db8e-697">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-697">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-698">下列程式碼範例示範如何使用 [\]，型別\[\]，型別\[\]，型別\[\]\[\]，型別\[\] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > 方法來建立`PInvoke`方法，以及如何新增<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>旗標，以在建立之後的方法實作旗標<xref:System.Reflection.Emit.MethodBuilder>，使用<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>和<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-698">The following code example demonstrates how to use the [\], Type\[\], Type\[\], Type\[\]\[\], Type\[\]\<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="3db8e-699">此範例會建立為單一型別，與一個動態模組的動態組件`MyType`，其中包含`PInvoke`方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-699">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="3db8e-700">`PInvoke`方法代表 Win32`GetTickCount`函式。</span><span class="sxs-lookup"><span data-stu-id="3db8e-700">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3db8e-701">若要取得非零的傳回值，您必須加入<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="3db8e-701">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-702">此範例會使用未指定的自訂修飾詞的多載。</span><span class="sxs-lookup"><span data-stu-id="3db8e-702">The example uses an overload that does not specify custom modifiers.</span></span> <span data-ttu-id="3db8e-703">若要指定自訂修飾詞，變更的範例程式碼，改為使用這個方法多載。</span><span class="sxs-lookup"><span data-stu-id="3db8e-703">To specify custom modifiers, change the example code to use this method overload instead.</span></span>  
  
 <span data-ttu-id="3db8e-704">執行範例時，它會執行`PInvoke`方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-704">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="3db8e-705">它也會儲存為 PInvokeTest.dll 的動態組件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-705">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="3db8e-706">您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)檢查`MyType`類別和`static`(`Shared`在 Visual Basic 中)`PInvoke`它所包含的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-706">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="3db8e-707">您可以編譯 Visual Basic 或 C# 的程式，以使用靜態`MyType.GetTickCount`方法包括 DLL 的參考，當您執行 csc.exe 或 vbc.exe; 例如， `/r:PInvokeTest.dll`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-707">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-708">這個方法不是靜態的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-708">The method is not static.</span>
          </span>
          <span data-ttu-id="3db8e-709">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-709">-or-</span>
          </span>
          <span data-ttu-id="3db8e-710">父類型是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-710">The parent type is an interface.</span>
          </span>
          <span data-ttu-id="3db8e-711">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-711">-or-</span>
          </span>
          <span data-ttu-id="3db8e-712">這是抽象方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-712">The method is abstract.</span>
          </span>
          <span data-ttu-id="3db8e-713">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-713">-or-</span>
          </span>
          <span data-ttu-id="3db8e-714">方法之前已定義過。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-714">The method was previously defined.</span>
          </span>
          <span data-ttu-id="3db8e-715">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-715">-or-</span>
          </span>
          <span data-ttu-id="3db8e-716">
            <paramref name="name" />、<paramref name="dllName" /> 或 <paramref name="entryName" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-716">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-717">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-717">-or-</span>
          </span>
          <span data-ttu-id="3db8e-718">
            <paramref name="parameterTypeRequiredCustomModifiers" /> 或 <paramref name="parameterTypeOptionalCustomModifiers" /> 的大小不等於 <paramref name="parameterTypes" /> 的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-718">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-719">
            <paramref name="name" />
            <paramref name="dllName" /> 或 <paramref name="entryName" /> 是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-719">
              <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-720">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-720">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-721">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-721">-or-</span>
          </span>
          <span data-ttu-id="3db8e-722">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-722">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-723">將新屬性加入類型中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-723">Adds a new property to the type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-724">屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-724">The name of the property.</span>
          </span>
          <span data-ttu-id="3db8e-725">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-725">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-726">這個屬性 (Property) 的屬性 (Attribute)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-726">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-727">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-727">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-728">屬性的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-728">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-729">以指定名稱和屬性簽章將新屬性加入此類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-729">Adds a new property to the type, with the given name and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-730">定義的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-730">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3db8e-731">下列程式碼範例示範如何定義動態屬性，並取得<xref:System.Reflection.Emit.PropertyBuilder>規格。</span><span class="sxs-lookup"><span data-stu-id="3db8e-731">The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification.</span></span> <span data-ttu-id="3db8e-732">請注意，`PropertyBuilder`也必須有對應<xref:System.Reflection.Emit.MethodBuilder>，其中將包含 IL 邏輯屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-732">Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-733">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-733">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-734">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-734">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-735">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-735">-or-</span>
          </span>
          <span data-ttu-id="3db8e-736">
            <paramref name="parameterTypes" /> 陣列的所有項目都是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-736">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-737">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-737">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-738">屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-738">The name of the property.</span>
          </span>
          <span data-ttu-id="3db8e-739">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-739">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-740">這個屬性 (Property) 的屬性 (Attribute)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-740">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-741">屬性存取子的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-741">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-742">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-742">The return type of the property.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-743">屬性的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-743">The types of the parameters of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-744">將新屬性加入具有指定名稱、屬性、呼叫慣例和屬性簽章的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-744">Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-745">定義的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-745">The defined property.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-746">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-746">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-747">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-747">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-748">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-748">-or-</span>
          </span>
          <span data-ttu-id="3db8e-749">
            <paramref name="parameterTypes" /> 陣列的所有項目都是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-749">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-750">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-750">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-751">屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-751">The name of the property.</span>
          </span>
          <span data-ttu-id="3db8e-752">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-752">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-753">這個屬性 (Property) 的屬性 (Attribute)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-753">The attributes of the property.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-754">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-754">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-755">代表該屬性傳回類型之必要自訂修飾詞的類型陣列，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-755">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="3db8e-756">如果傳回類型沒有必要的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-756">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-757">代表該屬性傳回類型之選擇性自訂修飾詞的類型陣列，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-757">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="3db8e-758">如果傳回類型沒有選擇性的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-758">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-759">屬性的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-759">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-760">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-760">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-761">每個類型陣列都代表其對應參數必要的自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-761">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-762">如果特定的參數沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-762">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-763">如果這些參數都沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-763">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-764">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-764">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-765">每個類型陣列都代表其對應參數的選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-765">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-766">如果特定的參數沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-766">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-767">如果這些參數都沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-767">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-768">將新屬性加入具有指定名稱、屬性簽章和自訂修飾詞的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-768">Adds a new property to the type, with the given name, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-769">定義的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-769">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-770">這個多載供設計工具的 managed 編譯器使用。</span><span class="sxs-lookup"><span data-stu-id="3db8e-770">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-771">如需有關自訂修飾詞的詳細資訊，請參閱 ECMA 第 II 中繼資料文件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-771">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="3db8e-772">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-772">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-773">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-773">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-774">
            <paramref name="name" /> 是 <see langword="null" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-774">
              <paramref name="name" /> is <see langword="null" /></span>
          </span>
          <span data-ttu-id="3db8e-775">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-775">-or-</span>
          </span>
          <span data-ttu-id="3db8e-776">
            <paramref name="parameterTypes" /> 陣列的所有項目都是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-776">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" /></span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-777">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-777">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-778">屬性的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-778">The name of the property.</span>
          </span>
          <span data-ttu-id="3db8e-779">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-779">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-780">這個屬性 (Property) 的屬性 (Attribute)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-780">The attributes of the property.</span>
          </span>
        </param>
        <param name="callingConvention">
          <span data-ttu-id="3db8e-781">屬性存取子的呼叫慣例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-781">The calling convention of the property accessors.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="3db8e-782">屬性的傳回型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-782">The return type of the property.</span>
          </span>
        </param>
        <param name="returnTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-783">代表該屬性傳回類型之必要自訂修飾詞的類型陣列，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-783">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="3db8e-784">如果傳回類型沒有必要的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-784">If the return type has no required custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="returnTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-785">代表該屬性傳回類型之選擇性自訂修飾詞的類型陣列，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-785">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span>
          </span>
          <span data-ttu-id="3db8e-786">如果傳回類型沒有選擇性的自訂修飾詞，則指定 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-786">If the return type has no optional custom modifiers, specify <see langword="null" />.</span>
          </span>
        </param>
        <param name="parameterTypes">
          <span data-ttu-id="3db8e-787">屬性的參數類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-787">The types of the parameters of the property.</span>
          </span>
        </param>
        <param name="parameterTypeRequiredCustomModifiers">
          <span data-ttu-id="3db8e-788">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-788">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-789">每個類型陣列都代表其對應參數必要的自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-789">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-790">如果特定的參數沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-790">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-791">如果這些參數都沒有必要的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-791">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <param name="parameterTypeOptionalCustomModifiers">
          <span data-ttu-id="3db8e-792">類型陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-792">An array of arrays of types.</span>
          </span>
          <span data-ttu-id="3db8e-793">每個類型陣列都代表其對應參數的選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-793">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span>
          </span>
          <span data-ttu-id="3db8e-794">如果特定的參數沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非類型陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-794">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span>
          </span>
          <span data-ttu-id="3db8e-795">如果這些參數都沒有選擇性的自訂修飾詞，則指定 <see langword="null" />，而非陣列的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-795">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-796">將新屬性加入具有指定名稱、呼叫慣例、屬性簽章和自訂修飾詞的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-796">Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-797">定義的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-797">The defined property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-798">這個多載供設計工具的 managed 編譯器使用。</span><span class="sxs-lookup"><span data-stu-id="3db8e-798">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-799">如需有關自訂修飾詞的詳細資訊，請參閱 ECMA 第 II 中繼資料文件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-799">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="3db8e-800">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-800">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="3db8e-801">中引進這個方法多載[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更新版本。</span><span class="sxs-lookup"><span data-stu-id="3db8e-801">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-802">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-802">The length of <paramref name="name" /> is zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-803">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-803">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-804">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-804">-or-</span>
          </span>
          <span data-ttu-id="3db8e-805">
            <paramref name="parameterTypes" /> 陣列的所有項目都是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-805">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-806">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-806">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-807">定義這個類型的初始設定式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-807">Defines the initializer for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-808">傳回類型初始設定式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-808">Returns a type initializer.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-809">建立初始設定式一定是公用的。</span><span class="sxs-lookup"><span data-stu-id="3db8e-809">The initializer created is always public.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-810">下列程式碼範例示範如何建立初始化建構函式使用`DefineTypeInitializer`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-810">The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.</span></span>  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-811">之前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立包含類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-811">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-812">用來參考資料的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-812">The name used to refer to the data.</span>
          </span>
          <span data-ttu-id="3db8e-813">
            <c>name</c> 不能包含內嵌的 Null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-813">
              <c>name</c> cannot contain embedded nulls.</span>
          </span>
        </param>
        <param name="size">
          <span data-ttu-id="3db8e-814">資料欄位的大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-814">The size of the data field.</span>
          </span>
        </param>
        <param name="attributes">
          <span data-ttu-id="3db8e-815">欄位的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-815">The attributes for the field.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-816">在可攜式執行檔 (PE) 的 <see langword=".sdata" /> 區段中定義未初始化的資料欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-816">Defines an uninitialized data field in the <see langword=".sdata" /> section of the portable executable (PE) file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-817">要參考資料的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-817">A field to reference the data.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-818">您使用這個方法建立的欄位會是`static`，即使您未包含`FieldAttributes.Static`中`attributes`參數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-818">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-819">下列程式碼範例示範如何使用`DefineUninitializedData`動態類型中建立未初始化的資料欄位：</span><span class="sxs-lookup"><span data-stu-id="3db8e-819">The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:</span></span>  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-820">
            <paramref name="name" /> 的長度為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-820">Length of <paramref name="name" /> is zero.</span>
          </span>
          <span data-ttu-id="3db8e-821">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-821">-or-</span>
          </span>
          <span data-ttu-id="3db8e-822">
            <paramref name="size" /> 小於或等於零，或者大於或等於 0x003f0000。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-822">
              <paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-823">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-823">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-824">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-824">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-825">擷取這個類型的完整路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-825">Retrieves the full path of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-826">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-826">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-827">擷取這個類型的完整路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-827">Retrieves the full path of this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-828">傳回的格式為"enclosingTypeFullName + nestedTypeName"巢狀的類型和"typeName"非巢狀類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-828">The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-829">取得值，指出目前泛型類型參數的共變數與特殊條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-829">Gets a value that indicates the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-830">
            <see cref="T:System.Reflection.GenericParameterAttributes" /> 值的位元組合，描述目前泛型類型參數的共變數和特殊條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-830">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-831">當發出程式碼，泛型型別參數由<xref:System.Reflection.Emit.GenericTypeParameterBuilder>物件而非由<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-831">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-832">取得類型參數在宣告參數的泛型類型之類型參數清單中的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-832">Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-833">當目前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件表示泛型類型參數時，在宣告參數的泛型類型之類型參數清單中，類型參數的位置：否則為未定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-833">If the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-834">當發出程式碼，泛型型別參數由<xref:System.Reflection.Emit.GenericTypeParameterBuilder>物件而非由<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-834">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="3db8e-835">如果目前<xref:System.Reflection.Emit.TypeBuilder>不代表泛型類型參數，這個屬性的值會是未定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-835">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined.</span></span> <span data-ttu-id="3db8e-836">使用<xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A>屬性來判斷是否目前<xref:System.Reflection.Emit.TypeBuilder>代表泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-836">Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="3db8e-837">傳回的是建構泛型類型的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-837">The constructed generic type whose constructor is returned.</span>
          </span>
        </param>
        <param name="constructor">
          <span data-ttu-id="3db8e-838">有關 <c>type</c> 的泛型型別定義建構函式，指定要傳回的 <c>type</c> 建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-838">A constructor on the generic type definition of <c>type</c>, which specifies which constructor of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-839">傳回指定建構泛型類型的建構函式，其對應於泛型類型定義的指定建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-839">Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-840">表示對應 <paramref name="constructor" /> (其指定屬於 <paramref name="type" /> 泛型類型定義的建構函式) 的 <paramref name="type" /> 建構函式的 <see cref="T:System.Reflection.ConstructorInfo" /> 物件，。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-840">A <see cref="T:System.Reflection.ConstructorInfo" /> object that represents the constructor of <paramref name="type" /> corresponding to <paramref name="constructor" />, which specifies a constructor belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-841"><xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>方法可用來取得<xref:System.Reflection.ConstructorInfo>表示建構的泛型類型所表示之泛型型別定義的建構函式物件<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-841">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="3db8e-842">例如，假設您有<xref:System.Reflection.Emit.TypeBuilder>物件，表示類型`G<T>`C# 語法 (`G(Of T)`在 Visual Basic 中`generic <T> ref class G`c + + 中) 和<xref:System.Reflection.Emit.ConstructorBuilder>表示的建構函式物件`G<T>`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-842">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`.</span></span> <span data-ttu-id="3db8e-843">假設`G<T>`具有泛型方法的型別參數`U`所建立的建構類型的執行個體`G<U>`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-843">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`.</span></span> <span data-ttu-id="3db8e-844">若要發出的程式碼建立的建構類型的執行個體，您需要<xref:System.Reflection.ConstructorInfo>物件，代表這個建構函式建構的型別，換句話說，所建立的執行個體`G<U>`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-844">In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type — in other words, that creates an instance of `G<U>`.</span></span> <span data-ttu-id="3db8e-845">若要這樣做，請先呼叫<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>方法<xref:System.Reflection.Emit.TypeBuilder>物件，指定<xref:System.Reflection.Emit.GenericTypeParameterBuilder>物件，代表`U`作為類型引數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-845">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="3db8e-846">然後呼叫<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>方法的傳回值與<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>做為參數的方法`type`和<xref:System.Reflection.Emit.ConstructorBuilder>表示的建構函式物件`G<U>`做為參數`constructor`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-846">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`.</span></span> <span data-ttu-id="3db8e-847">傳回值是<xref:System.Reflection.ConstructorInfo>您要發出的函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-847">The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call.</span></span> <span data-ttu-id="3db8e-848">程式碼範例示範此案例。</span><span class="sxs-lookup"><span data-stu-id="3db8e-848">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-849">下列程式碼範例包含名為泛型類別的原始程式碼`Sample`具有名為型別參數`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-849">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="3db8e-850">此類別具有名為的欄位`Field`，型別`T`，和名為泛型方法`GM`與它自己的型別參數，名稱為`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-850">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="3db8e-851">方法`GM`建立的執行個體`Sample`，以自己的型別參數的替代`U`的型別參數`Sample`，並將其輸入的參數中`Field`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-851">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="3db8e-852">這個原始程式碼已編譯的但未使用。您可以檢視它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)比較類別所發出的程式碼和`Example`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-852">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="3db8e-853">類別中的程式碼`Example`示範如何使用<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>發出一般的程式碼的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-853">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method to emit generic code.</span></span> <span data-ttu-id="3db8e-854">`Main`類別方法`Example`建立動態組件包含類別，名為`Sample`並用<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>方法，使它成為泛型藉由新增名為型別參數`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-854">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="3db8e-855">預設建構函式和名為的欄位`Field`，型別`T`，加入至類別`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-855">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="3db8e-856">方法`GM`加入，並轉換成泛型方法，使用<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-856">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-857">型別參數`GM`名為`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-857">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="3db8e-858">型別參數定義之後的簽章`GM`加入使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-858">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-859">沒有任何傳回型別，且沒有必要或自訂修飾詞，此方法讓所有的參數會`null`除了`parameterTypes`;`parameterTypes`設定方法的唯一參數的型別`U`，方法的泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-859">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="3db8e-860">方法主體建立的建構類型的執行個體`Sample<U>`(`Sample(Of U)`在 Visual Basic 中)，會指派至方法的參數`Field`，然後列印值`Field`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-860">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="3db8e-861"><xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A>方法用來建立<xref:System.Reflection.ConstructorInfo>表示建構的泛型類型的預設建構函式`Sample<U>`中<xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType>建立執行個體的指示。</span><span class="sxs-lookup"><span data-stu-id="3db8e-861">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the default constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction that creates the instance.</span></span>  
  
 <span data-ttu-id="3db8e-862">空的型別定義為保留的進入點方法`Main`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-862">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="3db8e-863">本文的`Main`，靜態`GM`建構的泛型類型上叫用方法`Sample<int>`(`Sample(Of Integer)`在 Visual Basic 中)，與類型<xref:System.String>取代`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-863">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="3db8e-864">當執行程式碼範例時，它會將發出的組件儲存為 TypeBuilderGetFieldExample.exe 中。</span><span class="sxs-lookup"><span data-stu-id="3db8e-864">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="3db8e-865">您可以執行 TypeBuilderGetFieldExample.exe，而且您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)比較發出程式碼的程式碼與`Sample`會編譯到本身的程式碼範例的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-865">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-866">
            <paramref name="type" /> 不代表泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-866">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="3db8e-867">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-867">-or-</span>
          </span>
          <span data-ttu-id="3db8e-868">
            <paramref name="type" /> 不是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-868">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="3db8e-869">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-869">-or-</span>
          </span>
          <span data-ttu-id="3db8e-870">
            <paramref name="constructor" /> 的宣告類型不是泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-870">The declaring type of <paramref name="constructor" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="3db8e-871">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-871">-or-</span>
          </span>
          <span data-ttu-id="3db8e-872">
            <paramref name="constructor" /> 的宣告類型不是 <paramref name="type" /> 的泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-872">The declaring type of <paramref name="constructor" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-873">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標，如同在 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 中等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-873">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-874">依照指定，傳回 <see cref="T:System.Reflection.ConstructorInfo" /> 物件的陣列，表示為這個類別所定義的公用和非公用建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-874">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the public and non-public constructors defined for this class, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-875">傳回 <see cref="T:System.Reflection.ConstructorInfo" /> 物件的陣列，表示為這個類別所定義的指定建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-875">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the specified constructors defined for this class.</span>
          </span>
          <span data-ttu-id="3db8e-876">如果未定義建構函式，則會傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-876">If no constructors are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-877">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-877">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-878">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-878">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-879">傳回為這個類型定義的自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-879">Returns the custom attributes defined for this type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <span data-ttu-id="3db8e-880">指定是否要搜尋這個成員的繼承鏈結以尋找屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-880">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-881">傳回為這個類型定義的所有自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-881">Returns all the custom attributes defined for this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-882">傳回代表這個類型的所有自訂屬性的物件陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-882">Returns an array of objects representing all the custom attributes of this type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-883">這個方法目前不支援不完整的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-883">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="3db8e-884">使用 <see cref="M:System.Type.GetType" /> 來擷取型別，並在傳回的 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> 上呼叫 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-884">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="3db8e-885">要搜尋的屬性類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-885">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="3db8e-886">只會傳回可指派給這種類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-886">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="3db8e-887">指定是否要搜尋這個成員的繼承鏈結以尋找屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-887">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-888">傳回可指派給指定類型之目前類型的所有自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-888">Returns all the custom attributes of the current type that are assignable to a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-889">在目前類型上定義的自訂屬性陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-889">An array of custom attributes defined on the current type.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-890">這個方法目前不支援不完整的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-890">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="3db8e-891">使用 <see cref="M:System.Type.GetType" /> 來擷取型別，並在傳回的 <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> 上呼叫 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-891">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-892">
            <paramref name="attributeType" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-892">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-893">類型必須是基礎執行階段系統所提供的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-893">The type must be a type provided by the underlying runtime system.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-894">呼叫這個方法一律會擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-894">Calling this method always throws <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-895">不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-895">This method is not supported.</span>
          </span>
          <span data-ttu-id="3db8e-896">沒有傳回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-896">No value is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-897">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-897">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-898">不支援這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-898">This method is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-899">要搜尋的事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-899">The name of the event to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-900">限制搜尋之 <see cref="T:System.Reflection.BindingFlags" /> 值的位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-900">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-901">傳回具有指定名稱的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-901">Returns the event with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-902">
            <see cref="T:System.Reflection.EventInfo" /> 物件，表示由這個型別使用指定名稱宣告或繼承的事件，如果沒有相符項目則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-902">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name, or <see langword="null" /> if there are no matches.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-903">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-903">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-904">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-904">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-905">傳回目前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 所定義的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-905">Returns the events defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-906">傳回由這個方法所宣告或繼承的公用事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-906">Returns the public events declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-907">傳回 <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，表示由這個型別所宣告或繼承的公用事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-907">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the public events declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="3db8e-908">如果沒有任何公用事件，則會傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-908">An empty array is returned if there are no public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-909">擷取型別使用<xref:System.Type.GetType%2A>或<xref:System.Reflection.Assembly.GetType%2A>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-909">Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-910">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-910">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-911">限制搜尋之 <see cref="T:System.Reflection.BindingFlags" /> 值的位元組合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-911">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-912">傳回這個類型所宣告的公用和非公用事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-912">Returns the public and non-public events that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-913">傳回 <see cref="T:System.Reflection.EventInfo" /> 物件的陣列，表示由這個型別所宣告或繼承而且與指定之繫結旗標相符的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-913">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the events declared or inherited by this type that match the specified binding flags.</span>
          </span>
          <span data-ttu-id="3db8e-914">如果沒有任何事件符合，則會傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-914">An empty array is returned if there are no matching events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-915">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-915">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-916">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-916">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-917">傳回目前 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 所定義的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-917">Returns a field defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-918">要取得的欄位名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-918">The name of the field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-919">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標，如同在 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 中等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-919">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-920">傳回指定之名稱所指定的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-920">Returns the field specified by the given name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-921">傳回 <see cref="T:System.Reflection.FieldInfo" /> 物件，表示由具有指定名稱和公用或非公用修飾詞 (Modifier) 的這個型別所宣告或繼承的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-921">Returns the <see cref="T:System.Reflection.FieldInfo" /> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</span>
          </span>
          <span data-ttu-id="3db8e-922">如果沒有符合的欄位，則傳回 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-922">If there are no matches then <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-923">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-923">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-924">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-924">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="3db8e-925">傳回欄位的建構泛型類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-925">The constructed generic type whose field is returned.</span>
          </span>
        </param>
        <param name="field">
          <span data-ttu-id="3db8e-926">有關 <c>type</c> 的泛型型別定義欄位，指定要傳回的 <c>type</c> 欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-926">A field on the generic type definition of <c>type</c>, which specifies which field of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-927">傳回對應至泛型類型定義指定欄位的指定建構泛型類型的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-927">Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-928">代表對應 <paramref name="field" /> (其指定屬於 <paramref name="type" /> 泛型類型定義的欄位) 的 <paramref name="type" /> 欄位的 <see cref="T:System.Reflection.FieldInfo" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-928">A <see cref="T:System.Reflection.FieldInfo" /> object that represents the field of <paramref name="type" /> corresponding to <paramref name="field" />, which specifies a field belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-929"><xref:System.Reflection.Emit.TypeBuilder.GetField%2A>方法可用來取得<xref:System.Reflection.FieldInfo>物件代表建構的泛型類型所表示之泛型型別定義的欄位，<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-929">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="3db8e-930">比方說，假設您有<xref:System.Reflection.Emit.TypeBuilder>物件，表示類型`G<T>`C# 語法 (`G(Of T)`在 Visual Basic 中`generic <T> ref class G`在 c + +) 和<xref:System.Reflection.Emit.FieldBuilder>物件，表示欄位`public T F`C# 語法 (`Public F As T`在 Visual Basic 中`public: T F`c + + 中) 所定義的`G<T>`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-930">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="3db8e-931">假設`G<T>`具有泛型方法的型別參數`U`所建立的建構類型的執行個體`G<U>`和呼叫欄位`F`該執行個體上。</span><span class="sxs-lookup"><span data-stu-id="3db8e-931">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance.</span></span> <span data-ttu-id="3db8e-932">若要發出的函式呼叫，您必須<xref:System.Reflection.FieldInfo>物件，代表`F`上建構的類型 — 亦即，屬於類型`U`而不是型別`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-932">In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type — in other words, that is of type `U` rather than type `T`.</span></span> <span data-ttu-id="3db8e-933">若要這樣做，請先呼叫<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>方法<xref:System.Reflection.Emit.TypeBuilder>物件，指定<xref:System.Reflection.Emit.GenericTypeParameterBuilder>物件，代表`U`作為類型引數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-933">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="3db8e-934">然後呼叫<xref:System.Reflection.Emit.TypeBuilder.GetField%2A>方法的傳回值與<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>做為參數的方法`type`和<xref:System.Reflection.Emit.FieldBuilder>物件，代表`F`做為參數`field`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-934">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`.</span></span> <span data-ttu-id="3db8e-935">傳回值是<xref:System.Reflection.FieldInfo>您要發出的函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-935">The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call.</span></span> <span data-ttu-id="3db8e-936">程式碼範例示範此案例。</span><span class="sxs-lookup"><span data-stu-id="3db8e-936">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-937">下列程式碼範例包含名為具有名為的類型參數的範例為泛型類別的原始程式碼`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-937">The following code example contains source code for a generic class named Sample that has a type parameter named `T`.</span></span> <span data-ttu-id="3db8e-938">此類別具有名為的欄位`Field`，型別`T`，和名為泛型方法`GM`與它自己的型別參數，名稱為`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-938">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="3db8e-939">方法`GM`建立的執行個體`Sample`，以自己的型別參數的替代`U`的型別參數`Sample`，並將其輸入的參數中`Field`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-939">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="3db8e-940">這個原始程式碼已編譯的但未使用。您可以檢視它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)比較類別所發出的程式碼和`Example`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-940">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="3db8e-941">類別中的程式碼`Example`示範如何使用<xref:System.Reflection.Emit.TypeBuilder.GetField%2A>發出一般的程式碼的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-941">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method to emit generic code.</span></span> <span data-ttu-id="3db8e-942">`Main`類別方法`Example`建立動態組件包含類別，名為`Sample`，並使用<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>方法，使它成為泛型藉由新增名為型別參數`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-942">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="3db8e-943">預設建構函式和名為的欄位`Field`，型別`T`，加入至類別`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-943">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="3db8e-944">方法`GM`加入，並轉換成泛型方法，使用<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-944">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-945">型別參數`GM`名為`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-945">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="3db8e-946">型別參數定義之後的簽章`GM`加入使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-946">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-947">沒有任何傳回型別，且沒有必要或自訂修飾詞，此方法讓所有的參數會`null`除了`parameterTypes`;`parameterTypes`設定方法的唯一參數的型別`U`，方法的泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-947">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="3db8e-948">方法主體建立的建構類型的執行個體`Sample<U>`(`Sample(Of U)`在 Visual Basic 中)，會指派至方法的參數`Field`，然後列印值`Field`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-948">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="3db8e-949"><xref:System.Reflection.Emit.TypeBuilder.GetField%2A>方法用來建立<xref:System.Reflection.FieldInfo>表示建構的泛型類型的欄位`Sample<U>`中<xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType>和<xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType>指示。</span><span class="sxs-lookup"><span data-stu-id="3db8e-949">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instructions.</span></span>  
  
 <span data-ttu-id="3db8e-950">空的型別定義為保留的進入點方法`Main`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-950">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="3db8e-951">本文的`Main`，靜態`GM`建構的泛型類型上叫用方法`Sample<int>`(`Sample(Of Integer)`在 Visual Basic 中)，與類型<xref:System.String>取代`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-951">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="3db8e-952">當執行程式碼範例時，它會將發出的組件儲存為 TypeBuilderGetFieldExample.exe 中。</span><span class="sxs-lookup"><span data-stu-id="3db8e-952">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="3db8e-953">您可以執行 TypeBuilderGetFieldExample.exe，而且您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)比較發出程式碼的程式碼與`Sample`會編譯到本身的程式碼範例的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-953">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-954">
            <paramref name="type" /> 不代表泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-954">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="3db8e-955">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-955">-or-</span>
          </span>
          <span data-ttu-id="3db8e-956">
            <paramref name="type" /> 不是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-956">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="3db8e-957">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-957">-or-</span>
          </span>
          <span data-ttu-id="3db8e-958">
            <paramref name="field" /> 的宣告類型不是泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-958">The declaring type of <paramref name="field" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="3db8e-959">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-959">-or-</span>
          </span>
          <span data-ttu-id="3db8e-960">
            <paramref name="field" /> 的宣告類型不是 <paramref name="type" /> 的泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-960">The declaring type of <paramref name="field" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-961">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 中的位元旗標：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-961">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-962">傳回這個類型所宣告的公用和非公用欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-962">Returns the public and non-public fields that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-963">傳回 <see cref="T:System.Reflection.FieldInfo" /> 物件的陣列，表示由這個型別所宣告或繼承的公用和非公用欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-963">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the public and non-public fields declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="3db8e-964">依指定，如果沒有的任何欄位，則會傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-964">An empty array is returned if there are no fields, as specified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-965"><xref:System.Reflection.Emit.TypeBuilder.GetFields%2A>方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。</span><span class="sxs-lookup"><span data-stu-id="3db8e-965">The <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="3db8e-966">您的程式碼必須依賴欄位會傳回的順序，因為該順序可能會有所不同。</span><span class="sxs-lookup"><span data-stu-id="3db8e-966">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="3db8e-967">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-967">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-968">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-968">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-969">傳回 <see cref="T:System.Type" /> 物件的陣列，表示泛型型別的型別引數或泛型型別定義的型別參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-969">Returns an array of <see cref="T:System.Type" /> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-970">
            <see cref="T:System.Type" /> 物件的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-970">An array of <see cref="T:System.Type" /> objects.</span>
          </span>
          <span data-ttu-id="3db8e-971">陣列的項目代表泛型類型的型別引數，或泛型類型定義的型別參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-971">The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-972">傳回陣列中的項目會以其出現在清單中的泛型類型定義的型別參數的順序。</span><span class="sxs-lookup"><span data-stu-id="3db8e-972">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</span></span>  
  
 <span data-ttu-id="3db8e-973">A<xref:System.Reflection.Emit.TypeBuilder>物件代表泛型類型定義，如果<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>已經用來提供給它的泛型類型參數的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-973">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="3db8e-974">這個方法會擷取<xref:System.Reflection.Emit.GenericTypeParameterBuilder>代表泛型型別參數的物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-974">This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.</span></span>  
  
 <span data-ttu-id="3db8e-975">如需有關反映和非變異條件在反映中泛型的詞彙的清單中的泛型類型的詳細資訊，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-975">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-976">傳回 <see cref="T:System.Type" /> 物件，代表可從中取得目前類型的泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-976">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current type can be obtained.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-977">
            <see cref="T:System.Type" /> 物件，代表可從中取得目前類型的泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-977">A <see cref="T:System.Type" /> object representing a generic type definition from which the current type can be obtained.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-978">如果您呼叫<xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A>方法<xref:System.Reflection.Emit.TypeBuilder>物件<xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A>屬性會傳回`true`、<xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A>屬性會傳回目前執行個體。</span><span class="sxs-lookup"><span data-stu-id="3db8e-978">If you call the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> property returns the current instance.</span></span> <span data-ttu-id="3db8e-979">A <xref:System.Reflection.Emit.TypeBuilder> ，代表泛型類型永遠是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-979">A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.</span></span>  
  
 <span data-ttu-id="3db8e-980">如果您使用<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>方法來建構泛型類型從<xref:System.Reflection.Emit.TypeBuilder>物件，代表泛型類型定義，使用<xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType>建構的類型上的方法取得回<xref:System.Reflection.Emit.TypeBuilder>物件，代表泛型型別定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-980">If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-981">目前的類型不是泛型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-981">The current type is not generic.</span>
          </span>
          <span data-ttu-id="3db8e-982">亦即，<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-982">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-983">介面的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-983">The name of the interface.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="3db8e-984">如果 <see langword="true" />，則搜尋不區分大小寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-984">If <see langword="true" />, the search is case-insensitive.</span>
          </span>
          <span data-ttu-id="3db8e-985">如果 <see langword="false" />，則搜尋區分大小寫。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-985">If <see langword="false" />, the search is case-sensitive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-986">傳回此類別所 (直接或間接) 實作的介面，且完整格式名稱符合指定的介面名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-986">Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-987">傳回 <see cref="T:System.Type" /> 物件，表示已實作的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-987">Returns a <see cref="T:System.Type" /> object representing the implemented interface.</span>
          </span>
          <span data-ttu-id="3db8e-988">如果找不到符合名稱的介面，便傳回 null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-988">Returns null if no interface matching name is found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-989">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-989">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-990">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-990">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="3db8e-991">介面的 <see cref="T:System.Type" />，要為其擷取對應。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-991">The <see cref="T:System.Type" /> of the interface for which the mapping is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-992">傳回所要求介面的介面對應。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-992">Returns an interface mapping for the requested interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-993">傳回要求的介面對應。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-993">Returns the requested interface mapping.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-994">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-994">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-995">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-995">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-996">傳回在這個類型及其基底類型上實作之所有介面的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-996">Returns an array of all the interfaces implemented on this type and its base types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-997">傳回 <see cref="T:System.Type" /> 物件的陣列，表示已實作的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-997">Returns an array of <see cref="T:System.Type" /> objects representing the implemented interfaces.</span>
          </span>
          <span data-ttu-id="3db8e-998">如果未定義，則會傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-998">If none are defined, an empty array is returned.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-999">成員的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-999">The name of the member.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="3db8e-1000">要傳回的成員類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1000">The type of the member to return.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-1001">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標，如同在 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 中等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1001">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1002">依指定傳回此類型所宣告或繼承的所有公用和非公用成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1002">Returns all the public and non-public members declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1003">如果使用 <paramref name="nonPublic" />，則傳回表示在這個型別上所定義的公用和非公用成員之 <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，否則，只傳回公用成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1003">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public members are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1004">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1004">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1005">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1005">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-1006">這必須是來自 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標，例如 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1006">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, such as <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1007">傳回這個類型所宣告或繼承的公用和非公用成員之成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1007">Returns the members for the public and non-public members declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1008">傳回 <see cref="T:System.Reflection.MemberInfo" /> 物件的陣列，表示由這個型別所宣告或繼承的公用和非公用成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1008">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members declared or inherited by this type.</span>
          </span>
          <span data-ttu-id="3db8e-1009">如果沒有任何成員符合，則會傳回空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1009">An empty array is returned if there are no matching members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1010">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1010">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1011">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1011">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="3db8e-1012">傳回方法的建構泛型類別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1012">The constructed generic type whose method is returned.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="3db8e-1013">有關 <c>type</c> 的泛型型別定義方法，指定要傳回的 <c>type</c> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1013">A method on the generic type definition of <c>type</c>, which specifies which method of <c>type</c> to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1014">傳回對應至泛型類型定義指定方法的指定建構泛型類型的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1014">Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1015">表示對應 <paramref name="method" /> (其指定屬於 <paramref name="type" /> 泛型類型定義的方法) 的 <paramref name="type" /> 方法的 <see cref="T:System.Reflection.MethodInfo" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1015">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the method of <paramref name="type" /> corresponding to <paramref name="method" />, which specifies a method belonging to the generic type definition of <paramref name="type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1016"><xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>方法可用來取得<xref:System.Reflection.MethodInfo>物件，表示建構的泛型類型所表示之泛型型別定義的方法<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1016">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="3db8e-1017">比方說，假設您有<xref:System.Reflection.Emit.TypeBuilder>物件，表示類型`G<T>`C# 語法 (`G(Of T)`在 Visual Basic 中`generic <T> ref class G`在 c + +) 和<xref:System.Reflection.Emit.MethodBuilder>物件，代表方法`T M()`C# 語法 (`Function M() As T`在 Visual Basic 中`T M()`c + + 中) 所定義的`G<T>`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1017">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="3db8e-1018">假設`G<T>`具有泛型方法的型別參數`U`所建立的建構類型的執行個體`G<U>`呼叫的方法`M`該執行個體上。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1018">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance.</span></span> <span data-ttu-id="3db8e-1019">若要發出的函式呼叫，您必須<xref:System.Reflection.MethodInfo>物件，代表`M`上建構的類型 — 亦即，傳回型別`U`而不是型別`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1019">In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type — in other words, that returns type `U` rather than type `T`.</span></span> <span data-ttu-id="3db8e-1020">若要這樣做，請先呼叫<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>方法<xref:System.Reflection.Emit.TypeBuilder>物件，指定<xref:System.Reflection.Emit.GenericTypeParameterBuilder>物件，代表`U`作為類型引數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1020">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="3db8e-1021">然後呼叫<xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>方法的傳回值與<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>做為參數的方法`type`和<xref:System.Reflection.Emit.MethodBuilder>物件，代表`T M()`做為參數`method`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1021">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`.</span></span> <span data-ttu-id="3db8e-1022">傳回值是<xref:System.Reflection.MethodInfo>您要發出的函式呼叫的物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1022">The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call.</span></span> <span data-ttu-id="3db8e-1023">程式碼範例示範如下所示的案例。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1023">The code example demonstrates a scenario similar to this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-1024">下列程式碼範例包含名為泛型類別的原始程式碼`Sample`具有名為型別參數`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1024">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="3db8e-1025">此類別具有名為的欄位`Field`，型別`T`，和名為泛型方法`GM`與它自己的型別參數，名稱為`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1025">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="3db8e-1026">方法`GM`建立的執行個體`Sample`，以自己的型別參數的替代`U`的型別參數`Sample`，並將其輸入的參數中`Field`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1026">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="3db8e-1027">這個原始程式碼已編譯的但未使用。您可以檢視它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)比較類別所發出的程式碼和`Example`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1027">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="3db8e-1028">類別中的程式碼`Example`示範如何使用<xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>發出一般的程式碼的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1028">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method to emit generic code.</span></span> <span data-ttu-id="3db8e-1029">`Main`類別方法`Example`建立動態組件包含類別，名為`Sample`並用<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>方法，使它成為泛型藉由新增名為型別參數`T`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1029">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="3db8e-1030">預設建構函式和名為的欄位`Field`，型別`T`，加入至類別`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1030">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="3db8e-1031">方法`GM`加入，並轉換成泛型方法，使用<xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1031">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-1032">型別參數`GM`名為`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1032">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="3db8e-1033">型別參數定義之後的簽章`GM`加入使用<xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1033">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3db8e-1034">沒有任何傳回型別，且沒有必要或自訂修飾詞，此方法讓所有的參數會`null`除了`parameterTypes`;`parameterTypes`設定方法的唯一參數的型別`U`，方法的泛型型別參數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1034">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="3db8e-1035">方法主體建立的建構類型的執行個體`Sample<U>`(`Sample(Of U)`在 Visual Basic 中)，會指派至方法的參數`Field`，然後列印值`Field`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1035">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="3db8e-1036">空的型別定義為保留的進入點方法`Main`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1036">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="3db8e-1037">本文的`Main`，靜態`GM`建構的泛型類型上叫用方法`Sample<int>`(`Sample(Of Integer)`在 Visual Basic 中)，與類型<xref:System.String>取代`U`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1037">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="3db8e-1038"><xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A>方法用來建立<xref:System.Reflection.MethodInfo>用於靜態`GM`方法建構的泛型型別`Sample<U>`，和<xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType>方法再用來建立<xref:System.Reflection.MethodInfo>，方法呼叫中所發出。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1038">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="3db8e-1039">當執行程式碼範例時，它會將發出的組件儲存為 TypeBuilderGetFieldExample.exe 中。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1039">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="3db8e-1040">您可以執行 TypeBuilderGetFieldExample.exe，而且您可以使用[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)比較發出程式碼的程式碼與`Sample`會編譯到本身的程式碼範例的類別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1040">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-1041">
            <paramref name="method" /> 是非泛型方法定義的泛型方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1041">
              <paramref name="method" /> is a generic method that is not a generic method definition.</span>
          </span>
          <span data-ttu-id="3db8e-1042">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1042">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1043">
            <paramref name="type" /> 不代表泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1043">
              <paramref name="type" /> does not represent a generic type.</span>
          </span>
          <span data-ttu-id="3db8e-1044">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1044">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1045">
            <paramref name="type" /> 不是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1045">
              <paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span>
          </span>
          <span data-ttu-id="3db8e-1046">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1046">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1047">
            <paramref name="method" /> 的宣告類型不是泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1047">The declaring type of <paramref name="method" /> is not a generic type definition.</span>
          </span>
          <span data-ttu-id="3db8e-1048">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1048">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1049">
            <paramref name="method" /> 的宣告類型不是 <paramref name="type" /> 的泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1049">The declaring type of <paramref name="method" /> is not the generic type definition of <paramref name="type" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-1050">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標，如同在 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 中等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1050">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1051">依指定傳回此類型所宣告或繼承的所有公用和非公用方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1051">Returns all the public and non-public methods declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1052">如果使用 <paramref name="nonPublic" />，則傳回表示在這個型別上所定義的公用和非公用方法之 <see cref="T:System.Reflection.MethodInfo" /> 物件的陣列，否則，只傳回公用方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1052">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing the public and non-public methods defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public methods are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1053">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1053">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1054">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1054">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-1055">
            <see cref="T:System.String" />，包含要取得的巢狀型別名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1055">The <see cref="T:System.String" /> containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-1056">位元遮罩，由一或多個 <see cref="T:System.Reflection.BindingFlags" /> 組成，而這些旗標會指定執行搜尋的方式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1056">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="3db8e-1057">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1057">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1058">零，表示要針對公用方法執行區分大小寫的搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1058">Zero, to conduct a case-sensitive search for public methods.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1059">傳回這個類型所宣告的公用和非公用巢狀類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1059">Returns the public and non-public nested types that are declared by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1060">
            <see cref="T:System.Type" /> 物件，表示符合指定之需求的巢狀型別 (如有找到)；否則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1060">A <see cref="T:System.Type" /> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1061">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1061">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="3db8e-1062">此類型是否完成，例如，如果`CreateType`已呼叫在此型別，但有巢狀的類型不完整的然後`GetNestedTypes`只會傳回這些巢狀的類型的`CreateType`已呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1062">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1063">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1063">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-1064">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 的位元旗標，如同在 <see langword="InvokeMethod" />、<see langword="NonPublic" /> 中等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1064">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1065">傳回這個類型所宣告或繼承的公用和非公用巢狀類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1065">Returns the public and non-public nested types that are declared or inherited by this type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1066">
            <see cref="T:System.Type" /> 物件的陣列，表示在目前 <see cref="T:System.Type" /> 內形成巢狀的所有型別皆符合指定的繫結條件約束。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1066">An array of <see cref="T:System.Type" /> objects representing all the types nested within the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="3db8e-1067">如果沒有任何型別在目前 <see cref="T:System.Type" /> 內形成巢狀，或沒有巢狀型別符合繫結條件約束，則為 <see cref="T:System.Type" /> 型別的空陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1067">An empty array of type <see cref="T:System.Type" />, if no types are nested within the current <see cref="T:System.Type" />, or if none of the nested types match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1068">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1068">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="3db8e-1069">此類型是否完成，例如，如果`CreateType`已呼叫在此型別，但有巢狀的類型不完整的然後`GetNestedTypes`只會傳回這些巢狀的類型的`CreateType`已呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1069">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1070">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1070">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="3db8e-1071">這個引動過程屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1071">This invocation attribute.</span>
          </span>
          <span data-ttu-id="3db8e-1072">這必須是 <see cref="T:System.Reflection.BindingFlags" /> 中的位元旗標：<see langword="InvokeMethod" />、<see langword="NonPublic" /> 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1072">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1073">依指定傳回這個類型所宣告或繼承的所有公用和非公用屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1073">Returns all the public and non-public properties declared or inherited by this type, as specified.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1074">如果使用 <paramref name="nonPublic" />，則傳回表示在這個型別上所定義的公用和非公用屬性之 <see langword="PropertyInfo" /> 物件的陣列，否則，只傳回公用屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1074">Returns an array of <see langword="PropertyInfo" /> objects representing the public and non-public properties defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public properties are returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1075">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1075">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1076">如果類型不完整，則不會實作這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1076">This method is not implemented for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1077">擷取這個類型的 GUID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1077">Retrieves the GUID of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1078">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1078">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1079">擷取這個類型的 GUID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1079">Retrieves the GUID of this type</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1080">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1080">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1081">這個方法目前不支援不完整的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1081">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="3db8e-1082">要叫用之成員的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1082">The name of the member to invoke.</span>
          </span>
          <span data-ttu-id="3db8e-1083">可以是建構函式、方法、屬性或欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1083">This can be a constructor, method, property, or field.</span>
          </span>
          <span data-ttu-id="3db8e-1084">您必須指定適當的引動過程屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1084">A suitable invocation attribute must be specified.</span>
          </span>
          <span data-ttu-id="3db8e-1085">請注意，將空字串當做成員名稱傳遞，可叫用類別的預設成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1085">Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="3db8e-1086">引動過程屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1086">The invocation attribute.</span>
          </span>
          <span data-ttu-id="3db8e-1087">這必須是來自 <see langword="BindingFlags" /> 的位元旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1087">This must be a bit flag from <see langword="BindingFlags" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="3db8e-1088">使用反映來啟用繫結、強制引數的類型、成員的引動過程，和擷取 <see langword="MemberInfo" /> 物件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1088">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span>
          </span>
          <span data-ttu-id="3db8e-1089">如果繫結器為 <see langword="null" />，則會使用預設繫結器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1089">If binder is <see langword="null" />, the default binder is used.</span>
          </span>
          <span data-ttu-id="3db8e-1090">請參閱 <see cref="T:System.Reflection.Binder" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1090">See <see cref="T:System.Reflection.Binder" />.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="3db8e-1091">要在其上叫用指定成員的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1091">The object on which to invoke the specified member.</span>
          </span>
          <span data-ttu-id="3db8e-1092">如果是靜態成員，則會忽略這個參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1092">If the member is static, this parameter is ignored.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="3db8e-1093">引數清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1093">An argument list.</span>
          </span>
          <span data-ttu-id="3db8e-1094">這是物件陣列，其中包含所要叫用之成員的參數數目、順序和類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1094">This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</span>
          </span>
          <span data-ttu-id="3db8e-1095">如果沒有任何參數，則這應該是 null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1095">If there are no parameters this should be null.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="3db8e-1096">與 <c>args</c> 長度相同的陣列，其中的項目代表與所要叫用成員的引數建立關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1096">An array of the same length as <c>args</c> with elements that represent the attributes associated with the arguments of the member to be invoked.</span>
          </span>
          <span data-ttu-id="3db8e-1097">參數在中繼資料內具有與其相關聯的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1097">A parameter has attributes associated with it in the metadata.</span>
          </span>
          <span data-ttu-id="3db8e-1098">許多互通性服務都會使用這些屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1098">They are used by various interoperability services.</span>
          </span>
          <span data-ttu-id="3db8e-1099">如需詳細資訊，請參閱中繼資料規格。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1099">See the metadata specs for more details.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="3db8e-1100">
            <see langword="CultureInfo" /> 的執行個體，用於管理類型的強制型轉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1100">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="3db8e-1101">如果這是 null，會使用目前執行緒的 <see langword="CultureInfo" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1101">If this is null, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="3db8e-1102">(請注意，要將代表 1000 的 String 轉換成 Double 值時，這是必要的，因為 1000 的表示方式會因不同文化特性而有所不同)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1102">(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="3db8e-1103">
            <c>namedParameters</c> 陣列中的每個參數會在 <c>args</c> 陣列中取得對應項目的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1103">Each parameter in the <c>namedParameters</c> array gets the value in the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="3db8e-1104">如果 <c>args</c> 的長度大於 <c>namedParameters</c> 的長度，則會依序傳遞其餘引數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1104">If the length of <c>args</c> is greater than the length of <c>namedParameters</c>, the remaining argument values are passed in order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1105">叫用指定的成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1105">Invokes the specified member.</span>
          </span>
          <span data-ttu-id="3db8e-1106">根據指定繫結器和引動過程屬性的條件約束，所要叫用的方法必須可存取，並提供與指定引數清單最特定的符合項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1106">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1107">傳回所叫用之成員的傳回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1107">Returns the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1108">如果方法宣告中的參數數目等於在指定的引數清單中，引數數目，以及每個引數型別參數的型別繫結器轉換，將會叫用方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1108">A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="3db8e-1109">繫結器將會尋找所有相符的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1109">The binder will find all of the matching methods.</span></span> <span data-ttu-id="3db8e-1110">這些方法會找到根據繫結要求 （BindingFlags.InvokeMethod、 BindingFlags.GetProperties，等等。） 的類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1110">These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</span></span> <span data-ttu-id="3db8e-1111">方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1111">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span> <span data-ttu-id="3db8e-1112">選取方法之後，就會叫用。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1112">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="3db8e-1113">協助工具會在該點檢查。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1113">Accessibility is checked at that point.</span></span> <span data-ttu-id="3db8e-1114">搜尋可以控制要根據與方法相關聯的協助工具屬性搜尋哪一組方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1114">The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="3db8e-1115">`IBinder.BindToMethod`方法負責選取方法被叫用。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1115">The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="3db8e-1116">預設繫結器選取最適合的相符項目。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1116">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1117">完全信任程式碼會忽略存取限制。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1117">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="3db8e-1118">也就是說，私用建構函式、 方法、 欄位和屬性可以存取，而且只要完全信任程式碼使用反映來叫用。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1118">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="3db8e-1119">目前不支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1119">This method is not currently supported.</span></span> <span data-ttu-id="3db8e-1120">您可以擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1120">You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1121">這個方法目前不支援不完整的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1121">This method is not currently supported for incomplete types.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1122">判斷指定類型是否可以指派給這個物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1122">Determines whether a specified type can be assigned to this object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">
          <span data-ttu-id="3db8e-1123">要測試的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1123">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1124">取得值，指出是否可以將指定的 <see cref="T:System.Reflection.TypeInfo" /> 物件指派給這個物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1124">Gets a value that indicates whether a specified <see cref="T:System.Reflection.TypeInfo" /> object can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1125">如果可以將 <paramref name="typeInfo" /> 指派給這個物件，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1125">
              <see langword="true" /> if <paramref name="typeInfo" /> can be assigned to this object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="3db8e-1126">要測試的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1126">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1127">取得值，指出指定的 <see cref="T:System.Type" /> 是否可以指派給這個物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1127">Gets a value that indicates whether a specified <see cref="T:System.Type" /> can be assigned to this object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1128">如果 <paramref name="c" /> 參數和目前型別表示相同的型別，或者如果目前型別是在 <paramref name="c" /> 的繼承階層架構中，又或者如果目前型別是 <paramref name="c" /> 支援的介面，則為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1128">
              <see langword="true" /> if the <paramref name="c" /> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <paramref name="c" />, or if the current type is an interface that <paramref name="c" /> supports.</span>
          </span>
          <span data-ttu-id="3db8e-1129">如果以上條件都無效，或是 <paramref name="c" /> 為 <see langword="false" />，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1129">
              <see langword="false" /> if none of these conditions are valid, or if <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1130">取得值，指出這個物件是否表示建構的泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1130">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1131">如果這個物件代表建構的泛型類型，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1131">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1132">傳回表示是否已建立目前動態類型的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1132">Returns a value that indicates whether the current dynamic type has been created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1133">如已呼叫 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1133">
              <see langword="true" /> if the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has been called; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1134">之後<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>方法呼叫之後所代表的類型<xref:System.Reflection.Emit.TypeBuilder>物件已完成。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1134">After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete.</span></span> <span data-ttu-id="3db8e-1135">若要將成員新增或變更之型別的其他特性的任何進一步嘗試都會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1135">Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <span data-ttu-id="3db8e-1136">要搜尋的屬性類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1136">The type of attribute to search for.</span>
          </span>
          <span data-ttu-id="3db8e-1137">只會傳回可指派給這種類型的屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1137">Only attributes that are assignable to this type are returned.</span>
          </span>
        </param>
        <param name="inherit">
          <span data-ttu-id="3db8e-1138">指定是否要搜尋這個成員的繼承鏈結以尋找屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1138">Specifies whether to search this member's inheritance chain to find the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1139">決定是否要將自訂屬性套用至目前的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1139">Determines whether a custom attribute is applied to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1140">如果已在這個型別上定義 <paramref name="attributeType" /> 的一個或多個執行個體或衍生自 <paramref name="attributeType" /> 的屬性，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1140">
              <see langword="true" /> if one or more instances of <paramref name="attributeType" />, or an attribute derived from <paramref name="attributeType" />, is defined on this type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1141">這個方法不支援不完整的泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1141">This method is not supported for incomplete generic type parameters.</span></span> <span data-ttu-id="3db8e-1142">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1142">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1143">這個方法目前不支援不完整的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1143">This method is not currently supported for incomplete types.</span>
          </span>
          <span data-ttu-id="3db8e-1144">使用 <see cref="M:System.Type.GetType" /> 來擷取型別，並在傳回的 <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> 上呼叫 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1144">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-1145">
            <paramref name="attributeType" />未定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1145">
              <paramref name="attributeType" /> is not defined.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-1146">
            <paramref name="attributeType" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1146">
              <paramref name="attributeType" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1147">取得值，指出目前類型是否為泛型類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1147">Gets a value indicating whether the current type is a generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1148">如果目前的 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件代表泛型類型參數，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1148">
              <see langword="true" /> if the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1149">當發出程式碼，泛型型別參數由<xref:System.Reflection.Emit.GenericTypeParameterBuilder>物件而非由<xref:System.Reflection.Emit.TypeBuilder>物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1149">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1150">取得值，指出目前類型是否為泛型類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1150">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1151">如果由目前的 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件所代表的類型為泛型，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1151">
              <see langword="true" /> if the type represented by the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object is generic; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1152">A<xref:System.Reflection.Emit.TypeBuilder>物件代表泛型類型定義，如果<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>已經用來提供給它的泛型類型參數的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1152">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="3db8e-1153">執行個體<xref:System.Reflection.Emit.TypeBuilder>泛用類別永遠是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1153">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="3db8e-1154">如需有關反映和非變異條件在反映中泛型的詞彙的清單中的泛型類型的詳細資訊，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1154">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1155">取得值，指出目前的 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 是否代表可用於建構其他泛型類型的泛型類型定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1155">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> represents a generic type definition from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1156">如果這個 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件代表泛型類型定義，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1156">
              <see langword="true" /> if this <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1157">A<xref:System.Reflection.Emit.TypeBuilder>物件代表泛型類型定義，如果<xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A>已經用來提供給它的泛型類型參數的方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1157">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="3db8e-1158">執行個體<xref:System.Reflection.Emit.TypeBuilder>泛用類別永遠是泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1158">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="3db8e-1159">A<xref:System.Reflection.Emit.TypeBuilder>可用來建置泛型類型定義，但未建構的泛型型別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1159">A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types.</span></span> <span data-ttu-id="3db8e-1160">若要取得建構的泛型類型，請呼叫<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>方法<xref:System.Reflection.Emit.TypeBuilder>，代表泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1160">To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span>  
  
 <span data-ttu-id="3db8e-1161">如需有關反映和非變異條件在反映中泛型的詞彙的清單中的泛型類型的詳細資訊，請參閱<xref:System.Type.IsGenericType%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1161">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1162">取得值，這個值表示目前類型是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1162">Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1163">如果目前型別為安全性關鍵或安全性安全關鍵，則為 <see langword="true" />，如果它是透明，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1163">
              <see langword="true" /> if the current type is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1164"><xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A>屬性報告類型的透明度，由 common language runtime (CLR) 所決定。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1164">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="3db8e-1165">這些屬性的組合是下表所示：</span><span class="sxs-lookup"><span data-stu-id="3db8e-1165">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="3db8e-1166">安全性層級</span><span class="sxs-lookup"><span data-stu-id="3db8e-1166">Security level</span></span>|<span data-ttu-id="3db8e-1167">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1167">IsSecurityCritical</span></span>|<span data-ttu-id="3db8e-1168">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1168">IsSecuritySafeCritical</span></span>|<span data-ttu-id="3db8e-1169">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="3db8e-1169">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="3db8e-1170">Critical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1170">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="3db8e-1171">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="3db8e-1171">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="3db8e-1172">透明</span><span class="sxs-lookup"><span data-stu-id="3db8e-1172">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="3db8e-1173">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1173">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="3db8e-1174">執行階段開始評估組件的透明度等級。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1174">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="3db8e-1175">比方說，如果在動態組件是安全性關鍵，型別上的註解會被忽略，和所有類型都是安全性關鍵。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1175">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="3db8e-1176">根據預設，動態組件會繼承它發出的組件的透明度。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1176">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="3db8e-1177">您可以使用覆寫此預設<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>， <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>，或<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>方法多載，並指定安全性屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1177">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="3db8e-1178">您無法提高安全性層級，這樣做。也就是透明的程式碼無法發出安全性關鍵或安全性安全關鍵程式碼。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1178">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="3db8e-1179">建立動態組件時，或它們不會生效之前已儲存至磁碟並重新載入組件時，必須指定屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1179">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1180">預設值繼承僅限於執行階段評估的透明度。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1180">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="3db8e-1181">沒有屬性會套用至動態組件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1181">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="3db8e-1182">如果您想要新增的安全性屬性，您必須套用它們自己。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1182">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="3db8e-1183">如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1183">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="3db8e-1184">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1184">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1185">尚未透過呼叫 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法來建立目前的動態型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1185">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1186">取得值，這個值表示目前類型是否為安全性安全關鍵，也就是說，它是否能執行重要作業並由安全性透明的程式碼存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1186">Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1187">如果目前型別為安全性安全關鍵，則為 <see langword="true" />，如果它是安全性關鍵或透明，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1187">
              <see langword="true" /> if the current type is security-safe-critical; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1188"><xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A>屬性報告類型的透明度，由 common language runtime (CLR) 所決定。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1188">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="3db8e-1189">這些屬性的組合是下表所示：</span><span class="sxs-lookup"><span data-stu-id="3db8e-1189">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="3db8e-1190">安全性層級</span><span class="sxs-lookup"><span data-stu-id="3db8e-1190">Security level</span></span>|<span data-ttu-id="3db8e-1191">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1191">IsSecurityCritical</span></span>|<span data-ttu-id="3db8e-1192">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1192">IsSecuritySafeCritical</span></span>|<span data-ttu-id="3db8e-1193">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="3db8e-1193">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="3db8e-1194">Critical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1194">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="3db8e-1195">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="3db8e-1195">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="3db8e-1196">透明</span><span class="sxs-lookup"><span data-stu-id="3db8e-1196">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="3db8e-1197">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1197">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="3db8e-1198">執行階段開始評估組件的透明度等級。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1198">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="3db8e-1199">比方說，如果在動態組件是安全性關鍵，型別上的註解會被忽略，和所有類型都是安全性關鍵。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1199">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="3db8e-1200">根據預設，動態組件會繼承它發出的組件的透明度。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1200">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="3db8e-1201">您可以使用覆寫此預設<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>， <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>，或<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>方法多載，並指定安全性屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1201">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="3db8e-1202">您無法提高安全性層級，這樣做。也就是透明的程式碼無法發出安全性關鍵或安全性安全關鍵程式碼。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1202">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="3db8e-1203">建立動態組件時，或它們不會生效之前已儲存至磁碟並重新載入組件時，必須指定屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1203">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1204">預設值繼承僅限於執行階段評估的透明度。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1204">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="3db8e-1205">沒有屬性會套用至動態組件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1205">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="3db8e-1206">如果您想要新增的安全性屬性，您必須套用它們自己。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1206">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="3db8e-1207">如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1207">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="3db8e-1208">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1208">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1209">尚未透過呼叫 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法來建立目前的動態型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1209">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1210">取得值，這個值表示目前類型是否為透明，因此無法執行重要作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1210">Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1211">如果型別為安全性透明，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1211">
              <see langword="true" /> if the type is security-transparent; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1212"><xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A>屬性報告類型的透明度，由 common language runtime (CLR) 所決定。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1212">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="3db8e-1213">這些屬性的組合是下表所示：</span><span class="sxs-lookup"><span data-stu-id="3db8e-1213">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="3db8e-1214">安全性層級</span><span class="sxs-lookup"><span data-stu-id="3db8e-1214">Security level</span></span>|<span data-ttu-id="3db8e-1215">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1215">IsSecurityCritical</span></span>|<span data-ttu-id="3db8e-1216">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1216">IsSecuritySafeCritical</span></span>|<span data-ttu-id="3db8e-1217">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="3db8e-1217">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="3db8e-1218">Critical</span><span class="sxs-lookup"><span data-stu-id="3db8e-1218">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="3db8e-1219">安全關鍵</span><span class="sxs-lookup"><span data-stu-id="3db8e-1219">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="3db8e-1220">透明</span><span class="sxs-lookup"><span data-stu-id="3db8e-1220">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="3db8e-1221">使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1221">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="3db8e-1222">執行階段開始評估組件的透明度等級。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1222">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="3db8e-1223">比方說，如果在動態組件是安全性關鍵，型別上的註解會被忽略，和所有類型都是安全性關鍵。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1223">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="3db8e-1224">根據預設，動態組件會繼承它發出的組件的透明度。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1224">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="3db8e-1225">您可以使用覆寫此預設<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>， <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>，或<xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>方法多載，並指定安全性屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1225">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="3db8e-1226">您無法提高安全性層級，這樣做。也就是透明的程式碼無法發出安全性關鍵或安全性安全關鍵程式碼。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1226">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="3db8e-1227">建立動態組件時，或它們不會生效之前已儲存至磁碟並重新載入組件時，必須指定屬性。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1227">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1228">預設值繼承僅限於執行階段評估的透明度。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1228">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="3db8e-1229">沒有屬性會套用至動態組件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1229">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="3db8e-1230">如果您想要新增的安全性屬性，您必須套用它們自己。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1230">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="3db8e-1231">如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1231">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="3db8e-1232">透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1232">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1233">尚未透過呼叫 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法來建立目前的動態型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1233">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="3db8e-1234">要檢查的 <see cref="T:System.Type" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1234">A <see cref="T:System.Type" /> that is to be checked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1235">判斷此類型是否衍生自指定的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1235">Determines whether this type is derived from a specified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1236">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1236">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1237">如果這個型別與型別 <paramref name="c" /> 相同，或是型別 <paramref name="c" /> 的子型別，則傳回 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1237">Returns <see langword="true" /> if this type is the same as the type <paramref name="c" />, or is a subtype of type <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1238">傳回代表目前類型之陣列的 <see cref="T:System.Type" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1238">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1239">傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成的一維陣列，其下限為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1239">Returns a <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1240">代表一維陣列類型的 <see cref="T:System.Type" /> 物件，其項目類型是目前的類型，下限為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1240">A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1241"><xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A>方法可用來產生任何可能的項目類型，包括泛型類型的陣列類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1241">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-1242">下列程式碼範例會建立動態模組，名為抽象型別`Sample`，和名為的抽象方法`TestMethod`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1242">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="3db8e-1243">`TestMethod` 會採用`ref`參數 (`ByRef`在 Visual Basic 中) 的型別`Sample`，類型的指標`Sample`，和類型的陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1243">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1244">它會傳回類型的二維陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1244">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1245">程式碼範例將儲存動態模組至磁碟，因此您可以檢查它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1245">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="3db8e-1246">陣列的維度數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1246">The number of dimensions for the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1247">傳回 <see cref="T:System.Type" /> 物件，代表由目前類型組成且為指定維度個數的陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1247">Returns a <see cref="T:System.Type" /> object that represents an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1248">
            <see cref="T:System.Type" /> 物件，代表目前類型的一維陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1248">A <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1249"><xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A>方法可用來產生任何可能的項目類型，包括泛型類型的陣列類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1249">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-1250">下列程式碼範例會建立動態模組，名為抽象型別`Sample`，和名為的抽象方法`TestMethod`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1250">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="3db8e-1251">`TestMethod` 會採用`ref`參數 (`ByRef`在 Visual Basic 中) 的型別`Sample`，類型的指標`Sample`，和類型的陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1251">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1252">它會傳回類型的二維陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1252">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1253">程式碼範例將儲存動態模組至磁碟，因此您可以檢查它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1253">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3db8e-1254">
            <paramref name="rank" /> 不是有效的陣列維度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1254">
              <paramref name="rank" /> is not a valid array dimension.</span>
          </span>
        </exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1255">傳回 <see cref="T:System.Type" /> 物件，表示當做 <see langword="ref" /> (Visual Basic 中為 <see langword="ByRef" />) 參數傳遞時的目前型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1255">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1256">
            <see cref="T:System.Type" /> 物件，表示當做 <see langword="ref" /> (Visual Basic 中為 <see langword="ByRef" />) 參數傳遞時的目前型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1256">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1257"><xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A>方法可用來產生`ref`類型 (`ByRef`在 Visual Basic 中) 的參數清單。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1257">The <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1258">使用 Microsoft intermediate language (MSIL) 語法中，如果目前<xref:System.Reflection.Emit.TypeBuilder>代表`MyType`，則這個方法所傳回的型別會是`MyType&`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1258">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-1259">下列程式碼範例會建立動態模組，名為抽象型別`Sample`，和名為的抽象方法`TestMethod`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1259">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="3db8e-1260">`TestMethod` 會採用`ref`參數 (`ByRef`在 Visual Basic 中) 的型別`Sample`，類型的指標`Sample`，和類型的陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1260">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1261">它會傳回類型的二維陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1261">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1262">程式碼範例將儲存動態模組至磁碟，因此您可以檢查它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1262">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="3db8e-1263">由類型組成的陣列，用來取代目前泛型類型定義的類型參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1263">An array of types to be substituted for the type parameters of the current generic type definition.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1264">用類型陣列的項目取代目前泛型類型定義的類型參數，並傳回產生的建構類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1264">Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1265">
            <see cref="T:System.Type" />，表示用 <paramref name="typeArguments" /> 的項目取代目前泛型類型之類型參數所得到的建構類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1265">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1266">當您發出程式碼需要從目前的泛型類型定義建構的類型時，請使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1266">Use this method when your emitted code requires a type constructed from the current generic type definition.</span></span> <span data-ttu-id="3db8e-1267">不需要呼叫<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>方法之前先呼叫<xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A>方法<xref:System.Reflection.Emit.TypeBuilder>，代表泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1267">It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span> <span data-ttu-id="3db8e-1268">如果目前<xref:System.Reflection.Emit.TypeBuilder>不代表泛型類型，定義<xref:System.InvalidOperationException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1268">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="3db8e-1269">這個方法的函式所傳回做為預留位置發出程式碼中建構的泛型類型的物件。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1269">The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</span></span> <span data-ttu-id="3db8e-1270">它是衍生自類別的執行個體<xref:System.Type>，具有有限的功能。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1270">It is an instance of a class derived from <xref:System.Type> that has limited capabilities.</span></span> <span data-ttu-id="3db8e-1271">特別之處在於：</span><span class="sxs-lookup"><span data-stu-id="3db8e-1271">In particular:</span></span>  
  
-   <span data-ttu-id="3db8e-1272">若要取得這些建構的泛型類型的方法、 欄位和建構函式，使用<xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>， <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>，和<xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1272">To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.</span></span>  
  
-   <span data-ttu-id="3db8e-1273">代表相同的建構的類型的兩個執行個體不會比較為相等。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1273">Two instances that represent the same constructed type do not compare as equal.</span></span> <span data-ttu-id="3db8e-1274">例如，在下列程式碼`t1.Equals(t2)`傳回`false`:</span><span class="sxs-lookup"><span data-stu-id="3db8e-1274">For example, in the following code `t1.Equals(t2)` returns `false`:</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-1275">目前類型不代表泛型類型的定義。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1275">The current type does not represent the definition of a generic type.</span>
          </span>
          <span data-ttu-id="3db8e-1276">亦即，<see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 會傳回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1276">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-1277">
            <paramref name="typeArguments" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1277">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-1278">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1278">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1279">
            <paramref name="typeArguments" /> 的任何項目是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1279">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-1280">
            <paramref name="typeArguments" /> 的任何項目之 <see cref="P:System.Type.Module" /> 屬性是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1280">The <see cref="P:System.Type.Module" /> property of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="3db8e-1281">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1281">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1282">
            <paramref name="typeArguments" /> 的任何項目模組之 <see cref="P:System.Reflection.Module.Assembly" /> 屬性是 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1282">The <see cref="P:System.Reflection.Module.Assembly" /> property of the module of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1283">傳回 <see cref="T:System.Type" /> 物件，代表指向目前類型之 Unmanaged 指標的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1283">Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1284">
            <see cref="T:System.Type" /> 物件，代表指向目前類型之 Unmanaged 指標的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1284">A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1285"><xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A>方法可用來產生參數清單的指標類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1285">The <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1286">使用 Microsoft intermediate language (MSIL) 語法中，如果目前<xref:System.Reflection.Emit.TypeBuilder>代表`MyType`，則這個方法所傳回的型別會是`MyType*`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1286">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3db8e-1287">下列程式碼範例會建立動態模組，名為抽象型別`Sample`，和名為的抽象方法`TestMethod`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1287">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="3db8e-1288">`TestMethod` 會採用`ref`參數 (`ByRef`在 Visual Basic 中) 的型別`Sample`，類型的指標`Sample`，和類型的陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1288">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1289">它會傳回類型的二維陣列`Sample`。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1289">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="3db8e-1290">程式碼範例將儲存動態模組至磁碟，因此您可以檢查它與[Ildasm.exe （IL 解譯器）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1290">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1291">擷取包含這個類型定義的動態模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1291">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1292">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1292">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1293">擷取包含這個類型定義的動態模組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1293">Retrieves the dynamic module that contains this type definition.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1294">擷取這個類型的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1294">Retrieves the name of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1295">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1295">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1296">擷取這個類型的 <see cref="T:System.String" /> 名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1296">Retrieves the <see cref="T:System.String" /> name of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1297">擷取定義這個 <see langword="TypeBuilder" /> 的命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1297">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1298">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1298">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1299">擷取定義這個 <see langword="TypeBuilder" /> 的命名空間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1299">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1300">擷取這個類型的封裝大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1300">Retrieves the packing size of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1301">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1301">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1302">擷取這個類型的封裝大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1302">Retrieves the packing size of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1303">傳回用來取得這個類型的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1303">Returns the type that was used to obtain this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1304">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1304">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1305">用來取得這個類型的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1305">The type that was used to obtain this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1306">設定自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1306">Sets a custom attribute.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">
          <span data-ttu-id="3db8e-1307">定義自訂屬性的協助程式類別執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1307">An instance of a helper class to define the custom attribute.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1308">使用自訂屬性產生器來設定自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1308">Set a custom attribute using a custom attribute builder.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1309">從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1309">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="3db8e-1310">(請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1310">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-1311">
            <paramref name="customBuilder" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1311">
              <paramref name="customBuilder" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-1312">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1312">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">
          <span data-ttu-id="3db8e-1313">自訂屬性的建構函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1313">The constructor for the custom attribute.</span>
          </span>
        </param>
        <param name="binaryAttribute">
          <span data-ttu-id="3db8e-1314">代表屬性的位元組 Blob。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1314">A byte blob representing the attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1315">使用指定的自訂屬性 Blob 來設定自訂屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1315">Sets a custom attribute using a specified custom attribute blob.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1316">如需有關如何格式化`binaryAttribute`，請參閱 Common Language Infrastructure (CLI) 文件，尤其是 < 磁碟分割 II： 中繼資料定義和語意 >。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1316">For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="3db8e-1317">您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](http://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1317">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3db8e-1318">從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1318">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="3db8e-1319">(請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1319">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3db8e-1320">
            <paramref name="con" /> 或 <paramref name="binaryAttribute" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1320">
              <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-1321">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1321">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">
          <span data-ttu-id="3db8e-1322">新的基底類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1322">The new base type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1323">設定目前建構中之類型的基底類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1323">Sets the base type of the type currently under construction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1324">如果`parent`是`null`，<xref:System.Object>做為基底類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1324">If `parent` is `null`, <xref:System.Object> is used as the base type.</span></span>  
  
 <span data-ttu-id="3db8e-1325">在.NET framework 1.0 和 1.1 版中，不會擲回例外狀況`parent`是介面類型，但<xref:System.TypeLoadException>時擲回<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1325">In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
 <span data-ttu-id="3db8e-1326"><xref:System.Reflection.Emit.TypeBuilder.SetParent%2A>方法不會檢查大部分無效的父類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1326">The <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> method does not check for most invalid parent types.</span></span> <span data-ttu-id="3db8e-1327">例如，它不會拒絕具有沒有預設建構函式，當目前的類型具有預設建構函式時，它不會拒絕密封的型別，而且它不會拒絕的父類型<xref:System.Delegate>型別。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1327">For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type.</span></span> <span data-ttu-id="3db8e-1328">在這些情況下，會擲回例外狀況由<xref:System.Reflection.Emit.TypeBuilder.CreateType%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1328">In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-1329">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1329">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
          <span data-ttu-id="3db8e-1330">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1330">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1331">
            <paramref name="parent" /> 為 <see langword="null" />，而且目前的執行個體代表其屬性不包含 <see cref="F:System.Reflection.TypeAttributes.Abstract" /> 的介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1331">
              <paramref name="parent" /> is <see langword="null" />, and the current instance represents an interface whose attributes do not include <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span>
          </span>
          <span data-ttu-id="3db8e-1332">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1332">-or-</span>
          </span>
          <span data-ttu-id="3db8e-1333">目前動態類型的 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> 屬性為 <see langword="true" />，但 <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> 屬性為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1333">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3db8e-1334">
            <paramref name="parent" /> 是介面。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1334">
              <paramref name="parent" /> is an interface.</span>
          </span>
          <span data-ttu-id="3db8e-1335">這是 .NET Framework 2.0 版的新例外狀況條件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1335">This exception condition is new in the .NET Framework version 2.0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1336">擷取類型的總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1336">Retrieves the total size of a type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1337">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1337">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1338">擷取這個類型的總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1338">Retrieves this type’s total size.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="3db8e-1339">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1339">Reserved for future use.</span>
          </span>
          <span data-ttu-id="3db8e-1340">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1340">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="3db8e-1341">要對應之傳入的名稱陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1341">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="3db8e-1342">要對應的名稱計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1342">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="3db8e-1343">用於解譯名稱的地區設定內容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1343">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="3db8e-1344">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1344">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1345">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1345">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1346">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1346">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3db8e-1347">如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1347">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3db8e-1348">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1348">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="3db8e-1349">要傳回的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1349">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="3db8e-1350">類型資訊的地區設定識別項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1350">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="3db8e-1351">接收要求的類型資訊物件的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1351">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1352">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1352">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1353">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1353">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3db8e-1354">如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1354">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3db8e-1355">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1355">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="3db8e-1356">指向接收物件提供的類型資訊介面數目的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1356">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1357">擷取物件提供的類型資訊介面數目 (0 或 1)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1357">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1358">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1358">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3db8e-1359">如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1359">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3db8e-1360">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1360">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="3db8e-1361">辨識成員。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1361">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="3db8e-1362">保留供未來使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1362">Reserved for future use.</span>
          </span>
          <span data-ttu-id="3db8e-1363">必須是 IID_NULL。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1363">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="3db8e-1364">地區設定內容，用於解譯引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1364">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="3db8e-1365">描述呼叫之內容的旗標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1365">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="3db8e-1366">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1366">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="3db8e-1367">指向用於儲存結果之位置的指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1367">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="3db8e-1368">包含例外狀況資訊的結構指標。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1368">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="3db8e-1369">第一個有錯誤的引數索引。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1369">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="3db8e-1370">提供物件所公開的屬性和方法的存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1370">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1371">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1371">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3db8e-1372">如需有關`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1372">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="3db8e-1373">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1373">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1374">傳回不含命名空間的類型名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1374">Returns the name of the type excluding the namespace.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="3db8e-1375">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1375">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1376">不含命名空間的類型名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1376">The name of the type excluding the namespace.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1377">在動態模組中不支援。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1377">Not supported in dynamic modules.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1378">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1378">Read-only.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3db8e-1379">擷取型別使用<xref:System.Type.GetType%2A?displayProperty=nameWithType>或<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>上，並使用反映來擷取類型。</span><span class="sxs-lookup"><span data-stu-id="3db8e-1379">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3db8e-1380">在動態模組中不支援。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1380">Not supported in dynamic modules.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1381">傳回這個類型的類型語彙基元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1381">Returns the type token of this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1382">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1382">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1383">傳回這個型別的 <see langword="TypeToken" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1383">Returns the <see langword="TypeToken" /> of this type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-1384">先前使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 建立的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1384">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1385">傳回這個 <see langword="TypeBuilder" /> 的基礎系統型別。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1385">Returns the underlying system type for this <see langword="TypeBuilder" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="3db8e-1386">唯讀。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1386">Read-only.</span>
          </span>
          <span data-ttu-id="3db8e-1387">傳回基礎系統類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1387">Returns the underlying system type.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3db8e-1388">這個類型是一種列舉，但沒有基礎系統類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1388">This type is an enumeration, but there is no underlying system type.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="3db8e-1389">代表未指定該類型的總大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="3db8e-1389">Represents that total size for the type is not specified.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>