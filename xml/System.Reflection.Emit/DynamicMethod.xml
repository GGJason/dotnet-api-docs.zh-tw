<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="337c0dfc53fd303d550b5b9161734953e0f07c58" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36469945" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定義及代表可以編譯、執行和捨棄的動態方法。 已捨棄的方法可供記憶體回收所用。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Reflection.Emit.DynamicMethod>類別來產生，並在執行階段，執行方法，而不需產生動態組件和動態的型別包含方法。 在 just-in-time (JIT) 編譯器所建立的可執行程式碼會回收時<xref:System.Reflection.Emit.DynamicMethod>收回物件。 動態方法是最有效率的方式來產生並執行程式碼的資訊量很少。  
  
 可以匿名裝載動態方法，或可以是邏輯上相關聯的模組或型別。  
  
-   如果匿名裝載動態方法，它是系統提供的組件，位於，因此與其他程式碼分開。 根據預設，它沒有任何非公用資料的存取權。 匿名裝載的動態方法可以限制略過 JIT 編譯器可見度檢查，如果被授與能力<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標。 動態方法所存取其非公用成員的組件的信任層級必須相同或發出動態方法的呼叫堆疊的信任層級的子集。 如需匿名裝載動態方法的詳細資訊，請參閱[逐步解說： 在部分信任案例中發出的程式碼](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)。  
  
-   如果您指定的模組相關聯的動態方法，動態方法在有效的全域模組。 它可以存取模組中的所有類型和所有`internal`(`Friend`在 Visual Basic 中) 的類型的成員。 您可以將動態方法與任何模組，不論您建立模組，但前提是要求<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>旗標都可藉由呼叫堆疊，其中包含您的程式碼。 如果<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標包含授權、 動態方法可以略過 JIT 編譯器可見度檢查，並且存取所有類型宣告為任何組件中的任何其他模組或模組中的私用資料。  
  
    > [!NOTE]
    >  當您指定動態方法在相關聯的模組時，該模組不能用於匿名裝載的系統提供組件中。  
  
-   如果您指定的型別相關聯的動態方法，其型別的所有成員的存取權不論存取層級。 此外，可以略過 JIT 可見度檢查。 這可讓在相同的模組或任何組件中的任何其他模組中宣告其他類型的私用資料的動態方法存取。 您可以將動態方法與任何類型，但您的程式碼必須被授與<xref:System.Security.Permissions.ReflectionPermission>兼具<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>和<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>旗標。  
  
 下表顯示哪些類型和成員可以存取匿名裝載的動態方法，與 JIT 可見度檢查，取決於是否不<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>旗標會授與。  
  
||不使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|不需略過 JIT 可見度檢查|任何組件中的公用類型的公用成員。|任何組件中的公用類型的公用成員。|  
|正在略過 JIT 可見度檢查，以限制|任何組件中的公用類型的公用成員。|只有在其信任層級會等於或小於發出動態方法的組件的信任層級的組件中的所有型別的所有成員。|  
  
> [!NOTE]
>  之前[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，發出程式碼所需<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 此權限會包含預設在完全信任和 LocalIntranet 具名使用權限集合中，但是不在網際網路權限集合。 因此，在舊版的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]程式庫可以使用具有網際網路權限，只有當<xref:System.Security.SecurityCriticalAttribute>屬性，也會執行<xref:System.Security.PermissionSet.Assert%2A>如<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>。 這類程式庫需要仔細的安全性檢閱，因為編碼錯誤可能會造成安全性漏洞。 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] 允許在部分信任案例中發出程式碼，而不需提出任何安全性要求，因為產生的程式碼本質上並非有權限的作業。 也就是產生的程式碼之權限不會比發出程式碼的組件還多。 這可讓程式庫發出安全性透明的程式碼，並可免除 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 判斷提示的需要，這可簡化撰寫安全程式庫的工作。 若要使用這項功能，您的應用程式應將目標設[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更新版本。  
  
 下表顯示哪些類型和成員都可以與模組或模組中的類型相關聯的動態方法存取。  
  
||模組相關聯|與類型相關聯|  
|-|-|-|  
|不需略過 JIT 可見度檢查|模組中的公用、 內部和私用類型的公用和內部成員。<br /><br /> 任何組件中的公用類型的公用成員。|所有成員相關聯的類型。 模組中的所有其他類型的公用和內部成員。<br /><br /> 任何組件中的公用類型的公用成員。|  
|正在略過 JIT 可見度檢查|任何組件中的所有型別的所有成員。|任何組件中的所有型別的所有成員。|  
  
 與模組相關聯的動態方法會具有該模組的權限。 與類型相關聯的動態方法已包含該類型的模組的權限。  
  
 動態方法和它們的參數不需要加以命名，但您可以指定名稱，以協助偵錯。 動態方法或其參數上不支援自訂屬性。  
  
 動態方法雖然`static`方法 (`Shared`方法，在 Visual Basic 中的)，則放寬規則，委派繫結中導入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]讓繫結至物件的動態方法，這樣它就像是執行個體方法時呼叫使用該委派執行個體。 提供範例示範這<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法多載。  
  
> [!NOTE]
>  在[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，動態方法並不支援的符號資訊、 本機變數名稱和行號對應。 這項限制可能會在未來版本中移除。 您可以使用<xref:System.Reflection.Emit.AssemblyBuilder>簡化偵錯的產生的 Microsoft intermediate language (MSIL)，然後再切換至動態方法最後在部署期間，因為在開發期間<xref:System.Reflection.Emit.ILGenerator>呼叫是這兩種情況中的相同。  
  
## <a name="verification"></a>驗證  
 下列清單摘要說明的動態方法可以包含無法驗證程式碼的狀況。 (例如，動態方法，將無法驗證如果其<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>屬性設定為`false`。)  
  
-   安全性關鍵組件相關聯的動態方法也是安全性關鍵，而且可以略過驗證。 例如，沒有安全性屬性當做桌面應用程式執行的組件視為為安全性關鍵的執行階段。 如果您將動態方法與組件產生關聯，動態方法包含無法驗證程式碼。  
  
-   如果具有層級 1 透明度的組件相關聯的動態方法含有未經驗證的程式碼，在 just-in-time (JIT) 編譯器會插入安全性要求。 只有當完全信任的程式碼執行動態方法，要求就會成功。 請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)。  
  
-   如果具有層級 2 透明度 （例如 mscorlib.dll) 的組件相關聯的動態方法含有未經驗證的程式碼，它就會擲回例外狀況 （由 JIT 編譯器插入） 而不是進行安全性要求。 請參閱[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
-   匿名裝載的動態方法包含無法驗證的程式碼一律會擲回例外狀況。 它永遠不可以略過驗證，即使它是建立並執行完全信任的程式碼。  
  
 無法驗證程式碼，會擲回的例外狀況會叫用動態方法的方式而有所不同。 如果您使用叫用動態方法所傳回的委派<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法，<xref:System.Security.VerificationException>就會擲回。 如果您使用叫用動態方法<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法，<xref:System.Reflection.TargetInvocationException>會擲回內部<xref:System.Security.VerificationException>。  
  
   
  
## Examples  
 下列程式碼範例會建立動態方法採用兩個參數。 這個範例會發出列印至主控台時，第一個參數的簡單函式主體，此範例會使用做為方法的傳回值的第二個參數。 此範例完成藉由建立委派的方法、 叫用使用不同的參數，委派和最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立動態方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <summary>初始化匿名裝載的動態方法，並指定方法名稱、傳回類型和參數類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法所建立的這個建構函式是匿名的組件，而不是現有的類型或模組相關聯。 匿名的組件存在只用來提供沙箱環境的動態方法，也就是，以將它們與其他程式碼隔離。 這個環境可讓您更安全的動態方法發出及執行部分信任程式碼。  
  
 這個建構函式指定在 just-in-time (JIT) 可見度檢查將會強制執行的 Microsoft intermediate language (MSIL) 的動態方法。 也就是動態方法中的程式碼可以存取公用類別的公用方法。 如果該方法嘗試存取類型或成員，會擲回例外狀況`private`， `protected`，或`internal`(`Friend`在 Visual Basic 中)。 若要建立具有限制略過 JIT 可見度檢查能力的動態方法，使用<xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>建構函式。  
  
 建構匿名裝載的動態方法時，發出的組件的呼叫堆疊會包含在內。 叫用方法時，發出的組件的權限可用而不是實際呼叫者的權限。 因此，無法執行動態方法，在發出，即使它是傳遞給方法以及具有較高的信任層級的組件所執行的組件的權限的較高層級。  
  
 這個建構函式指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  中引進這個建構函式[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更新版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="restrictedSkipVisibility">
          <see langword="true" /> 則略過對動態方法的 MSIL 所存取之類型和成員的 JIT 可視性檢查，但有此限制：包含這些類型和成員的組件的信任層級，必須等於或小於發出動態方法的呼叫堆疊的信任層級；否則為 <see langword="false" />。</param>
        <summary>初始化匿名裝載的動態方法，並指定方法名稱、傳回類型、參數類型、以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法所建立的這個建構函式是匿名的組件，而不是現有的類型或模組相關聯。 匿名的組件存在只用來提供沙箱環境的動態方法，也就是，以將它們與其他程式碼隔離。 這個環境可讓您更安全的動態方法發出及執行部分信任程式碼。  
  
 匿名裝載動態方法沒有任何類型或成員會自動存取`private`， `protected`，或`internal`(`Friend`在 Visual Basic 中)。 這是不同的動態方法與現有的類型或模組，相關聯的相關聯的範圍中具有隱藏成員的存取權。  
  
 指定`true`如`restrictedSkipVisibility`動態方法是否存取類型或成員`private`， `protected`，或`internal`。 這會提供給這些成員的動態方法，限制存取。 也就是符合下列條件時，才可以存取成員：  
  
-   目標成員屬於具有等於或小於發出動態方法的呼叫堆疊的信任層級的組件。  
  
-   發出動態方法的呼叫堆疊會授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標。 以完全信任執行的程式碼時，這是永遠為 true。 部分信任的程式碼，它才為 true 主機明確授與權限。  
  
    > [!IMPORTANT]
    >  如果未授與權限，安全性例外狀況時擲回<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>稱為或叫用動態方法時，不這個建構函式呼叫時。 發出動態方法不需要任何特殊權限。  
  
 例如，動態方法用來建立`restrictedSkipVisibility`設`true`可以存取在呼叫堆疊上的任何組件的私用成員，如果呼叫堆疊授與限制的成員存取。 如果呼叫堆疊上的部分信任程式碼會建立動態方法，它無法存取私用成員中的型別的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]組件，因為這類組件是完全受信任。  
  
 如果`restrictedSkipVisibility`是`false`，會強制執行的 JIT 可見度檢查。 動態方法中的程式碼可以存取公用類別的公用方法，而且如果它嘗試存取類型或成員，會擲回例外狀況`private`， `protected`，或`internal`。  
  
 建構匿名裝載的動態方法時，發出的組件的呼叫堆疊會包含在內。 叫用方法時，會使用發出的呼叫堆疊的權限，而不是實際呼叫者的權限。 因此，無法執行動態方法，在發出，即使它是傳遞給方法以及具有較高的信任層級的組件所執行的組件的權限的較高層級。  
  
 這個建構函式指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  中引進這個建構函式[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更新版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="m">
          <see cref="T:System.Reflection.Module" />，代表動態方法在邏輯上相關聯的模組。</param>
        <summary>建立對模組通用的動態方法，並指定方法名稱、傳回類型、參數類型和模組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，並不會略過在 just-in-time (JIT) 可見度檢查。  
  
 這個建構函式以建立動態方法可存取公用和`internal`(`Friend`在 Visual Basic 中) 包含在模組中的所有型別的成員`m`。  
  
> [!NOTE]
>  回溯相容性，這個建構函式要求<xref:System.Security.Permissions.SecurityPermission>與<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>旗標，如果下列條件都為 true:`m`是模組之外呼叫模組，以及需求的<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果要求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例會建立動態方法採用兩個參數。 這個範例會發出列印至主控台時，第一個參數的簡單函式主體，此範例會使用做為方法的傳回值的第二個參數。 此範例完成藉由建立委派的方法、 叫用使用不同的參數，委派和最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  -或-  <paramref name="m" /> 是為動態方法提供匿名裝載的模組。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  -或-  <paramref name="m" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要將動態方法產生關聯以外呼叫模組的模組。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="owner">動態方法在邏輯方面相關聯的 <see cref="T:System.Type" />。 動態方法可存取該類型的所有成員。</param>
        <summary>建立動態方法，指定方法名稱、傳回類型、參數類型及與動態方法在邏輯上相關聯的類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個建構函式建立此動態方法沒有型別的所有成員的存取權`owner`，並為 public 和`internal`(`Friend`在 Visual Basic 中) 包含的模組中的所有其他類型的成員`owner`。  
  
 這個建構函式指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，並不會略過在 just-in-time (JIT) 可見度檢查。  
  
> [!NOTE]
>  回溯相容性，這個建構函式要求<xref:System.Security.Permissions.SecurityPermission>與<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>旗標，如果下列條件都為 true:`owner`以外呼叫模組，以及需求的模組中<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果要求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Reflection.Emit.DynamicMethod>邏輯上相關聯的類型。 此關聯可讓它存取該類型的私用成員。  
  
 程式碼範例定義名為類別`Example`私用欄位，與類別名稱為`DerivedFromxample`衍生自第一個類別，名為委派類型`UseLikeStatic`傳回<xref:System.Int32>且具有參數的型別`Example`和<xref:System.Int32>，和名為委派類型`UseLikeInstance`傳回<xref:System.Int32>且具有一個參數的型別<xref:System.Int32>。  
  
 範例程式碼接著會建立<xref:System.Reflection.Emit.DynamicMethod>變更執行個體的私用欄位`Example`並傳回先前的值。  
  
> [!NOTE]
>  一般情況下，變更類別的內部欄位不是良好的物件導向程式設計方式。  
  
 範例程式碼建立的執行個體`Example`，然後建立兩個委派。 第一個是類型的`UseLikeStatic`，具有相同的動態方法的參數。 第二個是型別`UseLikeInstance`，缺少第一個參數 (型別`Example`)。 這個委派會使用建立<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法多載; 第二個參數，該方法多載是的執行個體`Example`，在此情況下建立的執行個體只，為繫結到新建立的委派。 動態方法時叫用委派時，處理程式碼的繫結的執行個體`Example`。  
  
> [!NOTE]
>  這是比較不嚴謹的規則的範例，委派繫結中導入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，以及新的多載<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法。 如需詳細資訊，請參閱 <xref:System.Delegate> 類別。  
  
 `UseLikeStatic`叫用委派，在執行個體中傳遞`Example`繫結至`UseLikeInstance`委派。 然後在`UseLikeInstance`叫用委派，使這兩個相同的執行個體的代理人`Example`。 每次呼叫之後，會顯示內部欄位的值中的變更。 最後，`UseLikeInstance`委派繫結的執行個體`DerivedFromxample`，和委派呼叫，會重複。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  -或-  <paramref name="owner" /> 是介面、陣列、開放式泛型型別，或者是泛型型別或方法的型別參數。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  -或-  <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 為 <see langword="null" />，或屬於 <see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" /> 的類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要動態方法關聯以外呼叫模組的模組中的型別。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="m">
          <see cref="T:System.Reflection.Module" />，代表動態方法在邏輯上相關聯的模組。</param>
        <param name="skipVisibility">
          <see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查。</param>
        <summary>建立對模組而言全域的動態方法，並指定方法名稱、傳回類型、參數類型、模組，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
 這個建構函式以建立動態方法可存取公用和`internal`(`Friend`在 Visual Basic 中) 所包含的模組中的所有型別的成員`m`。 略過 JIT 編譯器的可見性檢查可讓動態方法存取的所有其他型別的 private 和 protected 成員。 例如，撰寫程式碼來將物件序列化時，這十分有用。  
  
> [!NOTE]
>  回溯相容性，這個建構函式要求<xref:System.Security.Permissions.SecurityPermission>與<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>旗標，如果下列條件都為 true:`m`是模組之外呼叫模組，以及需求的<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果要求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  -或-  <paramref name="m" /> 是為動態方法提供匿名裝載的模組。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  -或-  <paramref name="m" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要將動態方法產生關聯以外呼叫模組的模組。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="owner">動態方法在邏輯方面相關聯的 <see cref="T:System.Type" />。 動態方法可存取該類型的所有成員。</param>
        <param name="skipVisibility">
          <see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查，否則為 <see langword="false" />。</param>
        <summary>建立動態方法，並指定方法名稱、傳回類型、參數類型、動態方法在邏輯上相關聯的類型，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個建構函式建立此動態方法沒有型別的所有成員的存取權`owner`，並為 public 和`internal`(`Friend`在 Visual Basic 中) 包含的模組中的所有其他類型的成員`owner`。 略過 JIT 編譯器的可見性檢查可讓動態方法存取的所有其他型別的 private 和 protected 成員。 例如，撰寫程式碼來將物件序列化時，這十分有用。  
  
 這個建構函式指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  回溯相容性，這個建構函式要求<xref:System.Security.Permissions.SecurityPermission>與<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>旗標，如果下列條件都為 true:`owner`以外呼叫模組，以及需求的模組中<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果要求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  -或-  <paramref name="owner" /> 是介面、陣列、開放式泛型型別，或者是泛型型別或方法的型別參數。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  -或-  <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="returnType" /> 為 <see langword="null" />，或屬於 <see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" /> 的類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要動態方法關聯以外呼叫模組的模組中的型別。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 可以是零長度字串，但不可為 <see langword="null" />。</param>
        <param name="attributes">指定動態方法屬性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的位元組合。 唯一允許的組合是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">動態方法的的呼叫慣例。 必須是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="m">To be added.</param>
        <param name="skipVisibility">
          <see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查，否則為 <see langword="false" />。</param>
        <summary>建立對模組而言全域的動態方法，並指定方法名稱、屬性、呼叫慣例、傳回類型、參數類型、模組，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式以建立動態方法可存取公用和`internal`(`Friend`在 Visual Basic 中) 的所有公用及內部類型包含在模組中的成員`m`。  
  
 略過 JIT 編譯器的可見性檢查可讓動態方法存取的所有其他類型和所有其他組件中模組的 private 和 protected 成員。 例如，撰寫程式碼來將物件序列化時，這十分有用。  
  
> [!NOTE]
>  回溯相容性，這個建構函式要求<xref:System.Security.Permissions.SecurityPermission>與<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>旗標，如果下列條件都為 true:`m`是模組之外呼叫模組，以及需求的<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果要求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  -或-  <paramref name="m" /> 是為動態方法提供匿名裝載的模組。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  -或-  <paramref name="m" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> 是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 以外的旗標組合。  -或-  <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  -或-  <paramref name="returnType" /> 是 <see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" /> 的型別。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要將動態方法產生關聯以外呼叫模組的模組。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 可以是零長度字串，但不可為 <see langword="null" />。</param>
        <param name="attributes">指定動態方法屬性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的位元組合。 唯一允許的組合是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">動態方法的的呼叫慣例。 必須是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="owner">動態方法在邏輯方面相關聯的 <see cref="T:System.Type" />。 動態方法可存取該類型的所有成員。</param>
        <param name="skipVisibility">
          <see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查，否則為 <see langword="false" />。</param>
        <summary>建立動態方法、指定方法名稱、屬性、呼叫慣例、傳回類型、參數類型、動態方法在邏輯上相關聯的類型，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法在全域範圍中包含的類型的模組`owner`。 存取類型的所有成員`owner`。  
  
 使用這個建構函式建立此動態方法沒有型別的所有成員的存取權`owner`，和為 public 和`internal`(`Friend`在 Visual Basic 中) 包含的模組中所包含的所有型別的成員`owner`。 略過 JIT 編譯器的可見性檢查可讓動態方法存取的所有其他型別的 private 和 protected 成員。 例如，撰寫程式碼來將物件序列化時，這十分有用。  
  
> [!NOTE]
>  回溯相容性，這個建構函式要求<xref:System.Security.Permissions.SecurityPermission>與<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>旗標，如果下列條件都為 true:`owner`以外呼叫模組，以及需求的模組中<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果要求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  從開始[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，不再需要此成員<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  -或-  <paramref name="owner" /> 是介面、陣列、開放式泛型型別，或者是泛型型別或方法的型別參數。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。  -或-  <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="attributes" /> 是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 以外的旗標組合。  -或-  <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  -或-  <paramref name="returnType" /> 是 <see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" /> 的型別。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要動態方法關聯以外呼叫模組的模組中的型別。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得建立動態方法時所指定的屬性。</summary>
        <value>
          <see cref="T:System.Reflection.MethodAttributes" /> 值的位元組合，代表此方法的屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前動態方法的方法屬性都<xref:System.Reflection.MethodAttributes.Public>和<xref:System.Reflection.MethodAttributes.Static>。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的方法屬性。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得建立動態方法時所指定的呼叫慣例。</summary>
        <value>
          <see cref="T:System.Reflection.CallingConventions" /> 值的其中一個，表示該方法的呼叫慣例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前動態方法的呼叫慣例是一律<xref:System.Reflection.CallingConventions.Standard>。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的呼叫慣例。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>完成動態方法，並建立可用來執行此動態方法的委派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">一種委派類型，其簽章符合動態方法。</param>
        <summary>完成動態方法，並建立可用來執行此動態方法的委派。</summary>
        <returns>指定類型的委派，可用於執行動態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成動態方法。 任何進一步嘗試改變動態方法，例如修改參數定義或發出多個 Microsoft 中繼語言 (MSIL)，則會忽略;擲不回任何例外狀況。  
  
 若要建立動態方法之方法主體，當您有自己的 MSIL 產生器時，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法，以取得<xref:System.Reflection.Emit.DynamicILInfo>物件。 如果您沒有自己的 MSIL 產生器，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法，以取得<xref:System.Reflection.Emit.ILGenerator>可以用來產生方法主體的物件。  
  
   
  
## Examples  
 下列程式碼範例會建立動態方法採用兩個參數。 這個範例會發出列印至主控台時，第一個參數的簡單函式主體，此範例會使用做為方法的傳回值的第二個參數。 此範例完成藉由建立委派的方法、 叫用使用不同的參數，委派和最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有任何方法主體。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="delegateType" /> 的參數數目錯誤或參數類型錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">一種委派類型，其簽章符合減去第一個參數的動態方法簽章。</param>
        <param name="target">委派繫結至的物件。 必須是與動態方法的第一個參數相同類型。</param>
        <summary>完成動態方法並建立可以用來執行它的委派，同時指定委派類型和委派繫結至的物件。</summary>
        <returns>指定類型的委派，可用於對指定目標物件執行動態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載建立委派繫結至特定的物件。 這類委派會在其第一個引數上關閉。 雖然這個方法是靜態的它可如同一般的執行個體方法。執行個體是`target`。  
  
 這個方法多載都需要`target`是相同類型的第一個參數的動態方法，或要指派給該型別 （例如，在衍生類別）。  簽章`delegateType`動態方法的第一個以外的所有參數。 例如，如果此動態方法沒有參數<xref:System.String>， <xref:System.Int32>，和<xref:System.Byte>，然後`delegateType`具有參數<xref:System.Int32>和<xref:System.Byte>;`target`的型別<xref:System.String>。  
  
 呼叫<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成動態方法。 任何進一步嘗試改變動態方法，例如修改參數定義或發出多個 Microsoft 中繼語言 (MSIL)，則會忽略;擲不回任何例外狀況。  
  
 若要建立動態方法之方法主體，當您有自己的 MSIL 產生器時，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法，以取得<xref:System.Reflection.Emit.DynamicILInfo>物件。 如果您沒有自己的 MSIL 產生器，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法，以取得<xref:System.Reflection.Emit.ILGenerator>可以用來產生方法主體的物件。  
  
   
  
## Examples  
 下列程式碼範例會建立繫結的委派<xref:System.Reflection.Emit.DynamicMethod>型別的執行個體，使方法的運作將相同的執行個體上每次叫用它。  
  
 程式碼範例定義名為類別`Example`私用欄位，與類別名稱為`DerivedFromxample`衍生自第一個類別，名為委派類型`UseLikeStatic`傳回<xref:System.Int32>且具有參數的型別`Example`和<xref:System.Int32>，和名為委派類型`UseLikeInstance`傳回<xref:System.Int32>且具有一個參數的型別<xref:System.Int32>。  
  
 範例程式碼接著會建立<xref:System.Reflection.Emit.DynamicMethod>變更執行個體的私用欄位`Example`並傳回先前的值。  
  
> [!NOTE]
>  一般情況下，變更類別的內部欄位不是良好的物件導向程式設計方式。  
  
 範例程式碼建立的執行個體`Example`，然後建立兩個委派。 第一個是類型的`UseLikeStatic`，具有相同的動態方法的參數。 第二個是型別`UseLikeInstance`，缺少第一個參數 (型別`Example`)。 這個委派會使用建立<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法多載; 第二個參數，該方法多載是的執行個體`Example`，在此情況下建立的執行個體只，為繫結到新建立的委派。 動態方法時叫用委派時，處理程式碼的繫結的執行個體`Example`。  
  
> [!NOTE]
>  這是比較不嚴謹的規則的範例，委派繫結中導入的[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，以及新的多載<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法。 如需詳細資訊，請參閱 <xref:System.Delegate> 類別。  
  
 `UseLikeStatic`叫用委派，在執行個體中傳遞`Example`繫結至`UseLikeInstance`委派。 然後在`UseLikeInstance`叫用委派，使這兩個相同的執行個體的代理人`Example`。 每次呼叫之後，會顯示內部欄位的值中的變更。 最後，`UseLikeInstance`委派繫結的執行個體`DerivedFromxample`，和委派呼叫，會重複。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有任何方法主體。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> 與動態方法的第一個參數不是相同類型，且無法指派給該類型。  -或-  <paramref name="delegateType" /> 的參數數目錯誤或參數類型錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得宣告方法的類型，如果是動態方法，則一律為 <see langword="null" />。</summary>
        <value>一定是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性永遠傳回`null`動態方法。 動態方法在邏輯上相關的類型項目，即使它不是由宣告型別。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的宣告型別。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">在參數清單中參數的位置。 第一個參數的參數索引從數字 1 開始。</param>
        <param name="attributes">指定參數屬性的 <see cref="T:System.Reflection.ParameterAttributes" /> 值的位元組合。</param>
        <param name="parameterName">參數名稱。 名稱可以是零長度字串。</param>
        <summary>定義動態方法的參數。</summary>
        <returns>一律傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`position`為 0，<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法是指傳回的值。 設定參數資訊有不會影響傳回的值。  
  
 如果動態方法已完成，藉由呼叫<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法，<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法沒有任何作用。 不會有例外狀況擲回。  
  
   
  
## Examples  
 下列程式碼範例示範如何定義的動態方法的參數資訊。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">這個方法沒有參數。  -或-  <paramref name="position" /> 小於 0。  -或-  <paramref name="position" /> 大於方法參數的數目。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回此方法的基底實作。</summary>
        <returns>此方法的基底實作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法一律會傳回目前`DynamicMethod`物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回套用至方法的自訂屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see langword="true" /> 表示搜尋方法的繼承鏈結以尋找自訂屬性，<see langword="false" /> 表示只檢查目前的方法。</param>
        <summary>傳回為這個方法定義的所有自訂屬性。</summary>
        <returns>代表這個方法所有自訂屬性的物件陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法，指定`true`如`inherit`沒有任何作用，因為型別中未宣告為方法。  
  
> [!NOTE]
>  自訂屬性目前不支援動態方法上。 唯一的屬性會傳回為<xref:System.Runtime.CompilerServices.MethodImplAttribute>; 您可以取得該方法實作旗標更輕鬆地使用<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <see cref="T:System.Type" />，表示要傳回之自訂屬性的型別。</param>
        <param name="inherit">
          <see langword="true" /> 表示搜尋方法的繼承鏈結以尋找自訂屬性，<see langword="false" /> 表示只檢查目前的方法。</param>
        <summary>傳回已套用至該方法之指定類型的自訂屬性。</summary>
        <returns>物件的陣列，表示型別為 <paramref name="attributeType" /> 或衍生自型別 <paramref name="attributeType" /> 之方法的屬性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法，指定`true`如`inherit`沒有任何作用，因為型別中未宣告為方法。  
  
> [!NOTE]
>  自訂屬性目前不支援動態方法上。 唯一的屬性會傳回為<xref:System.Runtime.CompilerServices.MethodImplAttribute>; 您可以取得該方法實作旗標更輕鬆地使用<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 物件，該物件可用於從中繼資料語彙基元 (Metadata Token)、範圍和 Microsoft Intermediate Language (MSIL) 資料流產生方法主體。</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 物件，可用於從中繼資料語彙基元、範圍和 MSIL 資料流產生方法主體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo>類別提供來支援 unmanaged 程式碼產生。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">執行 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回可以用來發出動態方法之主體的 MSIL 產生器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>針對方法，傳回具有預設 Microsoft Intermediate Language (MSIL) 資料流大小 64 位元組的 MSIL 產生器。</summary>
        <returns>方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已完成動態方法，藉由呼叫之後<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法中，任何進一步嘗試加入 MSIL 會被忽略。 不會有例外狀況擲回。  
  
> [!NOTE]
>  有一些限制在動態方法中，甚至在某些完全信任情況下無法驗證的程式碼。 如需了解 <xref:System.Reflection.Emit.DynamicMethod>，請參閱＜備註＞中的＜驗證＞一節。  
  
   
  
## Examples  
 下列程式碼範例會建立動態方法採用兩個參數。 這個範例會發出列印至主控台時，第一個參數的簡單函式主體，此範例會使用做為方法的傳回值的第二個參數。 此範例完成藉由建立委派的方法、 叫用使用不同的參數，委派和最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL 資料流的大小，以位元組為單位。</param>
        <summary>針對方法，傳回具有指定 Microsoft Intermediate Language (MSIL) 資料流大小的 MSIL 產生器。</summary>
        <returns>方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 物件，具有指定的 MSIL 資料流大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已完成動態方法，藉由呼叫之後<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法中，任何進一步嘗試加入 MSIL 會被忽略。 不會有例外狀況擲回。  
  
> [!NOTE]
>  有一些限制在動態方法中，甚至在某些完全信任情況下無法驗證的程式碼。 如需了解 <xref:System.Reflection.Emit.DynamicMethod>，請參閱＜備註＞中的＜驗證＞一節。  
  
   
  
## Examples  
 下列程式碼範例會示範這個方法多載。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回方法的實作旗標。</summary>
        <returns>
          <see cref="T:System.Reflection.MethodImplAttributes" /> 值的位元組合，表示方法的實作旗標。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前動態方法的方法實作屬性都<xref:System.Reflection.MethodImplAttributes.IL>和<xref:System.Reflection.MethodImplAttributes.NoInlining>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回動態方法的參數。</summary>
        <returns>
          <see cref="T:System.Reflection.ParameterInfo" /> 物件的陣列，代表動態方法的參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo>這個方法所傳回的物件是僅提供資訊。 使用<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法來設定或變更的參數特性。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的參數。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示在此方法中的區域變數是否以零起始。</summary>
        <value>如果在此方法中的區域變數以零起始，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為`true`，發出的 Microsoft 中繼語言 (MSIL) 包含本機變數的初始化。 如果設定為`false`、 未初始化的區域變數和產生的程式碼，將無法驗證。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>動態方法的屬性。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">由於這個參數是靜態的，因此動態方法會予以忽略。 請指定 <see langword="null" />。</param>
        <param name="invokeAttr">
          <see cref="T:System.Reflection.BindingFlags" /> 值的位元組合。</param>
        <param name="binder">
          <see cref="T:System.Reflection.Binder" /> 物件，它透過反映啟用繫結、引數型別的強制型轉 (Coercion)、成員的引動過程，和 <see cref="T:System.Reflection.MemberInfo" /> 物件的擷取。 如果 <c>Binder</c> 為 <see langword="null" />，則會使用預設 Binder。 如需詳細資訊，請參閱 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="parameters">引數清單。 這是引數陣列，其數目、順序和類型與要叫用的方法參數相同。 如果沒有參數，則這個參數應該是 <see langword="null" />。</param>
        <param name="culture">
          <see cref="T:System.Globalization.CultureInfo" /> 的執行個體，用於管理類型的強制型轉。 如果這是 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。 例如，必須有這個資訊，才能將表示 1000 的 <see cref="T:System.String" /> 正確地轉換為 <see cref="T:System.Double" /> 值，因為 1000 在不同文化特性中有不同的表示方式。</param>
        <summary>使用指定的文化特性資訊，在指定繫結器的條件約束下，以指定的參數叫用動態方法。</summary>
        <returns>
          <see cref="T:System.Object" />，包含叫用方法的傳回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了列出的例外狀況，呼叫程式碼應該準備好攔截動態方法所擲回任何例外狀況。  
  
 執行動態方法所建立的委派<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法會更有效率，比執行它與<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 呼叫<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法完成動態方法。 任何進一步嘗試改變動態方法，例如修改參數定義或發出多個 Microsoft 中繼語言 (MSIL)，則會忽略;擲不回任何例外狀況。  
  
 所有的動態方法是靜態的所以`obj`參數會被忽略。 若要將動態方法，就好像執行個體方法，使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>接受物件執行個體的多載。  
  
 如果動態方法沒有參數，值`parameters`應該`null`。 否則數字、 類型和參數陣列中項目的順序應該與數字、 類型和參數的動態方法的順序相同。  
  
> [!NOTE]
>  這個方法多載會呼叫<xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29>方法多載繼承自<xref:System.Reflection.MethodBase>類別中，因此上述的 < 備註 > 一套用於兩個多載。  
  
 這個方法不會直接要求權限，但叫用動態方法時，可能導致安全性要求，根據的方法。 例如，會提出任何要求的匿名裝載動態方法，以建立`restrictedSkipVisibility`參數設定為`false`。 另一方面，如果您建立的方法與`restrictedSkipVisibility`設`true`讓它可存取的目標組件的隱藏的成員，方法會導致目標組件加上的權限的要求<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標。  
  
> [!NOTE]
>  之前[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法所需<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>旗標。  
  
   
  
## Examples  
 下列程式碼範例中，會叫用動態方法與完全繫結，使用英文 （美國） 文化特性。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支援 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 呼叫慣例。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <paramref name="parameters" /> 中的項目數不符合動態方法中的參數數目。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parameters" /> 之一個或多個項目的型別不符合動態方法的對應參數型別。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">動態方法是與模組相關聯，不是匿名裝載，而且建構時 <paramref name="skipVisibility" /> 設為 <see langword="false" />，但是動態方法會存取不是 <see langword="public" /> 或 <see langword="internal" /> (Visual Basic 中為 <see langword="Friend" />) 的成員。  -或-  動態方法已匿名裝載，而且建構已將 <paramref name="skipVisibility" /> 設定為 <see langword="false" />，但其所存取的成員不是 <see langword="public" />。  -或-  動態方法含有未經驗證的程式碼。 如需了解 <see cref="T:System.Reflection.Emit.DynamicMethod" />，請參閱＜備註＞中的＜驗證＞一節。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">
          <see cref="T:System.Type" />，表示要搜尋之自訂屬性的型別。</param>
        <param name="inherit">
          <see langword="true" /> 表示搜尋方法的繼承鏈結以尋找自訂屬性，<see langword="false" /> 表示只檢查目前的方法。</param>
        <summary>指出是否已定義指定的自訂屬性類型。</summary>
        <returns>如果指定的自訂屬性型別已定義，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法，指定`true`如`inherit`沒有任何作用。 動態方法可以有任何的繼承鏈結。  
  
> [!NOTE]
>  自訂屬性目前不支援動態方法上。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前動態方法是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</summary>
        <value>如果目前動態方法為安全性關鍵或安全性安全關鍵，則為 <see langword="true" />，如果它是透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>屬性報告 common language runtime (CLR) 所決定的動態方法的透明度。 這些屬性的組合是下表所示：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
 動態方法的透明度，取決於其相關聯的模組。 如果動態方法的型別，而不是模組與相關聯，其透明度相依於此模組包含的型別。 動態方法沒有安全性註釋，因此就會指派預設的透明度相關聯的模組。  
  
-   匿名裝載動態方法永遠是透明的因為它們包含的系統提供模組而言是透明。  
  
-   下表描述與受信任的組件 （也就是強式名稱組件安裝在全域組件快取） 相關聯的動態方法的透明度。  
  
    |組件註解|層級 1 透明度|層級 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全重大|Critical|Critical|  
    |混合的透明度|透明|透明|  
    |無從驗證的安全性|安全關鍵|Critical|  
  
     例如，如果您將動態方法關聯 mscorlib.dll 中，有層級 2 混合的透明度，其中的型別動態方法是透明的並無法執行重要的程式碼。 透明度層級的相關資訊，請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  動態方法關聯中與安全性無關，（例如 system.dll），是信任層級 1 組件的模組不允許提高權限的信任。 如果呼叫的動態方法的程式碼的授權集不包含 System.dll （也就是完全信任） 的授權集<xref:System.Security.SecurityException>動態方法呼叫時擲回。  
  
-   載入組件的方式取決於部分信任組件相關聯的動態方法的透明度。 如果組件已載入以部分信任 （例如，插入的沙箱化應用程式定義域），執行階段就會忽略組件的安全性註釋。 組件和所有類型和成員，包括動態方法，會都視為透明的。 只有部分信任組件是以完全信任 （例如，插入的桌面應用程式的預設應用程式網域） 來載入執行階段會付款注意安全性註釋。 在此情況下，執行階段指派的動態方法預設透明度根據組件的註解的方法。  
  
 如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有方法主體。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前動態方法在目前信任層級上是否為安全性安全關鍵，也就是說，它是否能執行重要作業並由安全性透明的程式碼存取。</summary>
        <value>如果動態方法在目前信任層級上為安全性安全關鍵，則為 <see langword="true" />，如果它是安全性關鍵或透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>屬性報告 common language runtime (CLR) 所決定的動態方法的透明度。 這些屬性的組合是下表所示：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
 動態方法的透明度，取決於其相關聯的模組。 如果動態方法的型別，而不是模組與相關聯，其透明度相依於此模組包含的型別。 動態方法沒有安全性註釋，因此就會指派預設的透明度相關聯的模組。  
  
-   匿名裝載動態方法永遠是透明的因為它們包含的系統提供模組而言是透明。  
  
-   下表描述與受信任的組件 （也就是強式名稱組件安裝在全域組件快取） 相關聯的動態方法的透明度。  
  
    |組件註解|層級 1 透明度|層級 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全重大|Critical|Critical|  
    |混合的透明度|透明|透明|  
    |無從驗證的安全性|安全關鍵|Critical|  
  
     例如，如果您將動態方法關聯 mscorlib.dll 中，有層級 2 混合的透明度，其中的型別動態方法是透明的並無法執行重要的程式碼。 透明度層級的相關資訊，請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  動態方法關聯中與安全性無關，（例如 system.dll），是信任層級 1 組件的模組不允許提高權限的信任。 如果呼叫的動態方法的程式碼的授權集不包含 System.dll （也就是完全信任） 的授權集<xref:System.Security.SecurityException>動態方法呼叫時擲回。  
  
-   載入組件的方式取決於部分信任組件相關聯的動態方法的透明度。 如果組件已載入以部分信任 （例如，插入的沙箱化應用程式定義域），執行階段就會忽略組件的安全性註釋。 組件和所有類型和成員，包括動態方法，會都視為透明的。 只有部分信任組件是以完全信任 （例如，插入的桌面應用程式的預設應用程式網域） 來載入執行階段會付款注意安全性註釋。 在此情況下，執行階段指派的動態方法預設透明度根據組件的註解的方法。  
  
 如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有方法主體。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前動態方法在目前信任層級上是否為安全性透明，因此無法執行重要作業。</summary>
        <value>如果動態方法在目前信任層級上為安全性透明，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>屬性報告 common language runtime (CLR) 所決定的動態方法的透明度。 這些屬性的組合是下表所示：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
 動態方法的透明度，取決於其相關聯的模組。 如果動態方法的型別，而不是模組與相關聯，其透明度相依於此模組包含的型別。 動態方法沒有安全性註釋，因此就會指派預設的透明度相關聯的模組。  
  
-   匿名裝載動態方法永遠是透明的因為它們包含的系統提供模組而言是透明。  
  
-   下表描述與受信任的組件 （也就是強式名稱組件安裝在全域組件快取） 相關聯的動態方法的透明度。  
  
    |組件註解|層級 1 透明度|層級 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全重大|Critical|Critical|  
    |混合的透明度|透明|透明|  
    |無從驗證的安全性|安全關鍵|Critical|  
  
     例如，如果您將動態方法關聯 mscorlib.dll 中，有層級 2 混合的透明度，其中的型別動態方法是透明的並無法執行重要的程式碼。 透明度層級的相關資訊，請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  動態方法關聯中與安全性無關，（例如 system.dll），是信任層級 1 組件的模組不允許提高權限的信任。 如果呼叫的動態方法的程式碼的授權集不包含 System.dll （也就是完全信任） 的授權集<xref:System.Security.SecurityException>動態方法呼叫時擲回。  
  
-   載入組件的方式取決於部分信任組件相關聯的動態方法的透明度。 如果組件已載入以部分信任 （例如，插入的沙箱化應用程式定義域），執行階段就會忽略組件的安全性註釋。 組件和所有類型和成員，包括動態方法，會都視為透明的。 只有部分信任組件是以完全信任 （例如，插入的桌面應用程式的預設應用程式網域） 來載入執行階段會付款注意安全性註釋。 在此情況下，執行階段指派的動態方法預設透明度根據組件的註解的方法。  
  
 如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 透明度的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有方法主體。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>不支援動態方法。</summary>
        <value>不支援動態方法。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">不允許動態方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法在邏輯上相關聯的模組。</summary>
        <value>目前的動態方法與其相關聯的 <see cref="T:System.Reflection.Module" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定了模組建立動態方法時，這個屬性會傳回該模組。 如果建立動態方法時，已指定為擁有者的類型，這個屬性會傳回包含該類型的模組。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Reflection.Emit.DynamicMethod.Module%2A>動態方法的屬性。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法的名稱。</summary>
        <value>方法的簡單名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  您不需要動態方法的名稱。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的名稱。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用於反映中以取得方法的類別。</summary>
        <value>一定是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性永遠傳回`null`動態方法。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的反映型別。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法的傳回參數。</summary>
        <value>一定是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性永遠傳回`null`動態方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此動態方法傳回值的類型。</summary>
        <value>
          <see cref="T:System.Type" /> 代表目前方法之傳回值的類型；如果此方法沒有傳回類型，則為 <see cref="T:System.Void" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`null`時建立動態方法，這個屬性會傳回所指定的傳回型別的<xref:System.Void?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的傳回型別。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法之傳回型別的自訂屬性。</summary>
        <value>
          <see cref="T:System.Reflection.ICustomAttributeProvider" />，表示動態方法之傳回型別的自訂屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自訂屬性不支援之傳回類型的動態方法，因此所傳回的自訂屬性陣列<xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A>方法永遠為空白。  
  
   
  
## Examples  
 下列程式碼範例示範如何顯示之自訂屬性的動態方法的傳回型別。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回方法的簽章，以字串表示。</summary>
        <returns>表示方法簽章的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 簽章僅包含類型和方法名稱，如果有的話。 不包含參數名稱。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Reflection.Emit.DynamicMethod.ToString%2A>動態方法的方法。 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>