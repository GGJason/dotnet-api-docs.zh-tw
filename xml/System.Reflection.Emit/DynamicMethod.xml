<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1bd4c32b39444d8bae0938e364893b4e9b22d0bd" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52591098" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定義及代表可以編譯、執行和捨棄的動態方法。 已捨棄的方法可供記憶體回收所用。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Reflection.Emit.DynamicMethod>產生，並在執行階段，執行方法，而不需要產生動態組件和動態型別，包含方法的類別。 在 just-in-time (JIT) 編譯器所建立的可執行程式碼會回收時<xref:System.Reflection.Emit.DynamicMethod>收回物件。 動態方法是最有效率的方式來產生和執行少量程式碼。  
  
 可以匿名裝載動態方法，或可以是邏輯上相關聯的模組或類型。  
  
-   如果匿名裝載動態方法，它位於系統提供的組件，所以隔離從其他程式碼。 根據預設，它並沒有任何非公用資料的存取權。 匿名裝載動態方法可以限制能夠略過 JIT 編譯器可見度檢查，，如果它已被授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標。 動態方法存取其非公用成員的組件的信任層級必須相同或發出動態方法的呼叫堆疊的信任層級的子集。 如需匿名裝載動態方法的詳細資訊，請參閱[逐步解說： 在部分信任案例中發出的程式碼](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)。  
  
-   如果您指定的模組相關聯的動態方法，動態方法在有效的全域模組。 它可以存取模組中的所有型別，以及`internal`(`Friend` Visual Basic 中) 的類型成員。 您可以建立關聯的動態方法與任何模組，不論您建立模組，前提是要求<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>旗標可以滿足的呼叫堆疊，其中包含您的程式碼。 如果<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標包含授與、 動態方法可以略過 JIT 編譯器可見度檢查，並存取宣告任何組件中的任何其他模組或模組中的所有類型的私用資料。  
  
    > [!NOTE]
    >  當您指定與動態方法相關聯的模組時，該模組不能用於匿名裝載的系統提供組件中。  
  
-   如果您指定之類型的相關聯的動態方法，它會有不論存取層級型別的所有成員的存取權。 此外，可以略過 JIT 可見度檢查。 這可讓在相同的模組中，或任何組件中的任何其他模組中宣告其他類型的私用資料的動態方法存取。 您可以將動態方法與任何類型，但您的程式碼必須被授與<xref:System.Security.Permissions.ReflectionPermission>兼具<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>和<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>旗標。  
  
 下表顯示哪些類型和成員可以存取匿名裝載動態方法，包含或不含 JIT 可見度檢查，取決於是否<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>旗標會被授與。  
  
||不使用 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|不要略過 JIT 可見度檢查|任何組件中的公用類型的公用成員。|任何組件中的公用類型的公用成員。|  
|略過 JIT 可見度檢查，但有限制|任何組件中的公用類型的公用成員。|所有的類型，只能在其信任層級會等於或小於發出動態方法的組件的信任層級的組件中的所有成員。|  
  
> [!NOTE]
>  之前[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，發出程式碼需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 FullTrust 和 LocalIntranet 具名使用權限集合中的預設會包含此權限，但不是在網際網路權限集合。 因此，在舊版[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]程式庫可以使用具有網際網路權限，只有當<xref:System.Security.SecurityCriticalAttribute>屬性，也會執行<xref:System.Security.PermissionSet.Assert%2A>如<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>。 這類程式庫需要仔細的安全性檢閱，因為編碼錯誤可能會造成安全性漏洞。 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] 允許在部分信任案例中發出程式碼，而不需提出任何安全性要求，因為產生的程式碼本質上並非有權限的作業。 也就是產生的程式碼之權限不會比發出程式碼的組件還多。 這可讓程式庫發出安全性透明的程式碼，並可免除 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 判斷提示的需要，這可簡化撰寫安全程式庫的工作。 若要使用這項功能，您的應用程式應目標[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更新版本。  
  
 下表顯示哪些類型和成員都可以與模組或模組中的類型相關聯的動態方法存取。  
  
||與模組相關聯|與類型相關聯|  
|-|-|-|  
|不要略過 JIT 可見度檢查|在模組中的公用、 內部和私用類型的公用和內部成員。<br /><br /> 任何組件中的公用類型的公用成員。|相關聯的類型的所有成員。 在模組中的所有其他類型的公用和內部成員。<br /><br /> 任何組件中的公用類型的公用成員。|  
|略過 JIT 可見度檢查|任何組件中的所有類型的所有成員。|任何組件中的所有類型的所有成員。|  
  
 與模組相關聯的動態方法會具有該模組的權限。 與類型相關聯的動態方法已包含該類型的模組的權限。  
  
 動態方法和其參數不需要加以命名，但您可以指定名稱以協助偵錯。 動態方法或其參數上不支援自訂屬性。  
  
 雖然動態方法`static`方法 (`Shared`方法，在 Visual Basic 中的)、 寬鬆的規則，委派繫結中導入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]允許繫結至物件的動態方法，因此它的作用就像執行個體方法時使用該委派執行個體的呼叫。 此示範的範例，供<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法多載。  
  
> [!NOTE]
>  在  [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，動態方法不支援的符號資訊、 本機變數的名稱和行號的對應。 這項限制可能會在未來版本中移除。 您可以使用<xref:System.Reflection.Emit.AssemblyBuilder>來簡化偵錯的產生的 Microsoft intermediate language (MSIL)，然後切換到動態方法最後在部署期間，因為在開發期間<xref:System.Reflection.Emit.ILGenerator>呼叫都是相同的兩種情況。  
  
## <a name="verification"></a>驗證  
 下列清單摘要說明動態方法可在其下包含無法驗證的程式碼的狀況。 (例如，動態方法，將無法驗證如果其<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>屬性設定為`false`。)  
  
-   安全性關鍵組件相關聯的動態方法也是安全性關鍵的並可略過驗證。 比方說，沒有安全性屬性當做桌面應用程式執行的組件是安全性關鍵方式處理執行階段。 如果您將動態方法關聯的組件時，動態方法可以包含無法驗證的程式碼。  
  
-   如果具有層級 1 透明度的組件相關聯的動態方法含有未經驗證的程式碼，在 just-in-time (JIT) 編譯器會插入安全性要求。 要求成功，只有當動態方法完全受信任的程式碼所執行。 請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)。  
  
-   如果具有層級 2 透明度 （例如 mscorlib.dll 中) 的組件相關聯的動態方法含有未經驗證的程式碼，它就會擲回例外狀況 （由 JIT 編譯器插入） 而不是將安全性需求。 請參閱[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
-   永遠包含無法驗證的程式碼的匿名裝載動態方法會擲回例外狀況。 它永遠不會可以略過驗證，即使它是建立，且完全受信任的程式碼所執行。  
  
 無法驗證的程式碼，會擲回的例外狀況叫用動態方法的方式而有所不同。 如果您使用叫用動態方法所傳回的委派<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法，<xref:System.Security.VerificationException>就會擲回。 如果您使用叫用動態方法<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法中，<xref:System.Reflection.TargetInvocationException>會擲回內部<xref:System.Security.VerificationException>。  
  
   
  
## Examples  
 下列程式碼範例會建立兩個參數的動態方法。 此範例會列印到主控台中，第一個參數的簡單函式主體和此範例會使用第二個參數，為方法的傳回值。 此範例會完成藉由建立委派的方法、 叫用的委派，使用不同的參數，並最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">逐步解說：在部分信任案例中發出程式碼</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立動態方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <summary>初始化匿名裝載的動態方法，並指定方法名稱、傳回類型和參數類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法所建立的這個建構函式是匿名的組件，而不是現有類型或模組相關聯。 只有也就是提供動態方法的沙箱環境，以將它們隔離從其他程式碼，就會有匿名的組件。 這個環境可讓您更安全的動態方法發出及執行部分信任程式碼。  
  
 這個建構函式會指定在 just-in-time (JIT) 可見度檢查都會強制執行的 Microsoft intermediate language (MSIL) 的動態方法。 也就是動態方法中的程式碼可以存取的公用類別的公用方法。 如果此方法會嘗試存取類型或成員，會擲回例外狀況`private`， `protected`，或`internal`(`Friend` Visual Basic 中)。 若要建立具有限制略過 JIT 可見度檢查能力的動態方法，使用<xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>建構函式。  
  
 當建構匿名裝載動態方法時，發出的組件的呼叫堆疊包含。 叫用方法時，發出的組件的權限會使用而不是實際的呼叫者的權限。 因此，無法執行動態方法，在較高層級的權限比，發出它，即使它是傳遞給且具有較高的信任層級的組件所執行的組件。  
  
 這個建構函式會指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>並<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  中引進這個建構函式[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更新版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">逐步解說：在部分信任案例中發出程式碼</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="restrictedSkipVisibility"><see langword="true" /> 則略過對動態方法的 MSIL 所存取之類型和成員的 JIT 可視性檢查，但有此限制：包含這些類型和成員的組件的信任層級，必須等於或小於發出動態方法的呼叫堆疊的信任層級；否則為 <see langword="false" />。</param>
        <summary>初始化匿名裝載的動態方法，並指定方法名稱、傳回類型、參數類型、以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法所建立的這個建構函式是匿名的組件，而不是現有類型或模組相關聯。 只有也就是提供動態方法的沙箱環境，以將它們隔離從其他程式碼，就會有匿名的組件。 這個環境可讓您更安全的動態方法發出及執行部分信任程式碼。  
  
 匿名裝載動態方法並沒有自動的存取權的任何類型或成員`private`， `protected`，或`internal`(`Friend` Visual Basic 中)。 這是不同於動態方法與現有的類型或模組、 相關聯，具備其相關聯的範圍中的隱藏成員的存取權。  
  
 指定`true`for`restrictedSkipVisibility`動態方法是否存取類型或成員`private`， `protected`，或`internal`。 這可讓受限制的動態方法存取這些成員。 也就是符合下列條件時，才可以存取的成員：  
  
-   目標成員屬於具有等於或小於發出動態方法的呼叫堆疊的信任層級的組件。  
  
-   發出動態方法的呼叫堆疊會授與<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>旗標。 這一定是 true 時以完全信任執行的程式碼。 部分信任的程式碼，它為真的前提是主應用程式明確地授與權限。  
  
    > [!IMPORTANT]
    >  如果未授與權限，安全性例外狀況時擲回<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>呼叫或叫用動態方法時，沒有這個建構函式呼叫時。 沒有特殊權限，才能發出動態方法。  
  
 例如，動態方法用來建立`restrictedSkipVisibility`設定為`true`可以存取私用成員的呼叫堆疊上的任何組件，如果呼叫堆疊授與有限的成員存取。 如果呼叫堆疊上的部分信任程式碼會建立動態方法，它無法存取的私用成員中的型別[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]組件，因為這類組件是完全受信任。  
  
 如果`restrictedSkipVisibility`是`false`，JIT 可見度檢查會強制執行。 動態方法中的程式碼存取公用方法的公用類別，且如果嘗試存取類型或成員，會擲回例外狀況`private`， `protected`，或`internal`。  
  
 當建構匿名裝載動態方法時，發出的組件的呼叫堆疊包含。 叫用方法時，會使用發出的呼叫堆疊的使用權限，而不是實際的呼叫者的權限。 因此，無法執行動態方法，在較高層級的權限比，發出它，即使它是傳遞給且具有較高的信任層級的組件所執行的組件。  
  
 這個建構函式會指定方法屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>並<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  中引進這個建構函式[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更新版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">逐步解說：在部分信任案例中發出程式碼</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="m"><see cref="T:System.Reflection.Module" />，代表動態方法在邏輯上相關聯的模組。</param>
        <summary>建立對模組通用的動態方法，並指定方法名稱、傳回類型、參數類型和模組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會指定方法的屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>並<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，並嫄 梊-just-in-time (JIT) 可見度檢查。  
  
 使用這個建構函式建立動態方法可以存取公用及`internal`(`Friend` Visual Basic 中) 包含在模組中的所有型別的成員`m`。  
  
> [!NOTE]
>  回溯相容性，這個建構函式會要求<xref:System.Security.Permissions.SecurityPermission>具有<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>如果下列條件都加上旗標，則為 true:`m`是一個模組呼叫的模組和需求以外<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果對需求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例會建立兩個參數的動態方法。 此範例會列印到主控台中，第一個參數的簡單函式主體和此範例會使用第二個參數，為方法的傳回值。 此範例會完成藉由建立委派的方法、 叫用的委派，使用不同的參數，並最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="m" /> 是為動態方法提供匿名裝載的模組。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="m" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼叫模組以外的其他模組相關聯的動態方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="owner">動態方法在邏輯方面相關聯的 <see cref="T:System.Type" />。 動態方法可存取該類型的所有成員。</param>
        <summary>建立動態方法，指定方法名稱、傳回類型、參數類型及與動態方法在邏輯上相關聯的類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個建構函式所建立的動態方法具有型別的所有成員的存取權`owner`，以及公用和`internal`(`Friend`在 Visual Basic 中) 包含的模組中的所有其他類型的成員`owner`。  
  
 這個建構函式會指定方法的屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>並<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>，並嫄 梊-just-in-time (JIT) 可見度檢查。  
  
> [!NOTE]
>  回溯相容性，這個建構函式會要求<xref:System.Security.Permissions.SecurityPermission>具有<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>如果下列條件都加上旗標，則為 true:`owner`是在模組中呼叫的模組和需求以外<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果對需求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例會建立<xref:System.Reflection.Emit.DynamicMethod>邏輯上相關聯的型別。 此關聯可讓它存取該類型的私用成員。  
  
 程式碼範例定義名為的類別`Example`私用欄位中，使用具名的類別`DerivedFromxample`衍生自第一個類別，名為委派類型`UseLikeStatic`會傳回<xref:System.Int32>且具有參數的型別`Example`和<xref:System.Int32>，和名為委派型別`UseLikeInstance`會傳回<xref:System.Int32>且具有一個參數的型別<xref:System.Int32>。  
  
 範例程式碼接著會建立<xref:System.Reflection.Emit.DynamicMethod>變更執行個體的私用欄位`Example`，並傳回先前的值。  
  
> [!NOTE]
>  一般情況下，變更內部欄位的類別並不好的物件導向程式設計作法。  
  
 範例程式碼建立的執行個體`Example`，然後建立兩個委派。 第一個是型別的`UseLikeStatic`，其具有相同的動態方法的參數。 第二個是型別`UseLikeInstance`，其中缺少的第一個參數 (型別`Example`)。 這個委派會使用建立<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法多載; 第二個參數的方法多載是的執行個體`Example`，在此情況下建立的執行個體只是，繫結至新建立的委派。 動態方法時叫用該委派時，會繫結執行個體上`Example`。  
  
> [!NOTE]
>  這是寬鬆的規則的範例，委派繫結中導入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]，以及新的多載的<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法。 如需詳細資訊，請參閱 <xref:System.Delegate> 類別。  
  
 `UseLikeStatic`委派會叫用，在執行個體中傳遞`Example`繫結至`UseLikeInstance`委派。 然後`UseLikeInstance`叫用委派，以便在相同的執行個體上的這兩個委派做`Example`。 每次呼叫之後，會顯示內部欄位的值中的變更。 最後，`UseLikeInstance`委派要繫結的執行個體`DerivedFromxample`，且委派呼叫而重複。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="owner" /> 是介面、陣列、開放式泛型類型，或者是泛型類型或方法的類型參數。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 為 <see langword="null" />，或屬於 <see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" /> 的類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">在模組中呼叫的模組以外的類型相關聯的動態方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="m"><see cref="T:System.Reflection.Module" />，代表動態方法在邏輯上相關聯的模組。</param>
        <param name="skipVisibility"><see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查。</param>
        <summary>建立對模組而言全域的動態方法，並指定方法名稱、傳回類型、參數類型、模組，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式會指定方法的屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>並<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
 使用這個建構函式建立動態方法可以存取公用及`internal`(`Friend` Visual Basic 中) 所包含的模組中的所有型別的成員`m`。 略過 JIT 編譯器可見度檢查可讓動態方法來存取 private 和 protected 成員的所有其他型別。 比方說，撰寫程式碼來將物件序列化時，這是相當實用。  
  
> [!NOTE]
>  回溯相容性，這個建構函式會要求<xref:System.Security.Permissions.SecurityPermission>具有<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>如果下列條件都加上旗標，則為 true:`m`是一個模組呼叫的模組和需求以外<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果對需求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="m" /> 是為動態方法提供匿名裝載的模組。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="m" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼叫模組以外的其他模組相關聯的動態方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 這可以是零長度的字串，但不能是 <see langword="null" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="owner">動態方法在邏輯方面相關聯的 <see cref="T:System.Type" />。 動態方法可存取該類型的所有成員。</param>
        <param name="skipVisibility"><see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查，否則為 <see langword="false" />。</param>
        <summary>建立動態方法，並指定方法名稱、傳回類型、參數類型、動態方法在邏輯上相關聯的類型，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個建構函式所建立的動態方法具有型別的所有成員的存取權`owner`，以及公用和`internal`(`Friend`在 Visual Basic 中) 包含的模組中的所有其他類型的成員`owner`。 略過 JIT 編譯器可見度檢查可讓動態方法來存取 private 和 protected 成員的所有其他型別。 比方說，撰寫程式碼來將物件序列化時，這是相當實用。  
  
 這個建構函式會指定方法的屬性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>並<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>，和呼叫慣例<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  回溯相容性，這個建構函式會要求<xref:System.Security.Permissions.SecurityPermission>具有<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>如果下列條件都加上旗標，則為 true:`owner`是在模組中呼叫的模組和需求以外<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果對需求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="owner" /> 是介面、陣列、開放式泛型類型，或者是泛型類型或方法的類型參數。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 為 <see langword="null" />，或屬於 <see cref="P:System.Type.IsByRef" /> 會傳回 <see langword="true" /> 的類型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">在模組中呼叫的模組以外的類型相關聯的動態方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 可以是零長度字串，但不可為 <see langword="null" />。</param>
        <param name="attributes">指定動態方法屬性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的位元組合。 唯一允許的組合是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">動態方法的的呼叫慣例。 必須是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="m"><see cref="T:System.Reflection.Module" />，代表動態方法在邏輯上相關聯的模組。</param>
        <param name="skipVisibility"><see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查，否則為 <see langword="false" />。</param>
        <summary>建立對模組而言全域的動態方法，並指定方法名稱、屬性、呼叫慣例、傳回類型、參數類型、模組，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個建構函式建立動態方法可以存取公用及`internal`(`Friend` Visual Basic 中) 的所有公用和內部類型包含在模組中的成員`m`。  
  
 略過 JIT 編譯器可見度檢查可讓動態方法存取的所有其他類型的模組中和所有其他組件中的 private 和 protected 成員。 比方說，撰寫程式碼來將物件序列化時，這是相當實用。  
  
> [!NOTE]
>  回溯相容性，這個建構函式會要求<xref:System.Security.Permissions.SecurityPermission>具有<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>如果下列條件都加上旗標，則為 true:`m`是一個模組呼叫的模組和需求以外<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果對需求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="m" /> 是為動態方法提供匿名裝載的模組。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="m" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> 是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 以外的旗標組合。  
  
-或- 
 <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  
  
-或- 
 <paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼叫模組以外的其他模組相關聯的動態方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動態方法的名稱。 可以是零長度字串，但不可為 <see langword="null" />。</param>
        <param name="attributes">指定動態方法屬性的 <see cref="T:System.Reflection.MethodAttributes" /> 值的位元組合。 唯一允許的組合是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">動態方法的的呼叫慣例。 必須是 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">指定動態方法之傳回類型的 <see cref="T:System.Type" /> 物件；如果方法沒有傳回類型，則為 <see langword="null" />。</param>
        <param name="parameterTypes">指定動態方法之參數類型的 <see cref="T:System.Type" /> 物件陣列；如果方法沒有參數，則為 <see langword="null" />。</param>
        <param name="owner">動態方法在邏輯方面相關聯的 <see cref="T:System.Type" />。 動態方法可存取該類型的所有成員。</param>
        <param name="skipVisibility"><see langword="true" /> 表示要略過動態方法的 MSIL 所存取之類型和成員的 JIT 可見度檢查，否則為 <see langword="false" />。</param>
        <summary>建立動態方法、指定方法名稱、屬性、呼叫慣例、傳回類型、參數類型、動態方法在邏輯上相關聯的類型，以及是否應該略過動態方法的 Microsoft Intermediate Language (MSIL) 所存取之類型和成員的 Just-In-Time (JIT) 可見度檢查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態方法在全域模組包含的型別`owner`。 型別的所有成員都存取`owner`。  
  
 使用這個建構函式所建立的動態方法具有型別的所有成員的存取權`owner`，以及公用和`internal`(`Friend`在 Visual Basic 中) 包含的模組中所包含的所有型別的成員`owner`。 略過 JIT 編譯器可見度檢查可讓動態方法來存取 private 和 protected 成員的所有其他型別。 比方說，撰寫程式碼來將物件序列化時，這是相當實用。  
  
> [!NOTE]
>  回溯相容性，這個建構函式會要求<xref:System.Security.Permissions.SecurityPermission>具有<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>如果下列條件都加上旗標，則為 true:`owner`是在模組中呼叫的模組和需求以外<xref:System.Security.Permissions.ReflectionPermission>與<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標失敗。 如果對需求<xref:System.Security.Permissions.SecurityPermission>成功時，允許此作業。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的項目為 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
-或- 
 <paramref name="owner" /> 是介面、陣列、開放式泛型類型，或者是泛型類型或方法的類型參數。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="owner" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> 是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 以外的旗標組合。  
  
-或- 
 <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  
  
-或- 
 <paramref name="returnType" /> 類型是 <see cref="P:System.Type.IsByRef" /> 傳回 <see langword="true" /> 的對象。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">在模組中呼叫的模組以外的類型相關聯的動態方法。 關聯的列舉型別：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得建立動態方法時所指定的屬性。</summary>
        <value><see cref="T:System.Reflection.MethodAttributes" /> 值的位元組合，代表此方法的屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前動態方法的方法屬性都<xref:System.Reflection.MethodAttributes.Public>和<xref:System.Reflection.MethodAttributes.Static>。  
  
   
  
## Examples  
 下列程式碼範例顯示動態方法的方法的屬性。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得建立動態方法時所指定的呼叫慣例。</summary>
        <value><see cref="T:System.Reflection.CallingConventions" /> 值的其中一個，表示該方法的呼叫慣例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前動態方法的呼叫慣例是一律<xref:System.Reflection.CallingConventions.Standard>。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的呼叫慣例。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>完成動態方法，並建立可用來執行此動態方法的委派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">一種委派類型，其簽章符合動態方法。</param>
        <summary>完成動態方法，並建立可用來執行此動態方法的委派。</summary>
        <returns>指定類型的委派，可用於執行動態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成動態方法。 任何進一步嘗試改變動態方法，例如修改參數定義，或發出多個 Microsoft 中繼語言 (MSIL)，則會忽略;會擲不回任何例外狀況。  
  
 若要建立動態方法的方法主體，當您有自己的 MSIL 產生器時，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法，以取得<xref:System.Reflection.Emit.DynamicILInfo>物件。 如果您還沒有自己的 MSIL 產生器，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法，以取得<xref:System.Reflection.Emit.ILGenerator>可用來產生方法主體的物件。  
  
   
  
## Examples  
 下列程式碼範例會建立兩個參數的動態方法。 此範例會列印到主控台中，第一個參數的簡單函式主體和此範例會使用第二個參數，為方法的傳回值。 此範例會完成藉由建立委派的方法、 叫用的委派，使用不同的參數，並最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有任何方法主體。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> 的參數數目錯誤或參數類型錯誤。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">一種委派類型，其簽章符合減去第一個參數的動態方法簽章。</param>
        <param name="target">委派繫結至的物件。 必須是與動態方法的第一個參數相同類型。</param>
        <summary>完成動態方法並建立可以用來執行它的委派，同時指定委派類型和委派繫結至的物件。</summary>
        <returns>指定類型的委派，可用於對指定目標物件執行動態方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法多載會建立繫結至特定物件的委派。 這類委派會在第一個引數上關閉。 雖然此方法是靜態的它的作用如同一般的執行個體方法;執行個體是`target`。  
  
 這個方法多載都需要`target`屬於相同類型的第一個參數的動態方法，或要指派給該類型 （例如，衍生的類別）。  簽章`delegateType`具有動態方法的第一個以外的所有參數。 例如，如果此動態方法沒有參數<xref:System.String>， <xref:System.Int32>，並<xref:System.Byte>，然後`delegateType`具有參數<xref:System.Int32>和<xref:System.Byte>;`target`別的<xref:System.String>。  
  
 呼叫<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成動態方法。 任何進一步嘗試改變動態方法，例如修改參數定義，或發出多個 Microsoft 中繼語言 (MSIL)，則會忽略;會擲不回任何例外狀況。  
  
 若要建立動態方法的方法主體，當您有自己的 MSIL 產生器時，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法，以取得<xref:System.Reflection.Emit.DynamicILInfo>物件。 如果您還沒有自己的 MSIL 產生器，呼叫<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法，以取得<xref:System.Reflection.Emit.ILGenerator>可用來產生方法主體的物件。  
  
   
  
## Examples  
 下列程式碼範例會建立繫結的委派<xref:System.Reflection.Emit.DynamicMethod>型別的執行個體，使該方法的運作將相同的執行個體上每次叫用它。  
  
 程式碼範例定義名為的類別`Example`私用欄位中，使用具名的類別`DerivedFromxample`衍生自第一個類別，名為委派類型`UseLikeStatic`會傳回<xref:System.Int32>且具有參數的型別`Example`和<xref:System.Int32>，和名為委派型別`UseLikeInstance`會傳回<xref:System.Int32>且具有一個參數的型別<xref:System.Int32>。  
  
 範例程式碼接著會建立<xref:System.Reflection.Emit.DynamicMethod>變更執行個體的私用欄位`Example`，並傳回先前的值。  
  
> [!NOTE]
>  一般情況下，變更內部欄位的類別並不好的物件導向程式設計作法。  
  
 範例程式碼建立的執行個體`Example`，然後建立兩個委派。 第一個是型別的`UseLikeStatic`，其具有相同的動態方法的參數。 第二個是型別`UseLikeInstance`，其中缺少的第一個參數 (型別`Example`)。 這個委派會使用建立<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法多載; 第二個參數的方法多載是的執行個體`Example`，在此情況下建立的執行個體只是，繫結至新建立的委派。 動態方法時叫用該委派時，會繫結執行個體上`Example`。  
  
> [!NOTE]
>  這是寬鬆的規則的範例，委派繫結中導入的[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]，以及新的多載的<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法。 如需詳細資訊，請參閱 <xref:System.Delegate> 類別。  
  
 `UseLikeStatic`委派會叫用，在執行個體中傳遞`Example`繫結至`UseLikeInstance`委派。 然後`UseLikeInstance`叫用委派，以便在相同的執行個體上的這兩個委派做`Example`。 每次呼叫之後，會顯示內部欄位的值中的變更。 最後，`UseLikeInstance`委派要繫結的執行個體`DerivedFromxample`，且委派呼叫而重複。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有任何方法主體。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 與動態方法的第一個參數不是相同類型，且無法指派給該類型。  
  
-或- 
 <paramref name="delegateType" /> 的參數數目錯誤或參數類型錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得宣告方法的類型，如果是動態方法，則一律為 <see langword="null" />。</summary>
        <value>一定是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性一律傳回`null`動態方法。 動態方法在邏輯上相關的類型項目，即使它未宣告的型別。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的宣告型別。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="position">在參數清單中參數的位置。 第一個參數的參數索引從數字 1 開始。</param>
        <param name="attributes">指定參數屬性的 <see cref="T:System.Reflection.ParameterAttributes" /> 值的位元組合。</param>
        <param name="parameterName">參數名稱。 名稱可以是零長度字串。</param>
        <summary>定義動態方法的參數。</summary>
        <returns>一律傳回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`position`為 0，<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法是指傳回的值。 設定參數資訊會有不會影響傳回的值。  
  
 如果動態方法已完成，藉由呼叫<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或是<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法，<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法沒有任何作用。 不會有例外狀況擲回。  
  
   
  
## Examples  
 下列程式碼範例示範如何定義的動態方法的參數資訊。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">這個方法沒有參數。  
  
-或- 
 <paramref name="position" /> 小於 0。  
  
-或- 
 <paramref name="position" /> 大於方法參數的數目。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回此方法的基底實作。</summary>
        <returns>此方法的基底實作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法一律會傳回目前`DynamicMethod`物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回套用至方法的自訂屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><see langword="true" /> 表示要搜尋方法的繼承鏈結以尋找自訂屬性；<see langword="false" /> 表示只會檢查目前的方法。</param>
        <summary>傳回為這個方法定義的所有自訂屬性。</summary>
        <returns>代表這個方法所有自訂屬性的物件陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需動態方法，指定`true`針對`inherit`沒有任何作用，因為型別中未宣告的方法。  
  
> [!NOTE]
>  自訂屬性目前不支援動態方法。 唯一的屬性傳回<xref:System.Runtime.CompilerServices.MethodImplAttribute>; 您可以取得的方法實作旗標更輕鬆地使用<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><see cref="T:System.Type" />，代表要傳回的自訂屬性類型。</param>
        <param name="inherit"><see langword="true" /> 表示要搜尋方法的繼承鏈結以尋找自訂屬性；<see langword="false" /> 表示只會檢查目前的方法。</param>
        <summary>傳回已套用至該方法之指定類型的自訂屬性。</summary>
        <returns>代表此方法屬性的物件陣列之類型為 <paramref name="attributeType" /> 或衍生自類型 <paramref name="attributeType" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需動態方法，指定`true`針對`inherit`沒有任何作用，因為型別中未宣告的方法。  
  
> [!NOTE]
>  自訂屬性目前不支援動態方法。 唯一的屬性傳回<xref:System.Runtime.CompilerServices.MethodImplAttribute>; 您可以取得的方法實作旗標更輕鬆地使用<xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 物件，其可用於從中繼資料語彙基元、範圍以及 Microsoft 中繼語言 (MSIL) 資料流中產生方法主體。</summary>
        <returns>可用於從中繼資料語彙基元、範圍及 MSIL 資料流中產生方法主體的 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicILInfo>類別提供來支援非受控程式碼產生。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要執行 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回可以用來發出動態方法之主體的 MSIL 產生器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>針對方法，傳回具有預設 Microsoft Intermediate Language (MSIL) 資料流大小 64 位元組的 MSIL 產生器。</summary>
        <returns>方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已完成動態方法，藉由呼叫後<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法中，任何進一步嘗試新增 MSIL 會被忽略。 不會有例外狀況擲回。  
  
> [!NOTE]
>  有一些限制，無法驗證的程式碼，在動態方法，甚至在某些的完全信任情況下。 如需了解 <xref:System.Reflection.Emit.DynamicMethod>，請參閱＜備註＞中的＜驗證＞一節。  
  
   
  
## Examples  
 下列程式碼範例會建立兩個參數的動態方法。 此範例會列印到主控台中，第一個參數的簡單函式主體和此範例會使用第二個參數，為方法的傳回值。 此範例會完成藉由建立委派的方法、 叫用的委派，使用不同的參數，並最後會叫用動態方法使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL 資料流的大小，以位元組為單位。</param>
        <summary>針對方法，傳回具有指定 Microsoft Intermediate Language (MSIL) 資料流大小的 MSIL 產生器。</summary>
        <returns>方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 物件，具有指定的 MSIL 資料流大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已完成動態方法，藉由呼叫後<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法中，任何進一步嘗試新增 MSIL 會被忽略。 不會有例外狀況擲回。  
  
> [!NOTE]
>  有一些限制，無法驗證的程式碼，在動態方法，甚至在某些的完全信任情況下。 如需了解 <xref:System.Reflection.Emit.DynamicMethod>，請參閱＜備註＞中的＜驗證＞一節。  
  
   
  
## Examples  
 下列程式碼範例會示範這個方法多載。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定義和執行動態方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回方法的實作旗標。</summary>
        <returns><see cref="T:System.Reflection.MethodImplAttributes" /> 值的位元組合，代表此方法的實作旗標。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前動態方法的方法實作屬性都<xref:System.Reflection.MethodImplAttributes.IL>和<xref:System.Reflection.MethodImplAttributes.NoInlining>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回動態方法的參數。</summary>
        <returns><see cref="T:System.Reflection.ParameterInfo" /> 物件的陣列，代表動態方法的參數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ParameterInfo>這個方法所傳回的物件是僅提供資訊。 使用<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法來設定或變更參數的特性。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的參數。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，表示在此方法中的區域變數是否以零起始。</summary>
        <value>如果在此方法中的區域變數以零起始，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個屬性設定為`true`的發出的 Microsoft intermediate language (MSIL) 包含本機變數的初始化。 如果設定為`false`、 未初始化的區域變數和產生的程式碼，將無法驗證。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>動態方法的屬性。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">由於這個參數是靜態的，因此動態方法會予以忽略。 請指定 <see langword="null" />。</param>
        <param name="invokeAttr"><see cref="T:System.Reflection.BindingFlags" /> 值的位元組合。</param>
        <param name="binder"><see cref="T:System.Reflection.Binder" /> 物件能用來啟用繫結、引數類型的強制型轉、成員的引動過程，以及透過反映來擷取 <see cref="T:System.Reflection.MemberInfo" /> 物件等功能。 如果 <paramref name="binder" /> 為 <see langword="null" />，則會使用預設繫結器。 如需詳細資訊，請參閱 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="parameters">引數清單。 這是引數陣列，其數目、順序和類型與要叫用的方法參數相同。 如果沒有任何參數，這個參數應該為 <see langword="null" />。</param>
        <param name="culture"><see cref="T:System.Globalization.CultureInfo" /> 的執行個體，用於管理類型的強制型轉。 如果這是 <see langword="null" />，會使用目前執行緒的 <see cref="T:System.Globalization.CultureInfo" />。 例如，若要將代表 1000 的 <see cref="T:System.String" /> 正確轉換成 <see cref="T:System.Double" /> 值，需要這項資訊，因為 1000 的表示方式會因不同文化特性而有所不同。</param>
        <summary>使用指定的文化特性資訊，在指定繫結器的條件約束下，以指定的參數叫用動態方法。</summary>
        <returns><see cref="T:System.Object" />，其中包含已叫用之方法的傳回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了列出的例外狀況，呼叫程式碼應該準備好攔截動態方法所擲回任何例外狀況。  
  
 執行動態方法所建立的委派<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法的效率高於執行它與<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法。  
  
 呼叫<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法或<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法完成動態方法。 任何進一步嘗試改變動態方法，例如修改參數定義，或發出多個 Microsoft 中繼語言 (MSIL)，則會忽略;會擲不回任何例外狀況。  
  
 所有的動態方法是靜態的因此`obj`參數會被忽略。 若要將動態方法的執行個體方法一樣，請使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>多載，物件執行個體。  
  
 如果動態方法沒有任何參數，值`parameters`應該是`null`。 否則數字、 類型和參數陣列中元素的順序應該與數目、 類型和參數的動態方法的順序相同。  
  
> [!NOTE]
>  這個方法多載會呼叫<xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29>方法多載繼承自<xref:System.Reflection.MethodBase>類別中，因此上述的 < 備註 > 一套用於這兩個多載。  
  
 這個方法並不直接要求權限，但叫用動態方法時，可能導致安全性要求，根據的方法。 比方說，會提出任何要求匿名裝載動態方法以建立`restrictedSkipVisibility`參數設定為`false`。 另一方面，如果您建立的方法`restrictedSkipVisibility`設定為`true`讓它能夠存取目標組件的隱藏的成員，該方法將會導致加上之目標組件的權限<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>旗標。  
  
> [!NOTE]
>  之前[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個方法所需<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>旗標。  
  
   
  
## Examples  
 下列程式碼範例中，會叫用動態方法與使用英文 （美國） 文化特性的確切繫結。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支援 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 呼叫慣例。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><paramref name="parameters" /> 中的項目數不符合動態方法中的參數數目。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" /> 的一或多個項目類型不符合動態方法的對應參數類型。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">動態方法已與模組建立關聯、不是匿名裝載，而且建構時已將 <paramref name="skipVisibility" /> 設定為 <see langword="false" />，但動態方法所存取的成員卻不是 <see langword="public" /> 或 <see langword="internal" /> (在 Visual Basic 中為 <see langword="Friend" />)。  
  
-或- 
動態方法已匿名裝載，而且建構已將 <paramref name="skipVisibility" /> 設定為 <see langword="false" />，但其所存取的成員不是 <see langword="public" />。  
  
-或- 
動態方法含有未經驗證的程式碼。 如需了解 <see cref="T:System.Reflection.Emit.DynamicMethod" />，請參閱＜備註＞中的＜驗證＞一節。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><see cref="T:System.Type" />，代表要搜尋的自訂屬性類型。</param>
        <param name="inherit"><see langword="true" /> 表示要搜尋方法的繼承鏈結以尋找自訂屬性；<see langword="false" /> 表示只會檢查目前的方法。</param>
        <summary>指出是否已定義指定的自訂屬性類型。</summary>
        <returns>如果已定義指定的自訂屬性類型，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需動態方法，指定`true`針對`inherit`沒有任何作用。 動態方法有沒有繼承鏈結。  
  
> [!NOTE]
>  自訂屬性目前不支援動態方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前動態方法是否為安全性關鍵或安全性安全關鍵，因而可以執行重要的作業。</summary>
        <value>如果目前動態方法為安全性關鍵或安全性安全關鍵，則為 <see langword="true" />，如果是安全性透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>屬性報告為 common language runtime (CLR) 所決定的動態方法的透明度。 下表顯示這些屬性的組合：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
 動態方法的透明度，取決於其相關聯的模組。 如果型別，而不是模組相關聯的動態方法，其透明度，取決於包含類型的模組。 動態方法沒有安全性註解，讓它們已被指派預設的透明度相關聯的模組。  
  
-   匿名裝載動態方法永遠是透明的的因為包含它們的系統提供模組是透明的。  
  
-   下表說明與受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 相關聯的動態方法的透明度。  
  
    |組件註解|層級 1 透明度|層級 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完整重要|Critical|Critical|  
    |混合的透明度|透明|透明|  
    |無從驗證的安全性|安全關鍵|Critical|  
  
     例如，如果您將動態方法關聯 mscorlib.dll 中，有層級 2 混合的透明度，其中的型別動態方法是透明的而且無法執行重要的程式碼。 透明度層級的相關資訊，請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)並[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  動態方法關聯的模組中的信任層級 1 組件，與安全性無關，例如 System.dll，不允許提高權限的信任。 如果呼叫的動態方法的程式碼的授權集不包含 System.dll （也就是完全信任） 的授權集<xref:System.Security.SecurityException>呼叫動態方法時擲回。  
  
-   已載入組件的方式取決於部分信任的組件相關聯的動態方法的透明度。 如果以 （比方說，至沙箱應用程式網域） 的部分信任來載入組件，執行階段會略過組件的安全性註釋。 組件和所有類型和成員，包括動態方法，會都視為透明的。 執行階段在部分信任組件已載入以完全信任 （例如，載入預設應用程式定義域的桌面應用程式） 時，才支付注意安全性註釋。 在此情況下，執行階段會指派動態方法的預設透明度，根據組件的註解的方法。  
  
 如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 投影片的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有方法主體。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反映的安全性考量</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4.0 版中的安全性變更</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全性透明程式碼，層級 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全性透明的程式碼，層級 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前動態方法在目前信任層級上是否為安全性安全關鍵，也就是說，它是否能執行重要作業並由安全性透明的程式碼存取。</summary>
        <value>如果動態方法在目前信任層級上為安全性安全關鍵，則為 <see langword="true" />；如果為安全性關鍵或安全性透明，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>屬性報告為 common language runtime (CLR) 所決定的動態方法的透明度。 下表顯示這些屬性的組合：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
 動態方法的透明度，取決於其相關聯的模組。 如果型別，而不是模組相關聯的動態方法，其透明度，取決於包含類型的模組。 動態方法沒有安全性註解，讓它們已被指派預設的透明度相關聯的模組。  
  
-   匿名裝載動態方法永遠是透明的的因為包含它們的系統提供模組是透明的。  
  
-   下表說明與受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 相關聯的動態方法的透明度。  
  
    |組件註解|層級 1 透明度|層級 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完整重要|Critical|Critical|  
    |混合的透明度|透明|透明|  
    |無從驗證的安全性|安全關鍵|Critical|  
  
     例如，如果您將動態方法關聯 mscorlib.dll 中，有層級 2 混合的透明度，其中的型別動態方法是透明的而且無法執行重要的程式碼。 透明度層級的相關資訊，請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)並[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  動態方法關聯的模組中的信任層級 1 組件，與安全性無關，例如 System.dll，不允許提高權限的信任。 如果呼叫的動態方法的程式碼的授權集不包含 System.dll （也就是完全信任） 的授權集<xref:System.Security.SecurityException>呼叫動態方法時擲回。  
  
-   已載入組件的方式取決於部分信任的組件相關聯的動態方法的透明度。 如果以 （比方說，至沙箱應用程式網域） 的部分信任來載入組件，執行階段會略過組件的安全性註釋。 組件和所有類型和成員，包括動態方法，會都視為透明的。 執行階段在部分信任組件已載入以完全信任 （例如，載入預設應用程式定義域的桌面應用程式） 時，才支付注意安全性註釋。 在此情況下，執行階段會指派動態方法的預設透明度，根據組件的註解的方法。  
  
 如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 投影片的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有方法主體。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反映的安全性考量</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4.0 版中的安全性變更</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全性透明程式碼，層級 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全性透明的程式碼，層級 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示目前動態方法在目前信任層級上是否為安全性透明，因此無法執行重要作業。</summary>
        <value>如果動態方法在目前信任層級上為安全性透明，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>， <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A>，和<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>屬性報告為 common language runtime (CLR) 所決定的動態方法的透明度。 下表顯示這些屬性的組合：  
  
|安全性層級|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|安全關鍵|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用這些屬性會比檢查組件及其類型的安全性註釋、檢查目前的信任層級，以及嘗試複製執行階段規則更簡單。  
  
 動態方法的透明度，取決於其相關聯的模組。 如果型別，而不是模組相關聯的動態方法，其透明度，取決於包含類型的模組。 動態方法沒有安全性註解，讓它們已被指派預設的透明度相關聯的模組。  
  
-   匿名裝載動態方法永遠是透明的的因為包含它們的系統提供模組是透明的。  
  
-   下表說明與受信任的組件 （也就是強式名稱組件安裝在全域組件快取中） 相關聯的動態方法的透明度。  
  
    |組件註解|層級 1 透明度|層級 2 透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完整重要|Critical|Critical|  
    |混合的透明度|透明|透明|  
    |無從驗證的安全性|安全關鍵|Critical|  
  
     例如，如果您將動態方法關聯 mscorlib.dll 中，有層級 2 混合的透明度，其中的型別動態方法是透明的而且無法執行重要的程式碼。 透明度層級的相關資訊，請參閱[安全性透明程式碼，層級 1](~/docs/framework/misc/security-transparent-code-level-1.md)並[安全性透明程式碼，層級 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  動態方法關聯的模組中的信任層級 1 組件，與安全性無關，例如 System.dll，不允許提高權限的信任。 如果呼叫的動態方法的程式碼的授權集不包含 System.dll （也就是完全信任） 的授權集<xref:System.Security.SecurityException>呼叫動態方法時擲回。  
  
-   已載入組件的方式取決於部分信任的組件相關聯的動態方法的透明度。 如果以 （比方說，至沙箱應用程式網域） 的部分信任來載入組件，執行階段會略過組件的安全性註釋。 組件和所有類型和成員，包括動態方法，會都視為透明的。 執行階段在部分信任組件已載入以完全信任 （例如，載入預設應用程式定義域的桌面應用程式） 時，才支付注意安全性註釋。 在此情況下，執行階段會指派動態方法的預設透明度，根據組件的註解的方法。  
  
 如需有關反映發出和透明度，請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 投影片的相關資訊，請參閱[安全性變更](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此動態方法沒有方法主體。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反映發出中的安全性問題</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反映的安全性考量</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4.0 版中的安全性變更</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全性透明程式碼，層級 1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全性透明的程式碼，層級 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>不支援動態方法。</summary>
        <value>不支援動態方法。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">不允許動態方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法在邏輯上相關聯的模組。</summary>
        <value>與目前的動態方法關聯的 <see cref="T:System.Reflection.Module" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定了模組建立動態方法時，這個屬性會傳回該模組。 如果型別指定為擁有者建立動態方法時，這個屬性會傳回包含該類型的模組。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Reflection.Emit.DynamicMethod.Module%2A>動態方法的屬性。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法的名稱。</summary>
        <value>方法的簡單名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  您不需要動態方法的名稱。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的名稱。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用於反映中以取得方法的類別。</summary>
        <value>一定是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性一律傳回`null`動態方法。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的反映型別。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法的傳回參數。</summary>
        <value>一定是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性一律傳回`null`動態方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得此動態方法傳回值的類型。</summary>
        <value><see cref="T:System.Type" /> 代表目前方法之傳回值的類型；如果此方法沒有傳回型別，則為 <see cref="T:System.Void" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`null`時建立動態方法，這個屬性會傳回所指定的傳回型別的<xref:System.Void?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例會顯示動態方法的傳回型別。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得動態方法之傳回型別的自訂屬性。</summary>
        <value><see cref="T:System.Reflection.ICustomAttributeProvider" /> 表示動態方法之傳回型別的自訂屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自訂屬性不支援之傳回類型的動態方法，因此傳回的自訂屬性陣列<xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A>永遠是空的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何顯示自訂屬性的動態方法的傳回型別。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回方法的簽章，以字串表示。</summary>
        <returns>表示方法簽章的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 簽章只包含型別和方法名稱，如果有的話。 不包含參數名稱。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Reflection.Emit.DynamicMethod.ToString%2A>動態方法的方法。 此程式碼範例是針對提供之較大範例的一部分<xref:System.Reflection.Emit.DynamicMethod>類別。  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>