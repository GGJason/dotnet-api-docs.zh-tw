<Type Name="ModuleBuilder" FullName="System.Reflection.Emit.ModuleBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7ab2c1ac1867d289654d7a7cf690946d4d211ffc" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52599431" /></Metadata><TypeSignature Language="C#" Value="public class ModuleBuilder : System.Reflection.Module, System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ModuleBuilder extends System.Reflection.Module implements class System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ModuleBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class ModuleBuilder&#xA;Inherits Module&#xA;Implements _ModuleBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class ModuleBuilder : System::Reflection::Module, System::Runtime::InteropServices::_ModuleBuilder" />
  <TypeSignature Language="F#" Value="type ModuleBuilder = class&#xA;    inherit Module&#xA;    interface _ModuleBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Module</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ModuleBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ModuleBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定義及表示動態組件中的模組。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得的執行個體<xref:System.Reflection.Emit.ModuleBuilder>，使用<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用`ModuleBuilder`來建立動態模組。 請注意，透過呼叫建立 ModuleBuilder<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>在<xref:System.Reflection.Emit.AssemblyBuilder>，而不是透過建構函式。  
  
 [!code-cpp[ModuleBuilder_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_Class/CPP/modulebuilder.cpp#1)]
 [!code-csharp[ModuleBuilder_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_Class/CS/modulebuilder.cs#1)]
 [!code-vb[ModuleBuilder_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_Class/VB/modulebuilder.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ModuleBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ModuleBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得定義此 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 執行個體的動態組件。</summary>
        <value>定義目前動態模組的動態組件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly>傳回的物件<xref:System.Reflection.Emit.AssemblyBuilder>所定義的這個執行個體<xref:System.Reflection.Emit.ModuleBuilder>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGlobalFunctions">
      <MemberSignature Language="C#" Value="public void CreateGlobalFunctions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateGlobalFunctions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateGlobalFunctions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateGlobalFunctions();" />
      <MemberSignature Language="F#" Value="member this.CreateGlobalFunctions : unit -&gt; unit" Usage="moduleBuilder.CreateGlobalFunctions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成這個動態模組的全域函式定義和全域資料定義。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用者是使用定義在這個動態模組中的所有全域函式時，應該呼叫這個方法。 之後呼叫此函式，不允許任何的較新的全域函式或新的全域資料。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例說明如何使用`CreateGlobalFunctions`建立的全域的靜態方法，從<xref:System.Reflection.Emit.MethodBuilder>實作<xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>。  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#2)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#2)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">這個方法先前已呼叫過。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDocument (url As String, language As Guid, languageVendor As Guid, documentType As Guid) As ISymbolDocumentWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ DefineDocument(System::String ^ url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="member this.DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Usage="moduleBuilder.DefineDocument (url, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">文件的 URL。</param>
        <param name="language">識別文件語言的 GUID。 這可以是 <see cref="F:System.Guid.Empty" />。</param>
        <param name="languageVendor">識別文件語言廠商的 GUID。 這可以是 <see cref="F:System.Guid.Empty" />。</param>
        <param name="documentType">識別文件類型的 GUID。 這可以是 <see cref="F:System.Guid.Empty" />。</param>
        <summary>定義來源的文件。</summary>
        <returns>已定義的文件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  舊版.NET Framework 會擲回<xref:System.ArgumentException>而非<xref:System.ArgumentNullException>當`url`是`null`。  
  
   
  
## Examples  
 下列程式碼範例說明如何使用`DefineDocument`（在此情況下，原始 IL 檔案） 的外部符號文件附加至動態模組。  
  
 [!code-cpp[ModuleBuilder_DefineDocument#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CPP/modulebuilder_definedocument.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineDocument#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CS/modulebuilder_definedocument.cs#1)]
 [!code-vb[ModuleBuilder_DefineDocument#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineDocument/VB/modulebuilder_definedocument.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> 為 <see langword="null" />。 這是從舊版 .NET Framework 變更而來。</exception>
        <exception cref="T:System.InvalidOperationException">這個方法要在不是偵錯模組的動態模組上呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEnum">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EnumBuilder DefineEnum (string name, System.Reflection.TypeAttributes visibility, Type underlyingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EnumBuilder DefineEnum(string name, valuetype System.Reflection.TypeAttributes visibility, class System.Type underlyingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEnum (name As String, visibility As TypeAttributes, underlyingType As Type) As EnumBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EnumBuilder ^ DefineEnum(System::String ^ name, System::Reflection::TypeAttributes visibility, Type ^ underlyingType);" />
      <MemberSignature Language="F#" Value="member this.DefineEnum : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.EnumBuilder" Usage="moduleBuilder.DefineEnum (name, visibility, underlyingType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EnumBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="visibility" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="underlyingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">列舉型別的完整路徑。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="visibility">列舉型別的型別屬性。 屬性是由 <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> 定義的任何位元。</param>
        <param name="underlyingType">列舉型別的基礎型別。 這必須是內建整數型別 (Integer Type)。</param>
        <summary>定義列舉型別，此列舉型別為實值型別 (Value Type)，具有指定之型別的單一非靜態欄位 (稱為 <paramref name="value__" />)。</summary>
        <returns>已定義的列舉型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 定義的列舉是在衍生的類別的<xref:System.Enum>。 `value__`欄位都<xref:System.Reflection.FieldAttributes.Private>和<xref:System.Reflection.FieldAttributes.SpecialName>屬性集。  
  
 如需可以指定為基礎的列舉類型的內建整數類型的詳細資訊，請參閱[類別庫概觀](~/docs/standard/class-library-overview.md)。  
  
> [!NOTE]
>  在.NET framework 1.0 和 1.1 版中，就必須定義使用的列舉型別<xref:System.Reflection.Emit.TypeBuilder>因為<xref:System.Reflection.Emit.EnumBuilder>列舉型別，其項目屬於型別就會發出<xref:System.Int32>而不是列舉類型。 在.NET Framework 2.0 版中，<xref:System.Reflection.Emit.EnumBuilder>發出的列舉其項目具有正確的類型。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例示範如何將`DefineEnum`實作的動態模組中的列舉型別類別。 此範例會定義名為列舉型別`Elevation`具有基礎類型<xref:System.Int32>，並建立兩個項目： `Low`，值為 0，及`High`，值為 1。 已建立的類型之後，組件會儲存名稱`TempAssembly.dll`。 您可以使用[Ildasm.exe （IL 反組譯工具）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)來檢查此組件的內容。  
  
> [!NOTE]
>  .NET Framework 2.0 版中之前, 此程式碼範例不會產生正確的列舉型別。  
  
 [!code-cpp[ModuleBuilder_DefineEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CPP/modulebuilder_defineenum.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CS/modulebuilder_defineenum.cs#1)]
 [!code-vb[ModuleBuilder_DefineEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineEnum/VB/modulebuilder_defineenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">提供可視性屬性 (Attribute) 以外的屬性。  
  
-或- 
具有指定名稱的列舉型別存在於這個模組的父組件中。  
  
-或- 
可視性屬性不符合列舉型別範圍。 例如，<see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> 已指定給 <paramref name="visibility" />，但是列舉型別並非巢狀型別。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineGlobalMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義全域方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">方法的名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attributes">方法的屬性。 <paramref name="attributes" /> 必須包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="returnType">該方法的傳回類型。</param>
        <param name="parameterTypes">方法參數的類型。</param>
        <summary>使用指定的名稱、屬性、傳回型別和參數型別，來定義全域方法。</summary>
        <returns>已定義的全域方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法來定義全域方法不使用，直到您呼叫<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例示範如何將`DefineGlobalMethod`來建立繫結至目前的型別無關方法<xref:System.Reflection.Emit.ModuleBuilder>。 在建置通用的方法之後,<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>必須呼叫以完成它。  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">這個方法不是靜態的。 也就是說，<paramref name="attributes" /> 不包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。  
  
-或- 
<paramref name="name" /> 的長度為零。 
-或- 
<see cref="T:System.Type" /> 陣列中的元素為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已呼叫過 <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">方法的名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attributes">方法的屬性。 <paramref name="attributes" /> 必須包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">方法的呼叫慣例。</param>
        <param name="returnType">該方法的傳回類型。</param>
        <param name="parameterTypes">方法參數的類型。</param>
        <summary>使用指定的名稱、屬性、呼叫慣例、傳回型別和參數型別，來定義全域方法。</summary>
        <returns>已定義的全域方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法使用這個方法來定義直到您的全域方法呼叫<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列程式碼範例說明如何使用`DefineGlobalMethod`來建立繫結至目前的型別無關方法<xref:System.Reflection.Emit.ModuleBuilder>。 在建置通用的方法之後,<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>必須呼叫以完成它。  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">這個方法不是靜態的。 也就是說，<paramref name="attributes" /> 不包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。  
  
-或- 
<see cref="T:System.Type" /> 陣列中的元素為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已呼叫過 <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] requiredReturnTypeCustomModifiers, class System.Type[] optionalReturnTypeCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] requiredParameterTypeCustomModifiers, class System.Type[][] optionalParameterTypeCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, requiredReturnTypeCustomModifiers As Type(), optionalReturnTypeCustomModifiers As Type(), parameterTypes As Type(), requiredParameterTypeCustomModifiers As Type()(), optionalParameterTypeCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ requiredReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredParameterTypeCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, requiredReturnTypeCustomModifiers, optionalReturnTypeCustomModifiers, parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="requiredReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredParameterTypeCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalParameterTypeCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">方法的名稱。 <paramref name="name" /> 不能含有內嵌 null 字元。</param>
        <param name="attributes">方法的屬性。 <paramref name="attributes" /> 必須包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">方法的呼叫慣例。</param>
        <param name="returnType">該方法的傳回類型。</param>
        <param name="requiredReturnTypeCustomModifiers">型別的陣列，表示傳回型別的必要自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" /> 或 <see cref="T:System.Runtime.CompilerServices.IsBoxed" />。 如果傳回類型沒有必要的自訂修飾詞，則指定 <see langword="null" />。</param>
        <param name="optionalReturnTypeCustomModifiers">型別的陣列，表示傳回型別的選擇性自訂修飾詞，例如 <see cref="T:System.Runtime.CompilerServices.IsConst" /> 或 <see cref="T:System.Runtime.CompilerServices.IsBoxed" />。 如果傳回類型沒有選擇性的自訂修飾詞，則指定 <see langword="null" />。</param>
        <param name="parameterTypes">方法參數的類型。</param>
        <param name="requiredParameterTypeCustomModifiers">類型陣列的陣列。 每一個型別陣列都表示全域方法之對應參數的必要自訂修飾詞。 如果特定引數沒有必要的自訂修飾詞，請指定 <see langword="null" />，而不要指定型別的陣列。 如果全域方法沒有任何引數，或者沒有任何引數具有必要的自訂修飾詞，請指定 <see langword="null" />，而不要指定陣列的陣列。</param>
        <param name="optionalParameterTypeCustomModifiers">類型陣列的陣列。 每一個型別陣列都表示對應參數的選擇性自訂修飾詞。 如果特定引數沒有選擇性的自訂修飾詞，請指定 <see langword="null" />，而不要指定型別的陣列。 如果全域方法沒有任何引數，或者沒有任何引數具有選擇性自訂修飾詞，請指定 <see langword="null" />，而不要指定陣列的陣列。</param>
        <summary>使用指定的名稱、屬性、呼叫慣例、傳回型別、傳回型別的自訂修飾詞、參數型別以及參數型別的自訂修飾詞，來定義全域方法。</summary>
        <returns>已定義的全域方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載可供設計工具的 managed 編譯器。  
  
 您無法使用這個方法來定義直到您的全域方法呼叫<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">這個方法不是靜態的。 也就是說，<paramref name="attributes" /> 不包括 <see cref="F:System.Reflection.MethodAttributes.Static" />。  
  
-或- 
<see cref="T:System.Type" /> 陣列中的元素為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已呼叫 <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">用來參考資料的名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="data">資料的二進位大型物件 (BLOB)。</param>
        <param name="attributes">欄位的屬性。 預設值為 <see langword="Static" />。</param>
        <summary>在可攜式執行檔 (PE) 的 .sdata 區段中定義初始化的資料欄位。</summary>
        <returns>要參考資料的欄位。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> 會自動包含在`attributes`。  
  
 這個方法所定義的資料才建立<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>呼叫方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A>方法，以定義在未初始化的資料欄位`.sdata`可攜式執行檔 (PE) 一節。  
  
 [!code-cpp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CPP/modulebuilder_defineinitializeddata.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CS/modulebuilder_defineinitializeddata.cs#1)]
 [!code-vb[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/VB/modulebuilder_defineinitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 的長度為零。  
  
-或- 
<paramref name="data" /> 的大小是小於等於零，或大於等於 0x3f0000。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 或 <paramref name="data" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已呼叫過 <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineManifestResource">
      <MemberSignature Language="C#" Value="public void DefineManifestResource (string name, System.IO.Stream stream, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineManifestResource(string name, class System.IO.Stream stream, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineManifestResource(System::String ^ name, System::IO::Stream ^ stream, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineManifestResource : string * System.IO.Stream * System.Reflection.ResourceAttributes -&gt; unit" Usage="moduleBuilder.DefineManifestResource (name, stream, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">資源的名稱 (區分大小寫)。</param>
        <param name="stream">包含資源位元組的資料流。</param>
        <param name="attribute">列舉值，指定資源是公用或私用。</param>
        <summary>定義二進位大型物件 (BLOB)，表示要嵌入動態組件的資訊清單資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會記錄在組件資訊清單中的資源可以是受管理的資源或資訊清單資源的 Blob，而且每一種可以包含組件中連結或內嵌。 這四個案例都支援動態組件。  
  
-   這個方法可讓您將內嵌至動態組件資訊清單資源 BLOB。  
  
-   若要插入資訊清單模組的動態組件或附屬模組，請內嵌 managed 的資源，請使用<xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType>方法來取得資源寫入器，並使用<xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType>方法來新增資源。  
  
-   若要連結至動態組件的受管理的資源，請使用<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType>方法來取得資源寫入器，並使用<xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType>方法來新增連結的資源。  
  
-   若要連結至動態組件資訊清單資源 BLOB，請使用<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType>方法來新增連結的資源。  
  
 此外，單一的 Win32 資源可以附加至組件利用<xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType>方法或<xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType>方法。 此資源沒有出現在組件資訊清單。  
  
   
  
## Examples  
 下列範例會產生並儲存名為動態組件`EmittedManifestResourceAssembly.exe`，其中包含內嵌的 unmanaged 資源。 此範例會建立組件可包含一個模組，然後開啟記憶體資料流包含 unmanaged 的資源。 程式碼會接著呼叫<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>方法來定義資源。  
  
> [!NOTE]
>  您可以使用任何一種資料流，為您的資源;比方說，您也可以從檔案讀取的未受管理的二進位資料。  
  
 此範例中的動態模組中定義的類型`Main`方法，並產生方法主體的 MSIL。 之後的主體`Main`方法已經產生，而且已經建立型別，程式碼範例會將五個位元組寫入至資訊清單資源相關聯的資料流。 儲存組件時，資源會附加至它。  
  
 在之後執行此範例中，您可以執行發出的組件。 發出的組件中的程式碼`Main`方法會讀取內嵌的資訊清單資源，並會列印到主控台的位元組值。 您可以使用[Ildasm.exe （IL 反組譯工具）](~/docs/framework/tools/ildasm-exe-il-disassembler.md)來檢視組件資訊清單中的資訊。  
  
 [!code-csharp[DefineManifestResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineManifestResource/cs/source.cs#1)]
 [!code-vb[DefineManifestResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineManifestResource/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="stream" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 是零長度字串。</exception>
        <exception cref="T:System.InvalidOperationException">包含目前模組的動態組件是暫時性 (Transient) 的，也就是說，呼叫 <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /> 時未指定任何檔案名稱。</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)" />
        <altmember cref="M:System.Resources.ResourceWriter.AddResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)" />
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義 <see langword="PInvoke" /> 方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> 方法的名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="dllName"><see langword="PInvoke" /> 方法定義所在的 DLL 名稱。</param>
        <param name="attributes">方法的屬性。</param>
        <param name="callingConvention">方法的呼叫慣例。</param>
        <param name="returnType">方法的傳回類型。</param>
        <param name="parameterTypes">方法參數的類型。</param>
        <param name="nativeCallConv">原生呼叫慣例。</param>
        <param name="nativeCharSet">方法的原生字元集。</param>
        <summary>使用指定的名稱、定義方法的 DLL 名稱、方法的屬性、方法的呼叫慣例、方法的傳回型別、方法的參數型別和 <see langword="PInvoke" /> 旗標，來定義 <see langword="PInvoke" /> 方法。</summary>
        <returns>已定義的 <see langword="PInvoke" /> 方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 DLL 匯入屬性 （請參閱 System.Runtime.InteropServices.DllImportAttribute 的描述） 不能指定為此方法的引數。 這類屬性應該設定所發出之方法的自訂屬性。 例如，DLL 匯入屬性`PreserveSig`設定所發出的自訂屬性。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例示範如何將`DefinePInvokeMethod`方法用來建立<xref:System.Reflection.Emit.MethodBuilder>是外部的 unmanaged 方法，請`MessageBoxA`，Win32 API 中。 此範例會顯示在訊息方塊**重試**並**取消**按鈕，並顯示訊息方塊的傳回值。  
  
> [!IMPORTANT]
>  若要取得非零傳回值，您必須新增<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>方法實作旗標建立之後<xref:System.Reflection.Emit.MethodBuilder>，利用<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>和<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>方法。  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">方法不是靜態的，或者包含型別 (Containing Type) 是介面。  
  
-或- 
這是抽象方法。  
  
-或- 
方法之前已定義過。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 或 <paramref name="dllName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">包含型別先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 來建立。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><see langword="PInvoke" /> 方法的名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="dllName"><see langword="PInvoke" /> 方法定義所在的 DLL 名稱。</param>
        <param name="entryName">DLL 中的進入點名稱。</param>
        <param name="attributes">方法的屬性。</param>
        <param name="callingConvention">方法的呼叫慣例。</param>
        <param name="returnType">方法的傳回類型。</param>
        <param name="parameterTypes">方法參數的類型。</param>
        <param name="nativeCallConv">原生呼叫慣例。</param>
        <param name="nativeCharSet">方法的原生字元集。</param>
        <summary>使用指定的名稱、定義方法的 DLL 名稱、方法的屬性、方法的呼叫慣例、方法的傳回型別、方法的參數型別和 <see langword="PInvoke" /> 旗標，來定義 <see langword="PInvoke" /> 方法。</summary>
        <returns>已定義的 <see langword="PInvoke" /> 方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些 DLL 匯入屬性 (請參閱描述<xref:System.Runtime.InteropServices.DllImportAttribute>) 不能指定為此方法的引數。 這類屬性應該設定所發出之方法的自訂屬性。 例如，DLL 匯入屬性`PreserveSig`設定所發出的自訂屬性。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例示範如何將`DefinePInvokeMethod`方法用來建立<xref:System.Reflection.Emit.MethodBuilder>是外部的 unmanaged 方法，請`MessageBoxA`，Win32 API 中。 此範例會顯示在訊息方塊**重試**並**取消**按鈕，並顯示訊息方塊的傳回值。  
  
> [!IMPORTANT]
>  若要取得非零傳回值，您必須新增<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>方法實作旗標建立之後<xref:System.Reflection.Emit.MethodBuilder>，利用<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>和<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>方法。  
  
 這個範例會使用不同的多載的<xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A>方法，但此技術是一樣。  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">方法不是靜態的，或者如果包含型別是介面、方法是抽象的或方法是先前定義的。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 或 <paramref name="dllName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">包含型別先前已使用 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 來建立。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義要儲存於這個模組中的 Managed 內嵌資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">資源名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="description">資源的描述。</param>
        <summary>定義要儲存於這個模組中的具名 Managed 內嵌資源。</summary>
        <returns>定義之資源的資源寫入器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫端必須呼叫`ResourceWriter.Generate()`和`ResourceWriter.Close()`方法，因為會呼叫這些方法`ModuleBuilder.Save`時動態組件會寫入至磁碟。  
  
 使用此方法來內嵌 managed 的資源。 若要將內嵌資訊清單資源的 blob，請使用<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>方法。 如需內嵌和連結 managed 的資源和資訊清單資源的 blob 的摘要，請參閱<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例示範如何將`DefineResource`若要加入至目前的外部資源<xref:System.Reflection.Emit.ModuleBuilder>。  
  
 [!code-cpp[ModuleBuilder_DefineResource1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CPP/modulebuilder_defineresource1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CS/modulebuilder_defineresource1.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource1/VB/modulebuilder_defineresource1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 的長度為零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 null。</exception>
        <exception cref="T:System.InvalidOperationException">這個模組是暫時性的。  
  
-或- 
包含的組件不是保存性的。</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String, attribute As ResourceAttributes) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string * System.Reflection.ResourceAttributes -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">資源名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="description">資源的描述。</param>
        <param name="attribute">資源屬性。</param>
        <summary>以指定的屬性定義要儲存於這個模組中的具名 Managed 內嵌資源。</summary>
        <returns>定義之資源的資源寫入器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫端必須呼叫`ResourceWriter.Generate()`和`ResourceWriter.Close()`方法，因為會呼叫這些方法`ModuleBuilder.Save`時動態組件會寫入至磁碟。  
  
 使用此方法來內嵌 managed 的資源。 若要將內嵌資訊清單資源的 blob，請使用<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>方法。 如需內嵌和連結 managed 的資源和資訊清單資源的 blob 的摘要，請參閱<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例示範如何將加入至目前的外部資源的 DefineResource <xref:System.Reflection.Emit.ModuleBuilder>。  
  
 [!code-cpp[ModuleBuilder_DefineResource2#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CPP/modulebuilder_defineresource2.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CS/modulebuilder_defineresource2.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource2/VB/modulebuilder_defineresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 的長度為零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 null。</exception>
        <exception cref="T:System.InvalidOperationException">這個模組是暫時性的。  
  
-或- 
包含的組件不是保存性的。</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建構 <see langword="TypeBuilder" />。 若要定義值型別，請定義衍生自 <see cref="T:System.ValueType" /> 的型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">型別的完整路徑，包含命名空間。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <summary>在這個模組中使用指定的名稱來建構私用型別的 <see langword="TypeBuilder" />。</summary>
        <returns>具有指定之名稱的私用型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型名稱必須是組件內唯一的。 您不能有具有相同名稱的兩種類型的組件的兩個不同模組中。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.Emit.TypeBuilder>在目前的動態模組使用`CreateType`、 建置及完成型別，以及將儲存組件。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的型別存在於這個模組的父組件中。  
  
-或- 
巢狀型別 (Nested Type) 屬性 (Attribute) 要設定在沒有巢狀化的型別上。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">型別的完整路徑。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attr">定義型別的屬性。</param>
        <summary>建構 <see langword="TypeBuilder" /> 需指定型別名稱和型別屬性。</summary>
        <returns>使用所有要求的屬性建立的 <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型名稱必須是組件內唯一的。 您不能有具有相同名稱的兩種類型的組件的兩個不同模組中。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.Emit.TypeBuilder>在目前的動態模組使用`CreateType`、 建置及完成型別，以及將儲存組件。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的型別存在於這個模組的父組件中。  
  
-或- 
巢狀型別 (Nested Type) 屬性 (Attribute) 要設定在沒有巢狀化的型別上。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">型別的完整路徑。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attr">屬性，與型別相關聯。</param>
        <param name="parent">型別，定義型別所擴充的。</param>
        <summary>建構 <see langword="TypeBuilder" /> 需指定型別名稱、其屬性和定義型別所擴充的型別。</summary>
        <returns>使用所有要求的屬性建立的 <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型名稱必須是組件內唯一的。 您不能有具有相同名稱的兩種類型的組件的兩個不同模組中。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.Emit.TypeBuilder>在目前的動態模組使用`CreateType`、 建置及完成型別，以及將儲存組件。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的型別存在於這個模組的父組件中。  
  
-或- 
巢狀型別 (Nested Type) 屬性 (Attribute) 要設定在沒有巢狀化的型別上。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, typesize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">型別的完整路徑。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attr">定義型別的屬性。</param>
        <param name="parent">型別，定義型別所擴充的。</param>
        <param name="typesize">型別的總大小。</param>
        <summary>建構 <see langword="TypeBuilder" /> 需指定型別名稱、屬性、定義型別所擴充的型別和型別的總共大小。</summary>
        <returns><see langword="TypeBuilder" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型名稱必須是組件內唯一的。 禁止將具有相同名稱的兩種類型在組件的兩個不同的模組。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.Emit.TypeBuilder>在目前的動態模組使用`CreateType`、 建置及完成型別，以及將儲存組件。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的型別存在於這個模組的父組件中。  
  
-或- 
巢狀型別 (Nested Type) 屬性 (Attribute) 要設定在沒有巢狀化的型別上。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packsize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packsize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, packsize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packsize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packsize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packsize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">型別的完整路徑。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attr">定義型別的屬性。</param>
        <param name="parent">型別，定義型別所擴充的。</param>
        <param name="packsize">類型的封裝大小。</param>
        <summary>建構 <see langword="TypeBuilder" /> 需指定型別名稱、屬性、定義型別所擴充的型別和型別的封裝大小。</summary>
        <returns><see langword="TypeBuilder" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型名稱必須是組件內唯一的。 您不能有具有相同名稱的兩種類型的組件的兩個不同模組中。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.Emit.TypeBuilder>在目前的動態模組使用`CreateType`、 建置及完成型別，以及將儲存組件。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的型別存在於這個模組的父組件中。  
  
-或- 
巢狀型別 (Nested Type) 屬性 (Attribute) 要設定在沒有巢狀化的型別上。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">型別的完整路徑。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attr">屬性，與型別相關聯。</param>
        <param name="parent">型別，定義型別所擴充的。</param>
        <param name="interfaces">介面清單，為型別所實作的。</param>
        <summary>建構 <see langword="TypeBuilder" /> 需指定型別名稱、屬性、定義型別所擴充的型別和定義型別實作的介面。</summary>
        <returns>使用所有要求的屬性建立的 <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型名稱必須是組件內唯一的。 您不能有具有相同名稱的兩種類型的組件的兩個不同模組中。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.Emit.TypeBuilder>在目前的動態模組使用`CreateType`、 建置及完成型別，以及將儲存組件。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的型別存在於這個模組的父組件中。  
  
-或- 
巢狀型別 (Nested Type) 屬性 (Attribute) 要設定在沒有巢狀化的型別上。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packingSize, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packingSize, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packingSize, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packingSize, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packingSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">型別的完整路徑。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="attr">定義型別的屬性。</param>
        <param name="parent">型別，定義型別所擴充的。</param>
        <param name="packingSize">類型的封裝大小。</param>
        <param name="typesize">型別的總大小。</param>
        <summary>建構 <see langword="TypeBuilder" /> 需指定型別名稱、屬性、定義型別所擴充的型別、定義型別的封裝大小和定義型別的總共大小。</summary>
        <returns>使用所有要求的屬性建立的 <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 類型名稱必須是組件內唯一的。 您不能有具有相同名稱的兩種類型的組件的兩個不同模組中。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Reflection.Emit.TypeBuilder>在目前的動態模組使用`CreateType`、 建置及完成型別，以及將儲存組件。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的型別存在於這個模組的父組件中。  
  
-或- 
巢狀型別 (Nested Type) 屬性 (Attribute) 要設定在沒有巢狀化的型別上。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">用來參考資料的名稱。 <paramref name="name" /> 不能包含內嵌的 null。</param>
        <param name="size">資料欄位的大小。</param>
        <param name="attributes">欄位的屬性。</param>
        <summary>在可攜式執行檔 (PE) 的 .sdata 區段中定義未初始化的資料欄位。</summary>
        <returns>要參考資料的欄位。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> 會自動包含在`attributes`。  
  
 這個方法所定義的資料才建立<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>呼叫方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 的長度為零。  
  
-或- 
 <paramref name="size" /> 小於或等於零，或者大於或等於 0x003f0000。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">之前已呼叫過 <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineUnmanagedResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義這個模組中的 Unmanaged 資源。 二進位大型物件 (BLOB) 必須採用 Win32 資源的正確格式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resource As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(cli::array &lt;System::Byte&gt; ^ resource);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : byte[] -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">表示 Unmanaged 資源的不透明 BLOB。</param>
        <summary>指定二進位大型物件 (BLOB) 位元組，來定義 Unmanaged 內嵌資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以只有一個的 unmanaged 資源相關聯的組件。 這表示，呼叫`DefineVersionInfoResource`或是`DefineUnmanagedResource`其中一個方法之後呼叫先前會擲回<xref:System.ArgumentException>。 需要 Microsoft ResMerge 公用程式 （通用語言執行平台不提供） 之類的工具與合併多個未受管理的資源。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已經在模組的組件中定義 Unmanaged 資源。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resource" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resourceFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(System::String ^ resourceFileName);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : string -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resourceFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">Unmanaged 資源檔的名稱。</param>
        <summary>定義 Unmanaged 資源，需指定 Win32 資源檔名稱。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以只有一個的 unmanaged 資源相關聯的組件。 這表示，呼叫`DefineVersionInfoResource`或是`DefineUnmanagedResource`其中一個方法之後呼叫先前會擲回<xref:System.ArgumentException>。 需要 Microsoft ResMerge 公用程式 （通用語言執行平台不提供） 之類的工具與合併多個未受管理的資源。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已經在模組的組件中定義 Unmanaged 資源。  
  
-或- 
 <paramref name="resourceFileName" /> 為空字串 ("")。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="resourceFileName" />。  
  
-或- 
 <paramref name="resourceFileName" /> 是目錄。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="moduleBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">與這個執行個體相比較的物件，或 <see langword="null" />。</param>
        <summary>傳回值，這個值表示這個執行個體是否等於指定的物件。</summary>
        <returns>如果 <see langword="true" /> 和這個執行個體具有相同的類型和值，則為 <paramref name="obj" />否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public override string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see langword="String" />，表示這個模組的完整名稱和路徑。</summary>
        <value>完整的模組名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取得不含路徑名稱，請使用`Name`。  
  
> [!NOTE]
>  模組名稱的大小寫取決於平台。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">存取路徑中的資訊。 關聯的列舉型別：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetArrayMethod (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetArrayMethod(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethod (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetArrayMethod(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethod : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetArrayMethod (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">陣列類別。</param>
        <param name="methodName">陣列類別上方法的名稱。</param>
        <param name="callingConvention">方法的呼叫慣例。</param>
        <param name="returnType">該方法的傳回類型。</param>
        <param name="parameterTypes">方法參數的類型。</param>
        <summary>傳回陣列類別上的具名方法。</summary>
        <returns>陣列類別上的具名方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetArrayMethod` 當您有尚未完成其定義之型別的陣列，而且您想要存取上定義的方法時非常有用<xref:System.Array>。 例如，您可以定義型別，並想要定義採用的類型做為參數陣列的方法。 若要存取陣列的元素，您必須呼叫方法<xref:System.Array>類別。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>以取得<xref:System.Reflection.MethodInfo>對應至傳回陣列值的方法。  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#1)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#1)]
 [!code-vb[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="arrayClass" /> 不是陣列。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayClass" /> 或 <paramref name="methodName" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetArrayMethodToken (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetArrayMethodToken(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethodToken (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetArrayMethodToken(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethodToken : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetArrayMethodToken (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">陣列的物件。</param>
        <param name="methodName">字串，包含方法的名稱。</param>
        <param name="callingConvention">方法的呼叫慣例。</param>
        <param name="returnType">該方法的傳回類型。</param>
        <param name="parameterTypes">方法的參數類型。</param>
        <summary>傳回陣列類別上具名方法的語彙基元。</summary>
        <returns>陣列類別上具名方法的語彙基元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法很類似<xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>，只不過它會傳回陣列方法，而不是方法本身的語彙基元。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>以取得<xref:System.Reflection.Emit.MethodToken>對應至傳回陣列值的方法。  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#2)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#2)]
 [!code-vb[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="arrayClass" /> 不是陣列。  
  
-或- 
<paramref name="methodName" /> 的長度為零。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="arrayClass" /> 或 <paramref name="methodName" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructorToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回語彙基元，用來在這個模組中識別指定的建構函式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (con As ConstructorInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken con" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="con">要為其取得語彙基元的建構函式。</param>
        <summary>傳回語彙基元，用來在這個模組中識別指定的建構函式。</summary>
        <returns>語彙基元，用來在這個模組中識別指定的建構函式。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="con" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (constructor As ConstructorInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken (constructor, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">要為其取得語彙基元的建構函式。</param>
        <param name="optionalParameterTypes">建構函式選擇性參數之型別的集合。</param>
        <summary>傳回語彙基元，用來識別在這個模組中具有指定屬性和參數型別的建構函式。</summary>
        <returns>語彙基元，用來在這個模組中識別指定的建構函式。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="constructor" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回套用至目前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 的自訂屬性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回已套用至目前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 的所有自訂屬性。</summary>
        <returns>陣列，其中包含自訂屬性；如果沒有屬性，則陣列是空的。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">從中衍生屬性的基底類型。</param>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回已套用至目前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 的所有自訂屬性，以及衍生自指定屬性類型的所有自訂屬性。</summary>
        <returns>陣列，包含衍生自 <paramref name="attributeType" /> 任何層級的自訂屬性，如果沒有這類屬性則為空陣列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> 不是執行階段所提供的 <see cref="T:System.Type" /> 物件。 例如，<paramref name="attributeType" /> 是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="moduleBuilder.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回已套用至目前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 之屬性的相關資訊，表示為 <see cref="T:System.Reflection.CustomAttributeData" /> 物件。</summary>
        <returns><see cref="T:System.Reflection.CustomAttributeData" /> 物件的泛型清單，表示已套用至目前模組之屬性的資料。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要檢查的自訂屬性中僅限反映的內容，在其中已載入至僅限反映內容的程式碼中定義的自訂屬性本身的情況下的程式碼中使用這個方法。 等方法<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>不能在這種情況下，因為它們會產生屬性的執行個體。 無法執行僅限反映內容中的程式碼。 如需詳細資訊和例如程式碼，請參閱<xref:System.Reflection.CustomAttributeData>類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">欄位名稱。</param>
        <param name="bindingAttr">用來控制搜尋的 <see langword="BindingFlags" /> 位元旗標組合。</param>
        <summary>傳回可攜式執行檔 (PE) 的 .sdata 區域中所定義、有指定之名稱和繫結屬性的模組層級欄位。</summary>
        <returns>有指定之名稱和繫結屬性的欄位，如果欄位不存在，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您發出動態組件時，請使用所定義的可攜式執行檔 (PE) 的.sdata 區域中的欄位<xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A>或<xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A>方法。  
  
> [!IMPORTANT]
>  無法擷取模組層級的欄位，直到之後<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>模組呼叫方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="moduleBuilder.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">用來控制搜尋的 <see langword="BindingFlags" /> 位元旗標組合。</param>
        <summary>傳回可攜式執行檔 (PE) 的 .sdata 區域中所定義、符合指定之繫結旗標的所有欄位。</summary>
        <returns>符合指定之旗標的欄位陣列，如果這類欄位不存在則為空陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您發出動態組件時，請使用所定義的可攜式執行檔 (PE) 的.sdata 區域中的欄位<xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A>或<xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A>方法。  
  
> [!IMPORTANT]
>  無法擷取模組層級的欄位，直到之後<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>模組呼叫方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldToken GetFieldToken (System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.FieldToken GetFieldToken(class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFieldToken (field As FieldInfo) As FieldToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldToken GetFieldToken(System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="member this.GetFieldToken : System.Reflection.FieldInfo -&gt; System.Reflection.Emit.FieldToken" Usage="moduleBuilder.GetFieldToken field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="field">要為其取得語彙基元的欄位。</param>
        <summary>傳回語彙基元，用來在這個模組中識別指定欄位。</summary>
        <returns>語彙基元，用來在這個模組中識別指定的欄位。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="field" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="moduleBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個執行個體的雜湊碼。</summary>
        <returns>32 位元帶正負號的整數雜湊碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">方法名稱。</param>
        <param name="bindingAttr">用來控制搜尋的 <see langword="BindingFlags" /> 位元旗標組合。</param>
        <param name="binder">該物件會實作 <see langword="Binder" />，其中包含與此方法相關的屬性。</param>
        <param name="callConvention">方法的呼叫慣例。</param>
        <param name="types">方法的參數型別。</param>
        <param name="modifiers">參數修飾詞的陣列，用來進行與參數簽章的繫結工作，其中該參數簽章的類別已修改。</param>
        <summary>傳回符合指定之準則的模組層級方法。</summary>
        <returns>在模組層級上定義而且符合指定之準則的方法，如果這類方法不存在則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法提供繼承的所有多載的實作<xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType>方法。 使用 繼承<xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType>方法來取得在模組層級的已宣告的方法。 您可以使用模組層級方法定義中發出的程式碼<xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>方法。  
  
> [!IMPORTANT]
>  無法擷取模組層級方法，直到之後<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>模組呼叫方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />，<paramref name="types" /> 為 <see langword="null" />，或 <paramref name="types" /> 的項目為 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="moduleBuilder.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">用來控制搜尋的 <see langword="BindingFlags" /> 位元旗標組合。</param>
        <summary>傳回為目前 <see cref="T:System.Reflection.Emit.ModuleBuilder" /> 在模組層級上已定義而且符合指定之繫結旗標的所有方法。</summary>
        <returns>陣列，包含符合 <paramref name="bindingFlags" /> 的所有模組層級方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用模組層級方法定義中發出的程式碼<xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>方法。  
  
> [!IMPORTANT]
>  無法擷取模組層級方法，直到之後<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>模組呼叫方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回語彙基元，用來在這個模組中識別指定方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="method">要為其取得語彙基元的方法。</param>
        <summary>傳回語彙基元，用來在這個模組中識別指定方法。</summary>
        <returns>語彙基元，用來在這個模組中識別指定的方法。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">方法的宣告型別不在這個模組中。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken (method, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="method">要為其取得語彙基元的方法。</param>
        <param name="optionalParameterTypes">方法選擇性參數之型別的集合。</param>
        <summary>傳回語彙基元，用來識別在這個模組中具有指定屬性和參數型別的方法。</summary>
        <returns>語彙基元，用來在這個模組中識別指定的方法。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="method" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">方法的宣告型別不在這個模組中。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public override void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="override this.GetPEKind :  *  -&gt; unit" Usage="moduleBuilder.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">這個方法會傳回 <see cref="T:System.Reflection.PortableExecutableKinds" /> 值的組合，表示模組中的程式碼性質。</param>
        <param name="machine">這個方法會傳回其中一個 <see cref="T:System.Reflection.ImageFileMachine" /> 值，表示模組的目標平台。</param>
        <summary>取得值組，表示模組中的程式碼性質，以及模組的目標平台。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動態模組，`peKind`總是<xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType>和`machine`一律為 0 （零）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSignatureToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>定義簽章語彙基元。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (System.Reflection.Emit.SignatureHelper sigHelper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(class System.Reflection.Emit.SignatureHelper sigHelper) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigHelper As SignatureHelper) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(System::Reflection::Emit::SignatureHelper ^ sigHelper);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : System.Reflection.Emit.SignatureHelper -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken sigHelper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigHelper" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="sigHelper">簽章。</param>
        <summary>針對由指定的 <see cref="T:System.Reflection.Emit.SignatureHelper" /> 所定義的簽章，定義語彙基元。</summary>
        <returns>已定義之簽章的語彙基元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法來定義所描述的簽章的中繼資料語彙基元`sigHelper`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sigHelper" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (byte[] sigBytes, int sigLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(unsigned int8[] sigBytes, int32 sigLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigBytes As Byte(), sigLength As Integer) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(cli::array &lt;System::Byte&gt; ^ sigBytes, int sigLength);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : byte[] * int -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken (sigBytes, sigLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigBytes" Type="System.Byte[]" />
        <Parameter Name="sigLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sigBytes">簽章二進位大型物件 (BLOB)。</param>
        <param name="sigLength">簽章 BLOB 的長度。</param>
        <summary>針對有指定之字元陣列和簽章長度的簽章，定義語彙基元。</summary>
        <returns>所指定簽章的語彙基元。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sigBytes" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="moduleBuilder.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> 物件，對應到這個模組所屬之組件的 Authenticode 簽章中所包含的憑證。 如果組件還未經 Authenticode 簽名，則傳回 <see langword="null" />。</summary>
        <returns>憑證，如果這個模組所屬的組件尚未經過 Authenticode 簽署，則為 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStringConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.StringToken GetStringConstant (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.StringToken GetStringConstant(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStringConstant (str As String) As StringToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::StringToken GetStringConstant(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.GetStringConstant : string -&gt; System.Reflection.Emit.StringToken" Usage="moduleBuilder.GetStringConstant str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.StringToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">字串，要加入至模組常數集區。</param>
        <summary>傳回模組常數集區中指定字串的權杖。</summary>
        <returns>常數集區中的字串語彙基元。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`str`已定義，現有的語彙基元將會傳回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSymWriter">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSymWriter () As ISymbolWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolWriter ^ GetSymWriter();" />
      <MemberSignature Language="F#" Value="member this.GetSymWriter : unit -&gt; System.Diagnostics.SymbolStore.ISymbolWriter" Usage="moduleBuilder.GetSymWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回符號寫入器，與這個動態模組相關聯。</summary>
        <returns>與這個動態模組相關聯的符號寫入器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得在模組中定義的具名型別。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="moduleBuilder.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">要取得的 <see cref="T:System.Type" /> 名稱。</param>
        <summary>取得在模組中定義的具名型別。</summary>
        <returns>如果此模組中已定義要求的型別則為該型別，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿使用這個方法來產生陣列類型、 指標類型或 byref 類型。 使用<xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>， <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType>方法改為。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="className" /> 的長度為零或大於 1023。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="className" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">要求的 <see cref="T:System.Type" /> 是非公用的，而且呼叫端並沒有 <see cref="T:System.Security.Permissions.ReflectionPermission" /> 來反映目前組件之外的非公用物件。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException">在載入 <see cref="T:System.Type" /> 時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="moduleBuilder.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">要取得的 <see cref="T:System.Type" /> 名稱。</param>
        <param name="ignoreCase">如果為 <see langword="true" />，搜尋不區分大小寫。 如果為 <see langword="false" />，搜尋會區分大小寫。</param>
        <summary>取得模組中定義的具名型別，選擇性地忽略型別名稱的大小寫。</summary>
        <returns>如果此模組中已定義要求的型別則為該型別，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請勿使用這個方法來產生陣列類型、 指標類型或 byref 類型。 使用<xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>， <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType>方法改為。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="className" /> 的長度為零或大於 1023。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="className" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">要求的 <see cref="T:System.Type" /> 是非公用的，而且呼叫端並沒有 <see cref="T:System.Security.Permissions.ReflectionPermission" /> 來反映目前組件之外的非公用物件。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="moduleBuilder.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">要取得的 <see cref="T:System.Type" /> 名稱。</param>
        <param name="throwOnError"><see langword="true" /> 表示找不到該類型時擲回例外狀況，而 <see langword="false" /> 則表示傳回 <see langword="null" />。</param>
        <param name="ignoreCase">如果為 <see langword="true" />，搜尋不區分大小寫。 如果為 <see langword="false" />，搜尋會區分大小寫。</param>
        <summary>取得模組中定義的具名型別，選擇性地忽略型別名稱的大小寫。 如果找不到型別，則是選擇性的擲回例外狀況。</summary>
        <returns>如果此模組中已宣告指定的型別則為該型別，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `throwOnError`參數只會影響找不到類型時，會發生什麼事。 它不會影響其他可能會擲回的例外狀況。 特別是，如果找到的型別，但無法載入，<xref:System.TypeLoadException>可能會擲回即使`throwOnError`是`false`。  
  
 請勿使用這個方法來產生陣列類型、 指標類型或 byref 類型。 使用<xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>， <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>，和<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType>方法改為。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="className" /> 的長度為零或大於 1023。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="className" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">要求的 <see cref="T:System.Type" /> 是非公用的，而且呼叫端並沒有 <see cref="T:System.Security.Permissions.ReflectionPermission" /> 來反映目前組件之外的非公用物件。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">叫用類別初始設定式並擲回例外狀況。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 為 <see langword="true" />，且找不到指定的型別。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="override this.GetTypes : unit -&gt; Type[]" Usage="moduleBuilder.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回在這個模組中定義的所有類別。</summary>
        <returns>陣列，含有在這個執行個體反映的模組中定義的型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException` 是特殊類別載入例外狀況。 `ReflectionTypeLoadException.Types`屬性包含的模組中定義並且載入的類別之陣列。 這個陣列可以包含部分 null 值。 `ReflectionTypeLoadException.LoaderExceptions`屬性為陣列，代表類別載入器擲回的例外狀況的例外狀況。 類別陣列漏洞產品有例外狀況。  
  
 例如，如果其中一個類別的類別初始設定式擲回例外狀況，它載入時，`TargetInvocationException`中的對應項目會儲存`LoaderExceptions`陣列。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">無法載入模組中的一或多個類別。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回型別語彙基元。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeToken (name As String) As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : string -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">類別的名稱，包含命名空間。</param>
        <summary>傳回語彙基元，用來識別具有指定之名稱的型別。</summary>
        <returns>語彙基元，用來在這個模組中識別具有指定之名稱的型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法相當實用的用戶端<xref:System.Reflection.Emit.MethodRental>想要直接修改方法的主體類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 為空字串 ("")。  
  
-或- 
 <paramref name="name" /> 表示 <see langword="ByRef" /> 型別。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 為 <see langword="null" />。  
  
-或- 
找不到 <paramref name="name" /> 所指定的型別。</exception>
        <exception cref="T:System.InvalidOperationException">這是參考暫時性模組的非暫時性模組。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : Type -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">表示類別型別的型別物件。</param>
        <summary>傳回語彙基元，用來在這個模組中識別指定的型別。</summary>
        <returns>語彙基元，用來在這個模組中識別指定的型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 權杖用於 Microsoft intermediate language (MSIL) 指令，以識別物件。 權杖是相對於其所包含的模組。 例如，權杖值供`String`很可能是不同的模組對模組。 當`GetTypeToken`是叫用，參考新增至模組。 參考會變成永久的模組;使用相同的引數的多個呼叫有任何額外的作用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 是 <see langword="ByRef" /> 型別。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">這是參考暫時性模組的非暫時性模組。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="moduleBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">所要測試之自訂屬性的型別。</param>
        <param name="inherit">這個類型的物件會忽略這個引數。</param>
        <summary>傳回值，這個值表示指定的屬性型別是否已套用至此模組。</summary>
        <returns>如果一個或多個 <paramref name="attributeType" /> 的執行個體已套用至這個模組，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> 不是執行階段所提供的 <see cref="T:System.Type" /> 物件。 例如，<paramref name="attributeType" /> 是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 物件。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public override bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsResource();" />
      <MemberSignature Language="F#" Value="override this.IsResource : unit -&gt; bool" Usage="moduleBuilder.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得值，指出物件是否為資源。</summary>
        <returns>如果物件為資源，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransient">
      <MemberSignature Language="C#" Value="public bool IsTransient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsTransient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsTransient" />
      <MemberSignature Language="VB.NET" Value="Public Function IsTransient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsTransient();" />
      <MemberSignature Language="F#" Value="member this.IsTransient : unit -&gt; bool" Usage="moduleBuilder.IsTransient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示這個動態模組是否為暫時性。</summary>
        <returns>如果這個動態模組是暫時性的，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public override int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得中繼資料流的版本。</summary>
        <value>32 位元的整數，表示中繼資料流的版本。 高順序的兩位元表示主要的版本號碼，而低順序的兩位元則表示次要的版本號碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如需有關中繼資料標頭的詳細資訊，請參閱 Common Language Infrastructure (CLI) 文件中的"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得語彙基元，可識別中繼資料中的目前動態模組。</summary>
        <value>整數語彙基元，可識別中繼資料中的目前模組。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性取得的權杖可以傳遞至 unmanaged 反映 API。 如需詳細資訊，請參閱 < [Unmanaged 反映 API](https://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public override Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可用來區別兩個模組版本的全域唯一識別碼 (UUID)。</summary>
        <value><see cref="T:System.Guid" />，可用來區別兩個模組版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由，在未受管理的中繼資料，傳回的 GUID<xref:System.Reflection.Module.ModuleVersionId%2A>屬性指`mvid`，而且會儲存在 GUID 堆積。  
  
> [!NOTE]
>  Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 > 中，可以找到中繼資料的詳細資訊。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示這是記憶體中模組的字串。</summary>
        <value>表示這是記憶體中模組的文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 無法取得動態模組的名稱，直到已儲存並從磁碟重新載入模組。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內欄位的中繼資料語彙基元。</param>
        <param name="genericTypeArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的欄位。</summary>
        <returns><see cref="T:System.Reflection.FieldInfo" /> 物件，表示指定之中繼資料語彙基元所識別的欄位。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="metadataToken" /> 在目前模組範圍中不是欄位的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 可識別欄位，而此欄位的父代 <see langword="TypeSpec" /> 具有包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的必要泛型型別引數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="moduleBuilder.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內型別或成員的中繼資料語彙基元。</param>
        <param name="genericTypeArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的型別或成員。</summary>
        <returns><see cref="T:System.Reflection.MemberInfo" /> 物件，表示指定之中繼資料語彙基元所識別的型別或成員。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="metadataToken" /> 在目前模組的範圍中不是型別或成員的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="MethodSpec" /> 或 <see langword="TypeSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的必要泛型型別引數。  
  
-或- 
 <paramref name="metadataToken" /> 識別屬性或事件。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="moduleBuilder.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內方法或建構函式的中繼資料語彙基元。</param>
        <param name="genericTypeArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的方法或建構函式。</summary>
        <returns><see cref="T:System.Reflection.MethodBase" /> 物件，表示指定之中繼資料語彙基元所識別的方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericMethodArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="metadataToken" /> 在目前模組的範圍中不是方法或建構函式的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="MethodSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的泛型型別引數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public override byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveSignature : int -&gt; byte[]" Usage="moduleBuilder.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內簽章的中繼資料語彙基元。</param>
        <summary>傳回中繼資料語彙基元所識別的簽章 Blob (二進位大型物件)。</summary>
        <returns>位元組的陣列，表示簽章 Blob。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  中繼資料語彙基元和簽章的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="metadataToken" />在目前模組的範圍中不是有效的 <see langword="MemberRef" />、<see langword="MethodDef" />、<see langword="TypeSpec" />、簽章或 <see langword="FieldDef" /> 語彙基元。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public override string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveString : int -&gt; string" Usage="moduleBuilder.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">中繼資料語彙基元，可識別模組字串堆積中的字串。</param>
        <summary>傳回指定之中繼資料語彙基元所識別的字串。</summary>
        <returns><see cref="T:System.String" />，包含中繼資料字串堆積中的字串值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="metadataToken" /> 在目前模組範圍中不是字串的語彙基元。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public override Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="moduleBuilder.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">識別模組內型別的中繼資料語彙基元。</param>
        <param name="genericTypeArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之型別的泛型型別引數，如果該型別不是泛型，則為 <see langword="null" />。</param>
        <param name="genericMethodArguments"><see cref="T:System.Type" /> 物件的陣列，表示語彙基元在範圍中之方法的泛型型別引數，如果該方法不是泛型，則為 <see langword="null" />。</param>
        <summary>以指定之泛型型別參數所定義的內容，傳回指定之中繼資料語彙基元所識別的型別。</summary>
        <returns><see cref="T:System.Type" /> 物件，表示指定之中繼資料語彙基元所識別的型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型別上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 使用<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>方法上的方法所在`metadataToken`位於範圍內，以取得泛型類型引數的陣列`genericTypeArguments`。 您總是安全地提供這些引數，即使不需要它們。  
  
> [!NOTE]
>  中繼資料語彙基元的相關資訊可在 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 線上; 會提供文件請參閱[ECMA C# 和 Common Language Infrastructure 標準](https://go.microsoft.com/fwlink/?LinkID=99212)MSDN 上並[標準 ECMA-335-通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) ECMA 網站上。  
  
 如示範語彙基元解析程式碼使用一般的內容 （也就是泛型型別和 （或） 權杖會內嵌的泛型方法的泛型型別參數） 請參閱<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="metadataToken" /> 在目前模組的範圍中不是型別的語彙基元。  
  
-或- 
 <paramref name="metadataToken" /> 是 <see langword="TypeSpec" />，其簽章包含項目型別 <see langword="var" /> (泛型型別的型別參數) 或 <see langword="mvar" /> (泛型方法的型別參數)，且未提供 <paramref name="genericTypeArguments" /> 和 <paramref name="genericMethodArguments" /> 其一或兩者的泛型型別引數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="metadataToken" /> 在目前模組的範圍中是無效的語彙基元。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public override string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示動態模組名稱的字串。</summary>
        <value>動態模組的名稱。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將自訂屬性套用至這個模組。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="moduleBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">用來指定所要套用的自訂屬性的 Helper 類別執行個體。</param>
        <summary>使用自訂屬性產生器，將自訂屬性套用至這個模組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="customBuilder" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="moduleBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">自訂屬性的建構函式。</param>
        <param name="binaryAttribute">表示屬性的位元組 BLOB。</param>
        <summary>將自訂屬性套用至這個模組，方式是使用指定的二進位大型物件 (BLOB) 表示該屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關如何格式化`binaryAttribute`，請參閱 Common Language Infrastructure (CLI) 文件，尤其是"Partition II:: 中繼資料定義和語意 >。 您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](https://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="con" /> 或 <paramref name="binaryAttribute" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="moduleBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">自訂屬性的名稱</param>
        <param name="data">不透明的位元組二進位大型物件 (BLOB)，表示自訂屬性的值。</param>
        <summary>這個方法不會有任何作用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會有任何作用。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="url" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public void SetUserEntryPoint (System.Reflection.MethodInfo entryPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetUserEntryPoint(class System.Reflection.MethodInfo entryPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetUserEntryPoint (entryPoint As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetUserEntryPoint(System::Reflection::MethodInfo ^ entryPoint);" />
      <MemberSignature Language="F#" Value="member this.SetUserEntryPoint : System.Reflection.MethodInfo -&gt; unit" Usage="moduleBuilder.SetUserEntryPoint entryPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryPoint" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryPoint">使用者進入點。</param>
        <summary>設定使用者進入點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 編譯器可能會產生啟動的虛設常式，然後再呼叫使用者的主要。 啟動的虛設常式將會進入點。 雖然主要使用者的使用者進入點，讓偵錯工具不會逐步執行至編譯器的進入點。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]，這個成員已不再需要<xref:System.Security.Permissions.ReflectionPermission>使用<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>旗標。 (請參閱[反映發出中的安全性問題](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用這項功能，您的應用程式應將目標設為 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] (含) 以後版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="entryPoint" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">這個方法要在不是偵錯模組的動態模組上呼叫。  
  
-或- 
 <paramref name="entryPoint" /> 不包含於這個動態模組中。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ModuleBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ModuleBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 這個成員是明確介面成員實作， 只有在 <xref:System.Reflection.Emit.ModuleBuilder> 執行個體轉換成 <xref:System.Runtime.InteropServices._ModuleBuilder> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ModuleBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">所要求類型資訊物件的指標。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 這個成員是明確介面成員實作， 只有在 <xref:System.Reflection.Emit.ModuleBuilder> 執行個體轉換成 <xref:System.Runtime.InteropServices._ModuleBuilder> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ModuleBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">接收物件提供的型別資訊介面數目的位置。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 這個成員是明確介面成員實作， 只有在 <xref:System.Reflection.Emit.ModuleBuilder> 執行個體轉換成 <xref:System.Runtime.InteropServices._ModuleBuilder> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ModuleBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ModuleBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">成員 ID。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。 如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 這個成員是明確介面成員實作， 只有在 <xref:System.Reflection.Emit.ModuleBuilder> 執行個體轉換成 <xref:System.Runtime.InteropServices._ModuleBuilder> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">方法使用 COM <c>IDispatch</c> 介面進行晚期繫結呼叫。</exception>
      </Docs>
    </Member>
  </Members>
</Type>