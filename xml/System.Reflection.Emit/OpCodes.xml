<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="22b85af836552ccbbe3eee4a23c0f8e2510b9978" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65013627" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供用於 Microsoft Intermediate Language (MSIL) 指令的欄位表示<see cref="T:System.Reflection.Emit.ILGenerator" />類別成員 (例如<see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成員 opcode 的詳細說明，請參閱 Common Language Infrastructure (CLI) 文件，特別是 「 第三部分：CIL 指令集 」 和 「 分割 II:中繼資料定義和語意 」。 您可以線上取得這份文件；請參閱 MSDN 上的 [ECMA C# 和通用語言基礎結構標準](https://go.microsoft.com/fwlink/?LinkID=99212)，以及 Ecma International 網站上的[標準 ECMA-335 - 通用語言基礎結構 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
   
  
## Examples  
 下列範例會示範動態方法，使用的建構<xref:System.Reflection.Emit.ILGenerator>發出`OpCodes`到<xref:System.Reflection.Emit.MethodBuilder>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>相加兩個值，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|58|add|將兩個數字的值，傳回新的數值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`新增至`value2`。  
  
4.  結果會推送至堆疊。  
  
 整數運算溢位都沒有偵測到 (處理適當的溢位，請參閱<xref:System.Reflection.Emit.OpCodes.Add_Ovf>)。  
  
 整數加法包裝，而不是飽和。 比方說，假設 8 位元整數，其中`value1`設定為 255 和`value2`設為 1，已包裝的結果會是 0，而不是 256。  
  
 傳回浮點溢位`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 可接受的運算元類型和其對應的結果資料類型會列在下表中。 如果沒有任何項目，針對特定類型的組合 (例如`int32`和`float`;`int32`和`int64`)，它是無效 Microsoft Intermediate Language (MSIL)，並產生錯誤。  
  
|運算元|value1 類型|value2 類型|結果型別|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`add`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>相加兩個整數、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D6|add.ovf|相加兩個的帶正負號的整數值，具有溢位檢查。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`新增至`value2`具有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果未顯示的結果型別，會擲回。  
  
 您可以執行這項作業帶正負號的整數。 浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 可接受的運算元類型和其對應的結果資料類型會列在下表中。 如果沒有任何項目，針對特定類型的組合 (例如`int32`和`float`;`int32`和`int64`)，它是無效的 Microsoft Intermediate Language (MSIL) 指示並產生錯誤。  
  
|運算元|value1 類型|value2 類型|結果型別|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`add.ovf`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>相加兩個不帶正負號的整數 (Unsigned Integer) 值、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|新增兩個不帶正負號的整數值，具有溢位檢查。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`新增至`value2`具有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果未顯示的結果型別，會擲回。  
  
 您可以執行這項作業帶正負號的整數。 浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 可接受的運算元類型和其對應的結果資料類型會列在下表中。 如果沒有任何項目，針對特定類型的組合 (例如`int32`和`float`;`int32`和`int64`)，它是無效的 Microsoft Intermediate Language (MSIL) 指示並產生錯誤。  
  
|運算元|value1 類型|value2 類型|結果型別|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|add|`int32`|`native int`|`native int`|  
|add|`int32`|`&`|`&`|  
|add|`int32`|`*`|`*`|  
|add|`int64`|`int64`|`int64`|  
|add|`native int`|`int32`|`native int`|  
|add|`native int`|`native int`|`native int`|  
|add|`native int`|`&`|`&`|  
|add|`native int`|`*`|`*`|  
|add|`F`|`F`|`F`|  
|add|`&`|`int32`|`&`|  
|add|`&`|`native int`|`&`|  
|add|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`add.ovf.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算兩個值的位元 AND 運算，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|指令|描述|  
|------------|-----------------|-----------------|  
|5F|和|判斷兩個整數值的位元 AND。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value1` 和`value2`從堆疊; 所推出的兩個值的位元 AND 的計算。  
  
4.  結果會推送至堆疊。  
  
 `and`指令會在堆疊上的前兩個值的位元 AND 的計算，並將結果留在堆疊上。  
  
 `And` 是整數特定作業。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`and`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將 Unmanaged 指標傳回目前方法的引數清單。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 00|arglist|傳回目前方法的引數清單的控制代碼。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `arglist`指令傳回的不透明的控制代碼 (類型的 unmanaged 的指標`native int`)，表示目前方法的引數清單。 只有在目前方法的存留期期間，這個控制代碼是有效的。 只要目前的方法是在控制項的執行緒上，可以不過，其他方法來傳遞控制代碼。 您只能執行`arglist`採用可變數目的引數的方法中的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`arglist`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果兩個值相等，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|分支至目標指令，位移`target`兩個值是否相等。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`等於`value2`，執行分支作業。  
  
 `beq`指令將控制權傳輸至指定的目標指示如果`value1`等於`value2`。 效果等同於執行`ceq`後面的指示`brtrue`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 封裝可接受的運算元類型如下：  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。  
  
 控制傳入和傳出傳輸`try`， `catch`， `filter`，以及`finally`區塊無法執行此指令 (這類傳輸有嚴格限制，而且必須使用<xref:System.Reflection.Emit.OpCodes.Leave>指令改為)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`beq`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果兩個值相等，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2E < `int8` >|後 `target`|分支至目標指令，位移`target`相等，如果簡短形式|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`等於`value2`，執行分支作業。  
  
 `beq.s`指令將控制權傳輸至指定的目標指示如果`value1`等於`value2`。 效果等同於執行`ceq`後面的指示`brtrue`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 封裝可接受的運算元類型如下：  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。  
  
 控制傳入和傳出傳輸`try`， `catch`， `filter`，以及`finally`區塊無法執行此指令 (這類傳輸有嚴格限制，而且必須使用<xref:System.Reflection.Emit.OpCodes.Leave>指令改為)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`beq.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於或等於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge.s 使用 `target`|分支至目標指令中指定的位移的第一個值是否大於或等於第二個值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。  
  
 `bge`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`。 效果等同於執行`clt.un`後面的指示`brfalse`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2F `<int8>`|後 `target`|分支至目標指令中指定的位移的第一個值是否大於或等於第二個值，也就是簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。  
  
 `bge.s`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`。 效果等同於執行`clt.un`後面的指示`brfalse`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|分支至目標指令中指定的位移的第一個值是否大於或等於第二個值 （不帶正負號的值）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。  
  
 `bge.un`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`clt`後面的指示`brfalse`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge.un`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|分支至目標指令中指定的位移的第一個值是否大於或等於第二個值 （不帶正負號的值）、 簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於或等於`value2`，執行分支作業。  
  
 `bge.un.s`指令將控制權傳輸至指定的目標指示如果`value1`大於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`clt`後面的指示`brfalse`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bge.un.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt.s 使用 `target`|分支至目標指令中指定的位移的第一個值是否大於第二個值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。  
  
 `bgt`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`。 效果等同於執行`cgt`後面的指示`brtrue`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|30 < `int8` >|後 `target`|分支至目標指令中指定的位移的第一個值是否大於第二個值，也就是簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。  
  
 `bgt.s`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`。 效果等同於執行`cgt`後面的指示`brtrue`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|分支至目標指令中指定的位移的第一個值是否大於第二個值 （不帶正負號的值）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。  
  
 `bgt.un`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`cgt.un`後面的指示`brtrue`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt.un`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值大於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|分支至目標指令中指定的位移的第一個值是否大於第二個值 （不帶正負號的值）、 簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`大於`value2`，執行分支作業。  
  
 `bgt.un.s`指令將控制權傳輸至指定的目標指示如果`value1`大於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`cgt.un`後面的指示`brtrue`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bgt.un.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble `target`|分支至目標指令中指定的位移的第一個值是否小於或等於第二個值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。  
  
 `ble`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`。 效果等同於執行`cgt`指令 (`cgt.un`的浮點數) 後面接著`brfalse`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|31 `<int8>`|後 `target`|分支至目標指令中指定的位移的第一個值是否小於或等於第二個值，也就是簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。  
  
 `ble.s`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`。 效果等同於執行`cgt`指令 (`cgt.un`的浮點數) 指令，後面跟著`brfalse`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|分支至目標指令中指定的位移的第一個值是否小於或等於第二個值 （不帶正負號的值）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。  
  
 `ble.un`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`cgt.un`指令 (`cgt`的浮點數) 後面接著`brfalse`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble.un`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於或等於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|分支至目標指令中指定的位移的第一個值是否小於或等於第二個值 （不帶正負號的值）、 簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`小於或等於`value2`，執行分支作業。  
  
 `ble.un.s`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`cgt.un`指令 (`cgt`的浮點數) 後面接著`brfalse`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ble.un.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|分支到在指定的位移的第一個值是否小於第二個值的目標指令。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。  
  
 `blt`指令將控制權傳輸至指定的目標指示如果`value1`小於或等於`value2`。 效果等同於執行`clt`後面的指示`brtrue`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一個值小於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|32 < `int8` >|後 `target`|分支至目標指令，在指定的位移的第一個值是否小於第二個值，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。  
  
 `blt.s`指令將控制權傳輸至指定的目標指示如果`value1`是小於`value2`。 效果等同於執行`clt`後面的指示`brtrue`分支至的特定目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於第二個值，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|分支至目標指令，在指定的位移的第一個值是否小於第二個值 （不帶正負號的值）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。  
  
 `blt.un`指令將控制權傳輸至指定的目標指示如果`value1`是小於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`clt.un`後面的指示`brtrue`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt.un`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當比較不帶正負號的整數值或未按順序的浮點值時，如果第一個值小於第二個值，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|分支至目標指令，在指定的位移的第一個值是否小於第二個值 （不帶正負號的值）、 簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`是小於`value2`，執行分支作業。  
  
 `blt.un`指令將控制權傳輸至指定的目標指示如果`value1`是小於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`clt.un`後面的指示`brtrue`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`blt.un.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當兩個不帶正負號的整數值或未按順序的浮點值不相等時，則將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|分支至目標指令時所指定的位移，如果兩個不帶正負號的整數值是不相等的 （不帶正負號的值）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`不等於`value2`，執行分支作業。  
  
 `bne.un`指令將控制權傳輸至指定的目標指示如果`value1`不等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`ceq`後面的指示`brfalse`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bne.un`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當兩個不帶正負號的整數值或未按順序的浮點值不相等時，則將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|分支至目標指令時所指定的位移，如果兩個不帶正負號的整數值是不相等的 （不帶正負號的值）、 簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`如果從堆疊; 快顯`value1`不等於`value2`，執行分支作業。  
  
 `bne.un`指令將控制權傳輸至指定的目標指示如果`value1`不等於`value2`，當使用不帶正負號的整數或未排序的浮點值進行比較。 效果等同於執行`ceq`後面的指示`brfalse`分支至的特定目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`bne.un.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將實值型別轉換成物件參考 (型別<see langword="O" />)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8C < `T` >|box `valTypeToken`|將實值型別轉換 (在指定之型別的`valTypeToken`)，則為 true 的物件參考。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  實值型別會推送至堆疊。  
  
2.  實值型別會從堆疊; 推出`box`作業。  
  
3.  產生的"boxed"的值類型的物件參考推送至堆疊。  
  
 實值型別有兩種不同的表示法在 Common Language Infrastructure (CLI):  
  
-   當實值型別會內嵌在另一個物件，或在堆疊上時，使用 'raw' 格式。  
  
-   'Boxed' 格式，其中實值型別中的資料會包裝 （進行 boxed 處理） 到物件讓它可以當作獨立的實體存在。  
  
 `box`指令會將未經處理 」 (unboxed) 實值類型轉換成物件參考 (型別`O`)。 這被透過建立新的物件和資料複製到新配置物件的實值型別。 `valTypeToken` 這中繼資料語彙基元，表示在堆疊上之值型別的型別。  
  
 <xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 轉換成機器碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`box`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無條件地將控制權傳輸至目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|分支至目標指令中指定的位移。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `br`指令無條件地將控制權傳輸至目標指令。 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`br`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無條件地將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|分支至目標指令中指定的位移，簡短形式。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `br.s`指令無條件地將控制權傳輸至目標指令。 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`br.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以訊號指示 Common Language Infrastructure (CLI) 向偵錯工具告知已經過中斷點。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|01|break|告知偵錯工具已到達中斷點。|  
  
 沒有評估堆疊行為都是透過這項作業。  
  
 `break`指示是針對偵錯支援。 它會通知來通知偵錯工具中斷點已跳脫 CLI。 它有沒有其他作用在解譯器的狀態。  
  
 `break`指令具有最小可能指令的大小可讓程式碼修補設有中斷點，並產生周圍的程式碼所造成的最小影響。  
  
 `break`指令可以捕捉到偵錯工具，不執行任何動作，或引發安全性例外狀況。 確切的行為是由實作定義。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`break`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果將控制權傳輸至目標指令<paramref name="value" />是<see langword="false" />，為 null 參考 (<see langword="Nothing" /> Visual Basic 中)，則為零。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|分支至目標指令在指定的位移 if `false`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊的前一項作業。  
  
2.  `value` 會從堆疊; 推出如果`value`已`false`，分支到`target`。  
  
 `brfalse`指令 (和其別名`brnull`並`brzero`) 將控制權傳輸至指定的目標指令，如果`value`(型別的`int32`， `int64`，物件參考`O`、 managed 指標`&`，暫時性指標`*`， `native int`) 為零 (`false`)。 如果`value`為非零 (`true`) 會繼續在下一步 的指示執行。  
  
 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brfalse`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果將控制權傳輸至目標指令<paramref name="value" />是<see langword="false" />，null 參考或零。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|分支至目標指令在指定的位移 if `false`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊的前一項作業。  
  
2.  `value` 會從堆疊; 推出如果`value`已`false`，分支到`target`。  
  
 `brfalse.s`指令 (和其別名`brnull`並`brzero`) 將控制權傳輸至指定的目標指令，如果`value`(型別的`int32`， `int64`，物件參考`O`、 managed 指標`&`，暫時性指標`*`， `native int`) 為零 (`false`)。 如果`value`為非零 (`true`) 會繼續在下一步 的指示執行。  
  
 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brfalse.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果將控制權傳輸至目標指令<paramref name="value" />是<see langword="true" />、 非 null 或非零。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|如果不是零，分支至目標指令中指定的位移 (`true`)。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊的前一項作業。  
  
2.  `value` 會從堆疊; 推出如果`value`已`true`，分支到`target`。  
  
 `brtrue`指令將控制權傳輸至指定的目標指示如果`value`(型別`native int`) 為非零值 (`true`)。 如果`value`為零 (`false`) 會繼續在下一步 的指示執行。  
  
 如果`value`是物件參考 (型別`O`) 然後`brinst`(的別名`brtrue`) 將控制權轉移，如果它代表物件的執行個體 (例如，如果不是 null 的物件參考，請參閱<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 目標指令會表示成 4 位元組帶正負號的位移，從緊跟在目前指令的開頭。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brtrue`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將控制權傳輸至目標指令 （簡短形式），如果<paramref name="value" />是<see langword="true" />、 非 null 或非零。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|如果不是零，分支至目標指令中指定的位移 (`true`)，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊的前一項作業。  
  
2.  `value` 會從堆疊; 推出如果`value`已`true`，分支到`target`。  
  
 `brtrue.s`指令將控制權傳輸至指定的目標指示如果`value`(型別`native int`) 為非零值 (`true`)。 如果`value`為零 (`false`) 會繼續在下一步 的指示執行。  
  
 如果`value`是物件參考 (型別`O`) 然後`brinst`(的別名`brtrue`) 將控制權轉移，如果它代表物件的執行個體 (例如，如果不是 null 的物件參考，請參閱<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 目標指令被以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`brtrue.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼叫傳遞的方法描述項所指示的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|28 < `T` >|呼叫 `methodDesc`|呼叫所描述方法`methodDesc`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  方法引數`arg1`透過`argN`推送至堆疊。  
  
2.  方法引數`arg1`透過`argN`會彈出從堆疊; 方法呼叫會使用這些引數來執行，而且控制權會轉移至方法描述元所參考的方法。 完成時，傳回的值就是被呼叫端方法所產生，並傳送至呼叫端。  
  
3.  傳回值推送至堆疊。  
  
 `call`指令呼叫傳遞指令的方法描述項所指定的方法。 方法描述元是中繼資料語彙基元，表示要呼叫數目、 類型和放置要傳遞至該方法，以及要使用的呼叫慣例在堆疊的引數順序的方法。 `call`指令可以前面緊接`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前置詞來指定應該釋放目前的方法狀態，才能將控制權轉移的指示。 如果呼叫會將控制權傳輸至較高的信任，比原始方法的方法，是不會釋放堆疊框架。 相反地，會繼續執行無訊息方式如同`tail`尚未提供。 的中繼資料語彙基元會傳送足夠的資訊來判斷呼叫是否為靜態方法，執行個體方法，虛擬方法，或全域函式。 在這些情況下的所有目的地位址由都決定完全從方法描述元 (與<xref:System.Reflection.Emit.OpCodes.Callvirt>呼叫虛擬方法，其中的目的地位址也取決於執行階段類型的執行個體的指示參考推入之前<xref:System.Reflection.Emit.OpCodes.Callvirt>)。  
  
 引數會放在堆疊上，在左到右的順序。 也就是第一個引數會計算並放置在堆疊上，則第二個引數，則第三個，直到所有必要的引數是以遞減順序堆疊的頂端。 有三個重要的特殊情況：  
  
 1. 呼叫執行個體 （或虛擬） 方法必須將推入執行個體參考之前的任何使用者可見的引數。 執行個體的參考不能為 null 參考。 執行中繼資料中的簽章不包含的參數清單中的項目`this`指標，而是使用位元來指出方法是否需要傳遞`this`指標。  
  
 2. 它會有效地呼叫虛擬方法，使用`call`(而非`callvirt`); 這表示，方法是使用指定方法，而不是以動態方式從物件叫用指定的類別來解決。  
  
 3. 請注意，委派`Invoke`可以使用呼叫方法`call`或`callvirt`指令。  
  
 <xref:System.Security.SecurityException> 可能會擲回，如果系統安全性不會授與被呼叫的方法的呼叫端存取。 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時，可能會發生安全性檢查。  
  
> [!NOTE]
>  當實值型別上呼叫 System.Object 的方法，請考慮使用`constrained`加上前置詞`callvirt`而不是發出指令`call`指令。 這可免除發出不同 IL 根據實值型別會覆寫方法，避免潛在的版本控制問題。 請考慮使用`constrained`可以使用變更時叫用介面方法上實值型別，因為實作介面方法的值類型方法的前置詞`MethodImpl`。 會更詳細地說明這些問題<xref:System.Reflection.Emit.OpCodes.Constrained>opcode。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`call`opcode:  
  
-   ILGenerator.Emit （OpCode、 MethodInfo）  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>方法提供給`varargs`呼叫。 使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>一般呼叫的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以呼叫慣例所描述的引數，呼叫在評估堆疊上指示的方法 (做為進入點的指標)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|呼叫方法的呼叫慣例所描述的引數所指向。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  方法引數`arg1`透過`argN`推送至堆疊。  
  
2.  方法項目指標會推送至堆疊。  
  
3.  方法引數`arg1`透過`argN`和方法的項目指標會從堆疊推出; 方法的呼叫會執行。 完成時，傳回的值就是被呼叫端方法所產生，並傳送至呼叫端。  
  
4.  傳回值推送至堆疊。  
  
 `calli`指令呼叫方法的項目指標使用的引數`arg1`透過`argN`。 這些引數類型會描述特定的呼叫慣例 (`callSiteDesc`)。 `calli`指示可能前面緊接`tail`前置詞 (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 來指定應該釋放目前的方法狀態，才能將控制權轉移。 如果呼叫，就會傳輸將不會釋放控制項的信任層級高於原始方法的堆疊框架的方法;相反地，執行會以無訊息模式繼續如同`tail`尚未提供。  
  
 方法的項目指標會假設為原生程式碼 （的目標電腦） 可以合法地呼叫 （獨立的簽章的中繼資料語彙基元） 的呼叫慣例所描述的引數的特定指標。 您可以使用建立這類指標<xref:System.Reflection.Emit.OpCodes.Ldftn>或<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>的指示，或傳入的原生程式碼。  
  
 呼叫慣例不會以動態方式檢查，因此程式碼該使用`calli`指令無法正常運作如果目的地不會實際使用指定的呼叫慣例。  
  
 引數會放在堆疊上，在左到右的順序。 也就是第一個引數會計算並放置在堆疊上，則第二個引數，則第三個，直到所有必要的引數是以遞減順序堆疊的頂端。 執行個體或虛擬方法的引數建置程式碼順序必須將該執行個體參考 （不得為 null 參考） 之前的任何使用者可見的引數推入。  
  
 <xref:System.Security.SecurityException> 可能會擲回，如果系統安全性不會授與被呼叫的方法的呼叫端存取。 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時，可以發生安全性檢查。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法可用來執行`calli`堆疊上的指示。 請注意，`calli`應該透過呼叫以下方法，而不是使用<xref:System.Reflection.Emit.ILGenerator.Emit%2A>類別將直接在堆疊上的指示。  
  
-   ILGenerator.EmitCalli (Opcode、 CallingConventions、 型別，Type []，Type[]) 呼叫使用的 managed 呼叫慣例。  
  
-   ILGenerator.EmitCalli (Opcode CallingConvention，型別，Type[]) 呼叫使用的 unmanaged 呼叫慣例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在物件上呼叫晚期繫結方法，將傳回值推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|呼叫相關聯的特定方法`obj`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`obj`推送至堆疊。  
  
2.  方法引數`arg1`透過`argN`推送至堆疊。  
  
3.  方法引數`arg1`透過`argN`和物件參考`obj`會彈出從堆疊; 方法呼叫會使用這些引數來執行，而且控制權會轉移至中的方法`obj`指方法中繼資料語彙基元。 完成時，傳回的值就是被呼叫端方法所產生，並傳送至呼叫端。  
  
4.  傳回值推送至堆疊。  
  
 `callvirt`指令的物件上呼叫晚期繫結方法。 也就是說，方法選擇根據執行階段類型的`obj`而不是編譯時期類別顯示在方法的指標。 `Callvirt` 可用來呼叫虛擬和執行個體方法。 `callvirt`指示可能前面緊接`tail`(<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前置詞，以指定應該釋放目前的堆疊框架，才能將控制權轉移。 如果呼叫，就會傳輸不會釋放控制項的信任層級高於原始方法的堆疊框架的方法。  
  
 方法的中繼資料語彙基元提供名稱、 類別和要呼叫之方法的簽章。 與相關聯的類別`obj`是它的執行個體的類別。 如果類別定義了符合指定的方法名稱和簽章的非靜態方法，會呼叫這個方法。 否則順序會檢查此類別的基底類別鏈結中的所有類別。 如果找不到任何方法，它就會是錯誤。  
  
 `Callvirt` 在呼叫方法之前出現的物件和相關聯的引數，從評估堆疊。 如果方法具有傳回值，則會將它推入方法完成時的堆疊。 被呼叫端一端`obj`參數會當做引數為 0，`arg1`做為引數 1，依此類推。  
  
 引數會放在堆疊上，在左到右的順序。 也就是第一個引數會計算並放置在堆疊上，則第二個引數，則第三個，直到所有必要的引數是以遞減順序堆疊的頂端。 執行個體參考`obj`(一律所需的`callvirt`) 必須推送之前的任何使用者可見的引數。 （包含在中繼資料語彙基元） 的簽章不需要這個包含的參數清單中的項目指標。  
  
 請注意，虛擬方法也可以呼叫使用<xref:System.Reflection.Emit.OpCodes.Call>指令。  
  
 <xref:System.MissingMethodException> 如果相關聯的類別中找不到具有指定的名稱和簽章的非靜態方法會擲回`obj`或任何其基底類別。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 <xref:System.NullReferenceException> 如果 obj 為 null，會擲回。  
  
 <xref:System.Security.SecurityException> 如果系統安全性不會授與被呼叫的方法的呼叫端存取，會擲回。 CIL 轉換至原生程式碼，而不是在執行階段時，可能會發生安全性檢查。  
  
> [!NOTE]
>  當實值型別上呼叫 System.Object 的方法，請考慮使用`constrained`加上前置詞`callvirt`指令。 這可免除發出不同 IL 根據實值型別會覆寫方法，避免潛在的版本控制問題。 請考慮使用`constrained`可以使用變更時叫用介面方法上實值型別，因為實作介面方法的值類型方法的前置詞`MethodImpl`。 會更詳細地說明這些問題<xref:System.Reflection.Emit.OpCodes.Constrained>opcode。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`callvirt`opcode:  
  
-   ILGenerator.Emit （OpCode、 MethodInfo）  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>嘗試將參考所傳遞的物件轉型為指定的類別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|將轉換至新的物件型別的物件`class`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考推送至堆疊。  
  
2.  物件參考是從堆疊; 推出參考的物件轉換為指定`class`。  
  
3.  如果成功，則會將新的物件參考推送至堆疊。  
  
 `castclass`指令會嘗試轉換的物件參考 (型別`O`) 指定的類別到堆疊的頂端。 新的類別被指定的中繼資料語彙基元，指出所需的類別。 如果堆疊頂端的物件類別不會實作新的類別 （假設新的類別介面），而不是在衍生的類別的新類別則<xref:System.InvalidCastException>就會擲回。 如果物件參考為 null 參考，`castclass`成功並傳回新的物件為 null 參考。  
  
 <xref:System.InvalidCastException> 如果 obj 無法轉換成類別，會擲回。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`castclass`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個值。 如果兩者相等，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 01|ceq|推送 1，如果`value1`等於`value2`，否則將 0 推入。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`相較於`value2`。  
  
4.  如果`value1`等於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。  
  
 `ceq`指示比較`value1`和`value2`。 如果`value1`等於`value2`，然後 1 (型別`int32`) 推送到堆疊上。 否則為 0 (型別`int32`) 推送到堆疊上。  
  
 浮點數的`ceq`會傳回 0，如果數字排序 （或兩者皆是 NaN）。 對其本身的無限值相等。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ceq`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個值。 如果第一個值大於第二個，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 02|cgt|推送 1，如果`value1`大於`value2`，否則將 0 推入。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`cgt`測試`value1`大於`value2`。  
  
4.  如果`value1`大於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。  
  
 `cgt`指示比較`value1`和`value2`。 如果`value1`必定大於`value2`，然後`int32`值 1 會推送到堆疊上。 否則， `int32` 0 值推送到堆疊上。  
  
-   浮點數，`cgt`會傳回 0，如果數字排序 （亦即，如果一或兩個引數是 NaN）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cgt`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個沒有正負號或未排序的值。 如果第一個值大於第二個，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|推送 1，如果`value1`大於`value2`，否則將 0 （不帶正負號的值） 推入。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`cgt.un`測試`value1`大於`value2`。  
  
4.  如果`value1`大於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。  
  
 `int32`值為 1 會推送到堆疊上，如果下列任一項為`true`:  
  
 浮點數，如`value1`相對於未經過排序`value2`。  
  
 對於整數值`value1`必定大於`value2`時視為不帶正負號的數字。  
  
 否則`int32`0 值推送到堆疊上。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cgt.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>會擲回<see cref="T:System.ArithmeticException" />如果值不是有限的數量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|C3|ckfinite|擲回<xref:System.ArithmeticException>如果值不是有限的數量。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。 
  
2.  `value` 會從堆疊推出和`ckfinite`指令會在其上執行。  
  
3.  `value` 推送回至堆疊在擲回任何例外狀況。  
  
 `ckfinite instruction`會擲回<xref:System.ArithmeticException>如果`value`（浮點數） 是 「 不是數字 」 值 (NaN) 或`+-`無限大值。 `Ckfinite` 如果擲不回任何例外狀況，請將值保留在堆疊上。 如果未指定執行，是`value`不是浮點數的數字。  
  
 <xref:System.ArithmeticException> 如果擲回`value`不是 'normal' 的數字。  
  
 請注意，特殊的例外狀況或衍生的類別的<xref:System.ArithmeticException>可能更合適，將不正確的值傳遞至例外狀況處理常式。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ckfinite`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較兩個值。 如果第一個值小於第二個，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊。否則為 0 (<see langword="int32" />) 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 04|clt|推送 1，如果`value1`是小於`value2`，否則將 0 推入。|  
  
 堆疊的轉換行為，依連續順序是： 

1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`clt`測試`value1`是小於`value2`。  
  
4.  如果`value1`是小於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。  
  
 `clt`指示比較`value1`和`value2`。 如果`value1`是小於`value2`，然後`int32`值 1 會推送到堆疊上。 否則， `int32` 0 值推送到堆疊上。  
  
-   浮點數，`clt`會傳回 0，如果數字排序 （亦即，如果一或兩個引數是 NaN）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`clt`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比較不帶正負號或未排序的值<paramref name="value1" />和<paramref name="value2" />。 如果<paramref name="value1" />是小於<paramref name="value2" />，則將整數值 1 <see langword="(int32" />) 推送至評估堆疊，否則將 0 (<see langword="int32" />) 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|推送 1，如果`value1`是小於`value2`，否則將 0 （不帶正負號的值） 推入。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`clt.un`測試`value1`是小於`value2`。  
  
4.  如果`value1`是小於`value2`，1 會推送至堆疊，否則為 0 會推入至堆疊。  
  
 `clt.un`指示比較`value1`和`value2`。 `int32`值 1 會推送到堆疊上，如果下列任一項為真：  
  
-   `value1` 是小於`value2`(與`clt`)。  
  
-   浮點數，如`value1`相對於未經過排序`value2`。  
  
-   對於整數值`value1`是小於`value2`時視為不帶正負號的數字。  
  
 否則， `int32` 0 值推送到堆疊上。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`clt.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>限制其上可進行虛擬方法呼叫的類型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|限制。 `thisType`|呼叫虛擬方法的型別上限制為型別`T`。|  
  
 `constrained`前置詞僅允許`callvirt`指令。  
  
 MSIL 堆疊目前的狀態必須如下所示：  
  
1.  受管理的指標， `ptr`，推送到堆疊。 型別`ptr`必須是 managed 的指標 (`&`) 以`thisType`。 請注意，這是從無前置詞的大小寫不同`callvirt`指令，這需要的參考`thisType`。  
  
2.  方法引數`arg1`經由`argN`推送到堆疊上，就如同無前置詞`callvirt`指令。  
  
 `constrained`前置詞設計成允許`callvirt`指示，設定成以統一方式獨立是否`thisType`是實值類型或參考型別。  
  
 當`callvirt``method`指示加`constrained` `thisType`，指示執行，如下所示：  
  
-   如果`thisType`是參考型別 （而不是實值型別），則`ptr`已取值，而且傳遞 'this' 指標`callvirt`的`method`。  
  
-   如果`thisType`是實值類型和`thisType`實作`method`然後`ptr`傳遞未修改為 'this' 指標`call``method`實作的指示，`method`由`thisType`.  
  
-   如果`thisType`是實值類型和`thisType`不會實作`method`然後`ptr`取值、 boxed，和以 'this' 指標傳遞`callvirt``method`指令。  
  
 最後這個情況下可能會發生時，才`method`上已定義<xref:System.Object>， <xref:System.ValueType>，或<xref:System.Enum>並沒有覆寫`thisType`。 在此情況下，boxing 會導致設為原始物件的複本。 不過，因為沒有任何方法<xref:System.Object>， <xref:System.ValueType>，和<xref:System.Enum>修改狀態的物件，無法偵測到這項事實。  
  
 `constrained`前置詞支援建立泛型的程式碼的 IL 產生器。 通常`callvirt`指令無效，無法在實值型別。 而是需要 IL 編譯器會有效地執行上面所述，在編譯時期，視類型而定的 'this' 的轉換`ptr`和被呼叫的方法。 不過，當`ptr`是在編譯時期不知道泛型型別不可能進行這項轉換，在編譯時期。  
  
 `constrained` Opcode 允許 IL 編譯器來進行統一的虛擬函式呼叫是否方式獨立`ptr`是實值類型或參考型別。 雖然它適用於案例所在`thisType`是泛型型別變數，`constrained`前置詞也適用於非泛型型別，並且可以減少產生隱藏實值型別之間的差異的語言中的虛擬呼叫的複雜性和參考型別。  
  
 使用`constrained`前置詞也可避免潛在的實值類型的版本控制問題。 如果`constrained`不使用前置詞，根據實值型別是否會覆寫 System.Object 的方法必須發出不同的 IL。 比方說，如果實值型別`V`object.tostring （） 方法，就會覆寫`call``V.ToString()`指令，就會發出; 如果沒有出現，請`box`指令並`callvirt``Object.ToString()`發出指令。 版本控制問題可能發生在先前的情況下，如果稍後移除覆寫，並在後者的情況下，如果稍後新增覆寫。  
  
 `constrained`前置詞可以也實值類型上的介面方法引動過程使用，因為實作介面方法的值型別方法可以使用變更`MethodImpl`。 如果`constrained`不使用前置詞，編譯器會強迫選擇其中一個值在編譯時期繫結至類型的方法。 使用`constrained`前置詞可讓繫結至的方法，在執行階段，而不是在編譯時期，會實作介面方法的 MSIL。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`constrained`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值，轉換<see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D3|conv.i|將轉換成`native int`推送、`native int`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.i` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值轉換<see langword="int8" />，然後擴充 （填補） 到<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|67|conv.i1|將轉換成`int8`推送、`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.i1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值轉換<see langword="int16" />，然後擴充 （填補） 到<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|68|conv.i2|將轉換成`int16`推送、`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.i2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值，轉換<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|69|conv.i4|將轉換成`int32`推送、`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.i4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值，轉換<see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6A|conv.i8|將轉換成`int64`推送、`int64`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.i8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.i8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="native int" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|將轉換成`native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="native int" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|將不帶正負號的值轉換`native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換成帶正負號 <see langword="int8" />，將它擴充到 <see langword="int32" />，並在溢位上擲回 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|將轉換成`int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int8" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|將不帶正負號的值轉換`int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i1.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i1.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|將轉換成`int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|將不帶正負號的值轉換`int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i2.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i2.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|將轉換成`int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|將不帶正負號的值轉換`int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i4.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i4.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端帶正負號的值<see langword="int64" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|將轉換成`int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將轉換成帶正負號的評估堆疊頂端不帶正負號的值<see langword="int64" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|將不帶正負號的值轉換`int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.i8.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.i8.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換<see langword="unsigned native int" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|將轉換成`unsigned native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned native int" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|將取消不帶正負號值`unsigned native int`(在堆疊上`native int`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.uvf.u.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int8" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|將轉換成`unsigned int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int8" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|將不帶正負號的值轉換`unsigned int8`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u1.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u1.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|將轉換成`unsigned int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int16" />並將它擴充到<see langword="int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|將不帶正負號的值轉換`unsigned int16`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u2.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u2.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|將轉換成`unsigned int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int32" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|將不帶正負號的值轉換`unsigned int32`(在堆疊上`int32`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u4.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u4.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端帶正負號的值轉換<see langword="unsigned int64" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|將轉換成`unsigned int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的值轉換<see langword="unsigned int64" />擲回、<see cref="T:System.OverflowException" />溢位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|將不帶正負號的值轉換`unsigned int64`(在堆疊上`int64`) 並在溢位上擲回的例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。 如果發生溢位，則會擲回例外狀況。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.ovf.u8.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的位置中指定的型別堆疊的頂端。 如果值太大或太小，表示目標類型，則會擲回例外狀況。  
  
 浮點數轉換成整數值會截斷趨近於零的數字。 請注意少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.ovf.i`或是`conv.ovf.u`使用時，結果在此情況下也是`native int`)。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.ovf.u8.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端不帶正負號的整數值轉換<see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Convert 不帶正負號的整數到浮點數，推送`F`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.r.un` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位浮點類型轉換成整數`result`傳回未指定。 `conv.r.un`作業會接受整數堆疊、 將它解譯為不帶正負號，並取代浮點數，表示整數： 任一`float32`，如果這是寬度不足以代表整數而不會遺失有效位數，或其他`float64`。  
  
 使用此欄位時，以往會擲不回任何例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.r.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值，轉換<see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6B|conv.r4|將轉換成`float32`推送、`F`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.r4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.r4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值，轉換<see langword="float64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6C|conv.r8|將轉換成`float64`推送、`F`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.r8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.r8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值轉換<see langword="unsigned native int" />，並將它擴充到<see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|E0|conv.u|將轉換成`unsigned native int`推送、`native int`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.u` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值轉換<see langword="unsigned int8" />，並將它擴充到<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D2|conv.u1|將轉換成`int8`推送、`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.u1` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值轉換<see langword="unsigned int16" />，並將它擴充到<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D1|conv.u2|將轉換成`int16`推送、`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.u2` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值轉換<see langword="unsigned int32" />，並將它擴充到<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6D|conv.u4|將轉換成`unsigned int32`推送、`int32`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.u4` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將評估堆疊頂端值轉換<see langword="unsigned int64" />，並將它擴充到<see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|6E|conv.u8|將轉換成`int64`推送、`int64`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 時會推出堆疊，並轉換從嘗試作業。  
  
3.  如果轉換成功，則會將產生的值推送至堆疊。  
  
 `conv.u8` Opcode 轉換`value`opcode 及轉換的堆疊頂端值的保留在指定的型別堆疊的頂端。 少於 4 個位元組的整數值已擴充來`int32`時載入至評估堆疊 (除非`conv.i`或是`conv.u`使用時，結果在此情況下也是`native int`)。 浮點數的值會轉換成`F`型別。  
  
 從浮點數轉換成整數值會截斷趨近於零的數字。 從轉換時`float64`至`float32`，有效位數可能會遺失。 如果`value`太大，以致於無法納入`float32 (F)`，正無限大 (如果`value`是正值) 或負的無限值 (如果`value`是負數) 會傳回。 如果轉換的一個整數型別到另一個發生溢位，會截斷高序位位元。 如果結果為小於`int32`，值是 sign-extended 以填滿的位置。  
  
 如果發生溢位而將浮點類型轉換成整數傳回的值未指定。  
  
 使用此欄位時，以往會擲不回任何例外狀況。 請參閱<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>和<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>的對應時的結果型別可以正確地代表結果值將會擲回例外狀況的指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`conv.u8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將指定的數值位元組數從來源位址複製到目的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|將資料從一個記憶體區塊複製到另一個。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  目的地位址被推送至堆疊。  
  
2.  來源地址推送至堆疊。  
  
3.  要複製的位元組數目會推送至堆疊。  
  
4.  從堆疊; 所推出的位元組、 來源位址和目的地位址數目指定的位元組數目會從來源位址複製，其目的位址。  
  
 `cpblk`指令會將複製的數字 (型別`unsigned int32`) 的位元組從來源位址 (型別的`*`， `native int`，或`&`) 到目的地位址 (型別的`*`， `native int`，或`&`)。 行為`cpblk`是未指定，如果來源和目的地區域重疊。  
  
 `cpblk` 假設來源和目的位址對齊自然機器的大小。 `cpblk`指令可以前面緊接`unaligned.<prefix>`表示未對齊的來源或目的地的指示。  
  
 營運`cpblk`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cpblk`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>實值型別位於物件位址的複本 (型別<see langword="&amp;" />，<see langword="*" />或是<see langword="native int" />) 到目的地物件的位址 (型別<see langword="&amp;" />，<see langword="*" />或<see langword="native int" />)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|目的地物件，從來源物件類型值的複本。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  目的地物件參考推送至堆疊。  
  
2.  來源物件參考推送至堆疊。  
  
3.  從堆疊; 所推出的兩個物件參考實值型別在位址的來源物件會複製到目的地物件的位址。  
  
 行為`cpobj`未指定的來源和目的端物件的參考不是類別的語彙基元所代表的類別的執行個體的指標是否`classTok`(`typeref`或是`typedef`)，或如果`classTok`不代表實值型別。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`cpobj`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個值相除，並將結果做為浮點 (型別<see langword="F" />) 或商數 (類型<see langword="int32" />) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5B|div|兩個值相除並傳回商數或浮點結果。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`除以`value2`。  
  
4.  結果會推送至堆疊。  
  
 `result` = `value1` div value2 滿足以下條件：  
  
 &#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:  
  
 正負號 (`result`) = +，如果登入 (`value1`) = 號 (`value2`)，或-，如果登 (`value1`) ~ = 登 (`value2`)  
  
 `div`指令會計算結果，並將它推送到堆疊上。  
  
 整數除法運算會截斷推向零。  
  
 有限數字為零的除法中，會產生正確簽署的無限值。  
  
 除以零的零或無限大的無限值，便會產生 NaN （Not A-數字） 值。 任何數字除以無限大，會產生零值。  
  
 整數類資料的作業會擲回<xref:System.ArithmeticException>如果結果無法表示的結果型別中。 如果此情形`value1`的最大負數的值，和`value2`為-1。  
  
 整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。  
  
 請注意，在 Intel 平台上<xref:System.OverflowException>計算 (minint div-1) 時，會擲回。 浮點運算絕不會擲回例外狀況 （會產生 Nan 或無限大改為）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`div`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個不帶正負號的整數值相除，並將結果 (<see langword="int32" />) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5C|div.un|兩個值相除，不帶正負號，並傳回商數。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`除以`value2`。  
  
4.  結果會推送至堆疊。  
  
 `div.un`指示計算`value1`除以`value2`，同時將其視為不帶正負號的整數和推播`result`堆疊上。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`div.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複製評估堆疊上目前最頂端的值，然後將複製推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|25|dup|重複的堆疊頂端的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 是從重複資料刪除的堆疊取出。  
  
3.  `value` 是回推至堆疊。  
  
4.  重複的值會推入至堆疊。  
  
 `dup`指令重複項目堆疊中的最上層的項目，並將留在它之上的兩個相同的值。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`dup`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將控制權從<see langword="filter" />子句傳回 Common Language Infrastructure (CLI) 例外狀況處理常式的例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|結束 SEH 例外狀況處理的篩選子句。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 會從堆疊; 推出`endfilter`執行時，控制權會轉移到例外狀況處理常式。  
  
 `Value` (這必須是型別`int32`的一組特定值的其中一個) 會傳回篩選子句。 它應該是其中之一：  
  
-   `exception_continue_search` (`value` = 0) 繼續搜尋例外狀況處理常式  
  
-   `exception_execute_handler` (`value` = 1) 啟動第二個階段，就是最後區塊會執行直到與這個篩選條件子句的處理常式相關聯的例外狀況處理的所在。 發現時，會執行處理常式。  
  
 其他的整數值會產生未指定的結果。  
  
 使用的篩選器的進入點方法的例外狀況資料表中所示必須是在篩選條件的程式碼區塊的第一個指令。 `endfilter`指令必須是最後一個指令，篩選條件的程式碼區塊中 (因此只能有一個`endfilter`針對單一篩選條件的所有區塊)。 在執行後`endfilter`指令，控制以邏輯方式流動回到 CLI 例外狀況處理機制。  
  
 控制項無法傳輸到篩選區塊以外，透過例外狀況機制。 控制項無法傳出使用篩選區塊以外`throw`指示或藉由執行最終`endfilter`指令。 您無法內嵌`try`區塊`filter`區塊。 如果在擲回例外狀況`filter`區塊中，遭到攔截和值為 0 (`exception_continue_search`) 會傳回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`endfilter`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將控制權從<see langword="fault" />或<see langword="finally" />回到 Common Language Infrastructure (CLI) 例外狀況處理常式的例外狀況區塊的子句。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|結束`finally`或`fault`例外狀況區塊的子句。|  
  
 這個指示的轉換行為有任何堆疊。  
  
 `Endfinally` 並`endfault`表示結束`finally`或`fault`子句，該堆疊回溯可以繼續，直到例外狀況處理常式會叫用。 `endfinally`或`endfault`指令會將控制權傳輸至 CLI 例外狀況機制。 [機制] 和 [下一步] 會搜尋`finally`如果受保護的區塊已結束與 leave 鏈結中的子句。 如果受保護的區塊已結束並發生例外狀況，CLI 會搜尋在接下來`finally`或`fault`，或輸入例外狀況處理的第一個階段期間所選擇的例外狀況處理常式。  
  
 `endfinally`指示可能只會顯示語彙內`finally`區塊。 不同於`endfilter`的指示，在區塊結尾不需要`endfinally`的指示，而且可以有多個`endfinally`所需區塊中的指示。 這些相同的限制適用於`endfault`指令和`fault`區塊。  
  
 控制項無法傳輸到`finally`(或`fault`) 除了封鎖透過例外狀況機制。 控制項無法轉移共`finally`(或`fault`) 除了封鎖使用`throw`指示或執行`endfinally`(或`endfault`) 指令。 特別的是，您無法 「 切換 」 的`finally`(或`fault`) 區塊，或執行<xref:System.Reflection.Emit.OpCodes.Ret>或是<xref:System.Reflection.Emit.OpCodes.Leave>內的指令`finally`(或`fault`) 區塊。  
  
 請注意，`endfault`和`endfinally`指示別名-它們對應至相同的 opcode。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可用`endfinally`(`endfault`) 作業碼，以及`ILGenerator`方法<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>。  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將指定位址上的指定記憶體區塊初始化為指定的大小和初始值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 18|initblk|設定每個位置中的指定值的記憶體區塊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  起始位址會推送至堆疊。  
  
2.  初始化值會推入至堆疊。  
  
3.  要初始化的位元組數目會推送至堆疊。  
  
4.  位元組，初始化值的起始位址的數目會從堆疊彈出，並根據其值會執行初始化。  
  
 `initblk`指令會設定數字 (`unsigned int32`) 的指定位址開頭的位元組 (型別的`native int`， `&`，或`*`) 來初始化值 (類型的`unsigned int8`)。 `initblk` 假設的起始位址的對齊自然機器的大小。  
  
 營運`initblk`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`initblk`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定位址之值類型的各個欄位，初始化為適當之基本類型的 null 參考或 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|初始化實值型別。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  實值型別，初始化的地址推送至堆疊。  
  
2.  位址會從堆疊; 推出實值型別，在指定的位址會初始化為型別`typeTok`。  
  
 `initobj`指令會初始化推入位址所指定之值型別的每個欄位 (型別的`native int`， `&`，或`*`) 為 null 參考或 0，以適當的基本類型。 會呼叫這個方法之後，就有一個執行個體可供要呼叫的建構函式方法。 如果`typeTok`是參考型別，這個指令會有相同的效果`ldnull`後面`stind.ref`。  
  
 不同於<xref:System.Reflection.Emit.OpCodes.Newobj>，`initobj`不會呼叫建構函式方法。 `Initobj` 是要用於初始化實值型別，而`newobj`用來配置並初始化物件。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`initobj`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>測試是否有物件參考 (型別<see langword="O" />) 是特定類別的執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|測試的執行個體的物件參考是否`class`、 傳回 null 參考或該類別的執行個體，或介面。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考推送至堆疊。  
  
2.  物件參考是從堆疊推出，並測試以查看它是否傳入類別的執行個體`class`。  
  
3.  將結果 （物件參考或 null 參考） 推送至堆疊。  
  
 `Class` 這中繼資料語彙基元，表示所需的類別。 堆疊頂端的物件類別會實作`class`(如果`class`是一種介面) 的衍生的類別是否`class`(如果`class`是規則的類別) 則將它轉換成輸入`class`和結果推入堆疊，完全如同<xref:System.Reflection.Emit.OpCodes.Castclass>呼叫。 否則為 null 參考為推送到堆疊上。 如果物件參考本身是 null 參考，則`isinst`同樣的則傳回 null 參考。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`isinst`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>結束目前方法，並跳至指定的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|結束目前的方法，並跳至指定的方法。|  
  
 這個指示的轉換行為有任何堆疊。  
  
 `jmp` （跳躍） 指示將控制權傳輸至指定的方法`method`，這是方法參考的中繼資料語彙基元。 目前的引數會傳輸至目標方法。  
  
 執行此指令時，必須是空評估堆疊。 呼叫慣例、 類型與數量的引數，在目的地位址必須符合目前的方法。  
  
 `jmp`指令不能用來傳輸控制項，共`try`， `filter`， `catch`，或`finally`區塊。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`jmp`opcode:  
  
-   ILGenerator.Emit （OpCode、 MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入引數 (為指定的索引值所參考) 至堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|載入位於引數`index`至堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  在引數值`index`推送至堆疊。  
  
 `ldarg`指令會在索引的引數推入`index`，其中引數則是從 0 開始，至評估堆疊。 `ldarg`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。 引數，目前的方法簽章所指定的型別相同的引數值的類型。  
  
 程序，使用可變長度引數清單，如`ldarg`指示可以僅用於初始的固定引數，不是這些簽章的變動部分 (請參閱<xref:System.Reflection.Emit.OpCodes.Arglist>指令，如需詳細資訊)。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg`opcode:  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 0 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|02|ldarg.0|載入至堆疊的引數 0|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 0 的引數值推入至堆疊。  
  
 `ldarg.0`指令都是有效的編碼方式，來載入位於索引 0 的引數值。  
  
 `ldarg.0`指令會推入至評估堆疊的 0 編製索引的引數。 `ldarg.0`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。 引數，目前的方法簽章所指定的型別相同的引數值的類型。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.0`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 1 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|03|ldarg.1|載入至堆疊的引數 1。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 1 的引數值推入至堆疊。  
  
 `ldarg.1`指令都是有效的編碼方式，來載入位於索引 1 的引數值。  
  
 `ldarg.1`指令會推入至評估堆疊的 1 編製索引的引數。 `ldarg.1`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。 引數，目前的方法簽章所指定的型別相同的引數值的類型。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 2 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|04|ldarg.2|載入至堆疊的引數 2。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 2 的引數值推入至堆疊。  
  
 `ldarg.2`指令都是有效的編碼方式，來載入位於索引 2 的引數值。  
  
 `ldarg.2`指令會推入至評估堆疊的 2 編製索引的引數。 `ldarg.2`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。 引數，目前的方法簽章所指定的型別相同的引數值的類型。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於索引 3 的引數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|05|ldarg.3|載入至堆疊的引數 3。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 3 的引數值推入至堆疊。  
  
 `ldarg.3`指令都是有效的編碼方式，來載入位於索引 3 的引數值。  
  
 `ldarg.3`指令會推入至評估堆疊的 3 編製索引的引數。 `ldarg.3`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。 引數，目前的方法簽章所指定的型別相同的引數值的類型。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.3`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入引數 (為指定的簡短形式索引所參考) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|載入位於引數`index`至堆疊，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  在引數值`index`推送至堆疊。  
  
 `ldarg.s`指令都是有效的編碼方式為載入引數從 4 到 255 的編製索引。  
  
 `ldarg.s`指令會在索引的引數推入`index`，其中引數則是從 0 開始，至評估堆疊。 `ldarg.s`指令可以用來載入藉由複製從傳入的引數的實值類型或基本值至堆疊。 引數，目前的方法簽章所指定的型別相同的引數值的類型。  
  
 程序，使用可變長度引數清單，如`ldarg.s`指示可以僅用於初始的固定引數，不是這些簽章的變動部分 (請參閱<xref:System.Reflection.Emit.OpCodes.Arglist>指令，如需詳細資訊)。  
  
 存放小於 4 個位元組的整數值的引數會展開以輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarg.s`opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入引數位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|擷取由編製索引的引數位址`index`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  地址`addr`編製索引的引數的`index`推送至堆疊。  
  
 `ldarga`指令會擷取位址 (型別的`*`) 以編製索引的引數的`index`，其中的引數則是從 0 開始。 位址`addr`一律會在目標電腦上的自然界限對齊。  
  
 如需使用可變長度引數清單的程序`ldarga`指示可以僅用於初始的固定引數不簽章的變動部分中的那些。  
  
 `ldarga` 用於依 ref 參數傳遞。 其他情況下，如<xref:System.Reflection.Emit.OpCodes.Ldarg>和<xref:System.Reflection.Emit.OpCodes.Starg>應該使用。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarga`opcode:  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以簡短形式，載入引數位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|擷取由編製索引的引數位址`index`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  地址`addr`編製索引的引數的`index`推送至堆疊。  
  
 `ldarga.s` (簡短形式`ldarga`) 應該使用引數的數字 0 到 255，而且是更有效率的編碼方式。  
  
 `ldarga.s`指令會擷取位址 (型別的`*`) 以編製索引的引數的`index`，其中的引數則是從 0 開始。 位址`addr`一律會在目標電腦上的自然界限對齊。  
  
 如需使用可變長度引數清單的程序`ldarga.s`指示可以僅用於初始的固定引數不簽章的變動部分中的那些。  
  
 `ldarga.s` 用於依 ref 參數傳遞。 其他情況下，如<xref:System.Reflection.Emit.OpCodes.Ldarg_S>和<xref:System.Reflection.Emit.OpCodes.Starg_S>應該使用。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldarga.s`opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送提供的值型別的<see langword="int32" />至評估堆疊做為<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|將值推入`num`至堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值`num`推送至堆疊。  
  
 請注意，有特殊的簡短 （並因此會更有效率） 編碼的整數-128 到 127，以及特別是簡短的編碼方式，-1 到 8。 所有較短的編碼會推入堆疊的 4 位元組整數。 較長的編碼會用於 8 位元組整數和 4 和 8 位元組浮點數，以及無法放入簡短形式的 4 位元組值。 有三種方式可推送至堆疊的 8 位元組整數常數  
  
 1. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I8>指示必須以多個 32 位元的常數。  
  
 2. 使用<xref:System.Reflection.Emit.OpCodes.Ldc_I4>後面的指示<xref:System.Reflection.Emit.OpCodes.Conv_I8>需要 9 到 32 位元的常數。  
  
 3. 使用簡短形式指令，後面跟著<xref:System.Reflection.Emit.OpCodes.Conv_I8>可以表示小於或等於 8 位元數的常數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4`opcode:  
  
-   ILGenerator.Emit (OpCode，int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送至評估堆疊做為 0 的整數值<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|推送至堆疊的 0。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值 0 推入至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.0`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 1 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|推送至堆疊的 1。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值 1 會推送至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 2 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|推送至堆疊的 2。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值 2 推送至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 3 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|推送至堆疊的 3。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  3 這個值會推入堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.3`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 4 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|推送至堆疊的 4。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  4 這個值會推入堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 5 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|推送至堆疊的 5。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值為 5 會推送至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.5`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 6 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|推送至堆疊的 6。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  將值 6 推送至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.6`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 7 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|推送至堆疊的 7。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值 7 會推送至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.7`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 8 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|將 8 推入至堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值為 8 推送至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 -1 以 <see langword="int32" /> 推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|推送至堆疊的-1。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值-1 會推送至堆疊。  
  
 這是特殊短的編碼方式的整數值 0 推播。 所有特殊較短的編碼會推入堆疊的 4 位元組整數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.m1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送提供<see langword="int8" />值至評估堆疊做為<see langword="int32" />，簡短形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|推播`num`至堆疊`int32`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值`num`推送至堆疊。  
  
 `ldc.i4.s` 是以更有效率的編碼方式，就將整數介於-128 的資料到 127 推送至評估堆疊。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i4.s`opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送提供的值型別的<see langword="int64" />至評估堆疊做為<see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|推播`num`至堆疊`int64`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值`num`推送至堆疊。  
  
 這種編碼方式將推入`int64`值至堆疊。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.i8`opcode:  
  
-   ILGenerator.Emit (OpCode，long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送提供的值型別的<see langword="float32" />至評估堆疊做為類型<see langword="F" />（浮點數）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|推播`num`至堆疊`F`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值`num`推送至堆疊。  
  
 這種編碼方式將推入`float32`值至堆疊。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.r4`opcode:  
  
-   ILGenerator.Emit (OpCode 單一)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送提供的值型別的<see langword="float64" />至評估堆疊做為類型<see langword="F" />（浮點數）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|推播`num`至堆疊`F`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  值`num`推送至堆疊。  
  
 這種編碼方式將推入`float64`值至堆疊。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldc.r8`opcode:  
  
-   ILGenerator.Emit (OpCode，double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於指定之陣列索引處的項目當做指令中指定的類型載入至評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|載入處的項目`index`類型堆疊的頂端`typeTok`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示型別的值`O`。  
  
 傳回值的型別由權杖`typeTok`指令中。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於上限`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="native int" />位於評估堆疊頂端指定的陣列索引處<see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|97|ldelem.i|載入項目類型`native int`位於`index`堆疊的頂端`native int`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.i`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i`是`native int`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="int8" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|載入項目類型`int8`位於`index`堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.i1`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i1`是`int8`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="int16" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|載入項目類型`int16`位於`index`堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.i2`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i2`是`int16`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="int32" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|載入項目類型`int32`位於`index`堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.i4`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i4`是`int32`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="int64" />位於評估堆疊頂端指定的陣列索引處<see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|載入項目類型`int64`位於`index`堆疊的頂端`int64`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.i8`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.i8`是`int64`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.i8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="float32" />指定的陣列索引至類型評估堆疊的頂端<see langword="F" />（浮點數）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|載入項目類型`float32`位於`index`做為類型堆疊的頂端`F`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.r4`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.r4`是`float32`。  
  
 浮點數的值會轉換成輸入`F`時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.r4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="float64" />指定的陣列索引至類型評估堆疊的頂端<see langword="F" />（浮點數）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|載入項目類型`float64`位於`index`類型堆疊的頂端`F`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.r8`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.r8`是`float64`。  
  
 浮點數的值會轉換成輸入`F`時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.r8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入包含位於評估堆疊頂端做為類型指定的陣列索引處的物件參考的項目<see langword="O" />（物件參考）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|載入位於的物件參考的項目`index`類型堆疊的頂端`O`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.ref`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.ref`是型別`O`（物件參考）。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.ref`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="unsigned int8" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|載入項目類型`unsigned int8`位於`index`堆疊的頂端`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.u1`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.u1`是`int8`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.u1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="unsigned int16" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|載入項目類型`unsigned int16`堆疊的頂端的索引處`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.u2`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.u2`是`int16`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.u2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入項目類型<see langword="unsigned int32" />位於評估堆疊頂端指定的陣列索引處<see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|載入項目類型`unsigned int32`堆疊的頂端的索引處`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出位置處儲存的值`index`在`array`查閱。  
  
4.  的值會推入至堆疊。  
  
 `ldelem.u4`指令會載入具有索引的項目值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。  
  
 傳回值`ldelem.u4`是`int32`。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果陣列不會保留項目所需型別，會擲回。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelem.u4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入至評估堆疊做為類型的頂端，指定的陣列索引處的陣列元素的位址<see langword="&amp;" />（managed 的指標）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|在陣列元素的位址載入`index`的型別評估堆疊頂端`&`（managed 的指標）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`array`推送至堆疊。  
  
2.  索引值`index`推送至堆疊。  
  
3.  `index` 並`array`會從堆疊; 推出儲存位置的位址`index`在`array`查閱。  
  
4.  地址推送至堆疊。  
  
 `ldelema`用來擷取物件的陣列中特定索引處的物件的位址 (型別`class`)。 `ldelema`指令載入位址的索引處的值`index`(型別`native int`) 中以零為起始的一維陣列`array`並將它放在堆疊的頂端。 陣列也是物件，表示類型的值由`O`。 值必須是型別`class`傳遞與指示。  
  
 傳回值`ldelema`是 managed 的指標 (型別`&`)。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldelema`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尋找物件中的欄位值，該值的參考目前位於評估堆疊中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|推入指定的物件至堆疊中的欄位值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考 （或指標） 推送至堆疊。  
  
2.  物件參考 （或指標） 會從堆疊; 中推出找到的物件中指定的欄位值。  
  
3.  在欄位中儲存的值推入至堆疊。  
  
 `ldfld`指令會推入至堆疊的物件中欄位的值。 物件必須位於堆疊的物件參考 (型別`O`)，managed 的指標 (型別`&`) 的 unmanaged 的指標 (型別`native int`)，暫時性指標 (型別`*`)，或實值類型的執行個體。 可驗證的程式碼中不允許使用的 unmanaged 指標。 指定物件的欄位的欄位成員必須參考中繼資料語彙基元。 傳回的型別是與欄位關聯的一個相同。 欄位可能是 （在此情況下的物件不得為 null 參考） 的執行個體欄位或靜態欄位。  
  
 `ldfld`指令可以加上一個或兩個<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 <xref:System.NullReferenceException> 如果物件是 null，且該欄位不是靜態，會擲回。  
  
 <xref:System.MissingFieldException> 如果在中繼資料中找不到指定的欄位，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldfld`opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尋找物件中的欄位位址，該位址的參考目前位於評估堆疊中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|推入的位址`field`中指定的物件至堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考 （或指標） 推送至堆疊。  
  
2.  物件參考 （或指標） 會從堆疊; 中推出找到的物件中的指定欄位的位址。  
  
3.  指定欄位的位址推送至堆疊。  
  
 `ldflda`指令會推入至堆疊的物件中欄位的位址。 物件必須位於堆疊的物件參考 (型別`O`)，managed 的指標 (型別`&`) 的 unmanaged 的指標 (型別`native int`)，暫時性指標 (型別`*`)，或實值類型的執行個體。 可驗證的程式碼中不允許使用的 unmanaged 指標。 指定物件的欄位的欄位成員必須參考中繼資料語彙基元。  
  
 所傳回的值`ldflda`是 managed 的指標 (型別`&`) 除非物件已推送至堆疊的 unmanaged 指標，在此情況下傳回地址還有的 unmanaged 的指標 (型別`native int`)。  
  
 `ldflda`指令可以加上一個或兩個<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 <xref:System.InvalidOperationException> 如果物件不是從中進行存取的應用程式定義域中，會擲回。 無法載入存取的應用程式定義域內不是欄位的位址。  
  
 <xref:System.NullReferenceException> 如果物件是 null，且該欄位不是靜態，會擲回。  
  
 <xref:System.MissingFieldException> 如果在中繼資料中找不到指定的欄位，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldflda`opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送的 unmanaged 的指標 (型別<see langword="native int" />) 來實作特定方法至評估堆疊的原生程式碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|instrukce `method`|將指標所參考的方法推入`method`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  特定方法的 unmanaged 的指標會推送至堆疊。  
  
 特定的方法 (`method`) 可以用來呼叫<xref:System.Reflection.Emit.OpCodes.Calli>看它所參考的 managed 的方法 （或從 managed 轉換到 unmanaged 程式碼 stub） 的指示。  
  
 使用 CLR 的呼叫慣例的原生程式碼點傳回的值。 這個方法的指標不應該傳遞至未受管理的原生程式碼中，但會做為回呼常式。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldftn`opcode:  
  
-   ILGenerator.Emit （OpCode、 MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="native int" />做為<see langword="native int" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4D|ldind.i|載入`native int`位址的值`addr`至堆疊`native int`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.i`間接載入指令`native int`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`native int`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="int8" />做為<see langword="int32" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|46|ldind.i1|載入`int8`位址的值`addr`至堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。 
  
 `ldind.i1`間接載入指令`int8`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`int32`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="int16" />做為<see langword="int32" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|48|ldind.i2|載入`int16`位址的值`addr`至堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.i2`間接載入指令`int16`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`int32`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="int32" />做為<see langword="int32" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|載入`int32`位址的值`addr`至堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.i4`間接載入指令`int32`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`int32`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="int64" />做為<see langword="int64" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|載入`int64`位址的值`addr`至堆疊`int64`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.i8`間接載入指令`int64`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`int64`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.i8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="float32" />做為類型<see langword="F" />（浮點數） 至評估堆疊間接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|載入`float32`位址的值`addr`至堆疊做為型別`F`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.r4`間接載入指令`float32`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊做為型別`F`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.r4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="float64" />做為類型<see langword="F" />（浮點數） 至評估堆疊間接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|載入`float64`位址的值`addr`至堆疊做為型別`F`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.r8`間接載入指令`float64`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`float64`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.r8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入物件參考做為型別<see langword="O" />（物件參考） 至評估堆疊間接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|50|ldind.ref|載入位址的物件參考`addr`至堆疊做為型別 `O`|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的物件參考。  
  
3.  擷取的參考會推送至堆疊。  
  
 `ldind.ref`間接載入指令的物件參考指定的位址 (型別的`native int`， `&`，或 *) 至堆疊類型`O`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.ref`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="unsigned int8" />做為<see langword="int32" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|47|ldind.u1|載入`unsigned int8`位址的值`addr`至堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.u1`間接載入指令`unsigned int8`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`int32`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.u1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="unsigned int16" />做為<see langword="int32" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|49|ldind.u2|載入`unsigned int16`位址的值`addr`至堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.u2`間接載入指令`unsigned int16`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`int32`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.u2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入型別的值<see langword="unsigned int32" />做為<see langword="int32" />間接至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|載入`unsigned int32`位址的值`addr`至堆疊`int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  位址會從堆疊; 推出擷取位於位址的值。  
  
3.  將擷取的值推入至堆疊。  
  
 `ldind.u4`間接載入指令`unsigned int32`值，從指定的位址 (型別的`native int`， `&`，或 *) 至堆疊`int32`。  
  
 所有`ldind`的快速鍵指示<xref:System.Reflection.Emit.OpCodes.Ldobj>指定相對應的內建實值類別的指示。  
  
 請注意少於 4 個位元組的整數值已擴充來`int32`(不`native int`) 時載入至評估堆疊。 浮點數的值會轉換成`F`輸入時載入至評估堆疊。  
  
 正確 Microsoft Intermediate Language (MSIL) 可確保`ldind`指示用於指標的類型與一致的方式。  
  
 一開始推送至堆疊的位址必須對齊的正常大小的電腦上的物件或<xref:System.NullReferenceException>可能會發生 (請參閱<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞的預防措施指示)。 所有傳回位址的 MSIL 指令的結果 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 安全地對齊。 對於大於 1 個位元組的資料類型，位元組順序。 相依於目標 CPU 取決於位元組順序的程式碼可能無法執行所有平台上。  
  
 <xref:System.NullReferenceException> 可能會擲回，如果偵測到無效的位址。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldind.u4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送以零為起始的一維陣列的項目數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8E|ldlen|推播長度 (型別`natural unsigned int`) 的堆疊上的陣列。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列的物件參考推送至堆疊。  
  
2.  陣列參考從堆疊推出，並計算長度。  
  
3.  長度會推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 將會傳回長度為`natural unsigned int`。  
  
 <xref:System.NullReferenceException> 如果陣列參考為 null 參考，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldlen`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|載入位於索引的區域變數`index`至堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  指定索引處的區域變數值推送至堆疊。  
  
 `ldloc`指令會推入內容的本機變數數目在傳遞的索引至評估堆疊，區域變數所在及更新版本編號為 0。 本機變數會初始化旗標，方法是，則為 true 時，才進入方法之前初始化為 0。 有 65,535 (2 ^16-1） 本機變數可能 (0-65534)。 索引 65,535 無效，因為可能的實作會使用 2 位元組的整數，來追蹤這兩個區域的索引，以及指定方法的區域變數的總數。 如果 65535 的索引已經變成有效，它將需要更多的整數，用來追蹤這類方法中的區域變數的數目。  
  
 `ldloc.0`， `ldloc.1`， `ldloc.2`，和`ldloc.3`指示可讓您提供有效的編碼方式，來存取前四個區域變數。  
  
 方法標頭中指定的本機變數的類型相同之值的類型。 請參閱小於 4 個位元組會展開成輸入的資料分割 I.本機變數`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc`opcode:  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 0 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|06|ldloc.0|將位於索引 0 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 0 的區域變數值推送至堆疊。  
  
 `ldloc.0` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 0 的本機變數的存取。  
  
 方法標頭中指定的本機變數的類型相同之值的類型。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.0`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 1 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|07|ldloc.1|將位於索引 1 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 1 的區域變數值推送至堆疊。  
  
 `ldloc.1` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 1 的本機變數的存取。  
  
 方法標頭中指定的本機變數的類型相同之值的類型。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 2 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|08|ldloc.2|將位於索引 2 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 2 的區域變數值推送至堆疊。  
  
 `ldloc.2` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 2 的存取權的本機變數。  
  
 方法標頭中指定的本機變數的類型相同之值的類型。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將位於索引 3 的區域變數載入至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|09|ldloc.3|將位於索引 3 的區域變數載入至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位於索引 3 的區域變數值推送至堆疊。  
  
 `ldloc.3` 是有效的編碼方式，如<xref:System.Reflection.Emit.OpCodes.Ldloc>，讓位於索引 3 的存取權的本機變數。  
  
 方法標頭中指定的本機變數的類型相同之值的類型。 小於 4 個位元組長的本機變數會展開為輸入`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.3`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數至評估堆疊 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|載入位於索引的區域變數`index`至堆疊，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  指定索引處的區域變數值推送至堆疊。  
  
 `ldloc.s`指令會推入內容的本機變數數目在傳遞的索引至評估堆疊，區域變數所在及更新版本編號為 0。 如果初始化旗標，方法是，則為 true，進入方法之前，本機變數會初始化為 0。 有 256 (2 ^8) 中的區域變數可能 (0-255) 的簡短形式，這是以更有效率的編碼方式，就比`ldloc`。  
  
 方法標頭中指定的本機變數的類型相同之值的類型。 請參閱小於 4 個位元組會展開成輸入的資料分割 I.本機變數`int32`時載入至堆疊。 浮點數的值會展開成其原生的大小 (型別`F`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloc.s`opcode:  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|在本機變數的位址載入`index`至評估堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  儲存在位於指定索引的區域變數的位址推送至堆疊。  
  
 `ldloca`指令會推入本機變數的數字的位址傳遞的索引，到堆疊上，在本機變數所在及更新版本編號為 0。 推送到堆疊上的值已正確對齊使用類似的指示<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 結果是暫時性的指標 (型別`*`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloca`opcode:  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>載入位於指定索引的區域變數位址至評估堆疊 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|在本機變數的位址載入`index`至評估堆疊，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  儲存在位於指定索引的區域變數的位址推送至堆疊。  
  
 `ldloca.s`指令會推入本機變數的數字的位址傳遞的索引，到堆疊上，在本機變數所在及更新版本編號為 0。 推送到堆疊上的值已正確對齊使用類似的指示<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>。 結果是暫時性的指標 (型別`*`)。  
  
 `ldloca.s`指令可讓您提供有效的編碼方式，搭配本機變數 0 到 255 之間。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldloca.s`opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送 null 參考 (型別<see langword="O" />) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|14|ldnull|推送至堆疊的 null 參考|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  Null 物件參考推送至堆疊。  
  
 `ldnull` 推送 null 參考 (型別`O`) 堆疊上。 這用來初始化位置，它們會填入資料之前，或當它們變成已被取代。  
  
 `ldnull` 提供與大小無關的 null 參考。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldnull`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>複製位址所指向的實值類型物件到評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|複製實值型別執行個體`class`堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  實值型別物件的位址推送至堆疊。  
  
2.  位址從堆疊推出，並在該特定位址的執行個體則會查閱。  
  
3.  儲存在該位址之物件的值推入至堆疊。  
  
 `ldobj`指令用來做為參數傳遞實值類型。  
  
 `ldobj`指令會將複製所指向的值`addrOfValObj`(型別的`&`， `*`，或`native int`) 至堆疊的頂端。 複製的位元組數目取決於類別的大小 (依指定`class`參數)。 `class`參數是代表實值型別中繼資料語彙基元。  
  
 營運`ldobj`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到的 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldobj`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送靜態欄位的值至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|推播的值`field`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  特定欄位的值推入至堆疊。  
  
 `ldsfld`指令會推入靜態 （在類別的所有執行個體之間共用） 的值在堆疊上的欄位。 傳遞的中繼資料語彙基元相關聯的傳回型別是`field`。  
  
 `ldsfld`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldsfld`opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送靜態欄位的位址至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|推播的位址`field`堆疊上|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  特定欄位的位址推送至堆疊。  
  
 `ldsflda`指令會推入靜態 （在類別的所有執行個體之間共用） 的位址欄位在堆疊上。 位址可表示為暫時性指標 (型別`*`) 如果中繼資料語彙基元`field`參考型別，其記憶體進行管理。 否則，它會對應至的 unmanaged 指標 (型別`native int`)。 請注意，`field`可能是靜態全域具有相對虛擬位址 （其包含的 PE 檔案載入到記憶體的基底地址中的欄位位移） 的記憶體是未受管理的位置。  
  
 `ldsflda`指令可以有<xref:System.Reflection.Emit.OpCodes.Volatile>前置詞。  
  
 <xref:System.MissingFieldException> 如果在中繼資料中找不到欄位，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldsflda`opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送新的物件參考至儲存於中繼資料的字串常值 (String Literal)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|將中繼資料字串語彙基元的字串物件推入`mdToken`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  字串的物件參考推送至堆疊。  
  
 `ldstr`指令會推入的物件參考 (型別`O`) 至新的字串物件，表示特定字串常值儲存在中繼資料。 `ldstr`指令會配置必要的記憶體數量，並執行任何轉換的字串常值字串所需的格式在執行階段檔案中所使用的形式所需的格式轉換。  
  
 Common Language Infrastructure (CLI) 可確保兩個結果`ldstr`指示參考兩個具有相同的字元序列的中繼資料語彙基元傳回精確的相同字串物件 （稱為 「 字串暫留 」 的程序）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldstr`opcode:  
  
-   ILGenerator.Emit (OpCode 字串)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將中繼資料語彙基元轉換成它的執行階段表示，並將它推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|將中繼資料語彙基元轉換成它的執行階段表示。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  傳入的語彙基元轉換成`RuntimeHandle`並推送至堆疊。  
  
 `ldtoken`指示推播`RuntimeHandle`針對指定的中繼資料語彙基元。 A`RuntimeHandle`可以是`fieldref/fielddef`，則`methodref/methoddef`，或`typeref/typedef`。  
  
 推送到堆疊上的值可用於呼叫`Reflection`系統類別庫中的方法。  
  
 在執行階段控制代碼上的資訊，請參閱下列類別： <xref:System.RuntimeFieldHandle>， <xref:System.RuntimeTypeHandle>，和<xref:System.RuntimeMethodHandle>。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldtoken`opcode:  
  
-   ILGenerator.Emit （OpCode、 MethodInfo）  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送的 unmanaged 的指標 (型別<see langword="native int" />) 實作與指定的物件至評估堆疊相關聯的特定虛擬方法的原生程式碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|將滑鼠指標物件的虛擬方法推入`method`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考推送至堆疊。  
  
2.  物件參考會從堆疊和進入點位址推出方法 (指定中繼資料語彙基元`method`) 查閱。  
  
3.  將指標`method`推送至堆疊。  
  
 產生的 unmanaged 的指標推入堆疊所`ldvirtftn`指令可以用來呼叫<xref:System.Reflection.Emit.OpCodes.Calli>看它所參考的 managed 的方法 （或從 managed 轉換到 unmanaged 程式碼 stub） 的指示。  
  
 Unmanaged 的指標會指向使用 CLR 的呼叫慣例的原生程式碼。 這個方法的指標不應該傳遞至未受管理的原生程式碼中，但會做為回呼常式。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ldvirtftn`opcode:  
  
-   ILGenerator.Emit （OpCode、 MethodInfo）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>結束程式碼的保護區，無條件地將控制權傳輸至特定的目標指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DD < `int32` >|保留 `target`|結束程式碼的受保護的區域。|  
  
 不沒有指定這個指示任何堆疊轉換行為。  
  
 `leave`指令無條件地將控制權傳輸至特定目標的指示，以 4 位元組帶正負號的位移，從開頭緊跟在目前的指令。  
  
 `leave`指示大致`br`的指示，但它可以用來結束`try`， `filter`，或`catch`封鎖而一般的分支指令可以只能在這類區塊內的控制權轉移它。 `leave`指令會清空評估堆疊，並確保適當的周圍`finally`區塊會執行。  
  
 您無法使用`leave`結束指令`finally`區塊。 為了簡化程式碼產生作業是使用在 catch 區塊內有效的例外狀況處理常式`leave`指令，以便將控制權移轉給中相關聯的任何指令`try`區塊。  
  
 指令會有一或多個前置詞程式碼，如果控制項只傳送至第一個一個前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`leave`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>結束程式碼的保護區，無條件地將控制權傳輸至目標指令 (簡短形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|結束程式碼中，簡短形式的保護的區。|  
  
 不沒有指定這個指示任何堆疊轉換行為。  
  
 `leave.s`指令無條件地將控制權傳輸至傳遞的目標的指示，以 1 位元帶正負號的位移，從開頭緊跟在目前的指令。  
  
 `leave.s`指示大致`br`的指示，但它可以用來結束`try`， `filter`，或`catch`封鎖而一般的分支指令可以只能在這類區塊內的控制權轉移它。 `leave.s`指令會清空評估堆疊，並確保適當的周圍`finally`區塊會執行。  
  
 您無法使用`leave.s`結束指令`finally`區塊。 為了簡化程式碼產生作業是使用在 catch 區塊內有效的例外狀況處理常式`leave.s`指令，以便將控制權移轉給中相關聯的任何指令`try`區塊。  
  
 指令會有一或多個前置詞程式碼，如果控制項只傳送至第一個一個前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`leave.s`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從區域動態記憶體集區中配置某些數量的位元組，並將推送的位址 (暫時性指標，類型<see langword="*" />) 至評估堆疊的第一個配置的位元組。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|從本機堆積中配置空間。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  要配置的位元組數目會推送至堆疊。  
  
2.  從堆疊; 彈出的位元組數目，本機堆積中配置的大小所對應的記憶體數量。  
  
3.  配置的記憶體中的第一個位元組的指標會推送至堆疊。  
  
 `localloc`指令會配置`size`(型別`natural unsigned int`) 個位元組，從區域動態記憶體集區，並將位址傳回 (暫時性指標，類型`*`) 的第一個配置的位元組。 方法上的初始化旗標才會初始化為 0 的記憶體區塊傳回`true`。 當目前的方法執行<xref:System.Reflection.Emit.OpCodes.Ret>，本機記憶體集區將可重複使用。  
  
 產生的位址，讓任何基本資料型別可以儲存在該處使用對齊`stind`指示 (例如<xref:System.Reflection.Emit.OpCodes.Stind_I4>) 並載入使用`ldind`指示 (例如<xref:System.Reflection.Emit.OpCodes.Ldind_I4>)。  
  
 `localloc`指令不能出現在`filter`， `catch`， `finally`，或`fault`區塊。  
  
 <xref:System.StackOverflowException> 如果沒有記憶體不足，無法服務要求，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`localloc`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將特定類型的執行個體之類型參考推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|類型的類型的參考推送`class`至堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  指標的資料推送至堆疊。  
  
2.  指標是快顯，轉換成具類型的參考型別的`class`。  
  
3.  具類型的參考推送至堆疊。  
  
 `mkrefany`指示支援的動態類型的參考傳遞。 類型必須是指標`&`， `*`，或`native int`，並保留一段資料的有效位址。 `Class` 類別的語彙基元所描述指標所參考的資料的類型。 `Mkrefany` 在堆疊上，提供不透明的描述元的指標和類型的類型的參考推送`class`。  
  
 唯一有效的作業允許的型別參考時，就是將它傳遞至要求做為參數的型別的參考的方法。 被呼叫者接著可以使用<xref:System.Reflection.Emit.OpCodes.Refanytype>和<xref:System.Reflection.Emit.OpCodes.Refanyval>分別擷取的型別 （類別） 與位址的指示。  
  
 <xref:System.TypeLoadException> 如果擲回`class`找不到。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mkrefany`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個值相乘，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5A|mul|將在堆疊上的兩個值相乘。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`乘以`value2`。  
  
4.  結果會推送至堆疊。  
  
 `mul`指示乘以`value1`由`value2`並將結果推至堆疊上。 整數運算溢位截斷發生溢位較高的位元。  
  
 請參閱<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>整數特定乘法運算溢位處理的作業。  
  
 浮點類型，0 * 無限大 = NaN。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mul`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個整數值相乘、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|將具有溢位檢查的堆疊上的兩個整數值相乘。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`乘以`value2`，具有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 `mul.ovf`指示乘以整數`value1`整數`value2`並將結果推至堆疊上。 如果結果無法納入結果類型，則會擲回例外狀況。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mul.ovf`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個不帶正負號的整數值相乘、執行溢位檢查，再將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|將具有溢位檢查的堆疊上的兩個不帶正負號的值相乘。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value1`乘以`value2`，具有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 `mul.ovf.un`指示乘以不帶正負號的整數`value1`不帶正負號的整數`value2`並將結果推至堆疊上。 如果結果無法納入結果類型，則會擲回例外狀況。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`mul.ovf.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將值變成相反值，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|65|neg|目前在堆疊頂端值的否定運算。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  的值會推入至堆疊。  
  
2.  值是從堆疊推出，否定。  
  
3.  結果會推送至堆疊。  
  
 `neg`指令執行值的否定運算，並將結果的堆疊的頂端。 傳回類型是運算元類型相同。  
  
 整數值的否定是標準二補數否定。 特別是，否定最大負數的數字 （但不需要正的對應項目） 會產生最大負數的數字。 若要偵測此溢位，請使用<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>指令改為 （也就是減去 0）。  
  
 將浮點數值不能溢位，並取消 NaN 會傳回 NaN。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`neg`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將新的以零為起始一維陣列 (其項目屬於特定類型) 的物件參考推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|建立新的陣列類型的項目`etype`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列中的項目數會推送至堆疊。  
  
2.  項目數會從堆疊推出，並在建立陣列。  
  
3.  新陣列的物件參考推送至堆疊。  
  
 `newarr`指令會推入的物件參考 (型別`O`) 以其元素為型別的新之以零起始的一維陣列`etype`（中繼資料語彙基元來描述型別）。 新陣列中的項目數應指定為`native int`。 陣列的有效索引範圍從零到最大項目數減一。  
  
 陣列的項目可以是任何類型，包括實值型別。  
  
 會使用參考適當的值類型的中繼資料語彙基元 」 來建立 「 數字的以零為起始的一維陣列 (<xref:System.Int32>等等)。 陣列的元素會初始化為 0 或適當的型別。  
  
 Nonzero-基礎的一維陣列和多維度陣列使用建立<xref:System.Reflection.Emit.OpCodes.Newobj>而非`newarr`。 通常，在建立使用的方法<xref:System.Array>.NET Framework 中的類別。  
  
 <xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。  
  
 <xref:System.OverflowException> 如果擲回`numElems`小於 0。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`newarr`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>建立新的物件或實值類型，將物件參考的新執行個體 (型別<see langword="O" />) 至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|配置未初始化的物件或實值類型，並呼叫建構函式方法`ctor`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  引數`arg1`透過`argn`序列中推送到堆疊上。  
  
2.  引數`argn`經由`arg1`會從堆疊推出，並傳遞至`ctor`建立物件。  
  
3.  新的物件參考推送至堆疊。  
  
 `newobj`指示會建立新的物件或實值類型的新執行個體。 `Ctor` 為中繼資料語彙基元 (`methodref`或`methoddef`，必須標示為建構函式)，表示名稱、 類別和建構函式呼叫的簽章。  
  
 `newobj`指令會配置與相關聯類別的新執行個體`ctor`並初始化 0 （或適當的型別） 或 null 參考為適當的新執行個體中的所有欄位。 然後它會呼叫建構函式`ctor`與指定的引數，以及新建立的執行個體。 在呼叫建構函式之後，現在會初始化物件參考 (型別`O`) 推送到堆疊上。  
  
 從建構函式的觀點來看，未初始化的物件是引數 0，而其他引數傳遞至 newobj 順序。  
  
 使用建立所有的以零為起始的一維陣列<xref:System.Reflection.Emit.OpCodes.Newarr>，而非`newobj`。 相反地，所有其他陣列 （一個維度，或是一維但不是以零為起始） 會建立使用`newobj`。  
  
 實值型別不通常會建立使用`newobj`。 通常會配置做為引數或區域變數，使用`newarr`（適用於以零為起始的一維陣列），或做為欄位的物件。 配置之後，它們會初始化使用<xref:System.Reflection.Emit.OpCodes.Initobj>。 不過，`newobj`指令可以用來建立實值類型的新執行個體上的堆疊，然後當做引數，儲存在區域變數中等等。  
  
 <xref:System.OutOfMemoryException> 如果沒有記憶體不足，無法滿足要求，會擲回。  
  
 <xref:System.MissingMethodException> 如果建構函式方法會擲回`ctor`使用指定的名稱、 類別和簽章找不到。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`newobj`opcode:  
  
-   ILGenerator.Emit(OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果已完成修補作業碼，則填滿空間。 雖然會耗用處理循環，卻不會執行任何有意義的運算。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|00|nop|執行作業而不需要的行為。|  
  
 定義這個指示沒有堆疊轉換行為。  
  
 `nop`作業不執行任何動作。 它被用來填滿空間中，如果修補作業碼。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`nop`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算堆疊頂端的整數值的位元補數 (Complement)，並將結果當做相同類型來推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|66|not|計算值的位元補數。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value` 推送至堆疊。  
  
2.  `value` 會從堆疊和其位元推出計算的補數。  
  
3.  結果會推送至堆疊。  
  
 `not`指令會計算整數值的位元補數，並推送至堆疊的結果。 傳回類型是運算元類型相同。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`not`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算堆疊頂端兩個整數值的位元補數，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|60|或|計算位元，或兩個整數值，傳回一個整數。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊和其位元 OR 運算計算。  
  
4.  結果會推送至堆疊。  
  
 `or`指令會計算位於堆疊中，頂端的兩個值的位元 OR，推送到堆疊上的結果。  
  
 `Or` 是整數特定作業。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`or`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>目前在評估堆疊頂端移除值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|26|pop|從最高的值從堆疊中取出。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  最高的值是從堆疊取出。  
  
 `pop`指令從堆疊移除最上層的項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`pop`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>這是保留的指示。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定後續陣列位址作業在執行階段不執行任何類型檢查，且會傳回限制其變動性的 Managed 指標。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1E|readonly。|指定後續陣列位址作業會執行任何型別檢查，在執行階段，以及它與受限制的可變動性，傳回的 managed 的指標。|  
  
 此前置詞只能出現正前面`ldelema`指令和呼叫特殊`Address`陣列上的方法。 其會影響後續的作業有兩個：  
  
1.  在執行階段類型檢查會不執行任何作業。 請注意，正常的隱含型別檢查`ldelema`和`stelem`指示在參考上使用時輸入陣列。 都不會實值類別的執行階段類型檢查因此`readonly`在此情況下會執行任何作業。  
  
2.  驗證器視為的 managed 指標與受限制的可變動性的地址的作業結果。  
  
 指標則稱為已限制可變動性，因為定義的型別可讓您控制是否可以變更值。 公開 （expose） 沒有公用欄位或更新進行中的值的方法的實值類別，指標是唯讀的 (因此前置詞的名稱)。 特別的是，表示基本類型 (例如 System.Int32) 的類別不會公開 mutator，並因此處於唯讀狀態。  
  
 這種方式在受限制的 managed 的指標只能用於透過下列方式：  
  
-   作為`object`參數`ldfld`， `ldflda`， `stfld`， `call`，或`constrained callvirt`指示。  
  
-   作為`pointer`參數來`ldobj`指示或其中一個`ldind`指示。  
  
-   作為`source`參數來`cpobj`指令。  
  
 所有其他作業，包括`stobj`， `initobj`，或`mkrefany`作業，或任何`stind`指示。  
  
 目的`readonly`前置詞是以擷取從泛型程式碼中陣列的項目時，避免類型檢查。 例如，運算式`arr[i].m()`，其中的項目類型的陣列`arr`限定於都有一個介面以方法為泛型型別`m`，可能會編譯為下列的 MSIL。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 不含`readonly`前置詞，`ldelema`指令會執行類型檢查，萬一其中 ！ 0 是參考型別。 不只是這個型別檢查效率不佳，但語意不正確。 型別檢查`ldelema`完全相符，也就是太強式。 如果陣列類型的子類別 ！ 0，上述程式碼將會失敗類型檢查。  
  
 陣列元素的位址會擷取，而不是項目本身，才會有的控制代碼`arr[i]`適用於同時實值類型和參考型別，並因此可以傳遞至`constrained callvirt`指令。  
  
 一般情況下會略過執行階段檢查，如果陣列是參考類型的項目不安全。 為了安全起見，就必須確保對陣列進行任何修改都會經過這個指標。 驗證器規則，請確定這。 受限制的 managed 的指標可以傳遞做為物件的執行個體方法呼叫，因此它不是嚴格來說唯讀的實值型別，但是是實值型別沒有型別安全問題。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`readonly`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>擷取內嵌於類型參考中的類型語彙基元。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|將推送儲存在具類型的參考型別語彙基元。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  實值類型參考推送至堆疊。  
  
2.  具類型的參考會從堆疊推出，並擷取其對應的型別語彙基元。  
  
3.  型別語彙基元會推送至堆疊。  
  
 具類型的參考包含型別語彙基元和物件執行個體的位址。  
  
 `refanytype`指令擷取內嵌於型別參考中的型別語彙基元。 請參閱<xref:System.Reflection.Emit.OpCodes.Mkrefany>指令，如需建立資訊型別參考。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`refanytype`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>擷取位址 (型別<see langword="&amp;" />) 內嵌在具類型的參考。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|將推送儲存在具類型參考的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  實值類型參考推送至堆疊。  
  
2.  具類型的參考會從堆疊推出，擷取對應的位址。  
  
3.  地址推送至堆疊。  
  
 具類型的參考包含型別語彙基元和物件執行個體的位址。  
  
 `refanyval`指令會擷取內嵌於位址的型別的參考。 內嵌在堆疊上提供的型別參考的型別必須符合所指定的型別`type`(中繼資料語彙基元，請`typedef`或`typeref`)。 請參閱<xref:System.Reflection.Emit.OpCodes.Mkrefany>相關內容的指示。  
  
 <xref:System.InvalidCastException> 如果擲回`type`不等於儲存在型別參考的型別 (在此情況下，`type`類別提供給<xref:System.Reflection.Emit.OpCodes.Mkrefany>建構的指示所說的具類型的參考)。  
  
 <xref:System.TypeLoadException> 如果擲回`type`找不到。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`refanyval`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個值相除，並將餘數推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5D|rem|將餘數推送`value1`由`value2`至堆疊。|  
  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  A`value1`推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`與在堆疊的其餘部分會彈出`value1` `div` `value2`計算。  
  
4.  結果會推送至堆疊。  
  
 `result` = `value1` `rem` `value2` 符合下列條件：  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`)，以及：  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;，符號 (`result`) = 號 (`value1`)，其中`div`推向零會截斷除法指令。  
  
 如果`value2`為零或`value1`是的無限大的結果為 NaN。 如果`value2`是無限大，結果就是`value1`(否定的`-infinity`)。  
  
 整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。  
  
 請注意，在 Intel 平台上<xref:System.OverflowException>計算時，會擲回 (minint `rem` -1)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`rem`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將兩個不帶正負號的值相除，並將餘數推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|5E|rem.un|將餘數推送不帶正負號`value1`的不帶正負號`value2`至堆疊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 並`value1`與在堆疊的其餘部分會彈出`value1` `div` `value2`計算。  
  
4.  結果會推送至堆疊。  
  
 `result` = `value1` `rem.un` `value2` 符合下列條件：  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`)，以及：  
  
 0 = `result`  <  `value2`，其中`div.un`為不帶正負號的除法指令。  
  
 `rem.un`指示計算`result`並將其推送到堆疊上。 `Rem.un` 其引數視為不帶正負號的整數，而<xref:System.Reflection.Emit.OpCodes.Rem>將它們視為為帶正負號的整數。  
  
 `Rem.un` 未指定為浮點數值。  
  
 整數類資料的作業會擲回<xref:System.DivideByZeroException>如果`value2`為零。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`rem.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從目前方法傳回，將被呼叫端評估堆疊的傳回值 (如果有) 推送至呼叫端的評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|2A|ret|從方法傳回，可能傳回值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  傳回值會從被呼叫端評估堆疊推出。  
  
2.  步驟 1 中取得的傳回值會推入至呼叫端評估堆疊。  
  
 如果傳回的值不存在，被呼叫端評估堆疊上，會傳回任何值 （沒有被呼叫端或呼叫端的方法使用 stack 轉換將行為）。  
  
 類型的傳回值，如果有的話，目前的方法會決定從堆疊的頂端和複製到堆疊呼叫目前方法的方法中擷取值的型別。 評估堆疊目前的方法必須是空的除了要傳回的值。  
  
 `ret`指令不能用於 out 的控制權轉移`try`， `filter`， `catch`，或`finally`區塊。 內在`try`或`catch`，使用<xref:System.Reflection.Emit.OpCodes.Leave>指令，目的地為`ret`之外所有封入的例外狀況區塊的指示。 因為`filter`和`finally`區塊在邏輯上是例外狀況處理與不在其中內嵌程式碼方法的組件、 正確地產生的 Microsoft Intermediate Language (MSIL) 指示不會執行方法會傳回從`filter`或`finally`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`ret`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>重新擲回目前的例外狀況。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1A|重新擲回|會重新擲回目前例外狀況|  
  
 這個指示不定義任何堆疊轉換行為。  
  
 `rethrow`指示只允許的主體內`catch`處理常式。 它會擲回相同這個處理常式所攔截的例外狀況。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`rethrow`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值向左移 (使用零) 指定的位元數，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|62|shl|將左側 （移位零） 的整數。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  的值會推入至堆疊。  
  
2.  要移位的位元數量會推送至堆疊。  
  
3.  要移位的位元數和值會彈出從堆疊;值是向左移位指定的位元數。  
  
4.  結果會推送至堆疊。  
  
 `shl`指示移位值 (型別`int32`，`int64`或`native int`) 所指定的位元數留下。 位元數是類型的值`int32`或`native int`。 要移位的位元數字是否大於或等於所提供的值的寬度 （以位元為單位），會指定傳回的值。  
  
 `Shl` 在每個排班上最低的位置插入零值的位元。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`shl`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將整數值 (使用正負號) 向右移指定的位元數，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|63|shr|整數，會向右位移 （移位正負號）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  的值會推入至堆疊。  
  
2.  要移位的位元數量會推送至堆疊。  
  
3.  要移位的位元數和值會彈出從堆疊;值是向右移位指定的位元數。  
  
4.  結果會推送至堆疊。  
  
 `shr.un`指示移位值 (型別`int32`，`int64`或`native int`) 權限所指定的位元數。 位元數是類型的值`int32`或`native int`。 要移位的位元數字是否大於或等於所提供的值的寬度 （以位元為單位），會指定傳回的值。  
  
 `Shr` 複寫在每個排班，保留原始值的正負號位元的高序位`result`。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`shr`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將不帶正負號的整數值 (使用零) 向右移指定的位元數，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|64|shr.un|整數，會向右位移 （移位零）。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  的值會推入至堆疊。  
  
2.  要移位的位元數量會推送至堆疊。  
  
3.  要移位的位元數和值會彈出從堆疊;值是向右移位指定的位元數。  
  
4.  結果會推送至堆疊。  
  
 `shr.un`指示移位值 (型別`int32`，`int64`或`native int`) 權限所指定的位元數。 位元數是類型的值`int32`，`int64`或`native int`。 要移位的位元數字是否大於或等於所提供的值的寬度 （以位元為單位），會指定傳回的值。  
  
 `Shr.un` 將零位元插入每個排班的最高位置。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`shr.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將所提供實值類型的大小推送至評估堆疊 (以位元組為單位)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|推送大小，以位元組為單位為實值型別`unsigned int32`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  提供的值類型的大小 （以位元組為單位） (`valType`) 推送至堆疊。  
  
 `valType` 必須是中繼資料語彙基元 (`typeref`或`typedef`)，在指定實值型別、 參考類型或泛型類型參數。  
  
 對於參考類型，傳回的大小會是對應的參考值的大小類型 （32 位元系統上的 4 位元組），不是參考值所參考之物件中儲存之資料的大小。 泛型類型參數僅用於型別或其定義的方法主體中。 該類型或方法具現化時，由實值類型或參考類型取代泛型類型參數。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sizeof`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指定索引的引數槽中將值存放在評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|取出從堆疊頂端的值，並將它儲存在引數位置`num`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  取出目前堆疊頂端值，並放在引數位置`num`。  
  
 `starg`指令從堆疊取出值，並將它放在引數位置`num`。 值的類型必須符合目前的方法簽章中指定的引數的類型。  
  
 使用變數引數清單的程序`starg`指示可以僅用於初始的固定引數，不是這些簽章的變動部分。  
  
 執行成存放小於 4 個位元組的整數值的引數的存放區會截斷值，從堆疊移到引數。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`starg`opcode:  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指定索引 (簡短形式) 的引數位置中將值儲存於評估堆疊的頂端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|取出從堆疊頂端的值，並將它儲存在引數位置`num`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  取出目前堆疊頂端值，並放在引數位置`num`。  
  
 `starg.s`指令從堆疊取出值，並將它放在引數位置`num`。 值的類型必須符合目前的方法簽章中指定的引數的類型。  
  
 `starg.s`指令可讓您提供有效的編碼方式，與前 256 個引數搭配使用。  
  
 使用變數引數清單的程序`starg.s`指示可以僅用於初始的固定引數，不是這些簽章的變動部分。  
  
 執行成存放小於 4 個位元組的整數值的引數的存放區會截斷值，從堆疊移到引數。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`starg.s`opcode:  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>使用評估堆疊上的值 (其類型在指令中指定)，取代在指定之索引處的陣列項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|取代類型的值中提供的索引處的陣列項目`typeTok`堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  索引值時，`index`中的項目`array`推送至堆疊。  
  
3.  在指令中指定之型別的值推送至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem`指示取代的一維陣列中提供之以零起始的索引處的項目值`array`的值。 此值有語彙基元所指定的型別`typeTok`指令中。  
  
 陣列也是物件，表示型別的值`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取代具有指定索引處的陣列元素<see langword="native int" />評估堆疊上的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9B|stelem.i|在使用提供的索引陣列項目取代`native int`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.i`指令會取代項目的值`index`中的一維陣列`array`使用`native int`值推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取代具有指定索引處的陣列元素<see langword="int8" />評估堆疊上的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|在使用提供的索引陣列項目取代`int8`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.i1`指令會取代項目的值`index`中的一維陣列`array`使用`int8`值推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取代具有指定索引處的陣列元素<see langword="int16" />評估堆疊上的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|在使用提供的索引陣列項目取代`int16`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.i2`指令會取代項目的值`index`中的一維陣列`array`使用`int16`值推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取代具有指定索引處的陣列元素<see langword="int32" />評估堆疊上的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|在使用提供的索引陣列項目取代`int32`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.i4`指令會取代項目的值`index`中的一維陣列`array`使用`int32`值推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取代具有指定索引處的陣列元素<see langword="int64" />評估堆疊上的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|在使用提供的索引陣列項目取代`int64`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.i8`指令會取代項目的值`index`中的一維陣列`array`使用`int64`值推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.i8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取代具有指定索引處的陣列元素<see langword="float32" />評估堆疊上的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|在使用提供的索引陣列項目取代`float32`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.r4`指令會取代項目的值`index`中的一維陣列`array`使用`float32`值推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.r4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取代具有指定索引處的陣列元素<see langword="float64" />評估堆疊上的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|在使用提供的索引陣列項目取代`float64`堆疊上的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.r8`指令會取代項目的值`index`中的一維陣列`array`使用`float64`值推送至堆疊。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.r8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>陣列項目取代位於指定索引處的物件參考值 (類型<see langword="O" />) 評估堆疊上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|在使用提供的索引陣列項目取代`ref`值 (類型`O`) 堆疊上。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  陣列，物件參考`array`，推送到堆疊。  
  
2.  有效的索引中的項目`array`推送至堆疊。  
  
3.  的值會推入至堆疊。  
  
4.  值，索引，而陣列參考是從推出到堆疊;值會放入指定的索引處的陣列項目。  
  
 `stelem.ref`指示取代的一維陣列中提供的索引處的項目值`array`具有`ref`(型別`O`) 推送至堆疊的值。  
  
 陣列也是物件，表示類型的值由`O`。 索引是型別`native int`。  
  
 請注意，`stelem.ref`隱含轉換的項目型別所提供的值`array`指派值的陣列項目之前。 此轉換可能會失敗，即使針對已驗證的程式碼。 因此`stelem.ref`指令可以擲回<xref:System.InvalidCastException>。 多維陣列，以及不以零為起始的一維陣列<xref:System.Array>類別提供<xref:System.Array.SetValue%2A>方法。  
  
 <xref:System.NullReferenceException> 如果擲回`array`為 null 參考。  
  
 <xref:System.IndexOutOfRangeException> 如果擲回`index`是負數，或大於的繫結`array`。  
  
 <xref:System.ArrayTypeMismatchException> 如果擲回`array`未持有必要的型別項目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stelem.ref`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以新值取代儲存在物件參考或指標的欄位中的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|取代的值`field`具有新值的物件。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考或指標會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值，而且物件參考/指標會彈出從堆疊;值`field`在該物件會取代所提供的值。  
  
 `stfld`指示取代物件的欄位的值 (型別`O`) 或透過指標 (型別`native int`， `&`，或`*`) 具有給定值。 `Field` 是指欄位成員參考中繼資料語彙基元。 `stfld`指令可以有一個或兩個前置詞<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.NullReferenceException> 如果物件參考或指標為 null 參考，而欄位並非靜態，會擲回。  
  
 <xref:System.MissingFieldException> 如果擲回`field`中繼資料中找不到。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指令被轉換成原生程式碼，不在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stfld`opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>儲存值的型別<see langword="native int" />在所提供的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DF|stind.i|存放區`native int`值在指定的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.i`指示存放區`native int`值所提供的位址 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i`指示用於指標的類型與一致的方式。 營運`stind.i`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>儲存值的型別<see langword="int8" />在所提供的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|52|stind.i1|存放區`int8`值在指定的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.i1`指示存放區`int8`值所提供的位址 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i1`指示用於指標的類型與一致的方式。 營運`stind.i1`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>儲存值的型別<see langword="int16" />在所提供的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|53|stind.i2|存放區`int16`值在指定的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.i2`指示存放區`int16`值所提供的位址 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.2i`指示用於指標的類型與一致的方式。 營運`stind.i2`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>儲存值的型別<see langword="int32" />在所提供的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|54|stind.i4|存放區`int32`值在指定的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.i4`指示存放區`int32`值所提供的位址 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i4`指示用於指標的類型與一致的方式。 營運`stind.i4`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>儲存值的型別<see langword="int64" />在所提供的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|55|stind.i8|存放區`int64`值在指定的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.i8`指示存放區`int64`值所提供的位址 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.i8`指示用於指標的類型與一致的方式。 營運`stind.i`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.i8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>儲存值的型別<see langword="float32" />在所提供的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|56|stind.r4|存放區`float32`值在指定的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.r4`指示存放區`float32`值所提供的位址 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.r4`指示用於指標的類型與一致的方式。 營運`stind.r4`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.r4`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>儲存值的型別<see langword="float64" />在所提供的位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|57|stind.r8|存放區`float64`值在指定的位址。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.r8`指示存放區`float64`值所提供的位址 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.r8`指示用於指標的類型與一致的方式。 營運`stind.r8`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.r8`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的位址儲存物件參考值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|51|stind.ref|儲存物件參考 (型別`O`) 在指定位址的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  的值會推入至堆疊。  
  
3.  值和位址快顯從堆疊;值會儲存在位址中。  
  
 `stind.ref`指令會儲存在所提供位址的物件參考值 (型別`native int`， `*`，或`&`)。  
  
 類型安全的作業需要`stind.ref`指示用於指標的類型與一致的方式。 營運`stind.ref`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.NullReferenceException> 如果擲回`addr`不會自然對齊的指示後置詞所隱含的引數類型。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stind.ref`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在指定索引的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|從堆疊取出值，並將它儲存在區域變數中`index`。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  從堆疊取出值，並放在區域變數`index`。  
  
 `stloc`指令會取出評估堆疊頂端的值，並將它移至本機變數數目`index`，其中的本機變數是及更新版本編號為 0。 值的類型必須符合目前方法的本機簽章中指定本機變數的型別。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 正確的 Microsoft Intermediate Language (MSIL) 指示要求`index`是有效的本機索引。 針對`stloc`的指示，`index`必須介於範圍 0 到 65534 （含） （具體而言，65535 無效）。 65535 排除在外的原因是務實： 可能的實作會使用 2 位元組的整數，來追蹤區域的索引，以及指定方法的區域變數的總數。 如果 65535 的索引已經變成有效，它將需要更多的整數，用來追蹤這類方法中的區域變數的數目。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc`opcode:  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode，short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 0 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0A|stloc.0|從堆疊中的值為 0 的區域變數中取出。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  從堆疊取出值，並放在索引為 0 的本機變數。  
  
 `stloc.0`指令取出評估堆疊頂端的值，並將它移至索引為 0 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的型別。  
  
 `stloc.0` 是有效的編碼方式，將值儲存在本機變數 0。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.0`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 1 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0B|stloc.1|從值從堆疊取出到 1 的區域變數。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  從堆疊取出值，並放在索引 1 的區域變數。  
  
 `stloc.1`指令取出評估堆疊頂端的值，並將它移至索引 1 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的型別。  
  
 `stloc.1` 是有效的編碼方式，將值儲存在區域變數 1。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.1`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 2 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0C|stloc.2|顯示堆疊中的值放入本機變數 2|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  從堆疊取出值，並放在索引 2 的區域變數。  
  
 `stloc.2`指令取出評估堆疊頂端的值，並將它移至索引為 2 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的型別。  
  
 `stloc.2` 是有效的編碼方式，將值儲存在本機變數 2。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.2`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊的頂端取出目前值，並將它存放在索引 3 的區域變數清單中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|0D|stloc.3|從值從堆疊取出到 3 的區域變數|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  從堆疊取出值，並放在索引 3 的區域變數。  
  
 `stloc.3`指令取出評估堆疊頂端的值，並將它移至索引為 3 的區域變數。 值的類型必須符合目前方法的本機簽章中指定本機變數的型別。  
  
 `stloc.3` 是有效的編碼方式，將值儲存在區域變數 3。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.3`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取出目前值從評估堆疊的頂端，並將其儲存在本機變數清單，在<paramref name="index" />（簡短形式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|從堆疊取出值，並將它儲存在區域變數中`index`，簡短形式。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  從堆疊取出值，並放在區域變數`index`。  
  
 `stloc.s`指令會取出評估堆疊頂端的值，並將它移至本機變數數目`index`，其中的本機變數是及更新版本編號為 0。 值的類型必須符合目前方法的本機簽章中指定本機變數的型別。  
  
 `stloc.s`指令可讓您提供有效的編碼方式，區域變數的 0 到 255 之間。  
  
 儲存至存放小於 4 個位元組的整數值的區域變數會截斷值，從堆疊移動。 從原生大小的浮點數的值會捨入 (型別`F`) 相關聯的引數的大小。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stloc.s`opcode:  
  
-   ILGenerator.Emit(OpCode, LocalBuilder)  
  
-   ILGenerator.Emit(OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>從評估堆疊複製指定類型的值到所提供的記憶體位址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|儲存值的型別`class`從堆疊載入記憶體。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
2.  類型的值型別物件`class`推送至堆疊。  
  
3.  物件和位址快顯從堆疊;實值類型物件會儲存在位址中。  
  
 `stobj`指令會將實值類型物件複製到指定位址的位址 (類型的指標`native int`， `*`，或`&`)。 已複製的位元組數目取決於所表示之類別的大小`class`、 表示實值型別中繼資料語彙基元。  
  
 營運`stobj`可以改變指示錯誤的前<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前置詞指令。  
  
 <xref:System.TypeLoadException> 如果找不到類別，會擲回。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stobj`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以來自評估堆疊的值取代靜態欄位的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|80 < `T` >|這個前置 `field`|中的值取代`field`與提供的值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  的值會推入至堆疊。  
  
2.  從堆疊取出值，並儲存在`field`。  
  
 `stsfld`指令會從堆疊以值取代靜態欄位的值。 `field` 為靜態欄位成員必須參考中繼資料語彙基元。  
  
 `stsfld`可能會加上指令<xref:System.Reflection.Emit.OpCodes.Volatile>。  
  
 <xref:System.MissingFieldException> 如果在中繼資料中找不到欄位，會擲回。 這通常會檢查 Microsoft Intermediate Language (MSIL) 指示轉換成原生程式碼，不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`stsfld`opcode:  
  
-   ILGenerator.Emit(OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將另一個值減去某一個值，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|59|sub|一個值減去另一個，傳回新的數值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value2`會減去`value1`。  
  
4.  結果會推送至堆疊。  
  
 整數運算溢位都沒有偵測到 (處理適當的溢位，請參閱<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)。  
  
 整數減法包裝，而不是飽和。 例如： 假設 8 位元整數，其中`value1`設定為 0 和`value2`設為 1 時，「 包裝的 」 的結果會是 255。  
  
 傳回浮點溢位`+inf`(`PositiveInfinity`) 或`-inf`(`NegativeInfinity`)。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sub`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將另一個值減去某一個值、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|一個整數值減去另一個具有溢位檢查。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value2`會減去`value1`具有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 帶正負號的整數; 上執行這項作業浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sub.ovf`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將另一個不帶正負號的值減去某一個不帶正負號的值、執行溢位檢查，並將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|一個不帶正負號的整數值減去另一個具有溢位檢查。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊;`value2`會減去`value1`具有溢位檢查。  
  
4.  結果會推送至堆疊。  
  
 <xref:System.OverflowException> 如果結果無法表示的結果型別中，會擲回。  
  
 帶正負號的整數; 上執行這項作業浮點數的值，使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`sub.ovf.un`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>實作跳躍表格。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|切換 (`N`， `t1`， `t2`...`tN`)|跳至其中一個`N`值。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  的值會推入至堆疊。  
  
2.  值從堆疊取出並將執行轉移至編製索引的值，位移指示其中的值是小於`N`。  
  
 `switch`指令實作跳躍表格。 指示的格式`unsigned int32`表示的目標數目`N`，後面接著`N`int32 值，指定跳躍目標。 這些目標時，會表示為位移 （正或負） 上，從一開始遵循此指示的`switch`指令。  
  
 `switch`指令從堆疊取出值，並比較其項目，做為不帶正負號的整數， `N`。 如果值是小於`N`，執行會傳輸至目標值，編製索引從 0 開始編號的目標 （例如，值為 0 會採用第一個目標，1 的值會採用第二個目標，並依此類推）。 如果值是大於或等於`N`，繼續執行下一個指令 （正常執行）。  
  
 如果目標指令具有一或多個前置詞程式碼，控制項只能傳送到第一個一個前置詞。  
  
 控制傳入和傳出傳輸`try`， `catch`， `filter`，和`finally`區塊無法執行這項指示。 （這類傳輸嚴重限制而必須改用）。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`switch`opcode。 `Label[]`引數是標籤代表 32 位元位移的陣列。  
  
-   ILGenerator.Emit(OpCode, Label[])  
  
   
  
## Examples  
 下列程式碼範例說明如何使用`Switch`產生跳躍表使用陣列的 opcode <xref:System.Reflection.Emit.Label>。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>執行後置的方法呼叫指令 (例如目前方法的堆疊框架) 會在執行實際的呼叫指令之前移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 14|結尾。|後續呼叫會終止目前的方法|  
  
 不沒有定義這個指示任何堆疊轉換行為。  
  
 `tail`前置詞指令必須緊接著<xref:System.Reflection.Emit.OpCodes.Call>， <xref:System.Reflection.Emit.OpCodes.Calli>，或<xref:System.Reflection.Emit.OpCodes.Callvirt>指令。 指出呼叫指令執行之前，應該移除目前方法的堆疊框架。 這也表示從下列呼叫傳回的值也是目前的方法所傳回的值，並因此可以跨方法跳到轉換呼叫。  
  
 堆疊不得為空白，除了下列的呼叫所傳送的引數。 緊跟在呼叫指令必須是 ret。唯一有效的程式碼序列會因而`tail. call`(或`calli`或`callvirt`)。 正確的 Microsoft Intermediate Language (MSIL) 指示不必須分支到`call`的指示，但它們可能會分支到後續<xref:System.Reflection.Emit.OpCodes.Ret>。  
  
 控制權會轉移不受信任的程式碼從信任的程式碼，因為這可能危及程式碼身分識別安全性時，就無法捨棄目前的框架。 .NET Framework 安全性檢查，因此可能會造成`tail`遭到忽略，離開標準<xref:System.Reflection.Emit.OpCodes.Call>指令。 同樣地，為了讓已同步處理的區域發生在呼叫傳回之後結束，則`tail`時用來結束標示為已同步處理的方法，會忽略前置詞。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`tail`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Opcode 物件的執行個體。</param>
        <summary>如果提供的作業碼採用單一位元組引數，則傳回 True 或 False。</summary>
        <returns><see langword="true" /> 或 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可用來找出哪些 MSIL 作業碼 「 簡短表單 」，用於最佳化程式碼中使用。  
  
 `TakesSingleByteArgument` 會傳回`true`如果<xref:System.Reflection.Emit.OpCode>執行個體使用單一位元組引數，在下列情況：  
  
-   Opcode 會執行分支指令的位元組大小的位址 (例如<xref:System.Reflection.Emit.OpCodes.Br_S>和<xref:System.Reflection.Emit.OpCodes.Bgt_S>)。  
  
-   Opcode 會推送至堆疊的位元組值 (例如<xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   Opcode 參考變數或引數，透過的位元組大小 」 簡短形式 」 (例如<xref:System.Reflection.Emit.OpCodes.Ldloc_S>和<xref:System.Reflection.Emit.OpCodes.Stloc_S>)。  
  
 否則，它會傳回 `false`。  
  
 下列範例示範如何使用`TakesSingleByteArgument`入反映`OpCodes`類別和測試以查看是否每個`OpCode`欄位採用單一位元組引數。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>擲回目前位於評估堆疊的例外狀況物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|7A|throw|擲回例外狀況。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  （將例外狀況） 的物件參考推送至堆疊。  
  
2.  物件參考會從堆疊並擲回的例外狀況中推出。  
  
 `throw`指令會擲回的例外狀況物件 (類型`O`) 目前在堆疊上。  
  
 <xref:System.NullReferenceException> 如果物件參考為 null 參考，會擲回。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`throw`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示目前位於評估堆疊頂端位置可能未對齊緊接的正常大小<see langword="ldind" />， <see langword="stind" />， <see langword="ldfld" />， <see langword="stfld" />， <see langword="ldobj" />， <see langword="stobj" />， <see langword="initblk" />，或<see langword="cpblk" />指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|未對齊。 `alignment`|表示後續指標指令可能未對齊。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
 `Unaligned` 指定的位址 (的 unmanaged 的指標， `native int`) 在堆疊上可能未對齊緊接的正常大小`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`，`initblk`，或`cpblk`指令。 也就是針對<xref:System.Reflection.Emit.OpCodes.Ldind_I4>指令位址的對齊方式可能無法與 4 位元組界限。 針對`initblk`和`cpblk`預設對齊方式是架構相依 （4 個 32 位元 cpu，在 64 位元 Cpu 上的 8 個位元組的位元組）。 未將其輸出限制為 32 位元字組大小的程式碼產生器必須使用`unaligned`如果對齊不在編譯時期已知為 8 個位元組。  
  
 對齊的值必須是 1、 2 或 4 和產生的程式碼應該採用的位址是雙位元組的位元組，或分別 4 位元組對齊的方式。 請注意該暫時性指標 (型別`*`) 一律對齊。  
  
 雖然的對齊方式`cpblk`指令會以邏輯方式需要兩個數字 （一個為來源），另一個用於目的地，則不會嚴重影響效能如果只指定較低的數字。  
  
 `unaligned`和`volatile`可以按照任何順序結合前置詞。 後面必須緊接著`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 只有<xref:System.Reflection.Emit.OpCodes.Volatile>允許前置詞<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`unaligned`opcode:  
  
-   ILGenerator.Emit （OpCode、 標籤）  
  
-   ILGenerator.Emit(Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將實值類型的 boxed 表示轉換成它的 unboxed 形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|79 < `T` >|unbox `valType`|擷取值的型別資料，從`obj`、 其表示法進行 boxed 處理。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考推送至堆疊。  
  
2.  物件參考是從堆疊推出和 unboxed 實值類型指標至。  
  
3.  實值型別指標會推送至堆疊。  
  
 實值型別有兩種不同的表示法在 Common Language Infrastructure (CLI):  
  
-   當實值型別內嵌在另一個物件時，使用 'raw' 格式。  
  
-   'Boxed' 格式，其中實值型別中的資料會包裝 （進行 boxed 處理） 到物件讓它可以當作獨立的實體存在。  
  
 `unbox`指令會將轉換的物件參考 (型別`O`)、 boxed 的實值類型，表示值的類型指標 (managed 的指標，類型`&`)、 其 unboxed 形式。 提供的實值型別 (`valType`) 為中繼資料語彙基元，表示類型的 boxed 物件內所包含的值型別。  
  
 不同於<xref:System.Reflection.Emit.OpCodes.Box>，這必要項目在物件中，製作一份使用實值型別`unbox`不需要複製物件中的實值型別。 通常它只會計算已存在的 boxed 物件內的值類型的位址。  
  
 <xref:System.InvalidCastException> 如果物件不化為會擲回`valType`。  
  
 <xref:System.NullReferenceException> 如果物件參考為 null 參考，會擲回。  
  
 <xref:System.TypeLoadException> 如果型別值，會擲回`valType`找不到。 這通常是偵測到 Microsoft Intermediate Language (MSIL) 指示轉換至原生程式碼，而不是在執行階段時。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`unbox`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>將指令中指定之類型的 boxed 表示轉換成其 unboxed 形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft intermediate language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.any `typeTok`|擷取從資料`obj`、 其表示法進行 boxed 處理。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  物件參考`obj`推送至堆疊。  
  
2.  物件參考是從堆疊推出和 unboxed 指令中指定的型別。  
  
3.  產生的物件參考或實值類型會推送至堆疊。  
  
 套用至 boxed 實值型別時`unbox.any`指令會擷取內含值`obj`(型別的`O`)，而因此相當於`unbox`後面`ldobj`。  
  
 當套用至參考型別`unbox.any`指令具有相同的效果`castclass` `typeTok`。  
  
 如果運算元`typeTok`是泛型類型參數，則執行階段行為取決於該泛型型別參數指定的型別。  
  
 <xref:System.InvalidCastException> 如果擲回`obj`不經過 boxing 處理的型別。  
  
 <xref:System.NullReferenceException> 如果擲回`obj`為 null 參考。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`unbox.any`opcode:  
  
-   ILGenerator.Emit(OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定目前在評估堆疊頂端的位址可能是 volatile，並且無法快取讀取該位置的結果，或者無法隱藏存放該位置的多個存放區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|FE 13|變動性。|表示後續指標參考為 volatile。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  位址會推送至堆疊。  
  
 `volatile`. 指定的位址是動態位址 （也就是可以從外部參考目前的執行緒） 和讀取位置無法快取，或發現無法隱藏多個門市，至該位置的結果。 標示為存取`volatile`只有該單一存取; 會影響其他存取相同的位置必須分別標示。 不需要以不可分割方式執行變動性的位置存取。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned>和`volatile`可以按照任何順序結合前置詞。 後面必須緊接著`ldind`， `stind`， `ldfld`， `stfld`， `ldobj`， `stobj`， `initblk`，或`cpblk`指令。 只有`volatile`允許前置詞<xref:System.Reflection.Emit.OpCodes.Ldsfld>和<xref:System.Reflection.Emit.OpCodes.Stsfld>指示。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`volatile`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>計算評估堆疊頂端兩個值的位元 XOR，將結果推送至評估堆疊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出的指示十六進位和 Microsoft Intermediate Language (MSIL) 的組件格式，以及簡短的參考摘要：  
  
|格式|組件格式|描述|  
|------------|---------------------|-----------------|  
|61|xor|計算兩個整數值的位元 XOR 並傳回一個整數。|  
  
 堆疊的轉換行為，依連續順序是：  
  
1.  `value1` 推送至堆疊。  
  
2.  `value2` 推送至堆疊。  
  
3.  `value2` 和`value1`會彈出從堆疊和其位元 XOR 計算。  
  
4.  位元 XOR`value2`和`value1`推送至堆疊。  
  
 `xor`指令會計算位元 XOR 的前兩個值在堆疊上，並將結果留在堆疊上。  
  
 `Xor` 是整數特定作業。  
  
 下列<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法多載可以使用`xor`opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>